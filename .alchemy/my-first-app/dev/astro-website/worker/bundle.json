{
  "kind": "esbuild::Bundle",
  "id": "bundle",
  "fqn": "my-first-app/dev/astro-website/worker/bundle",
  "seq": 0,
  "data": {},
  "status": "updated",
  "output": {
    "Symbol(alchemy::ResourceKind)": "esbuild::Bundle",
    "Symbol(alchemy::ResourceID)": "bundle",
    "Symbol(alchemy::ResourceFQN)": "my-first-app/dev/astro-website/worker/bundle",
    "Symbol(alchemy::ResourceScope)": {
      "@scope": null
    },
    "Symbol(alchemy::ResourceSeq)": 0,
    "entryPoint": "dist/_worker.js",
    "format": "esm",
    "target": "esnext",
    "platform": "node",
    "minify": false,
    "conditions": [
      "workerd",
      "worker",
      "browser"
    ],
    "absWorkingDir": "/Users/cameronpak/Projects/freedom-stack-v2",
    "keepNames": true,
    "loader": {
      ".sql": "text",
      ".json": "json"
    },
    "plugins": [
      {
        "name": "wasm"
      },
      {
        "name": "hybrid-nodejs_compat"
      }
    ],
    "external": [
      "node:async_hooks",
      "node:assert",
      "node:buffer",
      "node:console",
      "node:crypto",
      "node:debug",
      "node:diagnostics_channel",
      "node:dns",
      "node:events",
      "node:inspector",
      "node:net",
      "node:path",
      "node:perf_hooks",
      "node:process",
      "node:querystring",
      "node:stream",
      "node:string_decoder",
      "node:timers",
      "node:tls",
      "node:url",
      "node:util",
      "node:zlib",
      "async_hooks",
      "assert",
      "buffer",
      "console",
      "crypto",
      "debug",
      "diagnostics_channel",
      "dns",
      "events",
      "inspector",
      "net",
      "path",
      "perf_hooks",
      "process",
      "querystring",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "zlib",
      "cloudflare:workers",
      "cloudflare:workflows",
      "cloudflare:*"
    ],
    "hash": "H5aea8IDcX0",
    "content": "var __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __name = (target, value2) => __defProp(target, \"name\", { value: value2, configurable: true });\nvar __esm = (fn2, res) => function __init() {\n  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/_internal/utils.mjs\n// @__NO_SIDE_EFFECTS__\nfunction createNotImplementedError(name) {\n  return new Error(`[unenv] ${name} is not implemented yet!`);\n}\n// @__NO_SIDE_EFFECTS__\nfunction notImplemented(name) {\n  const fn2 = /* @__PURE__ */ __name(() => {\n    throw /* @__PURE__ */ createNotImplementedError(name);\n  }, \"fn\");\n  return Object.assign(fn2, { __unenv__: true });\n}\nvar init_utils = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/_internal/utils.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    __name(createNotImplementedError, \"createNotImplementedError\");\n    __name(notImplemented, \"notImplemented\");\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs\nvar _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;\nvar init_performance = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_utils();\n    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();\n    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;\n    nodeTiming = {\n      name: \"node\",\n      entryType: \"node\",\n      startTime: 0,\n      duration: 0,\n      nodeStart: 0,\n      v8Start: 0,\n      bootstrapComplete: 0,\n      environment: 0,\n      loopStart: 0,\n      loopExit: 0,\n      idleTime: 0,\n      uvMetricsInfo: {\n        loopCount: 0,\n        events: 0,\n        eventsWaiting: 0\n      },\n      detail: void 0,\n      toJSON() {\n        return this;\n      }\n    };\n    PerformanceEntry = class {\n      static {\n        __name(this, \"PerformanceEntry\");\n      }\n      __unenv__ = true;\n      detail;\n      entryType = \"event\";\n      name;\n      startTime;\n      constructor(name, options) {\n        this.name = name;\n        this.startTime = options?.startTime || _performanceNow();\n        this.detail = options?.detail;\n      }\n      get duration() {\n        return _performanceNow() - this.startTime;\n      }\n      toJSON() {\n        return {\n          name: this.name,\n          entryType: this.entryType,\n          startTime: this.startTime,\n          duration: this.duration,\n          detail: this.detail\n        };\n      }\n    };\n    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {\n      static {\n        __name(this, \"PerformanceMark\");\n      }\n      entryType = \"mark\";\n      constructor() {\n        super(...arguments);\n      }\n      get duration() {\n        return 0;\n      }\n    };\n    PerformanceMeasure = class extends PerformanceEntry {\n      static {\n        __name(this, \"PerformanceMeasure\");\n      }\n      entryType = \"measure\";\n    };\n    PerformanceResourceTiming = class extends PerformanceEntry {\n      static {\n        __name(this, \"PerformanceResourceTiming\");\n      }\n      entryType = \"resource\";\n      serverTiming = [];\n      connectEnd = 0;\n      connectStart = 0;\n      decodedBodySize = 0;\n      domainLookupEnd = 0;\n      domainLookupStart = 0;\n      encodedBodySize = 0;\n      fetchStart = 0;\n      initiatorType = \"\";\n      name = \"\";\n      nextHopProtocol = \"\";\n      redirectEnd = 0;\n      redirectStart = 0;\n      requestStart = 0;\n      responseEnd = 0;\n      responseStart = 0;\n      secureConnectionStart = 0;\n      startTime = 0;\n      transferSize = 0;\n      workerStart = 0;\n      responseStatus = 0;\n    };\n    PerformanceObserverEntryList = class {\n      static {\n        __name(this, \"PerformanceObserverEntryList\");\n      }\n      __unenv__ = true;\n      getEntries() {\n        return [];\n      }\n      getEntriesByName(_name, _type) {\n        return [];\n      }\n      getEntriesByType(type2) {\n        return [];\n      }\n    };\n    Performance = class {\n      static {\n        __name(this, \"Performance\");\n      }\n      __unenv__ = true;\n      timeOrigin = _timeOrigin;\n      eventCounts = /* @__PURE__ */ new Map();\n      _entries = [];\n      _resourceTimingBufferSize = 0;\n      navigation = void 0;\n      timing = void 0;\n      timerify(_fn, _options) {\n        throw createNotImplementedError(\"Performance.timerify\");\n      }\n      get nodeTiming() {\n        return nodeTiming;\n      }\n      eventLoopUtilization() {\n        return {};\n      }\n      markResourceTiming() {\n        return new PerformanceResourceTiming(\"\");\n      }\n      onresourcetimingbufferfull = null;\n      now() {\n        if (this.timeOrigin === _timeOrigin) {\n          return _performanceNow();\n        }\n        return Date.now() - this.timeOrigin;\n      }\n      clearMarks(markName) {\n        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== \"mark\");\n      }\n      clearMeasures(measureName) {\n        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== \"measure\");\n      }\n      clearResourceTimings() {\n        this._entries = this._entries.filter((e) => e.entryType !== \"resource\" || e.entryType !== \"navigation\");\n      }\n      getEntries() {\n        return this._entries;\n      }\n      getEntriesByName(name, type2) {\n        return this._entries.filter((e) => e.name === name && (!type2 || e.entryType === type2));\n      }\n      getEntriesByType(type2) {\n        return this._entries.filter((e) => e.entryType === type2);\n      }\n      mark(name, options) {\n        const entry = new PerformanceMark(name, options);\n        this._entries.push(entry);\n        return entry;\n      }\n      measure(measureName, startOrMeasureOptions, endMark) {\n        let start;\n        let end;\n        if (typeof startOrMeasureOptions === \"string\") {\n          start = this.getEntriesByName(startOrMeasureOptions, \"mark\")[0]?.startTime;\n          end = this.getEntriesByName(endMark, \"mark\")[0]?.startTime;\n        } else {\n          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();\n          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();\n        }\n        const entry = new PerformanceMeasure(measureName, {\n          startTime: start,\n          detail: {\n            start,\n            end\n          }\n        });\n        this._entries.push(entry);\n        return entry;\n      }\n      setResourceTimingBufferSize(maxSize) {\n        this._resourceTimingBufferSize = maxSize;\n      }\n      addEventListener(type2, listener, options) {\n        throw createNotImplementedError(\"Performance.addEventListener\");\n      }\n      removeEventListener(type2, listener, options) {\n        throw createNotImplementedError(\"Performance.removeEventListener\");\n      }\n      dispatchEvent(event) {\n        throw createNotImplementedError(\"Performance.dispatchEvent\");\n      }\n      toJSON() {\n        return this;\n      }\n    };\n    PerformanceObserver = class {\n      static {\n        __name(this, \"PerformanceObserver\");\n      }\n      __unenv__ = true;\n      static supportedEntryTypes = [];\n      _callback = null;\n      constructor(callback) {\n        this._callback = callback;\n      }\n      takeRecords() {\n        return [];\n      }\n      disconnect() {\n        throw createNotImplementedError(\"PerformanceObserver.disconnect\");\n      }\n      observe(options) {\n        throw createNotImplementedError(\"PerformanceObserver.observe\");\n      }\n      bind(fn2) {\n        return fn2;\n      }\n      runInAsyncScope(fn2, thisArg, ...args) {\n        return fn2.call(thisArg, ...args);\n      }\n      asyncId() {\n        return 0;\n      }\n      triggerAsyncId() {\n        return 0;\n      }\n      emitDestroy() {\n        return this;\n      }\n    };\n    performance2 = globalThis.performance && \"addEventListener\" in globalThis.performance ? globalThis.performance : new Performance();\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/perf_hooks.mjs\nvar init_perf_hooks = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/perf_hooks.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_performance();\n  }\n});\n\n// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs\nvar init_performance2 = __esm({\n  \"node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs\"() {\n    init_perf_hooks();\n    globalThis.performance = performance2;\n    globalThis.Performance = Performance;\n    globalThis.PerformanceEntry = PerformanceEntry;\n    globalThis.PerformanceMark = PerformanceMark;\n    globalThis.PerformanceMeasure = PerformanceMeasure;\n    globalThis.PerformanceObserver = PerformanceObserver;\n    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;\n    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;\n  }\n});\n\n// node_modules/unenv/dist/runtime/mock/noop.mjs\nvar noop_default;\nvar init_noop = __esm({\n  \"node_modules/unenv/dist/runtime/mock/noop.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    noop_default = Object.assign(() => {\n    }, { __unenv__: true });\n  }\n});\n\n// node_modules/unenv/dist/runtime/_internal/utils.mjs\n// @__NO_SIDE_EFFECTS__\nfunction createNotImplementedError2(name) {\n  return new Error(`[unenv] ${name} is not implemented yet!`);\n}\n// @__NO_SIDE_EFFECTS__\nfunction notImplemented2(name) {\n  const fn2 = /* @__PURE__ */ __name(() => {\n    throw /* @__PURE__ */ createNotImplementedError2(name);\n  }, \"fn\");\n  return Object.assign(fn2, { __unenv__: true });\n}\n// @__NO_SIDE_EFFECTS__\nfunction notImplementedClass(name) {\n  return class {\n    __unenv__ = true;\n    constructor() {\n      throw new Error(`[unenv] ${name} is not implemented yet!`);\n    }\n  };\n}\nvar init_utils2 = __esm({\n  \"node_modules/unenv/dist/runtime/_internal/utils.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    __name(createNotImplementedError2, \"createNotImplementedError\");\n    __name(notImplemented2, \"notImplemented\");\n    __name(notImplementedClass, \"notImplementedClass\");\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/console.mjs\nimport { Writable } from \"node:stream\";\nvar _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;\nvar init_console = __esm({\n  \"node_modules/unenv/dist/runtime/node/console.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_noop();\n    init_utils2();\n    _console = globalThis.console;\n    _ignoreErrors = true;\n    _stderr = new Writable();\n    _stdout = new Writable();\n    log = _console?.log ?? noop_default;\n    info = _console?.info ?? log;\n    trace = _console?.trace ?? info;\n    debug = _console?.debug ?? log;\n    table = _console?.table ?? log;\n    error = _console?.error ?? log;\n    warn = _console?.warn ?? error;\n    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented2(\"console.createTask\");\n    clear = _console?.clear ?? noop_default;\n    count = _console?.count ?? noop_default;\n    countReset = _console?.countReset ?? noop_default;\n    dir = _console?.dir ?? noop_default;\n    dirxml = _console?.dirxml ?? noop_default;\n    group = _console?.group ?? noop_default;\n    groupEnd = _console?.groupEnd ?? noop_default;\n    groupCollapsed = _console?.groupCollapsed ?? noop_default;\n    profile = _console?.profile ?? noop_default;\n    profileEnd = _console?.profileEnd ?? noop_default;\n    time = _console?.time ?? noop_default;\n    timeEnd = _console?.timeEnd ?? noop_default;\n    timeLog = _console?.timeLog ?? noop_default;\n    timeStamp = _console?.timeStamp ?? noop_default;\n    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass(\"console.Console\");\n    _times = /* @__PURE__ */ new Map();\n    _stdoutErrorHandler = noop_default;\n    _stderrErrorHandler = noop_default;\n  }\n});\n\n// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs\nvar workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;\nvar init_console2 = __esm({\n  \"node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_console();\n    workerdConsole = globalThis[\"console\"];\n    ({\n      assert,\n      clear: clear2,\n      context: (\n        // @ts-expect-error undocumented public API\n        context\n      ),\n      count: count2,\n      countReset: countReset2,\n      createTask: (\n        // @ts-expect-error undocumented public API\n        createTask2\n      ),\n      debug: debug2,\n      dir: dir2,\n      dirxml: dirxml2,\n      error: error2,\n      group: group2,\n      groupCollapsed: groupCollapsed2,\n      groupEnd: groupEnd2,\n      info: info2,\n      log: log2,\n      profile: profile2,\n      profileEnd: profileEnd2,\n      table: table2,\n      time: time2,\n      timeEnd: timeEnd2,\n      timeLog: timeLog2,\n      timeStamp: timeStamp2,\n      trace: trace2,\n      warn: warn2\n    } = workerdConsole);\n    Object.assign(workerdConsole, {\n      Console,\n      _ignoreErrors,\n      _stderr,\n      _stderrErrorHandler,\n      _stdout,\n      _stdoutErrorHandler,\n      _times\n    });\n    console_default = workerdConsole;\n  }\n});\n\n// node_modules/alchemy/lib/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console\nvar init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({\n  \"node_modules/alchemy/lib/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console\"() {\n    init_console2();\n    globalThis.console = console_default;\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs\nvar hrtime;\nvar init_hrtime = __esm({\n  \"node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {\n      const now = Date.now();\n      const seconds = Math.trunc(now / 1e3);\n      const nanos = now % 1e3 * 1e6;\n      if (startTime) {\n        let diffSeconds = seconds - startTime[0];\n        let diffNanos = nanos - startTime[0];\n        if (diffNanos < 0) {\n          diffSeconds = diffSeconds - 1;\n          diffNanos = 1e9 + diffNanos;\n        }\n        return [diffSeconds, diffNanos];\n      }\n      return [seconds, nanos];\n    }, \"hrtime\"), { bigint: /* @__PURE__ */ __name(function bigint() {\n      return BigInt(Date.now() * 1e6);\n    }, \"bigint\") });\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs\nvar WriteStream;\nvar init_write_stream = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    WriteStream = class {\n      static {\n        __name(this, \"WriteStream\");\n      }\n      fd;\n      columns = 80;\n      rows = 24;\n      isTTY = false;\n      constructor(fd) {\n        this.fd = fd;\n      }\n      clearLine(dir3, callback) {\n        callback && callback();\n        return false;\n      }\n      clearScreenDown(callback) {\n        callback && callback();\n        return false;\n      }\n      cursorTo(x, y3, callback) {\n        callback && typeof callback === \"function\" && callback();\n        return false;\n      }\n      moveCursor(dx, dy, callback) {\n        callback && callback();\n        return false;\n      }\n      getColorDepth(env2) {\n        return 1;\n      }\n      hasColors(count3, env2) {\n        return false;\n      }\n      getWindowSize() {\n        return [this.columns, this.rows];\n      }\n      write(str, encoding, cb) {\n        if (str instanceof Uint8Array) {\n          str = new TextDecoder().decode(str);\n        }\n        try {\n          console.log(str);\n        } catch {\n        }\n        cb && typeof cb === \"function\" && cb();\n        return false;\n      }\n    };\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs\nvar ReadStream;\nvar init_read_stream = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    ReadStream = class {\n      static {\n        __name(this, \"ReadStream\");\n      }\n      fd;\n      isRaw = false;\n      isTTY = false;\n      constructor(fd) {\n        this.fd = fd;\n      }\n      setRawMode(mode) {\n        this.isRaw = mode;\n        return this;\n      }\n    };\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/tty.mjs\nvar init_tty = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/tty.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_read_stream();\n    init_write_stream();\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs\nvar NODE_VERSION;\nvar init_node_version = __esm({\n  \"node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    NODE_VERSION = \"22.14.0\";\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/internal/process/process.mjs\nimport { EventEmitter } from \"node:events\";\nvar Process;\nvar init_process = __esm({\n  \"node_modules/unenv/dist/runtime/node/internal/process/process.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_tty();\n    init_utils2();\n    init_node_version();\n    Process = class _Process extends EventEmitter {\n      static {\n        __name(this, \"Process\");\n      }\n      env;\n      hrtime;\n      nextTick;\n      constructor(impl) {\n        super();\n        this.env = impl.env;\n        this.hrtime = impl.hrtime;\n        this.nextTick = impl.nextTick;\n        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {\n          const value2 = this[prop];\n          if (typeof value2 === \"function\") {\n            this[prop] = value2.bind(this);\n          }\n        }\n      }\n      emitWarning(warning, type2, code) {\n        console.warn(`${code ? `[${code}] ` : \"\"}${type2 ? `${type2}: ` : \"\"}${warning}`);\n      }\n      emit(...args) {\n        return super.emit(...args);\n      }\n      listeners(eventName) {\n        return super.listeners(eventName);\n      }\n      #stdin;\n      #stdout;\n      #stderr;\n      get stdin() {\n        return this.#stdin ??= new ReadStream(0);\n      }\n      get stdout() {\n        return this.#stdout ??= new WriteStream(1);\n      }\n      get stderr() {\n        return this.#stderr ??= new WriteStream(2);\n      }\n      #cwd = \"/\";\n      chdir(cwd2) {\n        this.#cwd = cwd2;\n      }\n      cwd() {\n        return this.#cwd;\n      }\n      arch = \"\";\n      platform = \"\";\n      argv = [];\n      argv0 = \"\";\n      execArgv = [];\n      execPath = \"\";\n      title = \"\";\n      pid = 200;\n      ppid = 100;\n      get version() {\n        return `v${NODE_VERSION}`;\n      }\n      get versions() {\n        return { node: NODE_VERSION };\n      }\n      get allowedNodeEnvironmentFlags() {\n        return /* @__PURE__ */ new Set();\n      }\n      get sourceMapsEnabled() {\n        return false;\n      }\n      get debugPort() {\n        return 0;\n      }\n      get throwDeprecation() {\n        return false;\n      }\n      get traceDeprecation() {\n        return false;\n      }\n      get features() {\n        return {};\n      }\n      get release() {\n        return {};\n      }\n      get connected() {\n        return false;\n      }\n      get config() {\n        return {};\n      }\n      get moduleLoadList() {\n        return [];\n      }\n      constrainedMemory() {\n        return 0;\n      }\n      availableMemory() {\n        return 0;\n      }\n      uptime() {\n        return 0;\n      }\n      resourceUsage() {\n        return {};\n      }\n      ref() {\n      }\n      unref() {\n      }\n      umask() {\n        throw createNotImplementedError2(\"process.umask\");\n      }\n      getBuiltinModule() {\n        return void 0;\n      }\n      getActiveResourcesInfo() {\n        throw createNotImplementedError2(\"process.getActiveResourcesInfo\");\n      }\n      exit() {\n        throw createNotImplementedError2(\"process.exit\");\n      }\n      reallyExit() {\n        throw createNotImplementedError2(\"process.reallyExit\");\n      }\n      kill() {\n        throw createNotImplementedError2(\"process.kill\");\n      }\n      abort() {\n        throw createNotImplementedError2(\"process.abort\");\n      }\n      dlopen() {\n        throw createNotImplementedError2(\"process.dlopen\");\n      }\n      setSourceMapsEnabled() {\n        throw createNotImplementedError2(\"process.setSourceMapsEnabled\");\n      }\n      loadEnvFile() {\n        throw createNotImplementedError2(\"process.loadEnvFile\");\n      }\n      disconnect() {\n        throw createNotImplementedError2(\"process.disconnect\");\n      }\n      cpuUsage() {\n        throw createNotImplementedError2(\"process.cpuUsage\");\n      }\n      setUncaughtExceptionCaptureCallback() {\n        throw createNotImplementedError2(\"process.setUncaughtExceptionCaptureCallback\");\n      }\n      hasUncaughtExceptionCaptureCallback() {\n        throw createNotImplementedError2(\"process.hasUncaughtExceptionCaptureCallback\");\n      }\n      initgroups() {\n        throw createNotImplementedError2(\"process.initgroups\");\n      }\n      openStdin() {\n        throw createNotImplementedError2(\"process.openStdin\");\n      }\n      assert() {\n        throw createNotImplementedError2(\"process.assert\");\n      }\n      binding() {\n        throw createNotImplementedError2(\"process.binding\");\n      }\n      permission = { has: /* @__PURE__ */ notImplemented2(\"process.permission.has\") };\n      report = {\n        directory: \"\",\n        filename: \"\",\n        signal: \"SIGUSR2\",\n        compact: false,\n        reportOnFatalError: false,\n        reportOnSignal: false,\n        reportOnUncaughtException: false,\n        getReport: /* @__PURE__ */ notImplemented2(\"process.report.getReport\"),\n        writeReport: /* @__PURE__ */ notImplemented2(\"process.report.writeReport\")\n      };\n      finalization = {\n        register: /* @__PURE__ */ notImplemented2(\"process.finalization.register\"),\n        unregister: /* @__PURE__ */ notImplemented2(\"process.finalization.unregister\"),\n        registerBeforeExit: /* @__PURE__ */ notImplemented2(\"process.finalization.registerBeforeExit\")\n      };\n      memoryUsage = Object.assign(() => ({\n        arrayBuffers: 0,\n        rss: 0,\n        external: 0,\n        heapTotal: 0,\n        heapUsed: 0\n      }), { rss: /* @__PURE__ */ __name(() => 0, \"rss\") });\n      mainModule = void 0;\n      domain = void 0;\n      send = void 0;\n      exitCode = void 0;\n      channel = void 0;\n      getegid = void 0;\n      geteuid = void 0;\n      getgid = void 0;\n      getgroups = void 0;\n      getuid = void 0;\n      setegid = void 0;\n      seteuid = void 0;\n      setgid = void 0;\n      setgroups = void 0;\n      setuid = void 0;\n      _events = void 0;\n      _eventsCount = void 0;\n      _exiting = void 0;\n      _maxListeners = void 0;\n      _debugEnd = void 0;\n      _debugProcess = void 0;\n      _fatalException = void 0;\n      _getActiveHandles = void 0;\n      _getActiveRequests = void 0;\n      _kill = void 0;\n      _preload_modules = void 0;\n      _rawDebug = void 0;\n      _startProfilerIdleNotifier = void 0;\n      _stopProfilerIdleNotifier = void 0;\n      _tickCallback = void 0;\n      _disconnect = void 0;\n      _handleQueue = void 0;\n      _pendingMessage = void 0;\n      _channel = void 0;\n      _send = void 0;\n      _linkedBinding = void 0;\n    };\n  }\n});\n\n// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs\nvar globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;\nvar init_process2 = __esm({\n  \"node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_hrtime();\n    init_process();\n    globalProcess = globalThis[\"process\"];\n    getBuiltinModule = globalProcess.getBuiltinModule;\n    ({ exit, platform, nextTick } = getBuiltinModule(\n      \"node:process\"\n    ));\n    unenvProcess = new Process({\n      env: globalProcess.env,\n      hrtime,\n      nextTick\n    });\n    ({\n      abort,\n      addListener,\n      allowedNodeEnvironmentFlags,\n      hasUncaughtExceptionCaptureCallback,\n      setUncaughtExceptionCaptureCallback,\n      loadEnvFile,\n      sourceMapsEnabled,\n      arch,\n      argv,\n      argv0,\n      chdir,\n      config,\n      connected,\n      constrainedMemory,\n      availableMemory,\n      cpuUsage,\n      cwd,\n      debugPort,\n      dlopen,\n      disconnect,\n      emit,\n      emitWarning,\n      env,\n      eventNames,\n      execArgv,\n      execPath,\n      finalization,\n      features,\n      getActiveResourcesInfo,\n      getMaxListeners,\n      hrtime: hrtime3,\n      kill,\n      listeners,\n      listenerCount,\n      memoryUsage,\n      on,\n      off,\n      once,\n      pid,\n      ppid,\n      prependListener,\n      prependOnceListener,\n      rawListeners,\n      release,\n      removeAllListeners,\n      removeListener,\n      report,\n      resourceUsage,\n      setMaxListeners,\n      setSourceMapsEnabled,\n      stderr,\n      stdin,\n      stdout,\n      title,\n      throwDeprecation,\n      traceDeprecation,\n      umask,\n      uptime,\n      version,\n      versions,\n      domain,\n      initgroups,\n      moduleLoadList,\n      reallyExit,\n      openStdin,\n      assert: assert2,\n      binding,\n      send,\n      exitCode,\n      channel,\n      getegid,\n      geteuid,\n      getgid,\n      getgroups,\n      getuid,\n      setegid,\n      seteuid,\n      setgid,\n      setgroups,\n      setuid,\n      permission,\n      mainModule,\n      _events,\n      _eventsCount,\n      _exiting,\n      _maxListeners,\n      _debugEnd,\n      _debugProcess,\n      _fatalException,\n      _getActiveHandles,\n      _getActiveRequests,\n      _kill,\n      _preload_modules,\n      _rawDebug,\n      _startProfilerIdleNotifier,\n      _stopProfilerIdleNotifier,\n      _tickCallback,\n      _disconnect,\n      _handleQueue,\n      _pendingMessage,\n      _channel,\n      _send,\n      _linkedBinding\n    } = unenvProcess);\n    _process = {\n      abort,\n      addListener,\n      allowedNodeEnvironmentFlags,\n      hasUncaughtExceptionCaptureCallback,\n      setUncaughtExceptionCaptureCallback,\n      loadEnvFile,\n      sourceMapsEnabled,\n      arch,\n      argv,\n      argv0,\n      chdir,\n      config,\n      connected,\n      constrainedMemory,\n      availableMemory,\n      cpuUsage,\n      cwd,\n      debugPort,\n      dlopen,\n      disconnect,\n      emit,\n      emitWarning,\n      env,\n      eventNames,\n      execArgv,\n      execPath,\n      exit,\n      finalization,\n      features,\n      getBuiltinModule,\n      getActiveResourcesInfo,\n      getMaxListeners,\n      hrtime: hrtime3,\n      kill,\n      listeners,\n      listenerCount,\n      memoryUsage,\n      nextTick,\n      on,\n      off,\n      once,\n      pid,\n      platform,\n      ppid,\n      prependListener,\n      prependOnceListener,\n      rawListeners,\n      release,\n      removeAllListeners,\n      removeListener,\n      report,\n      resourceUsage,\n      setMaxListeners,\n      setSourceMapsEnabled,\n      stderr,\n      stdin,\n      stdout,\n      title,\n      throwDeprecation,\n      traceDeprecation,\n      umask,\n      uptime,\n      version,\n      versions,\n      // @ts-expect-error old API\n      domain,\n      initgroups,\n      moduleLoadList,\n      reallyExit,\n      openStdin,\n      assert: assert2,\n      binding,\n      send,\n      exitCode,\n      channel,\n      getegid,\n      geteuid,\n      getgid,\n      getgroups,\n      getuid,\n      setegid,\n      seteuid,\n      setgid,\n      setgroups,\n      setuid,\n      permission,\n      mainModule,\n      _events,\n      _eventsCount,\n      _exiting,\n      _maxListeners,\n      _debugEnd,\n      _debugProcess,\n      _fatalException,\n      _getActiveHandles,\n      _getActiveRequests,\n      _kill,\n      _preload_modules,\n      _rawDebug,\n      _startProfilerIdleNotifier,\n      _stopProfilerIdleNotifier,\n      _tickCallback,\n      _disconnect,\n      _handleQueue,\n      _pendingMessage,\n      _channel,\n      _send,\n      _linkedBinding\n    };\n    process_default = _process;\n  }\n});\n\n// node_modules/alchemy/lib/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process\nvar init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({\n  \"node_modules/alchemy/lib/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process\"() {\n    init_process2();\n    globalThis.process = process_default;\n  }\n});\n\n// dist/_worker.js/chunks/astro/server_C8vVOH8G.mjs\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction normalizeLF(code) {\n  return code.replace(/\\r\\n|\\r(?!\\n)|\\n/g, \"\\n\");\n}\nfunction codeFrame(src, loc) {\n  if (!loc || loc.line === void 0 || loc.column === void 0) {\n    return \"\";\n  }\n  const lines = normalizeLF(src).split(\"\\n\").map((ln2) => ln2.replace(/\\t/g, \"  \"));\n  const visibleLines = [];\n  for (let n27 = -2; n27 <= 2; n27++) {\n    if (lines[loc.line + n27]) visibleLines.push(loc.line + n27);\n  }\n  let gutterWidth = 0;\n  for (const lineNo of visibleLines) {\n    let w3 = `> ${lineNo}`;\n    if (w3.length > gutterWidth) gutterWidth = w3.length;\n  }\n  let output = \"\";\n  for (const lineNo of visibleLines) {\n    const isFocusedLine = lineNo === loc.line - 1;\n    output += isFocusedLine ? \"> \" : \"  \";\n    output += `${lineNo + 1} | ${lines[lineNo]}\n`;\n    if (isFocusedLine)\n      output += `${Array.from({ length: gutterWidth }).join(\" \")}  | ${Array.from({\n        length: loc.column\n      }).join(\" \")}^\n`;\n  }\n  return output;\n}\nfunction validateArgs(args) {\n  if (args.length !== 3) return false;\n  if (!args[0] || typeof args[0] !== \"object\") return false;\n  return true;\n}\nfunction baseCreateComponent(cb, moduleId, propagation) {\n  const name = moduleId?.split(\"/\").pop()?.replace(\".astro\", \"\") ?? \"\";\n  const fn2 = /* @__PURE__ */ __name((...args) => {\n    if (!validateArgs(args)) {\n      throw new AstroError({\n        ...InvalidComponentArgs,\n        message: InvalidComponentArgs.message(name)\n      });\n    }\n    return cb(...args);\n  }, \"fn\");\n  Object.defineProperty(fn2, \"name\", { value: name, writable: false });\n  fn2.isAstroComponentFactory = true;\n  fn2.moduleId = moduleId;\n  fn2.propagation = propagation;\n  return fn2;\n}\nfunction createComponentWithOptions(opts) {\n  const cb = baseCreateComponent(opts.factory, opts.moduleId, opts.propagation);\n  return cb;\n}\nfunction createComponent(arg1, moduleId, propagation) {\n  if (typeof arg1 === \"function\") {\n    return baseCreateComponent(arg1, moduleId, propagation);\n  } else {\n    return createComponentWithOptions(arg1);\n  }\n}\nfunction createAstroGlobFn() {\n  const globHandler = /* @__PURE__ */ __name((importMetaGlobResult) => {\n    console.warn(`Astro.glob is deprecated and will be removed in a future major version of Astro.\nUse import.meta.glob instead: https://vitejs.dev/guide/features.html#glob-import`);\n    if (typeof importMetaGlobResult === \"string\") {\n      throw new AstroError({\n        ...AstroGlobUsedOutside,\n        message: AstroGlobUsedOutside.message(JSON.stringify(importMetaGlobResult))\n      });\n    }\n    let allEntries = [...Object.values(importMetaGlobResult)];\n    if (allEntries.length === 0) {\n      throw new AstroError({\n        ...AstroGlobNoMatch,\n        message: AstroGlobNoMatch.message(JSON.stringify(importMetaGlobResult))\n      });\n    }\n    return Promise.all(allEntries.map((fn2) => fn2()));\n  }, \"globHandler\");\n  return globHandler;\n}\nfunction createAstro(site) {\n  return {\n    // TODO: this is no longer necessary for `Astro.site`\n    // but it somehow allows working around caching issues in content collections for some tests\n    site: void 0,\n    generator: `Astro v${ASTRO_VERSION}`,\n    glob: createAstroGlobFn()\n  };\n}\nfunction init(x, y3) {\n  let rgx = new RegExp(`\\\\x1b\\\\[${y3}m`, \"g\");\n  let open = `\\x1B[${x}m`, close = `\\x1B[${y3}m`;\n  return function(txt) {\n    if (!$.enabled || txt == null) return txt;\n    return open + (!!~(\"\" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;\n  };\n}\nasync function renderEndpoint(mod, context2, isPrerendered, logger) {\n  const { request, url } = context2;\n  const method = request.method.toUpperCase();\n  let handler = mod[method] ?? mod[\"ALL\"];\n  if (!handler && method === \"HEAD\" && mod[\"GET\"]) {\n    handler = mod[\"GET\"];\n  }\n  if (isPrerendered && ![\"GET\", \"HEAD\"].includes(method)) {\n    logger.warn(\n      \"router\",\n      `${url.pathname} ${bold(\n        method\n      )} requests are not available in static endpoints. Mark this page as server-rendered (\\`export const prerender = false;\\`) or update your config to \\`output: 'server'\\` to make all your pages server-rendered by default.`\n    );\n  }\n  if (handler === void 0) {\n    logger.warn(\n      \"router\",\n      `No API Route handler exists for the method \"${method}\" for the route \"${url.pathname}\".\nFound handlers: ${Object.keys(mod).map((exp) => JSON.stringify(exp)).join(\", \")}\n` + (\"all\" in mod ? `One of the exported handlers is \"all\" (lowercase), did you mean to export 'ALL'?\n` : \"\")\n    );\n    return new Response(null, { status: 404 });\n  }\n  if (typeof handler !== \"function\") {\n    logger.error(\n      \"router\",\n      `The route \"${url.pathname}\" exports a value for the method \"${method}\", but it is of the type ${typeof handler} instead of a function.`\n    );\n    return new Response(null, { status: 500 });\n  }\n  let response = await handler.call(mod, context2);\n  if (!response || response instanceof Response === false) {\n    throw new AstroError(EndpointDidNotReturnAResponse);\n  }\n  if (REROUTABLE_STATUS_CODES.includes(response.status)) {\n    try {\n      response.headers.set(REROUTE_DIRECTIVE_HEADER, \"no\");\n    } catch (err) {\n      if (err.message?.includes(\"immutable\")) {\n        response = new Response(response.body, response);\n        response.headers.set(REROUTE_DIRECTIVE_HEADER, \"no\");\n      } else {\n        throw err;\n      }\n    }\n  }\n  if (method === \"HEAD\") {\n    return new Response(null, response);\n  }\n  return response;\n}\nfunction isPromise(value2) {\n  return !!value2 && typeof value2 === \"object\" && \"then\" in value2 && typeof value2.then === \"function\";\n}\nasync function* streamAsyncIterator(stream) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done, value: value2 } = await reader.read();\n      if (done) return;\n      yield value2;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\nfunction isHTMLString(value2) {\n  return Object.prototype.toString.call(value2) === \"[object HTMLString]\";\n}\nfunction markHTMLBytes(bytes) {\n  return new HTMLBytes(bytes);\n}\nfunction hasGetReader(obj) {\n  return typeof obj.getReader === \"function\";\n}\nasync function* unescapeChunksAsync(iterable) {\n  if (hasGetReader(iterable)) {\n    for await (const chunk of streamAsyncIterator(iterable)) {\n      yield unescapeHTML(chunk);\n    }\n  } else {\n    for await (const chunk of iterable) {\n      yield unescapeHTML(chunk);\n    }\n  }\n}\nfunction* unescapeChunks(iterable) {\n  for (const chunk of iterable) {\n    yield unescapeHTML(chunk);\n  }\n}\nfunction unescapeHTML(str) {\n  if (!!str && typeof str === \"object\") {\n    if (str instanceof Uint8Array) {\n      return markHTMLBytes(str);\n    } else if (str instanceof Response && str.body) {\n      const body = str.body;\n      return unescapeChunksAsync(body);\n    } else if (typeof str.then === \"function\") {\n      return Promise.resolve(str).then((value2) => {\n        return unescapeHTML(value2);\n      });\n    } else if (str[Symbol.for(\"astro:slot-string\")]) {\n      return str;\n    } else if (Symbol.iterator in str) {\n      return unescapeChunks(str);\n    } else if (Symbol.asyncIterator in str || hasGetReader(str)) {\n      return unescapeChunksAsync(str);\n    }\n  }\n  return markHTMLString(str);\n}\nfunction isVNode(vnode) {\n  return vnode && typeof vnode === \"object\" && vnode[AstroJSX];\n}\nfunction isAstroComponentFactory(obj) {\n  return obj == null ? false : obj.isAstroComponentFactory === true;\n}\nfunction isAPropagatingComponent(result, factory) {\n  let hint = factory.propagation || \"none\";\n  if (factory.moduleId && result.componentMetadata.has(factory.moduleId) && hint === \"none\") {\n    hint = result.componentMetadata.get(factory.moduleId).propagation;\n  }\n  return hint === \"in-tree\" || hint === \"self\";\n}\nfunction createRenderInstruction(instruction) {\n  return Object.defineProperty(instruction, RenderInstructionSymbol, {\n    value: true\n  });\n}\nfunction isRenderInstruction(chunk) {\n  return chunk && typeof chunk === \"object\" && chunk[RenderInstructionSymbol];\n}\nfunction r(e) {\n  var t, f2, n27 = \"\";\n  if (\"string\" == typeof e || \"number\" == typeof e) n27 += e;\n  else if (\"object\" == typeof e) if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (f2 = r(e[t])) && (n27 && (n27 += \" \"), n27 += f2);\n  } else for (f2 in e) e[f2] && (n27 && (n27 += \" \"), n27 += f2);\n  return n27;\n}\nfunction clsx() {\n  for (var e, t, f2 = 0, n27 = \"\", o = arguments.length; f2 < o; f2++) (e = arguments[f2]) && (t = r(e)) && (n27 && (n27 += \" \"), n27 += t);\n  return n27;\n}\nfunction serializeArray(value2, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {\n  if (parents.has(value2)) {\n    throw new Error(`Cyclic reference detected while serializing props for <${metadata.displayName} client:${metadata.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);\n  }\n  parents.add(value2);\n  const serialized = value2.map((v3) => {\n    return convertToSerializedForm(v3, metadata, parents);\n  });\n  parents.delete(value2);\n  return serialized;\n}\nfunction serializeObject(value2, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {\n  if (parents.has(value2)) {\n    throw new Error(`Cyclic reference detected while serializing props for <${metadata.displayName} client:${metadata.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);\n  }\n  parents.add(value2);\n  const serialized = Object.fromEntries(\n    Object.entries(value2).map(([k2, v3]) => {\n      return [k2, convertToSerializedForm(v3, metadata, parents)];\n    })\n  );\n  parents.delete(value2);\n  return serialized;\n}\nfunction convertToSerializedForm(value2, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {\n  const tag = Object.prototype.toString.call(value2);\n  switch (tag) {\n    case \"[object Date]\": {\n      return [PROP_TYPE.Date, value2.toISOString()];\n    }\n    case \"[object RegExp]\": {\n      return [PROP_TYPE.RegExp, value2.source];\n    }\n    case \"[object Map]\": {\n      return [PROP_TYPE.Map, serializeArray(Array.from(value2), metadata, parents)];\n    }\n    case \"[object Set]\": {\n      return [PROP_TYPE.Set, serializeArray(Array.from(value2), metadata, parents)];\n    }\n    case \"[object BigInt]\": {\n      return [PROP_TYPE.BigInt, value2.toString()];\n    }\n    case \"[object URL]\": {\n      return [PROP_TYPE.URL, value2.toString()];\n    }\n    case \"[object Array]\": {\n      return [PROP_TYPE.JSON, serializeArray(value2, metadata, parents)];\n    }\n    case \"[object Uint8Array]\": {\n      return [PROP_TYPE.Uint8Array, Array.from(value2)];\n    }\n    case \"[object Uint16Array]\": {\n      return [PROP_TYPE.Uint16Array, Array.from(value2)];\n    }\n    case \"[object Uint32Array]\": {\n      return [PROP_TYPE.Uint32Array, Array.from(value2)];\n    }\n    default: {\n      if (value2 !== null && typeof value2 === \"object\") {\n        return [PROP_TYPE.Value, serializeObject(value2, metadata, parents)];\n      }\n      if (value2 === Infinity) {\n        return [PROP_TYPE.Infinity, 1];\n      }\n      if (value2 === -Infinity) {\n        return [PROP_TYPE.Infinity, -1];\n      }\n      if (value2 === void 0) {\n        return [PROP_TYPE.Value];\n      }\n      return [PROP_TYPE.Value, value2];\n    }\n  }\n}\nfunction serializeProps(props, metadata) {\n  const serialized = JSON.stringify(serializeObject(props, metadata));\n  return serialized;\n}\nfunction extractDirectives(inputProps, clientDirectives) {\n  let extracted = {\n    isPage: false,\n    hydration: null,\n    props: {},\n    propsWithoutTransitionAttributes: {}\n  };\n  for (const [key, value2] of Object.entries(inputProps)) {\n    if (key.startsWith(\"server:\")) {\n      if (key === \"server:root\") {\n        extracted.isPage = true;\n      }\n    }\n    if (key.startsWith(\"client:\")) {\n      if (!extracted.hydration) {\n        extracted.hydration = {\n          directive: \"\",\n          value: \"\",\n          componentUrl: \"\",\n          componentExport: { value: \"\" }\n        };\n      }\n      switch (key) {\n        case \"client:component-path\": {\n          extracted.hydration.componentUrl = value2;\n          break;\n        }\n        case \"client:component-export\": {\n          extracted.hydration.componentExport.value = value2;\n          break;\n        }\n        // This is a special prop added to prove that the client hydration method\n        // was added statically.\n        case \"client:component-hydration\": {\n          break;\n        }\n        case \"client:display-name\": {\n          break;\n        }\n        default: {\n          extracted.hydration.directive = key.split(\":\")[1];\n          extracted.hydration.value = value2;\n          if (!clientDirectives.has(extracted.hydration.directive)) {\n            const hydrationMethods = Array.from(clientDirectives.keys()).map((d2) => `client:${d2}`).join(\", \");\n            throw new Error(\n              `Error: invalid hydration directive \"${key}\". Supported hydration methods: ${hydrationMethods}`\n            );\n          }\n          if (extracted.hydration.directive === \"media\" && typeof extracted.hydration.value !== \"string\") {\n            throw new AstroError(MissingMediaQueryDirective);\n          }\n          break;\n        }\n      }\n    } else {\n      extracted.props[key] = value2;\n      if (!transitionDirectivesToCopyOnIsland.includes(key)) {\n        extracted.propsWithoutTransitionAttributes[key] = value2;\n      }\n    }\n  }\n  for (const sym of Object.getOwnPropertySymbols(inputProps)) {\n    extracted.props[sym] = inputProps[sym];\n    extracted.propsWithoutTransitionAttributes[sym] = inputProps[sym];\n  }\n  return extracted;\n}\nasync function generateHydrateScript(scriptOptions, metadata) {\n  const { renderer: renderer2, result, astroId, props, attrs } = scriptOptions;\n  const { hydrate, componentUrl, componentExport } = metadata;\n  if (!componentExport.value) {\n    throw new AstroError({\n      ...NoMatchingImport,\n      message: NoMatchingImport.message(metadata.displayName)\n    });\n  }\n  const island = {\n    children: \"\",\n    props: {\n      // This is for HMR, probably can avoid it in prod\n      uid: astroId\n    }\n  };\n  if (attrs) {\n    for (const [key, value2] of Object.entries(attrs)) {\n      island.props[key] = escapeHTML(value2);\n    }\n  }\n  island.props[\"component-url\"] = await result.resolve(decodeURI(componentUrl));\n  if (renderer2.clientEntrypoint) {\n    island.props[\"component-export\"] = componentExport.value;\n    island.props[\"renderer-url\"] = await result.resolve(\n      decodeURI(renderer2.clientEntrypoint.toString())\n    );\n    island.props[\"props\"] = escapeHTML(serializeProps(props, metadata));\n  }\n  island.props[\"ssr\"] = \"\";\n  island.props[\"client\"] = hydrate;\n  let beforeHydrationUrl = await result.resolve(\"astro:scripts/before-hydration.js\");\n  if (beforeHydrationUrl.length) {\n    island.props[\"before-hydration-url\"] = beforeHydrationUrl;\n  }\n  island.props[\"opts\"] = escapeHTML(\n    JSON.stringify({\n      name: metadata.displayName,\n      value: metadata.hydrateArgs || \"\"\n    })\n  );\n  transitionDirectivesToCopyOnIsland.forEach((name) => {\n    if (typeof props[name] !== \"undefined\") {\n      island.props[name] = props[name];\n    }\n  });\n  return island;\n}\nfunction bitwise(str) {\n  let hash3 = 0;\n  if (str.length === 0) return hash3;\n  for (let i = 0; i < str.length; i++) {\n    const ch = str.charCodeAt(i);\n    hash3 = (hash3 << 5) - hash3 + ch;\n    hash3 = hash3 & hash3;\n  }\n  return hash3;\n}\nfunction shorthash(text) {\n  let num;\n  let result = \"\";\n  let integer = bitwise(text);\n  const sign3 = integer < 0 ? \"Z\" : \"\";\n  integer = Math.abs(integer);\n  while (integer >= binary) {\n    num = integer % binary;\n    integer = Math.floor(integer / binary);\n    result = dictionary[num] + result;\n  }\n  if (integer > 0) {\n    result = dictionary[integer] + result;\n  }\n  return sign3 + result;\n}\nfunction isHeadAndContent(obj) {\n  return typeof obj === \"object\" && obj !== null && !!obj[headAndContentSym];\n}\nfunction determineIfNeedsHydrationScript(result) {\n  if (result._metadata.hasHydrationScript) {\n    return false;\n  }\n  return result._metadata.hasHydrationScript = true;\n}\nfunction determinesIfNeedsDirectiveScript(result, directive) {\n  if (result._metadata.hasDirectives.has(directive)) {\n    return false;\n  }\n  result._metadata.hasDirectives.add(directive);\n  return true;\n}\nfunction getDirectiveScriptText(result, directive) {\n  const clientDirectives = result.clientDirectives;\n  const clientDirective = clientDirectives.get(directive);\n  if (!clientDirective) {\n    throw new Error(`Unknown directive: ${directive}`);\n  }\n  return clientDirective;\n}\nfunction getPrescripts(result, type2, directive) {\n  switch (type2) {\n    case \"both\":\n      return `${ISLAND_STYLES}<script>${getDirectiveScriptText(result, directive)};${astro_island_prebuilt_default}</script>`;\n    case \"directive\":\n      return `<script>${getDirectiveScriptText(result, directive)}</script>`;\n  }\n  return \"\";\n}\nfunction defineScriptVars(vars) {\n  let output = \"\";\n  for (const [key, value2] of Object.entries(vars)) {\n    output += `const ${toIdent(key)} = ${JSON.stringify(value2)?.replace(\n      /<\\/script>/g,\n      \"\\\\x3C/script>\"\n    )};\n`;\n  }\n  return markHTMLString(output);\n}\nfunction formatList(values) {\n  if (values.length === 1) {\n    return values[0];\n  }\n  return `${values.slice(0, -1).join(\", \")} or ${values[values.length - 1]}`;\n}\nfunction addAttribute(value2, key, shouldEscape = true) {\n  if (value2 == null) {\n    return \"\";\n  }\n  if (STATIC_DIRECTIVES.has(key)) {\n    console.warn(`[astro] The \"${key}\" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.\n\nMake sure to use the static attribute syntax (\\`${key}={value}\\`) instead of the dynamic spread syntax (\\`{...{ \"${key}\": value }}\\`).`);\n    return \"\";\n  }\n  if (key === \"class:list\") {\n    const listValue = toAttributeString(clsx(value2), shouldEscape);\n    if (listValue === \"\") {\n      return \"\";\n    }\n    return markHTMLString(` ${key.slice(0, -5)}=\"${listValue}\"`);\n  }\n  if (key === \"style\" && !(value2 instanceof HTMLString)) {\n    if (Array.isArray(value2) && value2.length === 2) {\n      return markHTMLString(\n        ` ${key}=\"${toAttributeString(`${toStyleString(value2[0])};${value2[1]}`, shouldEscape)}\"`\n      );\n    }\n    if (typeof value2 === \"object\") {\n      return markHTMLString(` ${key}=\"${toAttributeString(toStyleString(value2), shouldEscape)}\"`);\n    }\n  }\n  if (key === \"className\") {\n    return markHTMLString(` class=\"${toAttributeString(value2, shouldEscape)}\"`);\n  }\n  if (typeof value2 === \"string\" && value2.includes(\"&\") && isHttpUrl(value2)) {\n    return markHTMLString(` ${key}=\"${toAttributeString(value2, false)}\"`);\n  }\n  if (htmlBooleanAttributes.test(key)) {\n    return markHTMLString(value2 ? ` ${key}` : \"\");\n  }\n  if (value2 === \"\") {\n    return markHTMLString(` ${key}`);\n  }\n  if (key === \"popover\" && typeof value2 === \"boolean\") {\n    return markHTMLString(value2 ? ` popover` : \"\");\n  }\n  return markHTMLString(` ${key}=\"${toAttributeString(value2, shouldEscape)}\"`);\n}\nfunction internalSpreadAttributes(values, shouldEscape = true) {\n  let output = \"\";\n  for (const [key, value2] of Object.entries(values)) {\n    output += addAttribute(value2, key, shouldEscape);\n  }\n  return markHTMLString(output);\n}\nfunction renderElement$1(name, { props: _props, children = \"\" }, shouldEscape = true) {\n  const { lang: _3, \"data-astro-id\": astroId, \"define:vars\": defineVars, ...props } = _props;\n  if (defineVars) {\n    if (name === \"style\") {\n      delete props[\"is:global\"];\n      delete props[\"is:scoped\"];\n    }\n    if (name === \"script\") {\n      delete props.hoist;\n      children = defineScriptVars(defineVars) + \"\\n\" + children;\n    }\n  }\n  if ((children == null || children == \"\") && voidElementNames.test(name)) {\n    return `<${name}${internalSpreadAttributes(props, shouldEscape)}>`;\n  }\n  return `<${name}${internalSpreadAttributes(props, shouldEscape)}>${children}</${name}>`;\n}\nfunction createBufferedRenderer(destination, renderFunction) {\n  return new BufferedRenderer(destination, renderFunction);\n}\nfunction promiseWithResolvers() {\n  let resolve, reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\nfunction isHttpUrl(url) {\n  try {\n    const parsedUrl = new URL(url);\n    return VALID_PROTOCOLS.includes(parsedUrl.protocol);\n  } catch {\n    return false;\n  }\n}\nfunction renderAllHeadContent(result) {\n  result._metadata.hasRenderedHead = true;\n  const styles = Array.from(result.styles).filter(uniqueElements).map(\n    (style2) => style2.props.rel === \"stylesheet\" ? renderElement$1(\"link\", style2) : renderElement$1(\"style\", style2)\n  );\n  result.styles.clear();\n  const scripts = Array.from(result.scripts).filter(uniqueElements).map((script2) => {\n    if (result.userAssetsBase) {\n      script2.props.src = (result.base === \"/\" ? \"\" : result.base) + result.userAssetsBase + script2.props.src;\n    }\n    return renderElement$1(\"script\", script2, false);\n  });\n  const links = Array.from(result.links).filter(uniqueElements).map((link2) => renderElement$1(\"link\", link2, false));\n  let content = styles.join(\"\\n\") + links.join(\"\\n\") + scripts.join(\"\\n\");\n  if (result._metadata.extraHead.length > 0) {\n    for (const part of result._metadata.extraHead) {\n      content += part;\n    }\n  }\n  return markHTMLString(content);\n}\nfunction renderHead() {\n  return createRenderInstruction({ type: \"head\" });\n}\nfunction maybeRenderHead() {\n  return createRenderInstruction({ type: \"maybe-head\" });\n}\nfunction encodeHexUpperCase(data) {\n  let result = \"\";\n  for (let i = 0; i < data.length; i++) {\n    result += alphabetUpperCase[data[i] >> 4];\n    result += alphabetUpperCase[data[i] & 15];\n  }\n  return result;\n}\nfunction decodeHex(data) {\n  if (data.length % 2 !== 0) {\n    throw new Error(\"Invalid hex string\");\n  }\n  const result = new Uint8Array(data.length / 2);\n  for (let i = 0; i < data.length; i += 2) {\n    if (!(data[i] in decodeMap)) {\n      throw new Error(\"Invalid character\");\n    }\n    if (!(data[i + 1] in decodeMap)) {\n      throw new Error(\"Invalid character\");\n    }\n    result[i / 2] |= decodeMap[data[i]] << 4;\n    result[i / 2] |= decodeMap[data[i + 1]];\n  }\n  return result;\n}\nfunction encodeBase64(bytes) {\n  return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.Include);\n}\nfunction encodeBase64_internal(bytes, alphabet, padding) {\n  let result = \"\";\n  for (let i = 0; i < bytes.byteLength; i += 3) {\n    let buffer = 0;\n    let bufferBitSize = 0;\n    for (let j3 = 0; j3 < 3 && i + j3 < bytes.byteLength; j3++) {\n      buffer = buffer << 8 | bytes[i + j3];\n      bufferBitSize += 8;\n    }\n    for (let j3 = 0; j3 < 4; j3++) {\n      if (bufferBitSize >= 6) {\n        result += alphabet[buffer >> bufferBitSize - 6 & 63];\n        bufferBitSize -= 6;\n      } else if (bufferBitSize > 0) {\n        result += alphabet[buffer << 6 - bufferBitSize & 63];\n        bufferBitSize = 0;\n      } else if (padding === EncodingPadding.Include) {\n        result += \"=\";\n      }\n    }\n  }\n  return result;\n}\nfunction decodeBase64(encoded) {\n  return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Required);\n}\nfunction decodeBase64_internal(encoded, decodeMap2, padding) {\n  const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);\n  let totalBytes = 0;\n  for (let i = 0; i < encoded.length; i += 4) {\n    let chunk = 0;\n    let bitsRead = 0;\n    for (let j3 = 0; j3 < 4; j3++) {\n      if (padding === DecodingPadding.Required && encoded[i + j3] === \"=\") {\n        continue;\n      }\n      if (padding === DecodingPadding.Ignore && (i + j3 >= encoded.length || encoded[i + j3] === \"=\")) {\n        continue;\n      }\n      if (j3 > 0 && encoded[i + j3 - 1] === \"=\") {\n        throw new Error(\"Invalid padding\");\n      }\n      if (!(encoded[i + j3] in decodeMap2)) {\n        throw new Error(\"Invalid character\");\n      }\n      chunk |= decodeMap2[encoded[i + j3]] << (3 - j3) * 6;\n      bitsRead += 6;\n    }\n    if (bitsRead < 24) {\n      let unused;\n      if (bitsRead === 12) {\n        unused = chunk & 65535;\n      } else if (bitsRead === 18) {\n        unused = chunk & 255;\n      } else {\n        throw new Error(\"Invalid padding\");\n      }\n      if (unused !== 0) {\n        throw new Error(\"Invalid padding\");\n      }\n    }\n    const byteLength = Math.floor(bitsRead / 8);\n    for (let i2 = 0; i2 < byteLength; i2++) {\n      result[totalBytes] = chunk >> 16 - i2 * 8 & 255;\n      totalBytes++;\n    }\n  }\n  return result.slice(0, totalBytes);\n}\nasync function decodeKey(encoded) {\n  const bytes = decodeBase64(encoded);\n  return crypto.subtle.importKey(\"raw\", bytes, ALGORITHM, true, [\"encrypt\", \"decrypt\"]);\n}\nasync function encryptString(key, raw2) {\n  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH / 2));\n  const data = encoder$1.encode(raw2);\n  const buffer = await crypto.subtle.encrypt(\n    {\n      name: ALGORITHM,\n      iv\n    },\n    key,\n    data\n  );\n  return encodeHexUpperCase(iv) + encodeBase64(new Uint8Array(buffer));\n}\nasync function decryptString(key, encoded) {\n  const iv = decodeHex(encoded.slice(0, IV_LENGTH));\n  const dataArray = decodeBase64(encoded.slice(IV_LENGTH));\n  const decryptedBuffer = await crypto.subtle.decrypt(\n    {\n      name: ALGORITHM,\n      iv\n    },\n    key,\n    dataArray\n  );\n  const decryptedString = decoder$1.decode(decryptedBuffer);\n  return decryptedString;\n}\nfunction isRenderTemplateResult(obj) {\n  return typeof obj === \"object\" && obj !== null && !!obj[renderTemplateResultSym];\n}\nfunction renderTemplate(htmlParts, ...expressions) {\n  return new RenderTemplateResult(htmlParts, expressions);\n}\nfunction isSlotString(str) {\n  return !!str[slotString];\n}\nfunction renderSlot(result, slotted, fallback) {\n  if (!slotted && fallback) {\n    return renderSlot(result, fallback);\n  }\n  return {\n    async render(destination) {\n      await renderChild(destination, typeof slotted === \"function\" ? slotted(result) : slotted);\n    }\n  };\n}\nasync function renderSlotToString(result, slotted, fallback) {\n  let content = \"\";\n  let instructions = null;\n  const temporaryDestination = {\n    write(chunk) {\n      if (chunk instanceof SlotString) {\n        content += chunk;\n        if (chunk.instructions) {\n          instructions ??= [];\n          instructions.push(...chunk.instructions);\n        }\n      } else if (chunk instanceof Response) return;\n      else if (typeof chunk === \"object\" && \"type\" in chunk && typeof chunk.type === \"string\") {\n        if (instructions === null) {\n          instructions = [];\n        }\n        instructions.push(chunk);\n      } else {\n        content += chunkToString(result, chunk);\n      }\n    }\n  };\n  const renderInstance = renderSlot(result, slotted, fallback);\n  await renderInstance.render(temporaryDestination);\n  return markHTMLString(new SlotString(content, instructions));\n}\nasync function renderSlots(result, slots = {}) {\n  let slotInstructions = null;\n  let children = {};\n  if (slots) {\n    await Promise.all(\n      Object.entries(slots).map(\n        ([key, value2]) => renderSlotToString(result, value2).then((output) => {\n          if (output.instructions) {\n            if (slotInstructions === null) {\n              slotInstructions = [];\n            }\n            slotInstructions.push(...output.instructions);\n          }\n          children[key] = output;\n        })\n      )\n    );\n  }\n  return { slotInstructions, children };\n}\nfunction createSlotValueFromString(content) {\n  return function() {\n    return renderTemplate`${unescapeHTML(content)}`;\n  };\n}\nfunction containsServerDirective(props) {\n  return \"server:component-directive\" in props;\n}\nfunction safeJsonStringify(obj) {\n  return JSON.stringify(obj).replace(SCRIPT_RE, SCRIPT_REPLACER).replace(COMMENT_RE, COMMENT_REPLACER);\n}\nfunction createSearchParams(componentExport, encryptedProps, slots) {\n  const params = new URLSearchParams();\n  params.set(\"e\", componentExport);\n  params.set(\"p\", encryptedProps);\n  params.set(\"s\", slots);\n  return params;\n}\nfunction isWithinURLLimit(pathname, params) {\n  const url = pathname + \"?\" + params.toString();\n  const chars = url.length;\n  return chars < 2048;\n}\nfunction renderServerIsland(result, _displayName, props, slots) {\n  return {\n    async render(destination) {\n      const componentPath = props[\"server:component-path\"];\n      const componentExport = props[\"server:component-export\"];\n      const componentId = result.serverIslandNameMap.get(componentPath);\n      if (!componentId) {\n        throw new Error(`Could not find server component name`);\n      }\n      for (const key2 of Object.keys(props)) {\n        if (internalProps.has(key2)) {\n          delete props[key2];\n        }\n      }\n      destination.write(createRenderInstruction({ type: \"server-island-runtime\" }));\n      destination.write(\"<!--[if astro]>server-island-start<![endif]-->\");\n      const renderedSlots = {};\n      for (const name in slots) {\n        if (name !== \"fallback\") {\n          const content = await renderSlotToString(result, slots[name]);\n          renderedSlots[name] = content.toString();\n        } else {\n          await renderChild(destination, slots.fallback(result));\n        }\n      }\n      const key = await result.key;\n      const propsEncrypted = Object.keys(props).length === 0 ? \"\" : await encryptString(key, JSON.stringify(props));\n      const hostId = crypto.randomUUID();\n      const slash2 = result.base.endsWith(\"/\") ? \"\" : \"/\";\n      let serverIslandUrl = `${result.base}${slash2}_server-islands/${componentId}${result.trailingSlash === \"always\" ? \"/\" : \"\"}`;\n      const potentialSearchParams = createSearchParams(\n        componentExport,\n        propsEncrypted,\n        safeJsonStringify(renderedSlots)\n      );\n      const useGETRequest = isWithinURLLimit(serverIslandUrl, potentialSearchParams);\n      if (useGETRequest) {\n        serverIslandUrl += \"?\" + potentialSearchParams.toString();\n        destination.write(\n          `<link rel=\"preload\" as=\"fetch\" href=\"${serverIslandUrl}\" crossorigin=\"anonymous\">`\n        );\n      }\n      destination.write(`<script type=\"module\" data-astro-rerun data-island-id=\"${hostId}\">${useGETRequest ? (\n        // GET request\n        `let response = await fetch('${serverIslandUrl}');`\n      ) : (\n        // POST request\n        `let data = {\n\tcomponentExport: ${safeJsonStringify(componentExport)},\n\tencryptedProps: ${safeJsonStringify(propsEncrypted)},\n\tslots: ${safeJsonStringify(renderedSlots)},\n};\nlet response = await fetch('${serverIslandUrl}', {\n\tmethod: 'POST',\n\tbody: JSON.stringify(data),\n});`\n      )}\nreplaceServerIsland('${hostId}', response);</script>`);\n    }\n  };\n}\nfunction stringifyChunk(result, chunk) {\n  if (isRenderInstruction(chunk)) {\n    const instruction = chunk;\n    switch (instruction.type) {\n      case \"directive\": {\n        const { hydration } = instruction;\n        let needsHydrationScript = hydration && determineIfNeedsHydrationScript(result);\n        let needsDirectiveScript = hydration && determinesIfNeedsDirectiveScript(result, hydration.directive);\n        let prescriptType = needsHydrationScript ? \"both\" : needsDirectiveScript ? \"directive\" : null;\n        if (prescriptType) {\n          let prescripts = getPrescripts(result, prescriptType, hydration.directive);\n          return markHTMLString(prescripts);\n        } else {\n          return \"\";\n        }\n      }\n      case \"head\": {\n        if (result._metadata.hasRenderedHead || result.partial) {\n          return \"\";\n        }\n        return renderAllHeadContent(result);\n      }\n      case \"maybe-head\": {\n        if (result._metadata.hasRenderedHead || result._metadata.headInTree || result.partial) {\n          return \"\";\n        }\n        return renderAllHeadContent(result);\n      }\n      case \"renderer-hydration-script\": {\n        const { rendererSpecificHydrationScripts } = result._metadata;\n        const { rendererName } = instruction;\n        if (!rendererSpecificHydrationScripts.has(rendererName)) {\n          rendererSpecificHydrationScripts.add(rendererName);\n          return instruction.render();\n        }\n        return \"\";\n      }\n      case \"server-island-runtime\": {\n        if (result._metadata.hasRenderedServerIslandRuntime) {\n          return \"\";\n        }\n        result._metadata.hasRenderedServerIslandRuntime = true;\n        return renderServerIslandRuntime();\n      }\n      default: {\n        throw new Error(`Unknown chunk type: ${chunk.type}`);\n      }\n    }\n  } else if (chunk instanceof Response) {\n    return \"\";\n  } else if (isSlotString(chunk)) {\n    let out = \"\";\n    const c = chunk;\n    if (c.instructions) {\n      for (const instr of c.instructions) {\n        out += stringifyChunk(result, instr);\n      }\n    }\n    out += chunk.toString();\n    return out;\n  }\n  return chunk.toString();\n}\nfunction chunkToString(result, chunk) {\n  if (ArrayBuffer.isView(chunk)) {\n    return decoder.decode(chunk);\n  } else {\n    return stringifyChunk(result, chunk);\n  }\n}\nfunction chunkToByteArray(result, chunk) {\n  if (ArrayBuffer.isView(chunk)) {\n    return chunk;\n  } else {\n    const stringified = stringifyChunk(result, chunk);\n    return encoder.encode(stringified.toString());\n  }\n}\nfunction isRenderInstance(obj) {\n  return !!obj && typeof obj === \"object\" && \"render\" in obj && typeof obj.render === \"function\";\n}\nfunction renderChild(destination, child) {\n  if (isPromise(child)) {\n    return child.then((x) => renderChild(destination, x));\n  }\n  if (child instanceof SlotString) {\n    destination.write(child);\n    return;\n  }\n  if (isHTMLString(child)) {\n    destination.write(child);\n    return;\n  }\n  if (Array.isArray(child)) {\n    return renderArray(destination, child);\n  }\n  if (typeof child === \"function\") {\n    return renderChild(destination, child());\n  }\n  if (!child && child !== 0) {\n    return;\n  }\n  if (typeof child === \"string\") {\n    destination.write(markHTMLString(escapeHTML(child)));\n    return;\n  }\n  if (isRenderInstance(child)) {\n    return child.render(destination);\n  }\n  if (isRenderTemplateResult(child)) {\n    return child.render(destination);\n  }\n  if (isAstroComponentInstance(child)) {\n    return child.render(destination);\n  }\n  if (ArrayBuffer.isView(child)) {\n    destination.write(child);\n    return;\n  }\n  if (typeof child === \"object\" && (Symbol.asyncIterator in child || Symbol.iterator in child)) {\n    if (Symbol.asyncIterator in child) {\n      return renderAsyncIterable(destination, child);\n    }\n    return renderIterable(destination, child);\n  }\n  destination.write(child);\n}\nfunction renderArray(destination, children) {\n  const flushers = children.map((c) => {\n    return createBufferedRenderer(destination, (bufferDestination) => {\n      return renderChild(bufferDestination, c);\n    });\n  });\n  const iterator = flushers[Symbol.iterator]();\n  const iterate = /* @__PURE__ */ __name(() => {\n    for (; ; ) {\n      const { value: flusher, done } = iterator.next();\n      if (done) {\n        break;\n      }\n      const result = flusher.flush();\n      if (isPromise(result)) {\n        return result.then(iterate);\n      }\n    }\n  }, \"iterate\");\n  return iterate();\n}\nfunction renderIterable(destination, children) {\n  const iterator = children[Symbol.iterator]();\n  const iterate = /* @__PURE__ */ __name(() => {\n    for (; ; ) {\n      const { value: value2, done } = iterator.next();\n      if (done) {\n        break;\n      }\n      const result = renderChild(destination, value2);\n      if (isPromise(result)) {\n        return result.then(iterate);\n      }\n    }\n  }, \"iterate\");\n  return iterate();\n}\nasync function renderAsyncIterable(destination, children) {\n  for await (const value2 of children) {\n    await renderChild(destination, value2);\n  }\n}\nfunction validateComponentProps(props, clientDirectives, displayName) {\n  if (props != null) {\n    const directives = [...clientDirectives.keys()].map((directive) => `client:${directive}`);\n    for (const prop of Object.keys(props)) {\n      if (directives.includes(prop)) {\n        console.warn(\n          `You are attempting to render <${displayName} ${prop} />, but ${displayName} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`\n        );\n      }\n    }\n  }\n}\nfunction createAstroComponentInstance(result, displayName, factory, props, slots = {}) {\n  validateComponentProps(props, result.clientDirectives, displayName);\n  const instance = new AstroComponentInstance(result, props, slots, factory);\n  if (isAPropagatingComponent(result, factory)) {\n    result._metadata.propagators.add(instance);\n  }\n  return instance;\n}\nfunction isAstroComponentInstance(obj) {\n  return typeof obj === \"object\" && obj !== null && !!obj[astroComponentInstanceSym];\n}\nasync function renderToString(result, componentFactory, props, children, isPage = false, route) {\n  const templateResult = await callComponentAsTemplateResultOrResponse(\n    result,\n    componentFactory,\n    props,\n    children,\n    route\n  );\n  if (templateResult instanceof Response) return templateResult;\n  let str = \"\";\n  let renderedFirstPageChunk = false;\n  if (isPage) {\n    await bufferHeadContent(result);\n  }\n  const destination = {\n    write(chunk) {\n      if (isPage && !renderedFirstPageChunk) {\n        renderedFirstPageChunk = true;\n        if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {\n          const doctype = result.compressHTML ? \"<!DOCTYPE html>\" : \"<!DOCTYPE html>\\n\";\n          str += doctype;\n        }\n      }\n      if (chunk instanceof Response) return;\n      str += chunkToString(result, chunk);\n    }\n  };\n  await templateResult.render(destination);\n  return str;\n}\nasync function renderToReadableStream(result, componentFactory, props, children, isPage = false, route) {\n  const templateResult = await callComponentAsTemplateResultOrResponse(\n    result,\n    componentFactory,\n    props,\n    children,\n    route\n  );\n  if (templateResult instanceof Response) return templateResult;\n  let renderedFirstPageChunk = false;\n  if (isPage) {\n    await bufferHeadContent(result);\n  }\n  return new ReadableStream({\n    start(controller) {\n      const destination = {\n        write(chunk) {\n          if (isPage && !renderedFirstPageChunk) {\n            renderedFirstPageChunk = true;\n            if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {\n              const doctype = result.compressHTML ? \"<!DOCTYPE html>\" : \"<!DOCTYPE html>\\n\";\n              controller.enqueue(encoder.encode(doctype));\n            }\n          }\n          if (chunk instanceof Response) {\n            throw new AstroError({\n              ...ResponseSentError\n            });\n          }\n          const bytes = chunkToByteArray(result, chunk);\n          controller.enqueue(bytes);\n        }\n      };\n      (async () => {\n        try {\n          await templateResult.render(destination);\n          controller.close();\n        } catch (e) {\n          if (AstroError.is(e) && !e.loc) {\n            e.setLocation({\n              file: route?.component\n            });\n          }\n          setTimeout(() => controller.error(e), 0);\n        }\n      })();\n    },\n    cancel() {\n      result.cancelled = true;\n    }\n  });\n}\nasync function callComponentAsTemplateResultOrResponse(result, componentFactory, props, children, route) {\n  const factoryResult = await componentFactory(result, props, children);\n  if (factoryResult instanceof Response) {\n    return factoryResult;\n  } else if (isHeadAndContent(factoryResult)) {\n    if (!isRenderTemplateResult(factoryResult.content)) {\n      throw new AstroError({\n        ...OnlyResponseCanBeReturned,\n        message: OnlyResponseCanBeReturned.message(\n          route?.route,\n          typeof factoryResult\n        ),\n        location: {\n          file: route?.component\n        }\n      });\n    }\n    return factoryResult.content;\n  } else if (!isRenderTemplateResult(factoryResult)) {\n    throw new AstroError({\n      ...OnlyResponseCanBeReturned,\n      message: OnlyResponseCanBeReturned.message(route?.route, typeof factoryResult),\n      location: {\n        file: route?.component\n      }\n    });\n  }\n  return factoryResult;\n}\nasync function bufferHeadContent(result) {\n  const iterator = result._metadata.propagators.values();\n  while (true) {\n    const { value: value2, done } = iterator.next();\n    if (done) {\n      break;\n    }\n    const returnValue = await value2.init(result);\n    if (isHeadAndContent(returnValue)) {\n      result._metadata.extraHead.push(returnValue.head);\n    }\n  }\n}\nasync function renderToAsyncIterable(result, componentFactory, props, children, isPage = false, route) {\n  const templateResult = await callComponentAsTemplateResultOrResponse(\n    result,\n    componentFactory,\n    props,\n    children,\n    route\n  );\n  if (templateResult instanceof Response) return templateResult;\n  let renderedFirstPageChunk = false;\n  if (isPage) {\n    await bufferHeadContent(result);\n  }\n  let error4 = null;\n  let next = null;\n  const buffer = [];\n  let renderingComplete = false;\n  const iterator = {\n    async next() {\n      if (result.cancelled) return { done: true, value: void 0 };\n      if (next !== null) {\n        await next.promise;\n      } else if (!renderingComplete && !buffer.length) {\n        next = promiseWithResolvers();\n        await next.promise;\n      }\n      if (!renderingComplete) {\n        next = promiseWithResolvers();\n      }\n      if (error4) {\n        throw error4;\n      }\n      let length = 0;\n      for (let i = 0, len = buffer.length; i < len; i++) {\n        length += buffer[i].length;\n      }\n      let mergedArray = new Uint8Array(length);\n      let offset = 0;\n      for (let i = 0, len = buffer.length; i < len; i++) {\n        const item = buffer[i];\n        mergedArray.set(item, offset);\n        offset += item.length;\n      }\n      buffer.length = 0;\n      const returnValue = {\n        // The iterator is done when rendering has finished\n        // and there are no more chunks to return.\n        done: length === 0 && renderingComplete,\n        value: mergedArray\n      };\n      return returnValue;\n    },\n    async return() {\n      result.cancelled = true;\n      return { done: true, value: void 0 };\n    }\n  };\n  const destination = {\n    write(chunk) {\n      if (isPage && !renderedFirstPageChunk) {\n        renderedFirstPageChunk = true;\n        if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {\n          const doctype = result.compressHTML ? \"<!DOCTYPE html>\" : \"<!DOCTYPE html>\\n\";\n          buffer.push(encoder.encode(doctype));\n        }\n      }\n      if (chunk instanceof Response) {\n        throw new AstroError(ResponseSentError);\n      }\n      const bytes = chunkToByteArray(result, chunk);\n      if (bytes.length > 0) {\n        buffer.push(bytes);\n        next?.resolve();\n      } else if (buffer.length > 0) {\n        next?.resolve();\n      }\n    }\n  };\n  const renderResult = toPromise(() => templateResult.render(destination));\n  renderResult.catch((err) => {\n    error4 = err;\n  }).finally(() => {\n    renderingComplete = true;\n    next?.resolve();\n  });\n  return {\n    [Symbol.asyncIterator]() {\n      return iterator;\n    }\n  };\n}\nfunction toPromise(fn2) {\n  try {\n    const result = fn2();\n    return isPromise(result) ? result : Promise.resolve(result);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nfunction componentIsHTMLElement(Component) {\n  return typeof HTMLElement !== \"undefined\" && HTMLElement.isPrototypeOf(Component);\n}\nasync function renderHTMLElement(result, constructor, props, slots) {\n  const name = getHTMLElementName(constructor);\n  let attrHTML = \"\";\n  for (const attr in props) {\n    attrHTML += ` ${attr}=\"${toAttributeString(await props[attr])}\"`;\n  }\n  return markHTMLString(\n    `<${name}${attrHTML}>${await renderSlotToString(result, slots?.default)}</${name}>`\n  );\n}\nfunction getHTMLElementName(constructor) {\n  const definedName = customElements.getName(constructor);\n  if (definedName) return definedName;\n  const assignedName = constructor.name.replace(/^HTML|Element$/g, \"\").replace(/[A-Z]/g, \"-$&\").toLowerCase().replace(/^-/, \"html-\");\n  return assignedName;\n}\nfunction guessRenderers(componentUrl) {\n  const extname = componentUrl?.split(\".\").pop();\n  switch (extname) {\n    case \"svelte\":\n      return [\"@astrojs/svelte\"];\n    case \"vue\":\n      return [\"@astrojs/vue\"];\n    case \"jsx\":\n    case \"tsx\":\n      return [\"@astrojs/react\", \"@astrojs/preact\", \"@astrojs/solid-js\", \"@astrojs/vue (jsx)\"];\n    case void 0:\n    default:\n      return [\n        \"@astrojs/react\",\n        \"@astrojs/preact\",\n        \"@astrojs/solid-js\",\n        \"@astrojs/vue\",\n        \"@astrojs/svelte\"\n      ];\n  }\n}\nfunction isFragmentComponent(Component) {\n  return Component === Fragment;\n}\nfunction isHTMLComponent(Component) {\n  return Component && Component[\"astro:html\"] === true;\n}\nfunction removeStaticAstroSlot(html2, supportsAstroStaticSlot = true) {\n  const exp = supportsAstroStaticSlot ? ASTRO_STATIC_SLOT_EXP : ASTRO_SLOT_EXP;\n  return html2.replace(exp, \"\");\n}\nasync function renderFrameworkComponent(result, displayName, Component, _props, slots = {}) {\n  if (!Component && \"client:only\" in _props === false) {\n    throw new Error(\n      `Unable to render ${displayName} because it is ${Component}!\nDid you forget to import the component or is it possible there is a typo?`\n    );\n  }\n  const { renderers: renderers2, clientDirectives } = result;\n  const metadata = {\n    astroStaticSlot: true,\n    displayName\n  };\n  const { hydration, isPage, props, propsWithoutTransitionAttributes } = extractDirectives(\n    _props,\n    clientDirectives\n  );\n  let html2 = \"\";\n  let attrs = void 0;\n  if (hydration) {\n    metadata.hydrate = hydration.directive;\n    metadata.hydrateArgs = hydration.value;\n    metadata.componentExport = hydration.componentExport;\n    metadata.componentUrl = hydration.componentUrl;\n  }\n  const probableRendererNames = guessRenderers(metadata.componentUrl);\n  const validRenderers = renderers2.filter((r2) => r2.name !== \"astro:jsx\");\n  const { children, slotInstructions } = await renderSlots(result, slots);\n  let renderer2;\n  if (metadata.hydrate !== \"only\") {\n    let isTagged = false;\n    try {\n      isTagged = Component && Component[Renderer];\n    } catch {\n    }\n    if (isTagged) {\n      const rendererName = Component[Renderer];\n      renderer2 = renderers2.find(({ name }) => name === rendererName);\n    }\n    if (!renderer2) {\n      let error4;\n      for (const r2 of renderers2) {\n        try {\n          if (await r2.ssr.check.call({ result }, Component, props, children)) {\n            renderer2 = r2;\n            break;\n          }\n        } catch (e) {\n          error4 ??= e;\n        }\n      }\n      if (!renderer2 && error4) {\n        throw error4;\n      }\n    }\n    if (!renderer2 && typeof HTMLElement === \"function\" && componentIsHTMLElement(Component)) {\n      const output = await renderHTMLElement(\n        result,\n        Component,\n        _props,\n        slots\n      );\n      return {\n        render(destination) {\n          destination.write(output);\n        }\n      };\n    }\n  } else {\n    if (metadata.hydrateArgs) {\n      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;\n      if (clientOnlyValues.has(rendererName)) {\n        renderer2 = renderers2.find(\n          ({ name }) => name === `@astrojs/${rendererName}` || name === rendererName\n        );\n      }\n    }\n    if (!renderer2 && validRenderers.length === 1) {\n      renderer2 = validRenderers[0];\n    }\n    if (!renderer2) {\n      const extname = metadata.componentUrl?.split(\".\").pop();\n      renderer2 = renderers2.find(({ name }) => name === `@astrojs/${extname}` || name === extname);\n    }\n  }\n  if (!renderer2) {\n    if (metadata.hydrate === \"only\") {\n      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;\n      if (clientOnlyValues.has(rendererName)) {\n        const plural = validRenderers.length > 1;\n        throw new AstroError({\n          ...NoMatchingRenderer,\n          message: NoMatchingRenderer.message(\n            metadata.displayName,\n            metadata?.componentUrl?.split(\".\").pop(),\n            plural,\n            validRenderers.length\n          ),\n          hint: NoMatchingRenderer.hint(\n            formatList(probableRendererNames.map((r2) => \"`\" + r2 + \"`\"))\n          )\n        });\n      } else {\n        throw new AstroError({\n          ...NoClientOnlyHint,\n          message: NoClientOnlyHint.message(metadata.displayName),\n          hint: NoClientOnlyHint.hint(\n            probableRendererNames.map((r2) => r2.replace(\"@astrojs/\", \"\")).join(\"|\")\n          )\n        });\n      }\n    } else if (typeof Component !== \"string\") {\n      const matchingRenderers = validRenderers.filter(\n        (r2) => probableRendererNames.includes(r2.name)\n      );\n      const plural = validRenderers.length > 1;\n      if (matchingRenderers.length === 0) {\n        throw new AstroError({\n          ...NoMatchingRenderer,\n          message: NoMatchingRenderer.message(\n            metadata.displayName,\n            metadata?.componentUrl?.split(\".\").pop(),\n            plural,\n            validRenderers.length\n          ),\n          hint: NoMatchingRenderer.hint(\n            formatList(probableRendererNames.map((r2) => \"`\" + r2 + \"`\"))\n          )\n        });\n      } else if (matchingRenderers.length === 1) {\n        renderer2 = matchingRenderers[0];\n        ({ html: html2, attrs } = await renderer2.ssr.renderToStaticMarkup.call(\n          { result },\n          Component,\n          propsWithoutTransitionAttributes,\n          children,\n          metadata\n        ));\n      } else {\n        throw new Error(`Unable to render ${metadata.displayName}!\n\nThis component likely uses ${formatList(probableRendererNames)},\nbut Astro encountered an error during server-side rendering.\n\nPlease ensure that ${metadata.displayName}:\n1. Does not unconditionally access browser-specific globals like \\`window\\` or \\`document\\`.\n   If this is unavoidable, use the \\`client:only\\` hydration directive.\n2. Does not conditionally return \\`null\\` or \\`undefined\\` when rendered on the server.\n\nIf you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);\n      }\n    }\n  } else {\n    if (metadata.hydrate === \"only\") {\n      html2 = await renderSlotToString(result, slots?.fallback);\n    } else {\n      performance.now();\n      ({ html: html2, attrs } = await renderer2.ssr.renderToStaticMarkup.call(\n        { result },\n        Component,\n        propsWithoutTransitionAttributes,\n        children,\n        metadata\n      ));\n    }\n  }\n  if (!html2 && typeof Component === \"string\") {\n    const Tag = sanitizeElementName(Component);\n    const childSlots = Object.values(children).join(\"\");\n    const renderTemplateResult = renderTemplate`<${Tag}${internalSpreadAttributes(\n      props\n    )}${markHTMLString(\n      childSlots === \"\" && voidElementNames.test(Tag) ? `/>` : `>${childSlots}</${Tag}>`\n    )}`;\n    html2 = \"\";\n    const destination = {\n      write(chunk) {\n        if (chunk instanceof Response) return;\n        html2 += chunkToString(result, chunk);\n      }\n    };\n    await renderTemplateResult.render(destination);\n  }\n  if (!hydration) {\n    return {\n      render(destination) {\n        if (slotInstructions) {\n          for (const instruction of slotInstructions) {\n            destination.write(instruction);\n          }\n        }\n        if (isPage || renderer2?.name === \"astro:jsx\") {\n          destination.write(html2);\n        } else if (html2 && html2.length > 0) {\n          destination.write(\n            markHTMLString(removeStaticAstroSlot(html2, renderer2?.ssr?.supportsAstroStaticSlot))\n          );\n        }\n      }\n    };\n  }\n  const astroId = shorthash(\n    `<!--${metadata.componentExport.value}:${metadata.componentUrl}-->\n${html2}\n${serializeProps(\n      props,\n      metadata\n    )}`\n  );\n  const island = await generateHydrateScript(\n    { renderer: renderer2, result, astroId, props, attrs },\n    metadata\n  );\n  let unrenderedSlots = [];\n  if (html2) {\n    if (Object.keys(children).length > 0) {\n      for (const key of Object.keys(children)) {\n        let tagName = renderer2?.ssr?.supportsAstroStaticSlot ? !!metadata.hydrate ? \"astro-slot\" : \"astro-static-slot\" : \"astro-slot\";\n        let expectedHTML = key === \"default\" ? `<${tagName}>` : `<${tagName} name=\"${key}\">`;\n        if (!html2.includes(expectedHTML)) {\n          unrenderedSlots.push(key);\n        }\n      }\n    }\n  } else {\n    unrenderedSlots = Object.keys(children);\n  }\n  const template2 = unrenderedSlots.length > 0 ? unrenderedSlots.map(\n    (key) => `<template data-astro-template${key !== \"default\" ? `=\"${key}\"` : \"\"}>${children[key]}</template>`\n  ).join(\"\") : \"\";\n  island.children = `${html2 ?? \"\"}${template2}`;\n  if (island.children) {\n    island.props[\"await-children\"] = \"\";\n    island.children += `<!--astro:end-->`;\n  }\n  return {\n    render(destination) {\n      if (slotInstructions) {\n        for (const instruction of slotInstructions) {\n          destination.write(instruction);\n        }\n      }\n      destination.write(createRenderInstruction({ type: \"directive\", hydration }));\n      if (hydration.directive !== \"only\" && renderer2?.ssr.renderHydrationScript) {\n        destination.write(\n          createRenderInstruction({\n            type: \"renderer-hydration-script\",\n            rendererName: renderer2.name,\n            render: renderer2.ssr.renderHydrationScript\n          })\n        );\n      }\n      const renderedElement = renderElement$1(\"astro-island\", island, false);\n      destination.write(markHTMLString(renderedElement));\n    }\n  };\n}\nfunction sanitizeElementName(tag) {\n  const unsafe = /[&<>'\"\\s]+/;\n  if (!unsafe.test(tag)) return tag;\n  return tag.trim().split(unsafe)[0].trim();\n}\nasync function renderFragmentComponent(result, slots = {}) {\n  const children = await renderSlotToString(result, slots?.default);\n  return {\n    render(destination) {\n      if (children == null) return;\n      destination.write(children);\n    }\n  };\n}\nasync function renderHTMLComponent(result, Component, _props, slots = {}) {\n  const { slotInstructions, children } = await renderSlots(result, slots);\n  const html2 = Component({ slots: children });\n  const hydrationHtml = slotInstructions ? slotInstructions.map((instr) => chunkToString(result, instr)).join(\"\") : \"\";\n  return {\n    render(destination) {\n      destination.write(markHTMLString(hydrationHtml + html2));\n    }\n  };\n}\nfunction renderAstroComponent(result, displayName, Component, props, slots = {}) {\n  if (containsServerDirective(props)) {\n    return renderServerIsland(result, displayName, props, slots);\n  }\n  const instance = createAstroComponentInstance(result, displayName, Component, props, slots);\n  return {\n    render(destination) {\n      return instance.render(destination);\n    }\n  };\n}\nfunction renderComponent(result, displayName, Component, props, slots = {}) {\n  if (isPromise(Component)) {\n    return Component.catch(handleCancellation).then((x) => {\n      return renderComponent(result, displayName, x, props, slots);\n    });\n  }\n  if (isFragmentComponent(Component)) {\n    return renderFragmentComponent(result, slots).catch(handleCancellation);\n  }\n  props = normalizeProps(props);\n  if (isHTMLComponent(Component)) {\n    return renderHTMLComponent(result, Component, props, slots).catch(handleCancellation);\n  }\n  if (isAstroComponentFactory(Component)) {\n    return renderAstroComponent(result, displayName, Component, props, slots);\n  }\n  return renderFrameworkComponent(result, displayName, Component, props, slots).catch(\n    handleCancellation\n  );\n  function handleCancellation(e) {\n    if (result.cancelled)\n      return {\n        render() {\n        }\n      };\n    throw e;\n  }\n  __name(handleCancellation, \"handleCancellation\");\n}\nfunction normalizeProps(props) {\n  if (props[\"class:list\"] !== void 0) {\n    const value2 = props[\"class:list\"];\n    delete props[\"class:list\"];\n    props[\"class\"] = clsx(props[\"class\"], value2);\n    if (props[\"class\"] === \"\") {\n      delete props[\"class\"];\n    }\n  }\n  return props;\n}\nasync function renderComponentToString(result, displayName, Component, props, slots = {}, isPage = false, route) {\n  let str = \"\";\n  let renderedFirstPageChunk = false;\n  let head = \"\";\n  if (isPage && !result.partial && nonAstroPageNeedsHeadInjection(Component)) {\n    head += chunkToString(result, maybeRenderHead());\n  }\n  try {\n    const destination = {\n      write(chunk) {\n        if (isPage && !result.partial && !renderedFirstPageChunk) {\n          renderedFirstPageChunk = true;\n          if (!/<!doctype html/i.test(String(chunk))) {\n            const doctype = result.compressHTML ? \"<!DOCTYPE html>\" : \"<!DOCTYPE html>\\n\";\n            str += doctype + head;\n          }\n        }\n        if (chunk instanceof Response) return;\n        str += chunkToString(result, chunk);\n      }\n    };\n    const renderInstance = await renderComponent(result, displayName, Component, props, slots);\n    await renderInstance.render(destination);\n  } catch (e) {\n    if (AstroError.is(e) && !e.loc) {\n      e.setLocation({\n        file: route?.component\n      });\n    }\n    throw e;\n  }\n  return str;\n}\nfunction nonAstroPageNeedsHeadInjection(pageComponent) {\n  return !!pageComponent?.[needsHeadRenderingSymbol];\n}\nasync function renderJSX(result, vnode) {\n  switch (true) {\n    case vnode instanceof HTMLString:\n      if (vnode.toString().trim() === \"\") {\n        return \"\";\n      }\n      return vnode;\n    case typeof vnode === \"string\":\n      return markHTMLString(escapeHTML(vnode));\n    case typeof vnode === \"function\":\n      return vnode;\n    case (!vnode && vnode !== 0):\n      return \"\";\n    case Array.isArray(vnode):\n      return markHTMLString(\n        (await Promise.all(vnode.map((v3) => renderJSX(result, v3)))).join(\"\")\n      );\n  }\n  return renderJSXVNode(result, vnode);\n}\nasync function renderJSXVNode(result, vnode) {\n  if (isVNode(vnode)) {\n    switch (true) {\n      case !vnode.type: {\n        throw new Error(`Unable to render ${result.pathname} because it contains an undefined Component!\nDid you forget to import the component or is it possible there is a typo?`);\n      }\n      case vnode.type === Symbol.for(\"astro:fragment\"):\n        return renderJSX(result, vnode.props.children);\n      case isAstroComponentFactory(vnode.type): {\n        let props = {};\n        let slots = {};\n        for (const [key, value2] of Object.entries(vnode.props ?? {})) {\n          if (key === \"children\" || value2 && typeof value2 === \"object\" && value2[\"$$slot\"]) {\n            slots[key === \"children\" ? \"default\" : key] = () => renderJSX(result, value2);\n          } else {\n            props[key] = value2;\n          }\n        }\n        const str = await renderComponentToString(\n          result,\n          vnode.type.name,\n          vnode.type,\n          props,\n          slots\n        );\n        const html2 = markHTMLString(str);\n        return html2;\n      }\n      case (!vnode.type && vnode.type !== 0):\n        return \"\";\n      case (typeof vnode.type === \"string\" && vnode.type !== ClientOnlyPlaceholder):\n        return markHTMLString(await renderElement(result, vnode.type, vnode.props ?? {}));\n    }\n    if (vnode.type) {\n      let extractSlots2 = /* @__PURE__ */ __name(function(child) {\n        if (Array.isArray(child)) {\n          return child.map((c) => extractSlots2(c));\n        }\n        if (!isVNode(child)) {\n          _slots.default.push(child);\n          return;\n        }\n        if (\"slot\" in child.props) {\n          _slots[child.props.slot] = [..._slots[child.props.slot] ?? [], child];\n          delete child.props.slot;\n          return;\n        }\n        _slots.default.push(child);\n      }, \"extractSlots2\");\n      if (typeof vnode.type === \"function\" && vnode.props[\"server:root\"]) {\n        const output2 = await vnode.type(vnode.props ?? {});\n        return await renderJSX(result, output2);\n      }\n      if (typeof vnode.type === \"function\") {\n        if (vnode.props[hasTriedRenderComponentSymbol]) {\n          delete vnode.props[hasTriedRenderComponentSymbol];\n          const output2 = await vnode.type(vnode.props ?? {});\n          if (output2?.[AstroJSX] || !output2) {\n            return await renderJSXVNode(result, output2);\n          } else {\n            return;\n          }\n        } else {\n          vnode.props[hasTriedRenderComponentSymbol] = true;\n        }\n      }\n      const { children = null, ...props } = vnode.props ?? {};\n      const _slots = {\n        default: []\n      };\n      extractSlots2(children);\n      for (const [key, value2] of Object.entries(props)) {\n        if (value2?.[\"$$slot\"]) {\n          _slots[key] = value2;\n          delete props[key];\n        }\n      }\n      const slotPromises = [];\n      const slots = {};\n      for (const [key, value2] of Object.entries(_slots)) {\n        slotPromises.push(\n          renderJSX(result, value2).then((output2) => {\n            if (output2.toString().trim().length === 0) return;\n            slots[key] = () => output2;\n          })\n        );\n      }\n      await Promise.all(slotPromises);\n      let output;\n      if (vnode.type === ClientOnlyPlaceholder && vnode.props[\"client:only\"]) {\n        output = await renderComponentToString(\n          result,\n          vnode.props[\"client:display-name\"] ?? \"\",\n          null,\n          props,\n          slots\n        );\n      } else {\n        output = await renderComponentToString(\n          result,\n          typeof vnode.type === \"function\" ? vnode.type.name : vnode.type,\n          vnode.type,\n          props,\n          slots\n        );\n      }\n      return markHTMLString(output);\n    }\n  }\n  return markHTMLString(`${vnode}`);\n}\nasync function renderElement(result, tag, { children, ...props }) {\n  return markHTMLString(\n    `<${tag}${spreadAttributes(props)}${markHTMLString(\n      (children == null || children == \"\") && voidElementNames.test(tag) ? `/>` : `>${children == null ? \"\" : await renderJSX(result, prerenderElementChildren(tag, children))}</${tag}>`\n    )}`\n  );\n}\nfunction prerenderElementChildren(tag, children) {\n  if (typeof children === \"string\" && (tag === \"style\" || tag === \"script\")) {\n    return markHTMLString(children);\n  } else {\n    return children;\n  }\n}\nasync function renderScript(result, id2) {\n  if (result._metadata.renderedScripts.has(id2)) return;\n  result._metadata.renderedScripts.add(id2);\n  const inlined = result.inlinedScripts.get(id2);\n  if (inlined != null) {\n    if (inlined) {\n      return markHTMLString(`<script type=\"module\">${inlined}</script>`);\n    } else {\n      return \"\";\n    }\n  }\n  const resolved = await result.resolve(id2);\n  return markHTMLString(\n    `<script type=\"module\" src=\"${result.userAssetsBase ? (result.base === \"/\" ? \"\" : result.base) + result.userAssetsBase : \"\"}${resolved}\"></script>`\n  );\n}\nasync function renderPage(result, componentFactory, props, children, streaming, route) {\n  if (!isAstroComponentFactory(componentFactory)) {\n    result._metadata.headInTree = result.componentMetadata.get(componentFactory.moduleId)?.containsHead ?? false;\n    const pageProps = { ...props ?? {}, \"server:root\": true };\n    const str = await renderComponentToString(\n      result,\n      componentFactory.name,\n      componentFactory,\n      pageProps,\n      {},\n      true,\n      route\n    );\n    const bytes = encoder.encode(str);\n    return new Response(bytes, {\n      headers: new Headers([\n        [\"Content-Type\", \"text/html\"],\n        [\"Content-Length\", bytes.byteLength.toString()]\n      ])\n    });\n  }\n  result._metadata.headInTree = result.componentMetadata.get(componentFactory.moduleId)?.containsHead ?? false;\n  let body;\n  if (streaming) {\n    if (isNode && !isDeno) {\n      const nodeBody = await renderToAsyncIterable(\n        result,\n        componentFactory,\n        props,\n        children,\n        true,\n        route\n      );\n      body = nodeBody;\n    } else {\n      body = await renderToReadableStream(result, componentFactory, props, children, true, route);\n    }\n  } else {\n    body = await renderToString(result, componentFactory, props, children, true, route);\n  }\n  if (body instanceof Response) return body;\n  const init2 = result.response;\n  const headers = new Headers(init2.headers);\n  if (!streaming && typeof body === \"string\") {\n    body = encoder.encode(body);\n    headers.set(\"Content-Length\", body.byteLength.toString());\n  }\n  let status = init2.status;\n  let statusText = init2.statusText;\n  if (route?.route === \"/404\") {\n    status = 404;\n    if (statusText === \"OK\") {\n      statusText = \"Not Found\";\n    }\n  } else if (route?.route === \"/500\") {\n    status = 500;\n    if (statusText === \"OK\") {\n      statusText = \"Internal Server Error\";\n    }\n  }\n  if (status) {\n    return new Response(body, { ...init2, headers, status, statusText });\n  } else {\n    return new Response(body, { ...init2, headers });\n  }\n}\nfunction requireCssesc() {\n  if (hasRequiredCssesc) return cssesc_1;\n  hasRequiredCssesc = 1;\n  var object2 = {};\n  var hasOwnProperty2 = object2.hasOwnProperty;\n  var merge = /* @__PURE__ */ __name(function merge2(options, defaults) {\n    if (!options) {\n      return defaults;\n    }\n    var result = {};\n    for (var key in defaults) {\n      result[key] = hasOwnProperty2.call(options, key) ? options[key] : defaults[key];\n    }\n    return result;\n  }, \"merge\");\n  var regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\n  var regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\n  var regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n  var cssesc = /* @__PURE__ */ __name(function cssesc2(string2, options) {\n    options = merge(options, cssesc2.options);\n    if (options.quotes != \"single\" && options.quotes != \"double\") {\n      options.quotes = \"single\";\n    }\n    var quote = options.quotes == \"double\" ? '\"' : \"'\";\n    var isIdentifier = options.isIdentifier;\n    var firstChar = string2.charAt(0);\n    var output = \"\";\n    var counter = 0;\n    var length = string2.length;\n    while (counter < length) {\n      var character = string2.charAt(counter++);\n      var codePoint = character.charCodeAt();\n      var value2 = void 0;\n      if (codePoint < 32 || codePoint > 126) {\n        if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {\n          var extra = string2.charCodeAt(counter++);\n          if ((extra & 64512) == 56320) {\n            codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;\n          } else {\n            counter--;\n          }\n        }\n        value2 = \"\\\\\" + codePoint.toString(16).toUpperCase() + \" \";\n      } else {\n        if (options.escapeEverything) {\n          if (regexAnySingleEscape.test(character)) {\n            value2 = \"\\\\\" + character;\n          } else {\n            value2 = \"\\\\\" + codePoint.toString(16).toUpperCase() + \" \";\n          }\n        } else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n          value2 = \"\\\\\" + codePoint.toString(16).toUpperCase() + \" \";\n        } else if (character == \"\\\\\" || !isIdentifier && (character == '\"' && quote == character || character == \"'\" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n          value2 = \"\\\\\" + character;\n        } else {\n          value2 = character;\n        }\n      }\n      output += value2;\n    }\n    if (isIdentifier) {\n      if (/^-[-\\d]/.test(output)) {\n        output = \"\\\\-\" + output.slice(1);\n      } else if (/\\d/.test(firstChar)) {\n        output = \"\\\\3\" + firstChar + \" \" + output.slice(1);\n      }\n    }\n    output = output.replace(regexExcessiveSpaces, function($0, $1, $22) {\n      if ($1 && $1.length % 2) {\n        return $0;\n      }\n      return ($1 || \"\") + $22;\n    });\n    if (!isIdentifier && options.wrap) {\n      return quote + output + quote;\n    }\n    return output;\n  }, \"cssesc\");\n  cssesc.options = {\n    \"escapeEverything\": false,\n    \"isIdentifier\": false,\n    \"quotes\": \"single\",\n    \"wrap\": false\n  };\n  cssesc.version = \"3.0.0\";\n  cssesc_1 = cssesc;\n  return cssesc_1;\n}\nfunction spreadAttributes(values = {}, _name, { class: scopedClassName } = {}) {\n  let output = \"\";\n  if (scopedClassName) {\n    if (typeof values.class !== \"undefined\") {\n      values.class += ` ${scopedClassName}`;\n    } else if (typeof values[\"class:list\"] !== \"undefined\") {\n      values[\"class:list\"] = [values[\"class:list\"], scopedClassName];\n    } else {\n      values.class = scopedClassName;\n    }\n  }\n  for (const [key, value2] of Object.entries(values)) {\n    output += addAttribute(value2, key, true);\n  }\n  return markHTMLString(output);\n}\nvar ASTRO_VERSION, REROUTE_DIRECTIVE_HEADER, REWRITE_DIRECTIVE_HEADER_KEY, REWRITE_DIRECTIVE_HEADER_VALUE, NOOP_MIDDLEWARE_HEADER, ROUTE_TYPE_HEADER, DEFAULT_404_COMPONENT, REDIRECT_STATUS_CODES, REROUTABLE_STATUS_CODES, clientAddressSymbol, originPathnameSymbol, responseSentSymbol, ClientAddressNotAvailable, PrerenderClientAddressNotAvailable, StaticClientAddressNotAvailable, NoMatchingStaticPathFound, OnlyResponseCanBeReturned, MissingMediaQueryDirective, NoMatchingRenderer, NoClientOnlyHint, InvalidGetStaticPathsEntry, InvalidGetStaticPathsReturn, GetStaticPathsExpectedParams, GetStaticPathsInvalidRouteParam, GetStaticPathsRequired, ReservedSlotName, NoMatchingImport, InvalidComponentArgs, PageNumberParamNotFound, PrerenderDynamicEndpointPathCollide, ResponseSentError, MiddlewareNoDataOrNextCalled, MiddlewareNotAResponse, EndpointDidNotReturnAResponse, LocalsNotAnObject, LocalsReassigned, AstroResponseHeadersReassigned, AstroGlobUsedOutside, AstroGlobNoMatch, i18nNoLocaleFoundInPath, RewriteWithBodyUsed, ForbiddenRewrite, ActionsReturnedInvalidDataError, ActionNotFoundError, SessionStorageInitError, SessionStorageSaveError, AstroError, FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY, $, bold, dim, red, green, yellow, blue, replace, ca, esca, pe, escape, escapeHTML, HTMLBytes, HTMLString, markHTMLString, AstroJSX, RenderInstructionSymbol, PROP_TYPE, transitionDirectivesToCopyOnIsland, dictionary, binary, headAndContentSym, astro_island_prebuilt_default, ISLAND_STYLES, voidElementNames, htmlBooleanAttributes, AMPERSAND_REGEX, DOUBLE_QUOTE_REGEX, STATIC_DIRECTIVES, toIdent, toAttributeString, kebab, toStyleString, noop, BufferedRenderer, isNode, isDeno, VALID_PROTOCOLS, uniqueElements, alphabetUpperCase, decodeMap, EncodingPadding$1, DecodingPadding$1, base64Alphabet, EncodingPadding, DecodingPadding, base64DecodeMap, ALGORITHM, encoder$1, decoder$1, IV_LENGTH, renderTemplateResultSym, RenderTemplateResult, slotString, SlotString, internalProps, SCRIPT_RE, COMMENT_RE, SCRIPT_REPLACER, COMMENT_REPLACER, renderServerIslandRuntime, Fragment, Renderer, encoder, decoder, astroComponentInstanceSym, AstroComponentInstance, DOCTYPE_EXP, needsHeadRenderingSymbol, rendererAliases, clientOnlyValues, ASTRO_SLOT_EXP, ASTRO_STATIC_SLOT_EXP, ClientOnlyPlaceholder, hasTriedRenderComponentSymbol, cssesc_1, hasRequiredCssesc;\nvar init_server_C8vVOH8G = __esm({\n  \"dist/_worker.js/chunks/astro/server_C8vVOH8G.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    __name(getDefaultExportFromCjs, \"getDefaultExportFromCjs\");\n    ASTRO_VERSION = \"5.8.1\";\n    REROUTE_DIRECTIVE_HEADER = \"X-Astro-Reroute\";\n    REWRITE_DIRECTIVE_HEADER_KEY = \"X-Astro-Rewrite\";\n    REWRITE_DIRECTIVE_HEADER_VALUE = \"yes\";\n    NOOP_MIDDLEWARE_HEADER = \"X-Astro-Noop\";\n    ROUTE_TYPE_HEADER = \"X-Astro-Route-Type\";\n    DEFAULT_404_COMPONENT = \"astro-default-404.astro\";\n    REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308, 300, 304];\n    REROUTABLE_STATUS_CODES = [404, 500];\n    clientAddressSymbol = Symbol.for(\"astro.clientAddress\");\n    originPathnameSymbol = Symbol.for(\"astro.originPathname\");\n    responseSentSymbol = Symbol.for(\"astro.responseSent\");\n    ClientAddressNotAvailable = {\n      name: \"ClientAddressNotAvailable\",\n      title: \"`Astro.clientAddress` is not available in current adapter.\",\n      message: /* @__PURE__ */ __name((adapterName) => `\\`Astro.clientAddress\\` is not available in the \\`${adapterName}\\` adapter. File an issue with the adapter to add support.`, \"message\")\n    };\n    PrerenderClientAddressNotAvailable = {\n      name: \"PrerenderClientAddressNotAvailable\",\n      title: \"`Astro.clientAddress` cannot be used inside prerendered routes.\",\n      message: /* @__PURE__ */ __name((name) => `\\`Astro.clientAddress\\` cannot be used inside prerendered route ${name}`, \"message\")\n    };\n    StaticClientAddressNotAvailable = {\n      name: \"StaticClientAddressNotAvailable\",\n      title: \"`Astro.clientAddress` is not available in prerendered pages.\",\n      message: \"`Astro.clientAddress` is only available on pages that are server-rendered.\",\n      hint: \"See https://docs.astro.build/en/guides/on-demand-rendering/ for more information on how to enable SSR.\"\n    };\n    NoMatchingStaticPathFound = {\n      name: \"NoMatchingStaticPathFound\",\n      title: \"No static path found for requested path.\",\n      message: /* @__PURE__ */ __name((pathName) => `A \\`getStaticPaths()\\` route pattern was matched, but no matching static path was found for requested path \\`${pathName}\\`.`, \"message\"),\n      hint: /* @__PURE__ */ __name((possibleRoutes) => `Possible dynamic routes being matched: ${possibleRoutes.join(\", \")}.`, \"hint\")\n    };\n    OnlyResponseCanBeReturned = {\n      name: \"OnlyResponseCanBeReturned\",\n      title: \"Invalid type returned by Astro page.\",\n      message: /* @__PURE__ */ __name((route, returnedValue) => `Route \\`${route ? route : \"\"}\\` returned a \\`${returnedValue}\\`. Only a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) can be returned from Astro files.`, \"message\"),\n      hint: \"See https://docs.astro.build/en/guides/on-demand-rendering/#response for more information.\"\n    };\n    MissingMediaQueryDirective = {\n      name: \"MissingMediaQueryDirective\",\n      title: \"Missing value for `client:media` directive.\",\n      message: 'Media query not provided for `client:media` directive. A media query similar to `client:media=\"(max-width: 600px)\"` must be provided'\n    };\n    NoMatchingRenderer = {\n      name: \"NoMatchingRenderer\",\n      title: \"No matching renderer found.\",\n      message: /* @__PURE__ */ __name((componentName, componentExtension, plural, validRenderersCount) => `Unable to render \\`${componentName}\\`.\n\n${validRenderersCount > 0 ? `There ${plural ? \"are\" : \"is\"} ${validRenderersCount} renderer${plural ? \"s\" : \"\"} configured in your \\`astro.config.mjs\\` file,\nbut ${plural ? \"none were\" : \"it was not\"} able to server-side render \\`${componentName}\\`.` : `No valid renderer was found ${componentExtension ? `for the \\`.${componentExtension}\\` file extension.` : `for this file extension.`}`}`, \"message\"),\n      hint: /* @__PURE__ */ __name((probableRenderers) => `Did you mean to enable the ${probableRenderers} integration?\n\nSee https://docs.astro.build/en/guides/framework-components/ for more information on how to install and configure integrations.`, \"hint\")\n    };\n    NoClientOnlyHint = {\n      name: \"NoClientOnlyHint\",\n      title: \"Missing hint on client:only directive.\",\n      message: /* @__PURE__ */ __name((componentName) => `Unable to render \\`${componentName}\\`. When using the \\`client:only\\` hydration strategy, Astro needs a hint to use the correct renderer.`, \"message\"),\n      hint: /* @__PURE__ */ __name((probableRenderers) => `Did you mean to pass \\`client:only=\"${probableRenderers}\"\\`? See https://docs.astro.build/en/reference/directives-reference/#clientonly for more information on client:only`, \"hint\")\n    };\n    InvalidGetStaticPathsEntry = {\n      name: \"InvalidGetStaticPathsEntry\",\n      title: \"Invalid entry inside getStaticPath's return value\",\n      message: /* @__PURE__ */ __name((entryType) => `Invalid entry returned by getStaticPaths. Expected an object, got \\`${entryType}\\``, \"message\"),\n      hint: \"If you're using a `.map` call, you might be looking for `.flatMap()` instead. See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths.\"\n    };\n    InvalidGetStaticPathsReturn = {\n      name: \"InvalidGetStaticPathsReturn\",\n      title: \"Invalid value returned by getStaticPaths.\",\n      message: /* @__PURE__ */ __name((returnType) => `Invalid type returned by \\`getStaticPaths\\`. Expected an \\`array\\`, got \\`${returnType}\\``, \"message\"),\n      hint: \"See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths.\"\n    };\n    GetStaticPathsExpectedParams = {\n      name: \"GetStaticPathsExpectedParams\",\n      title: \"Missing params property on `getStaticPaths` route.\",\n      message: \"Missing or empty required `params` property on `getStaticPaths` route.\",\n      hint: \"See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths.\"\n    };\n    GetStaticPathsInvalidRouteParam = {\n      name: \"GetStaticPathsInvalidRouteParam\",\n      title: \"Invalid value for `getStaticPaths` route parameter.\",\n      message: /* @__PURE__ */ __name((key, value2, valueType) => `Invalid getStaticPaths route parameter for \\`${key}\\`. Expected undefined, a string or a number, received \\`${valueType}\\` (\\`${value2}\\`)`, \"message\"),\n      hint: \"See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths.\"\n    };\n    GetStaticPathsRequired = {\n      name: \"GetStaticPathsRequired\",\n      title: \"`getStaticPaths()` function required for dynamic routes.\",\n      message: \"`getStaticPaths()` function is required for dynamic routes. Make sure that you `export` a `getStaticPaths` function from your dynamic route.\",\n      hint: `See https://docs.astro.build/en/guides/routing/#dynamic-routes for more information on dynamic routes.\n\n\tIf you meant for this route to be server-rendered, set \\`export const prerender = false;\\` in the page.`\n    };\n    ReservedSlotName = {\n      name: \"ReservedSlotName\",\n      title: \"Invalid slot name.\",\n      message: /* @__PURE__ */ __name((slotName2) => `Unable to create a slot named \\`${slotName2}\\`. \\`${slotName2}\\` is a reserved slot name. Please update the name of this slot.`, \"message\")\n    };\n    NoMatchingImport = {\n      name: \"NoMatchingImport\",\n      title: \"No import found for component.\",\n      message: /* @__PURE__ */ __name((componentName) => `Could not render \\`${componentName}\\`. No matching import has been found for \\`${componentName}\\`.`, \"message\"),\n      hint: \"Please make sure the component is properly imported.\"\n    };\n    InvalidComponentArgs = {\n      name: \"InvalidComponentArgs\",\n      title: \"Invalid component arguments.\",\n      message: /* @__PURE__ */ __name((name) => `Invalid arguments passed to${name ? ` <${name}>` : \"\"} component.`, \"message\"),\n      hint: \"Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`.\"\n    };\n    PageNumberParamNotFound = {\n      name: \"PageNumberParamNotFound\",\n      title: \"Page number param not found.\",\n      message: /* @__PURE__ */ __name((paramName) => `[paginate()] page number param \\`${paramName}\\` not found in your filepath.`, \"message\"),\n      hint: \"Rename your file to `[page].astro` or `[...page].astro`.\"\n    };\n    PrerenderDynamicEndpointPathCollide = {\n      name: \"PrerenderDynamicEndpointPathCollide\",\n      title: \"Prerendered dynamic endpoint has path collision.\",\n      message: /* @__PURE__ */ __name((pathname) => `Could not render \\`${pathname}\\` with an \\`undefined\\` param as the generated path will collide during prerendering. Prevent passing \\`undefined\\` as \\`params\\` for the endpoint's \\`getStaticPaths()\\` function, or add an additional extension to the endpoint's filename.`, \"message\"),\n      hint: /* @__PURE__ */ __name((filename) => `Rename \\`${filename}\\` to \\`${filename.replace(/\\.(?:js|ts)/, (m2) => `.json` + m2)}\\``, \"hint\")\n    };\n    ResponseSentError = {\n      name: \"ResponseSentError\",\n      title: \"Unable to set response.\",\n      message: \"The response has already been sent to the browser and cannot be altered.\"\n    };\n    MiddlewareNoDataOrNextCalled = {\n      name: \"MiddlewareNoDataOrNextCalled\",\n      title: \"The middleware didn't return a `Response`.\",\n      message: \"Make sure your middleware returns a `Response` object, either directly or by returning the `Response` from calling the `next` function.\"\n    };\n    MiddlewareNotAResponse = {\n      name: \"MiddlewareNotAResponse\",\n      title: \"The middleware returned something that is not a `Response` object.\",\n      message: \"Any data returned from middleware must be a valid `Response` object.\"\n    };\n    EndpointDidNotReturnAResponse = {\n      name: \"EndpointDidNotReturnAResponse\",\n      title: \"The endpoint did not return a `Response`.\",\n      message: \"An endpoint must return either a `Response`, or a `Promise` that resolves with a `Response`.\"\n    };\n    LocalsNotAnObject = {\n      name: \"LocalsNotAnObject\",\n      title: \"Value assigned to `locals` is not accepted.\",\n      message: \"`locals` can only be assigned to an object. Other values like numbers, strings, etc. are not accepted.\",\n      hint: \"If you tried to remove some information from the `locals` object, try to use `delete` or set the property to `undefined`.\"\n    };\n    LocalsReassigned = {\n      name: \"LocalsReassigned\",\n      title: \"`locals` must not be reassigned.\",\n      message: \"`locals` can not be assigned directly.\",\n      hint: \"Set a `locals` property instead.\"\n    };\n    AstroResponseHeadersReassigned = {\n      name: \"AstroResponseHeadersReassigned\",\n      title: \"`Astro.response.headers` must not be reassigned.\",\n      message: \"Individual headers can be added to and removed from `Astro.response.headers`, but it must not be replaced with another instance of `Headers` altogether.\",\n      hint: \"Consider using `Astro.response.headers.add()`, and `Astro.response.headers.delete()`.\"\n    };\n    AstroGlobUsedOutside = {\n      name: \"AstroGlobUsedOutside\",\n      title: \"Astro.glob() used outside of an Astro file.\",\n      message: /* @__PURE__ */ __name((globStr) => `\\`Astro.glob(${globStr})\\` can only be used in \\`.astro\\` files. \\`import.meta.glob(${globStr})\\` can be used instead to achieve a similar result.`, \"message\"),\n      hint: \"See Vite's documentation on `import.meta.glob` for more information: https://vite.dev/guide/features.html#glob-import\"\n    };\n    AstroGlobNoMatch = {\n      name: \"AstroGlobNoMatch\",\n      title: \"Astro.glob() did not match any files.\",\n      message: /* @__PURE__ */ __name((globStr) => `\\`Astro.glob(${globStr})\\` did not return any matching files.`, \"message\"),\n      hint: \"Check the pattern for typos.\"\n    };\n    i18nNoLocaleFoundInPath = {\n      name: \"i18nNoLocaleFoundInPath\",\n      title: \"The path doesn't contain any locale\",\n      message: \"You tried to use an i18n utility on a path that doesn't contain any locale. You can use `pathHasLocale` first to determine if the path has a locale.\"\n    };\n    RewriteWithBodyUsed = {\n      name: \"RewriteWithBodyUsed\",\n      title: \"Cannot use Astro.rewrite after the request body has been read\",\n      message: \"Astro.rewrite() cannot be used if the request body has already been read. If you need to read the body, first clone the request.\"\n    };\n    ForbiddenRewrite = {\n      name: \"ForbiddenRewrite\",\n      title: \"Forbidden rewrite to a static route.\",\n      message: /* @__PURE__ */ __name((from, to2, component) => `You tried to rewrite the on-demand route '${from}' with the static route '${to2}', when using the 'server' output. \n\nThe static route '${to2}' is rendered by the component\n'${component}', which is marked as prerendered. This is a forbidden operation because during the build the component '${component}' is compiled to an\nHTML file, which can't be retrieved at runtime by Astro.`, \"message\"),\n      hint: /* @__PURE__ */ __name((component) => `Add \\`export const prerender = false\\` to the component '${component}', or use a Astro.redirect().`, \"hint\")\n    };\n    ActionsReturnedInvalidDataError = {\n      name: \"ActionsReturnedInvalidDataError\",\n      title: \"Action handler returned invalid data.\",\n      message: /* @__PURE__ */ __name((error4) => `Action handler returned invalid data. Handlers should return serializable data types like objects, arrays, strings, and numbers. Parse error: ${error4}`, \"message\"),\n      hint: \"See the devalue library for all supported types: https://github.com/rich-harris/devalue\"\n    };\n    ActionNotFoundError = {\n      name: \"ActionNotFoundError\",\n      title: \"Action not found.\",\n      message: /* @__PURE__ */ __name((actionName) => `The server received a request for an action named \\`${actionName}\\` but could not find a match. If you renamed an action, check that you've updated your \\`actions/index\\` file and your calling code to match.`, \"message\"),\n      hint: \"You can run `astro check` to detect type errors caused by mismatched action names.\"\n    };\n    SessionStorageInitError = {\n      name: \"SessionStorageInitError\",\n      title: \"Session storage could not be initialized.\",\n      message: /* @__PURE__ */ __name((error4, driver) => `Error when initializing session storage${driver ? ` with driver \\`${driver}\\`` : \"\"}. \\`${error4 ?? \"\"}\\``, \"message\"),\n      hint: \"For more information, see https://docs.astro.build/en/guides/sessions/\"\n    };\n    SessionStorageSaveError = {\n      name: \"SessionStorageSaveError\",\n      title: \"Session data could not be saved.\",\n      message: /* @__PURE__ */ __name((error4, driver) => `Error when saving session data${driver ? ` with driver \\`${driver}\\`` : \"\"}. \\`${error4 ?? \"\"}\\``, \"message\"),\n      hint: \"For more information, see https://docs.astro.build/en/guides/sessions/\"\n    };\n    __name(normalizeLF, \"normalizeLF\");\n    __name(codeFrame, \"codeFrame\");\n    AstroError = class extends Error {\n      static {\n        __name(this, \"AstroError\");\n      }\n      loc;\n      title;\n      hint;\n      frame;\n      type = \"AstroError\";\n      constructor(props, options) {\n        const { name, title: title3, message, stack, location: location2, hint, frame } = props;\n        super(message, options);\n        this.title = title3;\n        this.name = name;\n        if (message) this.message = message;\n        this.stack = stack ? stack : this.stack;\n        this.loc = location2;\n        this.hint = hint;\n        this.frame = frame;\n      }\n      setLocation(location2) {\n        this.loc = location2;\n      }\n      setName(name) {\n        this.name = name;\n      }\n      setMessage(message) {\n        this.message = message;\n      }\n      setHint(hint) {\n        this.hint = hint;\n      }\n      setFrame(source, location2) {\n        this.frame = codeFrame(source, location2);\n      }\n      static is(err) {\n        return err.type === \"AstroError\";\n      }\n    };\n    __name(validateArgs, \"validateArgs\");\n    __name(baseCreateComponent, \"baseCreateComponent\");\n    __name(createComponentWithOptions, \"createComponentWithOptions\");\n    __name(createComponent, \"createComponent\");\n    __name(createAstroGlobFn, \"createAstroGlobFn\");\n    __name(createAstro, \"createAstro\");\n    isTTY = true;\n    if (typeof process !== \"undefined\") {\n      ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});\n      isTTY = process.stdout && process.stdout.isTTY;\n    }\n    $ = {\n      enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== \"dumb\" && (FORCE_COLOR != null && FORCE_COLOR !== \"0\" || isTTY)\n    };\n    __name(init, \"init\");\n    bold = init(1, 22);\n    dim = init(2, 22);\n    red = init(31, 39);\n    green = init(32, 39);\n    yellow = init(33, 39);\n    blue = init(34, 39);\n    __name(renderEndpoint, \"renderEndpoint\");\n    ({ replace } = \"\");\n    ca = /[&<>'\"]/g;\n    esca = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"'\": \"&#39;\",\n      '\"': \"&quot;\"\n    };\n    pe = /* @__PURE__ */ __name((m2) => esca[m2], \"pe\");\n    escape = /* @__PURE__ */ __name((es2) => replace.call(es2, ca, pe), \"escape\");\n    __name(isPromise, \"isPromise\");\n    __name(streamAsyncIterator, \"streamAsyncIterator\");\n    escapeHTML = escape;\n    HTMLBytes = class extends Uint8Array {\n      static {\n        __name(this, \"HTMLBytes\");\n      }\n    };\n    Object.defineProperty(HTMLBytes.prototype, Symbol.toStringTag, {\n      get() {\n        return \"HTMLBytes\";\n      }\n    });\n    HTMLString = class extends String {\n      static {\n        __name(this, \"HTMLString\");\n      }\n      get [Symbol.toStringTag]() {\n        return \"HTMLString\";\n      }\n    };\n    markHTMLString = /* @__PURE__ */ __name((value2) => {\n      if (value2 instanceof HTMLString) {\n        return value2;\n      }\n      if (typeof value2 === \"string\") {\n        return new HTMLString(value2);\n      }\n      return value2;\n    }, \"markHTMLString\");\n    __name(isHTMLString, \"isHTMLString\");\n    __name(markHTMLBytes, \"markHTMLBytes\");\n    __name(hasGetReader, \"hasGetReader\");\n    __name(unescapeChunksAsync, \"unescapeChunksAsync\");\n    __name(unescapeChunks, \"unescapeChunks\");\n    __name(unescapeHTML, \"unescapeHTML\");\n    AstroJSX = \"astro:jsx\";\n    __name(isVNode, \"isVNode\");\n    __name(isAstroComponentFactory, \"isAstroComponentFactory\");\n    __name(isAPropagatingComponent, \"isAPropagatingComponent\");\n    RenderInstructionSymbol = Symbol.for(\"astro:render\");\n    __name(createRenderInstruction, \"createRenderInstruction\");\n    __name(isRenderInstruction, \"isRenderInstruction\");\n    __name(r, \"r\");\n    __name(clsx, \"clsx\");\n    PROP_TYPE = {\n      Value: 0,\n      JSON: 1,\n      // Actually means Array\n      RegExp: 2,\n      Date: 3,\n      Map: 4,\n      Set: 5,\n      BigInt: 6,\n      URL: 7,\n      Uint8Array: 8,\n      Uint16Array: 9,\n      Uint32Array: 10,\n      Infinity: 11\n    };\n    __name(serializeArray, \"serializeArray\");\n    __name(serializeObject, \"serializeObject\");\n    __name(convertToSerializedForm, \"convertToSerializedForm\");\n    __name(serializeProps, \"serializeProps\");\n    transitionDirectivesToCopyOnIsland = Object.freeze([\n      \"data-astro-transition-scope\",\n      \"data-astro-transition-persist\",\n      \"data-astro-transition-persist-props\"\n    ]);\n    __name(extractDirectives, \"extractDirectives\");\n    __name(generateHydrateScript, \"generateHydrateScript\");\n    dictionary = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY\";\n    binary = dictionary.length;\n    __name(bitwise, \"bitwise\");\n    __name(shorthash, \"shorthash\");\n    headAndContentSym = Symbol.for(\"astro.headAndContent\");\n    __name(isHeadAndContent, \"isHeadAndContent\");\n    astro_island_prebuilt_default = `(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!=\"symbol\"?o+\"\":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!=\"object\"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,\"Component\");d(this,\"hydrator\");d(this,\"hydrate\",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest(\"astro-island[ssr]\");if(e){e.addEventListener(\"astro:hydrate\",this.hydrate,{once:!0});return}let c=this.querySelectorAll(\"astro-slot\"),n={},h=this.querySelectorAll(\"template[data-astro-template]\");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute(\"data-astro-template\")||\"default\"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute(\"name\")||\"default\"]=r.innerHTML)}let p;try{p=this.hasAttribute(\"props\")?m(JSON.parse(this.getAttribute(\"props\"))):{}}catch(r){let s=this.getAttribute(\"component-url\")||\"<unknown>\",v=this.getAttribute(\"component-export\");throw v&&(s+=\\` (export \\${v})\\`),console.error(\\`[hydrate] Error parsing props for component \\${s}\\`,this.getAttribute(\"props\"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute(\"client\")}),this.removeAttribute(\"ssr\"),this.dispatchEvent(new CustomEvent(\"astro:hydrate\"))});d(this,\"unmount\",()=>{this.isConnected||this.dispatchEvent(new CustomEvent(\"astro:unmount\"))})}disconnectedCallback(){document.removeEventListener(\"astro:after-swap\",this.unmount),document.addEventListener(\"astro:after-swap\",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute(\"await-children\")||document.readyState===\"interactive\"||document.readyState===\"complete\")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener(\"DOMContentLoaded\",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue===\"astro:end\"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener(\"DOMContentLoaded\",e)}}async childrenConnectedCallback(){let e=this.getAttribute(\"before-hydration-url\");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute(\"opts\")),c=this.getAttribute(\"client\");if(Astro[c]===void 0){window.addEventListener(\\`astro:\\${c}\\`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute(\"renderer-url\"),[h,{default:p}]=await Promise.all([import(this.getAttribute(\"component-url\")),n?import(n):()=>()=>{}]),u=this.getAttribute(\"component-export\")||\"default\";if(!u.includes(\".\"))this.Component=h[u];else{this.Component=h;for(let f of u.split(\".\"))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(\\`[astro-island] Error hydrating \\${this.getAttribute(\"component-url\")}\\`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,\"observedAttributes\",[\"props\"]),customElements.get(\"astro-island\")||customElements.define(\"astro-island\",y)}})();`;\n    ISLAND_STYLES = `<style>astro-island,astro-slot,astro-static-slot{display:contents}</style>`;\n    __name(determineIfNeedsHydrationScript, \"determineIfNeedsHydrationScript\");\n    __name(determinesIfNeedsDirectiveScript, \"determinesIfNeedsDirectiveScript\");\n    __name(getDirectiveScriptText, \"getDirectiveScriptText\");\n    __name(getPrescripts, \"getPrescripts\");\n    voidElementNames = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n    htmlBooleanAttributes = /^(?:allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|inert|loop|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|selected|itemscope)$/i;\n    AMPERSAND_REGEX = /&/g;\n    DOUBLE_QUOTE_REGEX = /\"/g;\n    STATIC_DIRECTIVES = /* @__PURE__ */ new Set([\"set:html\", \"set:text\"]);\n    toIdent = /* @__PURE__ */ __name((k2) => k2.trim().replace(/(?!^)\\b\\w|\\s+|\\W+/g, (match, index) => {\n      if (/\\W/.test(match)) return \"\";\n      return index === 0 ? match : match.toUpperCase();\n    }), \"toIdent\");\n    toAttributeString = /* @__PURE__ */ __name((value2, shouldEscape = true) => shouldEscape ? String(value2).replace(AMPERSAND_REGEX, \"&#38;\").replace(DOUBLE_QUOTE_REGEX, \"&#34;\") : value2, \"toAttributeString\");\n    kebab = /* @__PURE__ */ __name((k2) => k2.toLowerCase() === k2 ? k2 : k2.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`), \"kebab\");\n    toStyleString = /* @__PURE__ */ __name((obj) => Object.entries(obj).filter(([_3, v3]) => typeof v3 === \"string\" && v3.trim() || typeof v3 === \"number\").map(([k2, v3]) => {\n      if (k2[0] !== \"-\" && k2[1] !== \"-\") return `${kebab(k2)}:${v3}`;\n      return `${k2}:${v3}`;\n    }).join(\";\"), \"toStyleString\");\n    __name(defineScriptVars, \"defineScriptVars\");\n    __name(formatList, \"formatList\");\n    __name(addAttribute, \"addAttribute\");\n    __name(internalSpreadAttributes, \"internalSpreadAttributes\");\n    __name(renderElement$1, \"renderElement$1\");\n    noop = /* @__PURE__ */ __name(() => {\n    }, \"noop\");\n    BufferedRenderer = class {\n      static {\n        __name(this, \"BufferedRenderer\");\n      }\n      chunks = [];\n      renderPromise;\n      destination;\n      /**\n       * Determines whether buffer has been flushed\n       * to the final destination.\n       */\n      flushed = false;\n      constructor(destination, renderFunction) {\n        this.destination = destination;\n        this.renderPromise = renderFunction(this);\n        if (isPromise(this.renderPromise)) {\n          Promise.resolve(this.renderPromise).catch(noop);\n        }\n      }\n      write(chunk) {\n        if (this.flushed) {\n          this.destination.write(chunk);\n        } else {\n          this.chunks.push(chunk);\n        }\n      }\n      flush() {\n        if (this.flushed) {\n          throw new Error(\"The render buffer has already been flushed.\");\n        }\n        this.flushed = true;\n        for (const chunk of this.chunks) {\n          this.destination.write(chunk);\n        }\n        return this.renderPromise;\n      }\n    };\n    __name(createBufferedRenderer, \"createBufferedRenderer\");\n    isNode = typeof process !== \"undefined\" && Object.prototype.toString.call(process) === \"[object process]\";\n    isDeno = typeof Deno !== \"undefined\";\n    __name(promiseWithResolvers, \"promiseWithResolvers\");\n    VALID_PROTOCOLS = [\"http:\", \"https:\"];\n    __name(isHttpUrl, \"isHttpUrl\");\n    uniqueElements = /* @__PURE__ */ __name((item, index, all) => {\n      const props = JSON.stringify(item.props);\n      const children = item.children;\n      return index === all.findIndex((i) => JSON.stringify(i.props) === props && i.children == children);\n    }, \"uniqueElements\");\n    __name(renderAllHeadContent, \"renderAllHeadContent\");\n    __name(renderHead, \"renderHead\");\n    __name(maybeRenderHead, \"maybeRenderHead\");\n    __name(encodeHexUpperCase, \"encodeHexUpperCase\");\n    __name(decodeHex, \"decodeHex\");\n    alphabetUpperCase = \"0123456789ABCDEF\";\n    decodeMap = {\n      \"0\": 0,\n      \"1\": 1,\n      \"2\": 2,\n      \"3\": 3,\n      \"4\": 4,\n      \"5\": 5,\n      \"6\": 6,\n      \"7\": 7,\n      \"8\": 8,\n      \"9\": 9,\n      a: 10,\n      A: 10,\n      b: 11,\n      B: 11,\n      c: 12,\n      C: 12,\n      d: 13,\n      D: 13,\n      e: 14,\n      E: 14,\n      f: 15,\n      F: 15\n    };\n    (function(EncodingPadding2) {\n      EncodingPadding2[EncodingPadding2[\"Include\"] = 0] = \"Include\";\n      EncodingPadding2[EncodingPadding2[\"None\"] = 1] = \"None\";\n    })(EncodingPadding$1 || (EncodingPadding$1 = {}));\n    (function(DecodingPadding2) {\n      DecodingPadding2[DecodingPadding2[\"Required\"] = 0] = \"Required\";\n      DecodingPadding2[DecodingPadding2[\"Ignore\"] = 1] = \"Ignore\";\n    })(DecodingPadding$1 || (DecodingPadding$1 = {}));\n    __name(encodeBase64, \"encodeBase64\");\n    __name(encodeBase64_internal, \"encodeBase64_internal\");\n    base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    __name(decodeBase64, \"decodeBase64\");\n    __name(decodeBase64_internal, \"decodeBase64_internal\");\n    (function(EncodingPadding2) {\n      EncodingPadding2[EncodingPadding2[\"Include\"] = 0] = \"Include\";\n      EncodingPadding2[EncodingPadding2[\"None\"] = 1] = \"None\";\n    })(EncodingPadding || (EncodingPadding = {}));\n    (function(DecodingPadding2) {\n      DecodingPadding2[DecodingPadding2[\"Required\"] = 0] = \"Required\";\n      DecodingPadding2[DecodingPadding2[\"Ignore\"] = 1] = \"Ignore\";\n    })(DecodingPadding || (DecodingPadding = {}));\n    base64DecodeMap = {\n      \"0\": 52,\n      \"1\": 53,\n      \"2\": 54,\n      \"3\": 55,\n      \"4\": 56,\n      \"5\": 57,\n      \"6\": 58,\n      \"7\": 59,\n      \"8\": 60,\n      \"9\": 61,\n      A: 0,\n      B: 1,\n      C: 2,\n      D: 3,\n      E: 4,\n      F: 5,\n      G: 6,\n      H: 7,\n      I: 8,\n      J: 9,\n      K: 10,\n      L: 11,\n      M: 12,\n      N: 13,\n      O: 14,\n      P: 15,\n      Q: 16,\n      R: 17,\n      S: 18,\n      T: 19,\n      U: 20,\n      V: 21,\n      W: 22,\n      X: 23,\n      Y: 24,\n      Z: 25,\n      a: 26,\n      b: 27,\n      c: 28,\n      d: 29,\n      e: 30,\n      f: 31,\n      g: 32,\n      h: 33,\n      i: 34,\n      j: 35,\n      k: 36,\n      l: 37,\n      m: 38,\n      n: 39,\n      o: 40,\n      p: 41,\n      q: 42,\n      r: 43,\n      s: 44,\n      t: 45,\n      u: 46,\n      v: 47,\n      w: 48,\n      x: 49,\n      y: 50,\n      z: 51,\n      \"+\": 62,\n      \"/\": 63\n    };\n    ALGORITHM = \"AES-GCM\";\n    __name(decodeKey, \"decodeKey\");\n    encoder$1 = new TextEncoder();\n    decoder$1 = new TextDecoder();\n    IV_LENGTH = 24;\n    __name(encryptString, \"encryptString\");\n    __name(decryptString, \"decryptString\");\n    renderTemplateResultSym = Symbol.for(\"astro.renderTemplateResult\");\n    RenderTemplateResult = class {\n      static {\n        __name(this, \"RenderTemplateResult\");\n      }\n      [renderTemplateResultSym] = true;\n      htmlParts;\n      expressions;\n      error;\n      constructor(htmlParts, expressions) {\n        this.htmlParts = htmlParts;\n        this.error = void 0;\n        this.expressions = expressions.map((expression) => {\n          if (isPromise(expression)) {\n            return Promise.resolve(expression).catch((err) => {\n              if (!this.error) {\n                this.error = err;\n                throw err;\n              }\n            });\n          }\n          return expression;\n        });\n      }\n      render(destination) {\n        const flushers = this.expressions.map((exp) => {\n          return createBufferedRenderer(destination, (bufferDestination) => {\n            if (exp || exp === 0) {\n              return renderChild(bufferDestination, exp);\n            }\n          });\n        });\n        let i = 0;\n        const iterate = /* @__PURE__ */ __name(() => {\n          while (i < this.htmlParts.length) {\n            const html2 = this.htmlParts[i];\n            const flusher = flushers[i];\n            i++;\n            if (html2) {\n              destination.write(markHTMLString(html2));\n            }\n            if (flusher) {\n              const result = flusher.flush();\n              if (isPromise(result)) {\n                return result.then(iterate);\n              }\n            }\n          }\n        }, \"iterate\");\n        return iterate();\n      }\n    };\n    __name(isRenderTemplateResult, \"isRenderTemplateResult\");\n    __name(renderTemplate, \"renderTemplate\");\n    slotString = Symbol.for(\"astro:slot-string\");\n    SlotString = class extends HTMLString {\n      static {\n        __name(this, \"SlotString\");\n      }\n      instructions;\n      [slotString];\n      constructor(content, instructions) {\n        super(content);\n        this.instructions = instructions;\n        this[slotString] = true;\n      }\n    };\n    __name(isSlotString, \"isSlotString\");\n    __name(renderSlot, \"renderSlot\");\n    __name(renderSlotToString, \"renderSlotToString\");\n    __name(renderSlots, \"renderSlots\");\n    __name(createSlotValueFromString, \"createSlotValueFromString\");\n    internalProps = /* @__PURE__ */ new Set([\n      \"server:component-path\",\n      \"server:component-export\",\n      \"server:component-directive\",\n      \"server:defer\"\n    ]);\n    __name(containsServerDirective, \"containsServerDirective\");\n    SCRIPT_RE = /<\\/script/giu;\n    COMMENT_RE = /<!--/gu;\n    SCRIPT_REPLACER = \"<\\\\/script\";\n    COMMENT_REPLACER = \"\\\\u003C!--\";\n    __name(safeJsonStringify, \"safeJsonStringify\");\n    __name(createSearchParams, \"createSearchParams\");\n    __name(isWithinURLLimit, \"isWithinURLLimit\");\n    __name(renderServerIsland, \"renderServerIsland\");\n    renderServerIslandRuntime = /* @__PURE__ */ __name(() => markHTMLString(\n      `\n\t<script>\n\t\tasync function replaceServerIsland(id, r) {\n\t\t\tlet s = document.querySelector(\\`script[data-island-id=\"\\${id}\"]\\`);\n\t\t\t// If there's no matching script, or the request fails then return\n\t\t\tif (!s || r.status !== 200 || r.headers.get('content-type')?.split(';')[0].trim() !== 'text/html') return;\n\t\t\t// Load the HTML before modifying the DOM in case of errors\n\t\t\tlet html = await r.text();\n\t\t\t// Remove any placeholder content before the island script\n\t\t\twhile (s.previousSibling && s.previousSibling.nodeType !== 8 && s.previousSibling.data !== '[if astro]>server-island-start<![endif]')\n\t\t\t\ts.previousSibling.remove();\n\t\t\ts.previousSibling?.remove();\n\t\t\t// Insert the new HTML\n\t\t\ts.before(document.createRange().createContextualFragment(html));\n\t\t\t// Remove the script. Prior to v5.4.2, this was the trick to force rerun of scripts.  Keeping it to minimize change to the existing behavior.\n\t\t\ts.remove();\n\t\t}\n\t</script>`.split(\"\\n\").map((line) => line.trim()).filter((line) => line && !line.startsWith(\"//\")).join(\" \")\n    ), \"renderServerIslandRuntime\");\n    Fragment = Symbol.for(\"astro:fragment\");\n    Renderer = Symbol.for(\"astro:renderer\");\n    encoder = new TextEncoder();\n    decoder = new TextDecoder();\n    __name(stringifyChunk, \"stringifyChunk\");\n    __name(chunkToString, \"chunkToString\");\n    __name(chunkToByteArray, \"chunkToByteArray\");\n    __name(isRenderInstance, \"isRenderInstance\");\n    __name(renderChild, \"renderChild\");\n    __name(renderArray, \"renderArray\");\n    __name(renderIterable, \"renderIterable\");\n    __name(renderAsyncIterable, \"renderAsyncIterable\");\n    astroComponentInstanceSym = Symbol.for(\"astro.componentInstance\");\n    AstroComponentInstance = class {\n      static {\n        __name(this, \"AstroComponentInstance\");\n      }\n      [astroComponentInstanceSym] = true;\n      result;\n      props;\n      slotValues;\n      factory;\n      returnValue;\n      constructor(result, props, slots, factory) {\n        this.result = result;\n        this.props = props;\n        this.factory = factory;\n        this.slotValues = {};\n        for (const name in slots) {\n          let didRender = false;\n          let value2 = slots[name](result);\n          this.slotValues[name] = () => {\n            if (!didRender) {\n              didRender = true;\n              return value2;\n            }\n            return slots[name](result);\n          };\n        }\n      }\n      init(result) {\n        if (this.returnValue !== void 0) {\n          return this.returnValue;\n        }\n        this.returnValue = this.factory(result, this.props, this.slotValues);\n        if (isPromise(this.returnValue)) {\n          this.returnValue.then((resolved) => {\n            this.returnValue = resolved;\n          }).catch(() => {\n          });\n        }\n        return this.returnValue;\n      }\n      render(destination) {\n        const returnValue = this.init(this.result);\n        if (isPromise(returnValue)) {\n          return returnValue.then((x) => this.renderImpl(destination, x));\n        }\n        return this.renderImpl(destination, returnValue);\n      }\n      renderImpl(destination, returnValue) {\n        if (isHeadAndContent(returnValue)) {\n          return returnValue.content.render(destination);\n        } else {\n          return renderChild(destination, returnValue);\n        }\n      }\n    };\n    __name(validateComponentProps, \"validateComponentProps\");\n    __name(createAstroComponentInstance, \"createAstroComponentInstance\");\n    __name(isAstroComponentInstance, \"isAstroComponentInstance\");\n    DOCTYPE_EXP = /<!doctype html/i;\n    __name(renderToString, \"renderToString\");\n    __name(renderToReadableStream, \"renderToReadableStream\");\n    __name(callComponentAsTemplateResultOrResponse, \"callComponentAsTemplateResultOrResponse\");\n    __name(bufferHeadContent, \"bufferHeadContent\");\n    __name(renderToAsyncIterable, \"renderToAsyncIterable\");\n    __name(toPromise, \"toPromise\");\n    __name(componentIsHTMLElement, \"componentIsHTMLElement\");\n    __name(renderHTMLElement, \"renderHTMLElement\");\n    __name(getHTMLElementName, \"getHTMLElementName\");\n    needsHeadRenderingSymbol = Symbol.for(\"astro.needsHeadRendering\");\n    rendererAliases = /* @__PURE__ */ new Map([[\"solid\", \"solid-js\"]]);\n    clientOnlyValues = /* @__PURE__ */ new Set([\"solid-js\", \"react\", \"preact\", \"vue\", \"svelte\"]);\n    __name(guessRenderers, \"guessRenderers\");\n    __name(isFragmentComponent, \"isFragmentComponent\");\n    __name(isHTMLComponent, \"isHTMLComponent\");\n    ASTRO_SLOT_EXP = /<\\/?astro-slot\\b[^>]*>/g;\n    ASTRO_STATIC_SLOT_EXP = /<\\/?astro-static-slot\\b[^>]*>/g;\n    __name(removeStaticAstroSlot, \"removeStaticAstroSlot\");\n    __name(renderFrameworkComponent, \"renderFrameworkComponent\");\n    __name(sanitizeElementName, \"sanitizeElementName\");\n    __name(renderFragmentComponent, \"renderFragmentComponent\");\n    __name(renderHTMLComponent, \"renderHTMLComponent\");\n    __name(renderAstroComponent, \"renderAstroComponent\");\n    __name(renderComponent, \"renderComponent\");\n    __name(normalizeProps, \"normalizeProps\");\n    __name(renderComponentToString, \"renderComponentToString\");\n    __name(nonAstroPageNeedsHeadInjection, \"nonAstroPageNeedsHeadInjection\");\n    ClientOnlyPlaceholder = \"astro-client-only\";\n    hasTriedRenderComponentSymbol = Symbol(\"hasTriedRenderComponent\");\n    __name(renderJSX, \"renderJSX\");\n    __name(renderJSXVNode, \"renderJSXVNode\");\n    __name(renderElement, \"renderElement\");\n    __name(prerenderElementChildren, \"prerenderElementChildren\");\n    __name(renderScript, \"renderScript\");\n    __name(renderPage, \"renderPage\");\n    __name(requireCssesc, \"requireCssesc\");\n    requireCssesc();\n    \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\".split(\"\").reduce((v3, c) => (v3[c.charCodeAt(0)] = c, v3), []);\n    \"-0123456789_\".split(\"\").reduce((v3, c) => (v3[c.charCodeAt(0)] = c, v3), []);\n    __name(spreadAttributes, \"spreadAttributes\");\n  }\n});\n\n// dist/_worker.js/renderers.mjs\nfunction requireReact_production() {\n  if (hasRequiredReact_production) return react_production;\n  hasRequiredReact_production = 1;\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n  function getIteratorFn(maybeIterable) {\n    if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n    return \"function\" === typeof maybeIterable ? maybeIterable : null;\n  }\n  __name(getIteratorFn, \"getIteratorFn\");\n  var ReactNoopUpdateQueue = {\n    isMounted: /* @__PURE__ */ __name(function() {\n      return false;\n    }, \"isMounted\"),\n    enqueueForceUpdate: /* @__PURE__ */ __name(function() {\n    }, \"enqueueForceUpdate\"),\n    enqueueReplaceState: /* @__PURE__ */ __name(function() {\n    }, \"enqueueReplaceState\"),\n    enqueueSetState: /* @__PURE__ */ __name(function() {\n    }, \"enqueueSetState\")\n  }, assign = Object.assign, emptyObject = {};\n  function Component(props, context2, updater) {\n    this.props = props;\n    this.context = context2;\n    this.refs = emptyObject;\n    this.updater = updater || ReactNoopUpdateQueue;\n  }\n  __name(Component, \"Component\");\n  Component.prototype.isReactComponent = {};\n  Component.prototype.setState = function(partialState, callback) {\n    if (\"object\" !== typeof partialState && \"function\" !== typeof partialState && null != partialState)\n      throw Error(\n        \"takes an object of state variables to update or a function which returns an object of state variables.\"\n      );\n    this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n  };\n  Component.prototype.forceUpdate = function(callback) {\n    this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n  };\n  function ComponentDummy() {\n  }\n  __name(ComponentDummy, \"ComponentDummy\");\n  ComponentDummy.prototype = Component.prototype;\n  function PureComponent(props, context2, updater) {\n    this.props = props;\n    this.context = context2;\n    this.refs = emptyObject;\n    this.updater = updater || ReactNoopUpdateQueue;\n  }\n  __name(PureComponent, \"PureComponent\");\n  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n  pureComponentPrototype.constructor = PureComponent;\n  assign(pureComponentPrototype, Component.prototype);\n  pureComponentPrototype.isPureReactComponent = true;\n  var isArrayImpl = Array.isArray, ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null }, hasOwnProperty2 = Object.prototype.hasOwnProperty;\n  function ReactElement(type2, key, self2, source, owner, props) {\n    self2 = props.ref;\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type2,\n      key,\n      ref: void 0 !== self2 ? self2 : null,\n      props\n    };\n  }\n  __name(ReactElement, \"ReactElement\");\n  function cloneAndReplaceKey(oldElement, newKey) {\n    return ReactElement(\n      oldElement.type,\n      newKey,\n      void 0,\n      void 0,\n      void 0,\n      oldElement.props\n    );\n  }\n  __name(cloneAndReplaceKey, \"cloneAndReplaceKey\");\n  function isValidElement(object2) {\n    return \"object\" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  __name(isValidElement, \"isValidElement\");\n  function escape2(key) {\n    var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n    return \"$\" + key.replace(/[=:]/g, function(match) {\n      return escaperLookup[match];\n    });\n  }\n  __name(escape2, \"escape\");\n  var userProvidedKeyEscapeRegex = /\\/+/g;\n  function getElementKey(element, index) {\n    return \"object\" === typeof element && null !== element && null != element.key ? escape2(\"\" + element.key) : index.toString(36);\n  }\n  __name(getElementKey, \"getElementKey\");\n  function noop$1() {\n  }\n  __name(noop$1, \"noop$1\");\n  function resolveThenable(thenable) {\n    switch (thenable.status) {\n      case \"fulfilled\":\n        return thenable.value;\n      case \"rejected\":\n        throw thenable.reason;\n      default:\n        switch (\"string\" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = \"pending\", thenable.then(\n          function(fulfilledValue) {\n            \"pending\" === thenable.status && (thenable.status = \"fulfilled\", thenable.value = fulfilledValue);\n          },\n          function(error4) {\n            \"pending\" === thenable.status && (thenable.status = \"rejected\", thenable.reason = error4);\n          }\n        )), thenable.status) {\n          case \"fulfilled\":\n            return thenable.value;\n          case \"rejected\":\n            throw thenable.reason;\n        }\n    }\n    throw thenable;\n  }\n  __name(resolveThenable, \"resolveThenable\");\n  function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {\n    var type2 = typeof children;\n    if (\"undefined\" === type2 || \"boolean\" === type2) children = null;\n    var invokeCallback = false;\n    if (null === children) invokeCallback = true;\n    else\n      switch (type2) {\n        case \"bigint\":\n        case \"string\":\n        case \"number\":\n          invokeCallback = true;\n          break;\n        case \"object\":\n          switch (children.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_PORTAL_TYPE:\n              invokeCallback = true;\n              break;\n            case REACT_LAZY_TYPE:\n              return invokeCallback = children._init, mapIntoArray(\n                invokeCallback(children._payload),\n                array2,\n                escapedPrefix,\n                nameSoFar,\n                callback\n              );\n          }\n      }\n    if (invokeCallback)\n      return callback = callback(children), invokeCallback = \"\" === nameSoFar ? \".\" + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = \"\", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"), mapIntoArray(callback, array2, escapedPrefix, \"\", function(c) {\n        return c;\n      })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(\n        callback,\n        escapedPrefix + (null == callback.key || children && children.key === callback.key ? \"\" : (\"\" + callback.key).replace(\n          userProvidedKeyEscapeRegex,\n          \"$&/\"\n        ) + \"/\") + invokeCallback\n      )), array2.push(callback)), 1;\n    invokeCallback = 0;\n    var nextNamePrefix = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n    if (isArrayImpl(children))\n      for (var i = 0; i < children.length; i++)\n        nameSoFar = children[i], type2 = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(\n          nameSoFar,\n          array2,\n          escapedPrefix,\n          type2,\n          callback\n        );\n    else if (i = getIteratorFn(children), \"function\" === typeof i)\n      for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )\n        nameSoFar = nameSoFar.value, type2 = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(\n          nameSoFar,\n          array2,\n          escapedPrefix,\n          type2,\n          callback\n        );\n    else if (\"object\" === type2) {\n      if (\"function\" === typeof children.then)\n        return mapIntoArray(\n          resolveThenable(children),\n          array2,\n          escapedPrefix,\n          nameSoFar,\n          callback\n        );\n      array2 = String(children);\n      throw Error(\n        \"Objects are not valid as a React child (found: \" + (\"[object Object]\" === array2 ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : array2) + \"). If you meant to render a collection of children, use an array instead.\"\n      );\n    }\n    return invokeCallback;\n  }\n  __name(mapIntoArray, \"mapIntoArray\");\n  function mapChildren(children, func, context2) {\n    if (null == children) return children;\n    var result = [], count3 = 0;\n    mapIntoArray(children, result, \"\", \"\", function(child) {\n      return func.call(context2, child, count3++);\n    });\n    return result;\n  }\n  __name(mapChildren, \"mapChildren\");\n  function lazyInitializer(payload) {\n    if (-1 === payload._status) {\n      var ctor = payload._result;\n      ctor = ctor();\n      ctor.then(\n        function(moduleObject) {\n          if (0 === payload._status || -1 === payload._status)\n            payload._status = 1, payload._result = moduleObject;\n        },\n        function(error4) {\n          if (0 === payload._status || -1 === payload._status)\n            payload._status = 2, payload._result = error4;\n        }\n      );\n      -1 === payload._status && (payload._status = 0, payload._result = ctor);\n    }\n    if (1 === payload._status) return payload._result.default;\n    throw payload._result;\n  }\n  __name(lazyInitializer, \"lazyInitializer\");\n  var reportGlobalError = \"function\" === typeof reportError ? reportError : function(error4) {\n    if (\"object\" === typeof window && \"function\" === typeof window.ErrorEvent) {\n      var event = new window.ErrorEvent(\"error\", {\n        bubbles: true,\n        cancelable: true,\n        message: \"object\" === typeof error4 && null !== error4 && \"string\" === typeof error4.message ? String(error4.message) : String(error4),\n        error: error4\n      });\n      if (!window.dispatchEvent(event)) return;\n    } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n      process.emit(\"uncaughtException\", error4);\n      return;\n    }\n    console.error(error4);\n  };\n  function noop3() {\n  }\n  __name(noop3, \"noop\");\n  react_production.Children = {\n    map: mapChildren,\n    forEach: /* @__PURE__ */ __name(function(children, forEachFunc, forEachContext) {\n      mapChildren(\n        children,\n        function() {\n          forEachFunc.apply(this, arguments);\n        },\n        forEachContext\n      );\n    }, \"forEach\"),\n    count: /* @__PURE__ */ __name(function(children) {\n      var n27 = 0;\n      mapChildren(children, function() {\n        n27++;\n      });\n      return n27;\n    }, \"count\"),\n    toArray: /* @__PURE__ */ __name(function(children) {\n      return mapChildren(children, function(child) {\n        return child;\n      }) || [];\n    }, \"toArray\"),\n    only: /* @__PURE__ */ __name(function(children) {\n      if (!isValidElement(children))\n        throw Error(\n          \"React.Children.only expected to receive a single React element child.\"\n        );\n      return children;\n    }, \"only\")\n  };\n  react_production.Component = Component;\n  react_production.Fragment = REACT_FRAGMENT_TYPE;\n  react_production.Profiler = REACT_PROFILER_TYPE;\n  react_production.PureComponent = PureComponent;\n  react_production.StrictMode = REACT_STRICT_MODE_TYPE;\n  react_production.Suspense = REACT_SUSPENSE_TYPE;\n  react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;\n  react_production.__COMPILER_RUNTIME = {\n    __proto__: null,\n    c: /* @__PURE__ */ __name(function(size) {\n      return ReactSharedInternals.H.useMemoCache(size);\n    }, \"c\")\n  };\n  react_production.cache = function(fn2) {\n    return function() {\n      return fn2.apply(null, arguments);\n    };\n  };\n  react_production.cloneElement = function(element, config3, children) {\n    if (null === element || void 0 === element)\n      throw Error(\n        \"The argument must be a React element, but you passed \" + element + \".\"\n      );\n    var props = assign({}, element.props), key = element.key, owner = void 0;\n    if (null != config3)\n      for (propName2 in void 0 !== config3.ref && (owner = void 0), void 0 !== config3.key && (key = \"\" + config3.key), config3)\n        !hasOwnProperty2.call(config3, propName2) || \"key\" === propName2 || \"__self\" === propName2 || \"__source\" === propName2 || \"ref\" === propName2 && void 0 === config3.ref || (props[propName2] = config3[propName2]);\n    var propName2 = arguments.length - 2;\n    if (1 === propName2) props.children = children;\n    else if (1 < propName2) {\n      for (var childArray = Array(propName2), i = 0; i < propName2; i++)\n        childArray[i] = arguments[i + 2];\n      props.children = childArray;\n    }\n    return ReactElement(element.type, key, void 0, void 0, owner, props);\n  };\n  react_production.createContext = function(defaultValue) {\n    defaultValue = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _currentValue: defaultValue,\n      _currentValue2: defaultValue,\n      _threadCount: 0,\n      Provider: null,\n      Consumer: null\n    };\n    defaultValue.Provider = defaultValue;\n    defaultValue.Consumer = {\n      $$typeof: REACT_CONSUMER_TYPE,\n      _context: defaultValue\n    };\n    return defaultValue;\n  };\n  react_production.createElement = function(type2, config3, children) {\n    var propName2, props = {}, key = null;\n    if (null != config3)\n      for (propName2 in void 0 !== config3.key && (key = \"\" + config3.key), config3)\n        hasOwnProperty2.call(config3, propName2) && \"key\" !== propName2 && \"__self\" !== propName2 && \"__source\" !== propName2 && (props[propName2] = config3[propName2]);\n    var childrenLength = arguments.length - 2;\n    if (1 === childrenLength) props.children = children;\n    else if (1 < childrenLength) {\n      for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\n        childArray[i] = arguments[i + 2];\n      props.children = childArray;\n    }\n    if (type2 && type2.defaultProps)\n      for (propName2 in childrenLength = type2.defaultProps, childrenLength)\n        void 0 === props[propName2] && (props[propName2] = childrenLength[propName2]);\n    return ReactElement(type2, key, void 0, void 0, null, props);\n  };\n  react_production.createRef = function() {\n    return { current: null };\n  };\n  react_production.forwardRef = function(render) {\n    return { $$typeof: REACT_FORWARD_REF_TYPE, render };\n  };\n  react_production.isValidElement = isValidElement;\n  react_production.lazy = function(ctor) {\n    return {\n      $$typeof: REACT_LAZY_TYPE,\n      _payload: { _status: -1, _result: ctor },\n      _init: lazyInitializer\n    };\n  };\n  react_production.memo = function(type2, compare2) {\n    return {\n      $$typeof: REACT_MEMO_TYPE,\n      type: type2,\n      compare: void 0 === compare2 ? null : compare2\n    };\n  };\n  react_production.startTransition = function(scope) {\n    var prevTransition = ReactSharedInternals.T, currentTransition = {};\n    ReactSharedInternals.T = currentTransition;\n    try {\n      var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;\n      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n      \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && returnValue.then(noop3, reportGlobalError);\n    } catch (error4) {\n      reportGlobalError(error4);\n    } finally {\n      ReactSharedInternals.T = prevTransition;\n    }\n  };\n  react_production.unstable_useCacheRefresh = function() {\n    return ReactSharedInternals.H.useCacheRefresh();\n  };\n  react_production.use = function(usable) {\n    return ReactSharedInternals.H.use(usable);\n  };\n  react_production.useActionState = function(action, initialState, permalink) {\n    return ReactSharedInternals.H.useActionState(action, initialState, permalink);\n  };\n  react_production.useCallback = function(callback, deps) {\n    return ReactSharedInternals.H.useCallback(callback, deps);\n  };\n  react_production.useContext = function(Context2) {\n    return ReactSharedInternals.H.useContext(Context2);\n  };\n  react_production.useDebugValue = function() {\n  };\n  react_production.useDeferredValue = function(value2, initialValue) {\n    return ReactSharedInternals.H.useDeferredValue(value2, initialValue);\n  };\n  react_production.useEffect = function(create, createDeps, update2) {\n    var dispatcher = ReactSharedInternals.H;\n    if (\"function\" === typeof update2)\n      throw Error(\n        \"useEffect CRUD overload is not enabled in this build of React.\"\n      );\n    return dispatcher.useEffect(create, createDeps);\n  };\n  react_production.useId = function() {\n    return ReactSharedInternals.H.useId();\n  };\n  react_production.useImperativeHandle = function(ref, create, deps) {\n    return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);\n  };\n  react_production.useInsertionEffect = function(create, deps) {\n    return ReactSharedInternals.H.useInsertionEffect(create, deps);\n  };\n  react_production.useLayoutEffect = function(create, deps) {\n    return ReactSharedInternals.H.useLayoutEffect(create, deps);\n  };\n  react_production.useMemo = function(create, deps) {\n    return ReactSharedInternals.H.useMemo(create, deps);\n  };\n  react_production.useOptimistic = function(passthrough, reducer) {\n    return ReactSharedInternals.H.useOptimistic(passthrough, reducer);\n  };\n  react_production.useReducer = function(reducer, initialArg, init2) {\n    return ReactSharedInternals.H.useReducer(reducer, initialArg, init2);\n  };\n  react_production.useRef = function(initialValue) {\n    return ReactSharedInternals.H.useRef(initialValue);\n  };\n  react_production.useState = function(initialState) {\n    return ReactSharedInternals.H.useState(initialState);\n  };\n  react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {\n    return ReactSharedInternals.H.useSyncExternalStore(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot\n    );\n  };\n  react_production.useTransition = function() {\n    return ReactSharedInternals.H.useTransition();\n  };\n  react_production.version = \"19.1.0\";\n  return react_production;\n}\nfunction requireReact() {\n  if (hasRequiredReact) return react.exports;\n  hasRequiredReact = 1;\n  {\n    react.exports = requireReact_production();\n  }\n  return react.exports;\n}\nfunction requireReactDom_production() {\n  if (hasRequiredReactDom_production) return reactDom_production;\n  hasRequiredReactDom_production = 1;\n  var React2 = requireReact();\n  function formatProdErrorMessage(code) {\n    var url = \"https://react.dev/errors/\" + code;\n    if (1 < arguments.length) {\n      url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n      for (var i = 2; i < arguments.length; i++)\n        url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n    }\n    return \"Minified React error #\" + code + \"; visit \" + url + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\";\n  }\n  __name(formatProdErrorMessage, \"formatProdErrorMessage\");\n  function noop3() {\n  }\n  __name(noop3, \"noop\");\n  var Internals = {\n    d: {\n      f: noop3,\n      r: /* @__PURE__ */ __name(function() {\n        throw Error(formatProdErrorMessage(522));\n      }, \"r\"),\n      D: noop3,\n      C: noop3,\n      L: noop3,\n      m: noop3,\n      X: noop3,\n      S: noop3,\n      M: noop3\n    },\n    p: 0,\n    findDOMNode: null\n  }, REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n  function createPortal$1(children, containerInfo, implementation) {\n    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n    return {\n      $$typeof: REACT_PORTAL_TYPE,\n      key: null == key ? null : \"\" + key,\n      children,\n      containerInfo,\n      implementation\n    };\n  }\n  __name(createPortal$1, \"createPortal$1\");\n  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n  function getCrossOriginStringAs(as2, input2) {\n    if (\"font\" === as2) return \"\";\n    if (\"string\" === typeof input2)\n      return \"use-credentials\" === input2 ? input2 : \"\";\n  }\n  __name(getCrossOriginStringAs, \"getCrossOriginStringAs\");\n  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;\n  reactDom_production.createPortal = function(children, container) {\n    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)\n      throw Error(formatProdErrorMessage(299));\n    return createPortal$1(children, container, null, key);\n  };\n  reactDom_production.flushSync = function(fn2) {\n    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;\n    try {\n      if (ReactSharedInternals.T = null, Internals.p = 2, fn2) return fn2();\n    } finally {\n      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();\n    }\n  };\n  reactDom_production.preconnect = function(href, options) {\n    \"string\" === typeof href && (options ? (options = options.crossOrigin, options = \"string\" === typeof options ? \"use-credentials\" === options ? options : \"\" : void 0) : options = null, Internals.d.C(href, options));\n  };\n  reactDom_production.prefetchDNS = function(href) {\n    \"string\" === typeof href && Internals.d.D(href);\n  };\n  reactDom_production.preinit = function(href, options) {\n    if (\"string\" === typeof href && options && \"string\" === typeof options.as) {\n      var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = \"string\" === typeof options.integrity ? options.integrity : void 0, fetchPriority = \"string\" === typeof options.fetchPriority ? options.fetchPriority : void 0;\n      \"style\" === as2 ? Internals.d.S(\n        href,\n        \"string\" === typeof options.precedence ? options.precedence : void 0,\n        {\n          crossOrigin,\n          integrity,\n          fetchPriority\n        }\n      ) : \"script\" === as2 && Internals.d.X(href, {\n        crossOrigin,\n        integrity,\n        fetchPriority,\n        nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n      });\n    }\n  };\n  reactDom_production.preinitModule = function(href, options) {\n    if (\"string\" === typeof href)\n      if (\"object\" === typeof options && null !== options) {\n        if (null == options.as || \"script\" === options.as) {\n          var crossOrigin = getCrossOriginStringAs(\n            options.as,\n            options.crossOrigin\n          );\n          Internals.d.M(href, {\n            crossOrigin,\n            integrity: \"string\" === typeof options.integrity ? options.integrity : void 0,\n            nonce: \"string\" === typeof options.nonce ? options.nonce : void 0\n          });\n        }\n      } else null == options && Internals.d.M(href);\n  };\n  reactDom_production.preload = function(href, options) {\n    if (\"string\" === typeof href && \"object\" === typeof options && null !== options && \"string\" === typeof options.as) {\n      var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin);\n      Internals.d.L(href, as2, {\n        crossOrigin,\n        integrity: \"string\" === typeof options.integrity ? options.integrity : void 0,\n        nonce: \"string\" === typeof options.nonce ? options.nonce : void 0,\n        type: \"string\" === typeof options.type ? options.type : void 0,\n        fetchPriority: \"string\" === typeof options.fetchPriority ? options.fetchPriority : void 0,\n        referrerPolicy: \"string\" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,\n        imageSrcSet: \"string\" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\n        imageSizes: \"string\" === typeof options.imageSizes ? options.imageSizes : void 0,\n        media: \"string\" === typeof options.media ? options.media : void 0\n      });\n    }\n  };\n  reactDom_production.preloadModule = function(href, options) {\n    if (\"string\" === typeof href)\n      if (options) {\n        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\n        Internals.d.m(href, {\n          as: \"string\" === typeof options.as && \"script\" !== options.as ? options.as : void 0,\n          crossOrigin,\n          integrity: \"string\" === typeof options.integrity ? options.integrity : void 0\n        });\n      } else Internals.d.m(href);\n  };\n  reactDom_production.requestFormReset = function(form2) {\n    Internals.d.r(form2);\n  };\n  reactDom_production.unstable_batchedUpdates = function(fn2, a2) {\n    return fn2(a2);\n  };\n  reactDom_production.useFormState = function(action, initialState, permalink) {\n    return ReactSharedInternals.H.useFormState(action, initialState, permalink);\n  };\n  reactDom_production.useFormStatus = function() {\n    return ReactSharedInternals.H.useHostTransitionStatus();\n  };\n  reactDom_production.version = \"19.1.0\";\n  return reactDom_production;\n}\nfunction requireReactDom() {\n  if (hasRequiredReactDom) return reactDom.exports;\n  hasRequiredReactDom = 1;\n  function checkDCE() {\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== \"function\") {\n      return;\n    }\n    try {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  __name(checkDCE, \"checkDCE\");\n  {\n    checkDCE();\n    reactDom.exports = requireReactDom_production();\n  }\n  return reactDom.exports;\n}\nfunction requireReactDomServer_edge_production() {\n  if (hasRequiredReactDomServer_edge_production) return reactDomServer_edge_production;\n  hasRequiredReactDomServer_edge_production = 1;\n  var React2 = requireReact(), ReactDOM2 = requireReactDom(), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"), REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"), REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray;\n  function murmurhash3_32_gc(key, seed) {\n    var remainder = key.length & 3;\n    var bytes = key.length - remainder;\n    var h1 = seed;\n    for (seed = 0; seed < bytes; ) {\n      var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;\n      ++seed;\n      k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n      h1 = h1 << 13 | h1 >>> 19;\n      h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;\n      h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);\n    }\n    k1 = 0;\n    switch (remainder) {\n      case 3:\n        k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n      case 2:\n        k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n      case 1:\n        k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;\n    }\n    h1 ^= key.length;\n    h1 ^= h1 >>> 16;\n    h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;\n    h1 ^= h1 >>> 13;\n    h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;\n    return (h1 ^ h1 >>> 16) >>> 0;\n  }\n  __name(murmurhash3_32_gc, \"murmurhash3_32_gc\");\n  function handleErrorInNextTick(error4) {\n    setTimeout(function() {\n      throw error4;\n    });\n  }\n  __name(handleErrorInNextTick, \"handleErrorInNextTick\");\n  var LocalPromise = Promise, scheduleMicrotask = \"function\" === typeof queueMicrotask ? queueMicrotask : function(callback) {\n    LocalPromise.resolve(null).then(callback).catch(handleErrorInNextTick);\n  }, currentView = null, writtenBytes = 0;\n  function writeChunk(destination, chunk) {\n    if (0 !== chunk.byteLength)\n      if (2048 < chunk.byteLength)\n        0 < writtenBytes && (destination.enqueue(\n          new Uint8Array(currentView.buffer, 0, writtenBytes)\n        ), currentView = new Uint8Array(2048), writtenBytes = 0), destination.enqueue(chunk);\n      else {\n        var allowableBytes = currentView.length - writtenBytes;\n        allowableBytes < chunk.byteLength && (0 === allowableBytes ? destination.enqueue(currentView) : (currentView.set(chunk.subarray(0, allowableBytes), writtenBytes), destination.enqueue(currentView), chunk = chunk.subarray(allowableBytes)), currentView = new Uint8Array(2048), writtenBytes = 0);\n        currentView.set(chunk, writtenBytes);\n        writtenBytes += chunk.byteLength;\n      }\n  }\n  __name(writeChunk, \"writeChunk\");\n  function writeChunkAndReturn(destination, chunk) {\n    writeChunk(destination, chunk);\n    return true;\n  }\n  __name(writeChunkAndReturn, \"writeChunkAndReturn\");\n  function completeWriting(destination) {\n    currentView && 0 < writtenBytes && (destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes)), currentView = null, writtenBytes = 0);\n  }\n  __name(completeWriting, \"completeWriting\");\n  var textEncoder = new TextEncoder();\n  function stringToChunk(content) {\n    return textEncoder.encode(content);\n  }\n  __name(stringToChunk, \"stringToChunk\");\n  function stringToPrecomputedChunk(content) {\n    return textEncoder.encode(content);\n  }\n  __name(stringToPrecomputedChunk, \"stringToPrecomputedChunk\");\n  function closeWithError(destination, error4) {\n    \"function\" === typeof destination.error ? destination.error(error4) : destination.close();\n  }\n  __name(closeWithError, \"closeWithError\");\n  var assign = Object.assign, hasOwnProperty2 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n    \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};\n  function isAttributeNameSafe(attributeName) {\n    if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))\n      return true;\n    if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) return false;\n    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n      return validatedAttributeNameCache[attributeName] = true;\n    illegalAttributeNameCache[attributeName] = true;\n    return false;\n  }\n  __name(isAttributeNameSafe, \"isAttributeNameSafe\");\n  var unitlessNumbers = new Set(\n    \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n      \" \"\n    )\n  ), aliases = /* @__PURE__ */ new Map([\n    [\"acceptCharset\", \"accept-charset\"],\n    [\"htmlFor\", \"for\"],\n    [\"httpEquiv\", \"http-equiv\"],\n    [\"crossOrigin\", \"crossorigin\"],\n    [\"accentHeight\", \"accent-height\"],\n    [\"alignmentBaseline\", \"alignment-baseline\"],\n    [\"arabicForm\", \"arabic-form\"],\n    [\"baselineShift\", \"baseline-shift\"],\n    [\"capHeight\", \"cap-height\"],\n    [\"clipPath\", \"clip-path\"],\n    [\"clipRule\", \"clip-rule\"],\n    [\"colorInterpolation\", \"color-interpolation\"],\n    [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n    [\"colorProfile\", \"color-profile\"],\n    [\"colorRendering\", \"color-rendering\"],\n    [\"dominantBaseline\", \"dominant-baseline\"],\n    [\"enableBackground\", \"enable-background\"],\n    [\"fillOpacity\", \"fill-opacity\"],\n    [\"fillRule\", \"fill-rule\"],\n    [\"floodColor\", \"flood-color\"],\n    [\"floodOpacity\", \"flood-opacity\"],\n    [\"fontFamily\", \"font-family\"],\n    [\"fontSize\", \"font-size\"],\n    [\"fontSizeAdjust\", \"font-size-adjust\"],\n    [\"fontStretch\", \"font-stretch\"],\n    [\"fontStyle\", \"font-style\"],\n    [\"fontVariant\", \"font-variant\"],\n    [\"fontWeight\", \"font-weight\"],\n    [\"glyphName\", \"glyph-name\"],\n    [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n    [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n    [\"horizAdvX\", \"horiz-adv-x\"],\n    [\"horizOriginX\", \"horiz-origin-x\"],\n    [\"imageRendering\", \"image-rendering\"],\n    [\"letterSpacing\", \"letter-spacing\"],\n    [\"lightingColor\", \"lighting-color\"],\n    [\"markerEnd\", \"marker-end\"],\n    [\"markerMid\", \"marker-mid\"],\n    [\"markerStart\", \"marker-start\"],\n    [\"overlinePosition\", \"overline-position\"],\n    [\"overlineThickness\", \"overline-thickness\"],\n    [\"paintOrder\", \"paint-order\"],\n    [\"panose-1\", \"panose-1\"],\n    [\"pointerEvents\", \"pointer-events\"],\n    [\"renderingIntent\", \"rendering-intent\"],\n    [\"shapeRendering\", \"shape-rendering\"],\n    [\"stopColor\", \"stop-color\"],\n    [\"stopOpacity\", \"stop-opacity\"],\n    [\"strikethroughPosition\", \"strikethrough-position\"],\n    [\"strikethroughThickness\", \"strikethrough-thickness\"],\n    [\"strokeDasharray\", \"stroke-dasharray\"],\n    [\"strokeDashoffset\", \"stroke-dashoffset\"],\n    [\"strokeLinecap\", \"stroke-linecap\"],\n    [\"strokeLinejoin\", \"stroke-linejoin\"],\n    [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n    [\"strokeOpacity\", \"stroke-opacity\"],\n    [\"strokeWidth\", \"stroke-width\"],\n    [\"textAnchor\", \"text-anchor\"],\n    [\"textDecoration\", \"text-decoration\"],\n    [\"textRendering\", \"text-rendering\"],\n    [\"transformOrigin\", \"transform-origin\"],\n    [\"underlinePosition\", \"underline-position\"],\n    [\"underlineThickness\", \"underline-thickness\"],\n    [\"unicodeBidi\", \"unicode-bidi\"],\n    [\"unicodeRange\", \"unicode-range\"],\n    [\"unitsPerEm\", \"units-per-em\"],\n    [\"vAlphabetic\", \"v-alphabetic\"],\n    [\"vHanging\", \"v-hanging\"],\n    [\"vIdeographic\", \"v-ideographic\"],\n    [\"vMathematical\", \"v-mathematical\"],\n    [\"vectorEffect\", \"vector-effect\"],\n    [\"vertAdvY\", \"vert-adv-y\"],\n    [\"vertOriginX\", \"vert-origin-x\"],\n    [\"vertOriginY\", \"vert-origin-y\"],\n    [\"wordSpacing\", \"word-spacing\"],\n    [\"writingMode\", \"writing-mode\"],\n    [\"xmlnsXlink\", \"xmlns:xlink\"],\n    [\"xHeight\", \"x-height\"]\n  ]), matchHtmlRegExp = /[\"'&<>]/;\n  function escapeTextForBrowser(text) {\n    if (\"boolean\" === typeof text || \"number\" === typeof text || \"bigint\" === typeof text)\n      return \"\" + text;\n    text = \"\" + text;\n    var match = matchHtmlRegExp.exec(text);\n    if (match) {\n      var html2 = \"\", index, lastIndex = 0;\n      for (index = match.index; index < text.length; index++) {\n        switch (text.charCodeAt(index)) {\n          case 34:\n            match = \"&quot;\";\n            break;\n          case 38:\n            match = \"&amp;\";\n            break;\n          case 39:\n            match = \"&#x27;\";\n            break;\n          case 60:\n            match = \"&lt;\";\n            break;\n          case 62:\n            match = \"&gt;\";\n            break;\n          default:\n            continue;\n        }\n        lastIndex !== index && (html2 += text.slice(lastIndex, index));\n        lastIndex = index + 1;\n        html2 += match;\n      }\n      text = lastIndex !== index ? html2 + text.slice(lastIndex, index) : html2;\n    }\n    return text;\n  }\n  __name(escapeTextForBrowser, \"escapeTextForBrowser\");\n  var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i;\n  function sanitizeURL(url) {\n    return isJavaScriptProtocol.test(\"\" + url) ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\" : url;\n  }\n  __name(sanitizeURL, \"sanitizeURL\");\n  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {\n    pending: false,\n    data: null,\n    method: null,\n    action: null\n  }, previousDispatcher = ReactDOMSharedInternals.d;\n  ReactDOMSharedInternals.d = {\n    f: previousDispatcher.f,\n    r: previousDispatcher.r,\n    D: prefetchDNS,\n    C: preconnect,\n    L: preload,\n    m: preloadModule,\n    X: preinitScript,\n    S: preinitStyle,\n    M: preinitModuleScript\n  };\n  var PRELOAD_NO_CREDS = [];\n  stringToPrecomputedChunk('\"></template>');\n  var startInlineScript = stringToPrecomputedChunk(\"<script>\"), endInlineScript = stringToPrecomputedChunk(\"</script>\"), startScriptSrc = stringToPrecomputedChunk('<script src=\"'), startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"'), scriptNonce = stringToPrecomputedChunk('\" nonce=\"'), scriptIntegirty = stringToPrecomputedChunk('\" integrity=\"'), scriptCrossOrigin = stringToPrecomputedChunk('\" crossorigin=\"'), endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>'), scriptRegex = /(<\\/|<)(s)(cript)/gi;\n  function scriptReplacer(match, prefix2, s2, suffix2) {\n    return \"\" + prefix2 + (\"s\" === s2 ? \"\\\\u0073\" : \"\\\\u0053\") + suffix2;\n  }\n  __name(scriptReplacer, \"scriptReplacer\");\n  var importMapScriptStart = stringToPrecomputedChunk(\n    '<script type=\"importmap\">'\n  ), importMapScriptEnd = stringToPrecomputedChunk(\"</script>\");\n  function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {\n    var inlineScriptWithNonce = void 0 === nonce ? startInlineScript : stringToPrecomputedChunk(\n      '<script nonce=\"' + escapeTextForBrowser(nonce) + '\">'\n    ), idPrefix = resumableState.idPrefix;\n    externalRuntimeConfig = [];\n    var bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;\n    void 0 !== bootstrapScriptContent && externalRuntimeConfig.push(\n      inlineScriptWithNonce,\n      stringToChunk(\n        (\"\" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer)\n      ),\n      endInlineScript\n    );\n    bootstrapScriptContent = [];\n    void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(\n      stringToChunk(\n        (\"\" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)\n      )\n    ), bootstrapScriptContent.push(importMapScriptEnd));\n    importMap = onHeaders ? {\n      preconnects: \"\",\n      fontPreloads: \"\",\n      highImagePreloads: \"\",\n      remainingCapacity: 2 + (\"number\" === typeof maxHeadersLength ? maxHeadersLength : 2e3)\n    } : null;\n    onHeaders = {\n      placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n      segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n      boundaryPrefix: stringToPrecomputedChunk(idPrefix + \"B:\"),\n      startInlineScript: inlineScriptWithNonce,\n      preamble: createPreambleState(),\n      externalRuntimeScript: null,\n      bootstrapChunks: externalRuntimeConfig,\n      importMapChunks: bootstrapScriptContent,\n      onHeaders,\n      headers: importMap,\n      resets: {\n        font: {},\n        dns: {},\n        connect: { default: {}, anonymous: {}, credentials: {} },\n        image: {},\n        style: {}\n      },\n      charsetChunks: [],\n      viewportChunks: [],\n      hoistableChunks: [],\n      preconnects: /* @__PURE__ */ new Set(),\n      fontPreloads: /* @__PURE__ */ new Set(),\n      highImagePreloads: /* @__PURE__ */ new Set(),\n      styles: /* @__PURE__ */ new Map(),\n      bootstrapScripts: /* @__PURE__ */ new Set(),\n      scripts: /* @__PURE__ */ new Set(),\n      bulkPreloads: /* @__PURE__ */ new Set(),\n      preloads: {\n        images: /* @__PURE__ */ new Map(),\n        stylesheets: /* @__PURE__ */ new Map(),\n        scripts: /* @__PURE__ */ new Map(),\n        moduleScripts: /* @__PURE__ */ new Map()\n      },\n      nonce,\n      hoistableState: null,\n      stylesToHoist: false\n    };\n    if (void 0 !== bootstrapScripts)\n      for (importMap = 0; importMap < bootstrapScripts.length; importMap++) {\n        var scriptConfig = bootstrapScripts[importMap];\n        idPrefix = inlineScriptWithNonce = void 0;\n        bootstrapScriptContent = {\n          rel: \"preload\",\n          as: \"script\",\n          fetchPriority: \"low\",\n          nonce\n        };\n        \"string\" === typeof scriptConfig ? bootstrapScriptContent.href = maxHeadersLength = scriptConfig : (bootstrapScriptContent.href = maxHeadersLength = scriptConfig.src, bootstrapScriptContent.integrity = idPrefix = \"string\" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, bootstrapScriptContent.crossOrigin = inlineScriptWithNonce = \"string\" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : \"use-credentials\" === scriptConfig.crossOrigin ? \"use-credentials\" : \"\");\n        scriptConfig = resumableState;\n        var href = maxHeadersLength;\n        scriptConfig.scriptResources[href] = null;\n        scriptConfig.moduleScriptResources[href] = null;\n        scriptConfig = [];\n        pushLinkImpl(scriptConfig, bootstrapScriptContent);\n        onHeaders.bootstrapScripts.add(scriptConfig);\n        externalRuntimeConfig.push(\n          startScriptSrc,\n          stringToChunk(escapeTextForBrowser(maxHeadersLength))\n        );\n        nonce && externalRuntimeConfig.push(\n          scriptNonce,\n          stringToChunk(escapeTextForBrowser(nonce))\n        );\n        \"string\" === typeof idPrefix && externalRuntimeConfig.push(\n          scriptIntegirty,\n          stringToChunk(escapeTextForBrowser(idPrefix))\n        );\n        \"string\" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(\n          scriptCrossOrigin,\n          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))\n        );\n        externalRuntimeConfig.push(endAsyncScript);\n      }\n    if (void 0 !== bootstrapModules)\n      for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)\n        bootstrapScriptContent = bootstrapModules[bootstrapScripts], inlineScriptWithNonce = maxHeadersLength = void 0, idPrefix = {\n          rel: \"modulepreload\",\n          fetchPriority: \"low\",\n          nonce\n        }, \"string\" === typeof bootstrapScriptContent ? idPrefix.href = importMap = bootstrapScriptContent : (idPrefix.href = importMap = bootstrapScriptContent.src, idPrefix.integrity = inlineScriptWithNonce = \"string\" === typeof bootstrapScriptContent.integrity ? bootstrapScriptContent.integrity : void 0, idPrefix.crossOrigin = maxHeadersLength = \"string\" === typeof bootstrapScriptContent || null == bootstrapScriptContent.crossOrigin ? void 0 : \"use-credentials\" === bootstrapScriptContent.crossOrigin ? \"use-credentials\" : \"\"), bootstrapScriptContent = resumableState, scriptConfig = importMap, bootstrapScriptContent.scriptResources[scriptConfig] = null, bootstrapScriptContent.moduleScriptResources[scriptConfig] = null, bootstrapScriptContent = [], pushLinkImpl(bootstrapScriptContent, idPrefix), onHeaders.bootstrapScripts.add(bootstrapScriptContent), externalRuntimeConfig.push(\n          startModuleSrc,\n          stringToChunk(escapeTextForBrowser(importMap))\n        ), nonce && externalRuntimeConfig.push(\n          scriptNonce,\n          stringToChunk(escapeTextForBrowser(nonce))\n        ), \"string\" === typeof inlineScriptWithNonce && externalRuntimeConfig.push(\n          scriptIntegirty,\n          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce))\n        ), \"string\" === typeof maxHeadersLength && externalRuntimeConfig.push(\n          scriptCrossOrigin,\n          stringToChunk(escapeTextForBrowser(maxHeadersLength))\n        ), externalRuntimeConfig.push(endAsyncScript);\n    return onHeaders;\n  }\n  __name(createRenderState, \"createRenderState\");\n  function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n    return {\n      idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n      nextFormID: 0,\n      streamingFormat: 0,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules,\n      instructions: 0,\n      hasBody: false,\n      hasHtml: false,\n      unknownResources: {},\n      dnsResources: {},\n      connectResources: { default: {}, anonymous: {}, credentials: {} },\n      imageResources: {},\n      styleResources: {},\n      scriptResources: {},\n      moduleUnknownResources: {},\n      moduleScriptResources: {}\n    };\n  }\n  __name(createResumableState, \"createResumableState\");\n  function createPreambleState() {\n    return {\n      htmlChunks: null,\n      headChunks: null,\n      bodyChunks: null,\n      contribution: 0\n    };\n  }\n  __name(createPreambleState, \"createPreambleState\");\n  function createFormatContext(insertionMode, selectedValue, tagScope) {\n    return {\n      insertionMode,\n      selectedValue,\n      tagScope\n    };\n  }\n  __name(createFormatContext, \"createFormatContext\");\n  function createRootFormatContext(namespaceURI) {\n    return createFormatContext(\n      \"http://www.w3.org/2000/svg\" === namespaceURI ? 4 : \"http://www.w3.org/1998/Math/MathML\" === namespaceURI ? 5 : 0,\n      null,\n      0\n    );\n  }\n  __name(createRootFormatContext, \"createRootFormatContext\");\n  function getChildFormatContext(parentContext, type2, props) {\n    switch (type2) {\n      case \"noscript\":\n        return createFormatContext(2, null, parentContext.tagScope | 1);\n      case \"select\":\n        return createFormatContext(\n          2,\n          null != props.value ? props.value : props.defaultValue,\n          parentContext.tagScope\n        );\n      case \"svg\":\n        return createFormatContext(4, null, parentContext.tagScope);\n      case \"picture\":\n        return createFormatContext(2, null, parentContext.tagScope | 2);\n      case \"math\":\n        return createFormatContext(5, null, parentContext.tagScope);\n      case \"foreignObject\":\n        return createFormatContext(2, null, parentContext.tagScope);\n      case \"table\":\n        return createFormatContext(6, null, parentContext.tagScope);\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n        return createFormatContext(7, null, parentContext.tagScope);\n      case \"colgroup\":\n        return createFormatContext(9, null, parentContext.tagScope);\n      case \"tr\":\n        return createFormatContext(8, null, parentContext.tagScope);\n      case \"head\":\n        if (2 > parentContext.insertionMode)\n          return createFormatContext(3, null, parentContext.tagScope);\n        break;\n      case \"html\":\n        if (0 === parentContext.insertionMode)\n          return createFormatContext(1, null, parentContext.tagScope);\n    }\n    return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, parentContext.tagScope) : parentContext;\n  }\n  __name(getChildFormatContext, \"getChildFormatContext\");\n  var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n  function pushTextInstance(target, text, renderState, textEmbedded) {\n    if (\"\" === text) return textEmbedded;\n    textEmbedded && target.push(textSeparator);\n    target.push(stringToChunk(escapeTextForBrowser(text)));\n    return true;\n  }\n  __name(pushTextInstance, \"pushTextInstance\");\n  var styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(' style=\"'), styleAssign = stringToPrecomputedChunk(\":\"), styleSeparator = stringToPrecomputedChunk(\";\");\n  function pushStyleAttribute(target, style2) {\n    if (\"object\" !== typeof style2)\n      throw Error(\n        \"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\"\n      );\n    var isFirst = true, styleName;\n    for (styleName in style2)\n      if (hasOwnProperty2.call(style2, styleName)) {\n        var styleValue = style2[styleName];\n        if (null != styleValue && \"boolean\" !== typeof styleValue && \"\" !== styleValue) {\n          if (0 === styleName.indexOf(\"--\")) {\n            var nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n            styleValue = stringToChunk(\n              escapeTextForBrowser((\"\" + styleValue).trim())\n            );\n          } else\n            nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = stringToPrecomputedChunk(\n              escapeTextForBrowser(\n                styleName.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\")\n              )\n            ), styleNameCache.set(styleName, nameChunk)), styleValue = \"number\" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? stringToChunk(\"\" + styleValue) : stringToChunk(styleValue + \"px\") : stringToChunk(\n              escapeTextForBrowser((\"\" + styleValue).trim())\n            );\n          isFirst ? (isFirst = false, target.push(\n            styleAttributeStart,\n            nameChunk,\n            styleAssign,\n            styleValue\n          )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);\n        }\n      }\n    isFirst || target.push(attributeEnd);\n  }\n  __name(pushStyleAttribute, \"pushStyleAttribute\");\n  var attributeSeparator = stringToPrecomputedChunk(\" \"), attributeAssign = stringToPrecomputedChunk('=\"'), attributeEnd = stringToPrecomputedChunk('\"'), attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n  function pushBooleanAttribute(target, name, value2) {\n    value2 && \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);\n  }\n  __name(pushBooleanAttribute, \"pushBooleanAttribute\");\n  function pushStringAttribute(target, name, value2) {\n    \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && \"boolean\" !== typeof value2 && target.push(\n      attributeSeparator,\n      stringToChunk(name),\n      attributeAssign,\n      stringToChunk(escapeTextForBrowser(value2)),\n      attributeEnd\n    );\n  }\n  __name(pushStringAttribute, \"pushStringAttribute\");\n  var actionJavaScriptURL = stringToPrecomputedChunk(\n    escapeTextForBrowser(\n      \"javascript:throw new Error('React form unexpectedly submitted.')\"\n    )\n  ), startHiddenInputChunk = stringToPrecomputedChunk('<input type=\"hidden\"');\n  function pushAdditionalFormField(value2, key) {\n    this.push(startHiddenInputChunk);\n    validateAdditionalFormField(value2);\n    pushStringAttribute(this, \"name\", key);\n    pushStringAttribute(this, \"value\", value2);\n    this.push(endOfStartTagSelfClosing);\n  }\n  __name(pushAdditionalFormField, \"pushAdditionalFormField\");\n  function validateAdditionalFormField(value2) {\n    if (\"string\" !== typeof value2)\n      throw Error(\n        \"File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.\"\n      );\n  }\n  __name(validateAdditionalFormField, \"validateAdditionalFormField\");\n  function getCustomFormFields(resumableState, formAction) {\n    if (\"function\" === typeof formAction.$$FORM_ACTION) {\n      var id2 = resumableState.nextFormID++;\n      resumableState = resumableState.idPrefix + id2;\n      try {\n        var customFields = formAction.$$FORM_ACTION(resumableState);\n        if (customFields) {\n          var formData = customFields.data;\n          null != formData && formData.forEach(validateAdditionalFormField);\n        }\n        return customFields;\n      } catch (x) {\n        if (\"object\" === typeof x && null !== x && \"function\" === typeof x.then)\n          throw x;\n      }\n    }\n    return null;\n  }\n  __name(getCustomFormFields, \"getCustomFormFields\");\n  function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {\n    var formData = null;\n    if (\"function\" === typeof formAction) {\n      var customFields = getCustomFormFields(resumableState, formAction);\n      null !== customFields ? (name = customFields.name, formAction = customFields.action || \"\", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(\n        attributeSeparator,\n        stringToChunk(\"formAction\"),\n        attributeAssign,\n        actionJavaScriptURL,\n        attributeEnd\n      ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));\n    }\n    null != name && pushAttribute(target, \"name\", name);\n    null != formAction && pushAttribute(target, \"formAction\", formAction);\n    null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n    null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n    null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n    return formData;\n  }\n  __name(pushFormActionAttribute, \"pushFormActionAttribute\");\n  function pushAttribute(target, name, value2) {\n    switch (name) {\n      case \"className\":\n        pushStringAttribute(target, \"class\", value2);\n        break;\n      case \"tabIndex\":\n        pushStringAttribute(target, \"tabindex\", value2);\n        break;\n      case \"dir\":\n      case \"role\":\n      case \"viewBox\":\n      case \"width\":\n      case \"height\":\n        pushStringAttribute(target, name, value2);\n        break;\n      case \"style\":\n        pushStyleAttribute(target, value2);\n        break;\n      case \"src\":\n      case \"href\":\n        if (\"\" === value2) break;\n      case \"action\":\n      case \"formAction\":\n        if (null == value2 || \"function\" === typeof value2 || \"symbol\" === typeof value2 || \"boolean\" === typeof value2)\n          break;\n        value2 = sanitizeURL(\"\" + value2);\n        target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value2)),\n          attributeEnd\n        );\n        break;\n      case \"defaultValue\":\n      case \"defaultChecked\":\n      case \"innerHTML\":\n      case \"suppressContentEditableWarning\":\n      case \"suppressHydrationWarning\":\n      case \"ref\":\n        break;\n      case \"autoFocus\":\n      case \"multiple\":\n      case \"muted\":\n        pushBooleanAttribute(target, name.toLowerCase(), value2);\n        break;\n      case \"xlinkHref\":\n        if (\"function\" === typeof value2 || \"symbol\" === typeof value2 || \"boolean\" === typeof value2)\n          break;\n        value2 = sanitizeURL(\"\" + value2);\n        target.push(\n          attributeSeparator,\n          stringToChunk(\"xlink:href\"),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value2)),\n          attributeEnd\n        );\n        break;\n      case \"contentEditable\":\n      case \"spellCheck\":\n      case \"draggable\":\n      case \"value\":\n      case \"autoReverse\":\n      case \"externalResourcesRequired\":\n      case \"focusable\":\n      case \"preserveAlpha\":\n        \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value2)),\n          attributeEnd\n        );\n        break;\n      case \"inert\":\n      case \"allowFullScreen\":\n      case \"async\":\n      case \"autoPlay\":\n      case \"controls\":\n      case \"default\":\n      case \"defer\":\n      case \"disabled\":\n      case \"disablePictureInPicture\":\n      case \"disableRemotePlayback\":\n      case \"formNoValidate\":\n      case \"hidden\":\n      case \"loop\":\n      case \"noModule\":\n      case \"noValidate\":\n      case \"open\":\n      case \"playsInline\":\n      case \"readOnly\":\n      case \"required\":\n      case \"reversed\":\n      case \"scoped\":\n      case \"seamless\":\n      case \"itemScope\":\n        value2 && \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeEmptyString\n        );\n        break;\n      case \"capture\":\n      case \"download\":\n        true === value2 ? target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeEmptyString\n        ) : false !== value2 && \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value2)),\n          attributeEnd\n        );\n        break;\n      case \"cols\":\n      case \"rows\":\n      case \"size\":\n      case \"span\":\n        \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && !isNaN(value2) && 1 <= value2 && target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value2)),\n          attributeEnd\n        );\n        break;\n      case \"rowSpan\":\n      case \"start\":\n        \"function\" === typeof value2 || \"symbol\" === typeof value2 || isNaN(value2) || target.push(\n          attributeSeparator,\n          stringToChunk(name),\n          attributeAssign,\n          stringToChunk(escapeTextForBrowser(value2)),\n          attributeEnd\n        );\n        break;\n      case \"xlinkActuate\":\n        pushStringAttribute(target, \"xlink:actuate\", value2);\n        break;\n      case \"xlinkArcrole\":\n        pushStringAttribute(target, \"xlink:arcrole\", value2);\n        break;\n      case \"xlinkRole\":\n        pushStringAttribute(target, \"xlink:role\", value2);\n        break;\n      case \"xlinkShow\":\n        pushStringAttribute(target, \"xlink:show\", value2);\n        break;\n      case \"xlinkTitle\":\n        pushStringAttribute(target, \"xlink:title\", value2);\n        break;\n      case \"xlinkType\":\n        pushStringAttribute(target, \"xlink:type\", value2);\n        break;\n      case \"xmlBase\":\n        pushStringAttribute(target, \"xml:base\", value2);\n        break;\n      case \"xmlLang\":\n        pushStringAttribute(target, \"xml:lang\", value2);\n        break;\n      case \"xmlSpace\":\n        pushStringAttribute(target, \"xml:space\", value2);\n        break;\n      default:\n        if (!(2 < name.length) || \"o\" !== name[0] && \"O\" !== name[0] || \"n\" !== name[1] && \"N\" !== name[1]) {\n          if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {\n            switch (typeof value2) {\n              case \"function\":\n              case \"symbol\":\n                return;\n              case \"boolean\":\n                var prefix$8 = name.toLowerCase().slice(0, 5);\n                if (\"data-\" !== prefix$8 && \"aria-\" !== prefix$8) return;\n            }\n            target.push(\n              attributeSeparator,\n              stringToChunk(name),\n              attributeAssign,\n              stringToChunk(escapeTextForBrowser(value2)),\n              attributeEnd\n            );\n          }\n        }\n    }\n  }\n  __name(pushAttribute, \"pushAttribute\");\n  var endOfStartTag = stringToPrecomputedChunk(\">\"), endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n  function pushInnerHTML(target, innerHTML, children) {\n    if (null != innerHTML) {\n      if (null != children)\n        throw Error(\n          \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n        );\n      if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n        throw Error(\n          \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n        );\n      innerHTML = innerHTML.__html;\n      null !== innerHTML && void 0 !== innerHTML && target.push(stringToChunk(\"\" + innerHTML));\n    }\n  }\n  __name(pushInnerHTML, \"pushInnerHTML\");\n  function flattenOptionChildren(children) {\n    var content = \"\";\n    React2.Children.forEach(children, function(child) {\n      null != child && (content += child);\n    });\n    return content;\n  }\n  __name(flattenOptionChildren, \"flattenOptionChildren\");\n  var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"'), formReplayingRuntimeScript = stringToPrecomputedChunk(\n    `addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`\n  );\n  function injectFormReplayingRuntime(resumableState, renderState) {\n    0 === (resumableState.instructions & 16) && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(\n      renderState.startInlineScript,\n      formReplayingRuntimeScript,\n      endInlineScript\n    ));\n  }\n  __name(injectFormReplayingRuntime, \"injectFormReplayingRuntime\");\n  var formStateMarkerIsMatching = stringToPrecomputedChunk(\"<!--F!-->\"), formStateMarkerIsNotMatching = stringToPrecomputedChunk(\"<!--F-->\");\n  function pushLinkImpl(target, props) {\n    target.push(startChunkForTag(\"link\"));\n    for (var propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              throw Error(\n                \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n              );\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(endOfStartTagSelfClosing);\n    return null;\n  }\n  __name(pushLinkImpl, \"pushLinkImpl\");\n  var styleRegex = /(<\\/|<)(s)(tyle)/gi;\n  function styleReplacer(match, prefix2, s2, suffix2) {\n    return \"\" + prefix2 + (\"s\" === s2 ? \"\\\\73 \" : \"\\\\53 \") + suffix2;\n  }\n  __name(styleReplacer, \"styleReplacer\");\n  function pushSelfClosing(target, props, tag) {\n    target.push(startChunkForTag(tag));\n    for (var propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              throw Error(\n                tag + \" is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n              );\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(endOfStartTagSelfClosing);\n    return null;\n  }\n  __name(pushSelfClosing, \"pushSelfClosing\");\n  function pushTitleImpl(target, props) {\n    target.push(startChunkForTag(\"title\"));\n    var children = null, innerHTML = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              children = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(endOfStartTag);\n    props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;\n    \"function\" !== typeof props && \"symbol\" !== typeof props && null !== props && void 0 !== props && target.push(stringToChunk(escapeTextForBrowser(\"\" + props)));\n    pushInnerHTML(target, innerHTML, children);\n    target.push(endChunkForTag(\"title\"));\n    return null;\n  }\n  __name(pushTitleImpl, \"pushTitleImpl\");\n  function pushScriptImpl(target, props) {\n    target.push(startChunkForTag(\"script\"));\n    var children = null, innerHTML = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              children = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(endOfStartTag);\n    pushInnerHTML(target, innerHTML, children);\n    \"string\" === typeof children && target.push(\n      stringToChunk((\"\" + children).replace(scriptRegex, scriptReplacer))\n    );\n    target.push(endChunkForTag(\"script\"));\n    return null;\n  }\n  __name(pushScriptImpl, \"pushScriptImpl\");\n  function pushStartSingletonElement(target, props, tag) {\n    target.push(startChunkForTag(tag));\n    var innerHTML = tag = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              tag = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(endOfStartTag);\n    pushInnerHTML(target, innerHTML, tag);\n    return tag;\n  }\n  __name(pushStartSingletonElement, \"pushStartSingletonElement\");\n  function pushStartGenericElement(target, props, tag) {\n    target.push(startChunkForTag(tag));\n    var innerHTML = tag = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              tag = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(endOfStartTag);\n    pushInnerHTML(target, innerHTML, tag);\n    return \"string\" === typeof tag ? (target.push(stringToChunk(escapeTextForBrowser(tag))), null) : tag;\n  }\n  __name(pushStartGenericElement, \"pushStartGenericElement\");\n  var leadingNewline = stringToPrecomputedChunk(\"\\n\"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();\n  function startChunkForTag(tag) {\n    var tagStartChunk = validatedTagCache.get(tag);\n    if (void 0 === tagStartChunk) {\n      if (!VALID_TAG_REGEX.test(tag)) throw Error(\"Invalid tag: \" + tag);\n      tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n      validatedTagCache.set(tag, tagStartChunk);\n    }\n    return tagStartChunk;\n  }\n  __name(startChunkForTag, \"startChunkForTag\");\n  var doctypeChunk = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n  function pushStartInstance(target$jscomp$0, type2, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {\n    switch (type2) {\n      case \"div\":\n      case \"span\":\n      case \"svg\":\n      case \"path\":\n        break;\n      case \"a\":\n        target$jscomp$0.push(startChunkForTag(\"a\"));\n        var children = null, innerHTML = null, propKey;\n        for (propKey in props)\n          if (hasOwnProperty2.call(props, propKey)) {\n            var propValue = props[propKey];\n            if (null != propValue)\n              switch (propKey) {\n                case \"children\":\n                  children = propValue;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML = propValue;\n                  break;\n                case \"href\":\n                  \"\" === propValue ? pushStringAttribute(target$jscomp$0, \"href\", \"\") : pushAttribute(target$jscomp$0, propKey, propValue);\n                  break;\n                default:\n                  pushAttribute(target$jscomp$0, propKey, propValue);\n              }\n          }\n        target$jscomp$0.push(endOfStartTag);\n        pushInnerHTML(target$jscomp$0, innerHTML, children);\n        if (\"string\" === typeof children) {\n          target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));\n          var JSCompiler_inline_result = null;\n        } else JSCompiler_inline_result = children;\n        return JSCompiler_inline_result;\n      case \"g\":\n      case \"p\":\n      case \"li\":\n        break;\n      case \"select\":\n        target$jscomp$0.push(startChunkForTag(\"select\"));\n        var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;\n        for (propKey$jscomp$0 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$0)) {\n            var propValue$jscomp$0 = props[propKey$jscomp$0];\n            if (null != propValue$jscomp$0)\n              switch (propKey$jscomp$0) {\n                case \"children\":\n                  children$jscomp$0 = propValue$jscomp$0;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$0 = propValue$jscomp$0;\n                  break;\n                case \"defaultValue\":\n                case \"value\":\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$0,\n                    propValue$jscomp$0\n                  );\n              }\n          }\n        target$jscomp$0.push(endOfStartTag);\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n        return children$jscomp$0;\n      case \"option\":\n        var selectedValue = formatContext.selectedValue;\n        target$jscomp$0.push(startChunkForTag(\"option\"));\n        var children$jscomp$1 = null, value2 = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;\n        for (propKey$jscomp$1 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$1)) {\n            var propValue$jscomp$1 = props[propKey$jscomp$1];\n            if (null != propValue$jscomp$1)\n              switch (propKey$jscomp$1) {\n                case \"children\":\n                  children$jscomp$1 = propValue$jscomp$1;\n                  break;\n                case \"selected\":\n                  selected = propValue$jscomp$1;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$1 = propValue$jscomp$1;\n                  break;\n                case \"value\":\n                  value2 = propValue$jscomp$1;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$1,\n                    propValue$jscomp$1\n                  );\n              }\n          }\n        if (null != selectedValue) {\n          var stringValue = null !== value2 ? \"\" + value2 : flattenOptionChildren(children$jscomp$1);\n          if (isArrayImpl(selectedValue))\n            for (var i = 0; i < selectedValue.length; i++) {\n              if (\"\" + selectedValue[i] === stringValue) {\n                target$jscomp$0.push(selectedMarkerAttribute);\n                break;\n              }\n            }\n          else\n            \"\" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);\n        } else selected && target$jscomp$0.push(selectedMarkerAttribute);\n        target$jscomp$0.push(endOfStartTag);\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n        return children$jscomp$1;\n      case \"textarea\":\n        target$jscomp$0.push(startChunkForTag(\"textarea\"));\n        var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;\n        for (propKey$jscomp$2 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$2)) {\n            var propValue$jscomp$2 = props[propKey$jscomp$2];\n            if (null != propValue$jscomp$2)\n              switch (propKey$jscomp$2) {\n                case \"children\":\n                  children$jscomp$2 = propValue$jscomp$2;\n                  break;\n                case \"value\":\n                  value$jscomp$0 = propValue$jscomp$2;\n                  break;\n                case \"defaultValue\":\n                  defaultValue = propValue$jscomp$2;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(\n                    \"`dangerouslySetInnerHTML` does not make sense on <textarea>.\"\n                  );\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$2,\n                    propValue$jscomp$2\n                  );\n              }\n          }\n        null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);\n        target$jscomp$0.push(endOfStartTag);\n        if (null != children$jscomp$2) {\n          if (null != value$jscomp$0)\n            throw Error(\n              \"If you supply `defaultValue` on a <textarea>, do not pass children.\"\n            );\n          if (isArrayImpl(children$jscomp$2)) {\n            if (1 < children$jscomp$2.length)\n              throw Error(\"<textarea> can only have at most one child.\");\n            value$jscomp$0 = \"\" + children$jscomp$2[0];\n          }\n          value$jscomp$0 = \"\" + children$jscomp$2;\n        }\n        \"string\" === typeof value$jscomp$0 && \"\\n\" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);\n        null !== value$jscomp$0 && target$jscomp$0.push(\n          stringToChunk(escapeTextForBrowser(\"\" + value$jscomp$0))\n        );\n        return null;\n      case \"input\":\n        target$jscomp$0.push(startChunkForTag(\"input\"));\n        var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;\n        for (propKey$jscomp$3 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$3)) {\n            var propValue$jscomp$3 = props[propKey$jscomp$3];\n            if (null != propValue$jscomp$3)\n              switch (propKey$jscomp$3) {\n                case \"children\":\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(\n                    \"input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                  );\n                case \"name\":\n                  name = propValue$jscomp$3;\n                  break;\n                case \"formAction\":\n                  formAction = propValue$jscomp$3;\n                  break;\n                case \"formEncType\":\n                  formEncType = propValue$jscomp$3;\n                  break;\n                case \"formMethod\":\n                  formMethod = propValue$jscomp$3;\n                  break;\n                case \"formTarget\":\n                  formTarget = propValue$jscomp$3;\n                  break;\n                case \"defaultChecked\":\n                  defaultChecked = propValue$jscomp$3;\n                  break;\n                case \"defaultValue\":\n                  defaultValue$jscomp$0 = propValue$jscomp$3;\n                  break;\n                case \"checked\":\n                  checked = propValue$jscomp$3;\n                  break;\n                case \"value\":\n                  value$jscomp$1 = propValue$jscomp$3;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$3,\n                    propValue$jscomp$3\n                  );\n              }\n          }\n        var formData = pushFormActionAttribute(\n          target$jscomp$0,\n          resumableState,\n          renderState,\n          formAction,\n          formEncType,\n          formMethod,\n          formTarget,\n          name\n        );\n        null !== checked ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n        null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n        target$jscomp$0.push(endOfStartTagSelfClosing);\n        null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);\n        return null;\n      case \"button\":\n        target$jscomp$0.push(startChunkForTag(\"button\"));\n        var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;\n        for (propKey$jscomp$4 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$4)) {\n            var propValue$jscomp$4 = props[propKey$jscomp$4];\n            if (null != propValue$jscomp$4)\n              switch (propKey$jscomp$4) {\n                case \"children\":\n                  children$jscomp$3 = propValue$jscomp$4;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$2 = propValue$jscomp$4;\n                  break;\n                case \"name\":\n                  name$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formAction\":\n                  formAction$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formEncType\":\n                  formEncType$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formMethod\":\n                  formMethod$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formTarget\":\n                  formTarget$jscomp$0 = propValue$jscomp$4;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$4,\n                    propValue$jscomp$4\n                  );\n              }\n          }\n        var formData$jscomp$0 = pushFormActionAttribute(\n          target$jscomp$0,\n          resumableState,\n          renderState,\n          formAction$jscomp$0,\n          formEncType$jscomp$0,\n          formMethod$jscomp$0,\n          formTarget$jscomp$0,\n          name$jscomp$0\n        );\n        target$jscomp$0.push(endOfStartTag);\n        null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n        if (\"string\" === typeof children$jscomp$3) {\n          target$jscomp$0.push(\n            stringToChunk(escapeTextForBrowser(children$jscomp$3))\n          );\n          var JSCompiler_inline_result$jscomp$0 = null;\n        } else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;\n        return JSCompiler_inline_result$jscomp$0;\n      case \"form\":\n        target$jscomp$0.push(startChunkForTag(\"form\"));\n        var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;\n        for (propKey$jscomp$5 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$5)) {\n            var propValue$jscomp$5 = props[propKey$jscomp$5];\n            if (null != propValue$jscomp$5)\n              switch (propKey$jscomp$5) {\n                case \"children\":\n                  children$jscomp$4 = propValue$jscomp$5;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$3 = propValue$jscomp$5;\n                  break;\n                case \"action\":\n                  formAction$jscomp$1 = propValue$jscomp$5;\n                  break;\n                case \"encType\":\n                  formEncType$jscomp$1 = propValue$jscomp$5;\n                  break;\n                case \"method\":\n                  formMethod$jscomp$1 = propValue$jscomp$5;\n                  break;\n                case \"target\":\n                  formTarget$jscomp$1 = propValue$jscomp$5;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$5,\n                    propValue$jscomp$5\n                  );\n              }\n          }\n        var formData$jscomp$1 = null, formActionName = null;\n        if (\"function\" === typeof formAction$jscomp$1) {\n          var customFields = getCustomFormFields(\n            resumableState,\n            formAction$jscomp$1\n          );\n          null !== customFields ? (formAction$jscomp$1 = customFields.action || \"\", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(\n            attributeSeparator,\n            stringToChunk(\"action\"),\n            attributeAssign,\n            actionJavaScriptURL,\n            attributeEnd\n          ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));\n        }\n        null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n        null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n        null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n        null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n        target$jscomp$0.push(endOfStartTag);\n        null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, \"name\", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n        if (\"string\" === typeof children$jscomp$4) {\n          target$jscomp$0.push(\n            stringToChunk(escapeTextForBrowser(children$jscomp$4))\n          );\n          var JSCompiler_inline_result$jscomp$1 = null;\n        } else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;\n        return JSCompiler_inline_result$jscomp$1;\n      case \"menuitem\":\n        target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n        for (var propKey$jscomp$6 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$6)) {\n            var propValue$jscomp$6 = props[propKey$jscomp$6];\n            if (null != propValue$jscomp$6)\n              switch (propKey$jscomp$6) {\n                case \"children\":\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(\n                    \"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\"\n                  );\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$6,\n                    propValue$jscomp$6\n                  );\n              }\n          }\n        target$jscomp$0.push(endOfStartTag);\n        return null;\n      case \"object\":\n        target$jscomp$0.push(startChunkForTag(\"object\"));\n        var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;\n        for (propKey$jscomp$7 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$7)) {\n            var propValue$jscomp$7 = props[propKey$jscomp$7];\n            if (null != propValue$jscomp$7)\n              switch (propKey$jscomp$7) {\n                case \"children\":\n                  children$jscomp$5 = propValue$jscomp$7;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$4 = propValue$jscomp$7;\n                  break;\n                case \"data\":\n                  var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                  if (\"\" === sanitizedValue) break;\n                  target$jscomp$0.push(\n                    attributeSeparator,\n                    stringToChunk(\"data\"),\n                    attributeAssign,\n                    stringToChunk(escapeTextForBrowser(sanitizedValue)),\n                    attributeEnd\n                  );\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$7,\n                    propValue$jscomp$7\n                  );\n              }\n          }\n        target$jscomp$0.push(endOfStartTag);\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n        if (\"string\" === typeof children$jscomp$5) {\n          target$jscomp$0.push(\n            stringToChunk(escapeTextForBrowser(children$jscomp$5))\n          );\n          var JSCompiler_inline_result$jscomp$2 = null;\n        } else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;\n        return JSCompiler_inline_result$jscomp$2;\n      case \"title\":\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)\n          var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(\n            target$jscomp$0,\n            props\n          );\n        else\n          isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);\n        return JSCompiler_inline_result$jscomp$3;\n      case \"link\":\n        var rel = props.rel, href = props.href, precedence = props.precedence;\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || \"string\" !== typeof rel || \"string\" !== typeof href || \"\" === href) {\n          pushLinkImpl(target$jscomp$0, props);\n          var JSCompiler_inline_result$jscomp$4 = null;\n        } else if (\"stylesheet\" === props.rel)\n          if (\"string\" !== typeof precedence || null != props.disabled || props.onLoad || props.onError)\n            JSCompiler_inline_result$jscomp$4 = pushLinkImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;\n            if (null !== resourceState) {\n              resumableState.styleResources[href] = null;\n              styleQueue || (styleQueue = {\n                precedence: stringToChunk(escapeTextForBrowser(precedence)),\n                rules: [],\n                hrefs: [],\n                sheets: /* @__PURE__ */ new Map()\n              }, renderState.styles.set(precedence, styleQueue));\n              var resource = {\n                state: 0,\n                props: assign({}, props, {\n                  \"data-precedence\": props.precedence,\n                  precedence: null\n                })\n              };\n              if (resourceState) {\n                2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);\n                var preloadResource = renderState.preloads.stylesheets.get(href);\n                preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;\n              }\n              styleQueue.sheets.set(href, resource);\n              hoistableState && hoistableState.stylesheets.add(resource);\n            } else if (styleQueue) {\n              var resource$9 = styleQueue.sheets.get(href);\n              resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);\n            }\n            textEmbedded && target$jscomp$0.push(textSeparator);\n            JSCompiler_inline_result$jscomp$4 = null;\n          }\n        else\n          props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(\n            target$jscomp$0,\n            props\n          ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$4 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));\n        return JSCompiler_inline_result$jscomp$4;\n      case \"script\":\n        var asyncProp = props.async;\n        if (\"string\" !== typeof props.src || !props.src || !asyncProp || \"function\" === typeof asyncProp || \"symbol\" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)\n          var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(\n            target$jscomp$0,\n            props\n          );\n        else {\n          var key = props.src;\n          if (\"module\" === props.type) {\n            var resources = resumableState.moduleScriptResources;\n            var preloads = renderState.preloads.moduleScripts;\n          } else\n            resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;\n          var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;\n          if (null !== resourceState$jscomp$0) {\n            resources[key] = null;\n            var scriptProps = props;\n            if (resourceState$jscomp$0) {\n              2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n              var preloadResource$jscomp$0 = preloads.get(key);\n              preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);\n            }\n            var resource$jscomp$0 = [];\n            renderState.scripts.add(resource$jscomp$0);\n            pushScriptImpl(resource$jscomp$0, scriptProps);\n          }\n          textEmbedded && target$jscomp$0.push(textSeparator);\n          JSCompiler_inline_result$jscomp$5 = null;\n        }\n        return JSCompiler_inline_result$jscomp$5;\n      case \"style\":\n        var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || \"string\" !== typeof precedence$jscomp$0 || \"string\" !== typeof href$jscomp$0 || \"\" === href$jscomp$0) {\n          target$jscomp$0.push(startChunkForTag(\"style\"));\n          var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;\n          for (propKey$jscomp$8 in props)\n            if (hasOwnProperty2.call(props, propKey$jscomp$8)) {\n              var propValue$jscomp$8 = props[propKey$jscomp$8];\n              if (null != propValue$jscomp$8)\n                switch (propKey$jscomp$8) {\n                  case \"children\":\n                    children$jscomp$6 = propValue$jscomp$8;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$5 = propValue$jscomp$8;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$8,\n                      propValue$jscomp$8\n                    );\n                }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;\n          \"function\" !== typeof child && \"symbol\" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(\n            stringToChunk((\"\" + child).replace(styleRegex, styleReplacer))\n          );\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);\n          target$jscomp$0.push(endChunkForTag(\"style\"));\n          var JSCompiler_inline_result$jscomp$6 = null;\n        } else {\n          var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);\n          if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {\n            resumableState.styleResources[href$jscomp$0] = null;\n            styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(\n              stringToChunk(escapeTextForBrowser(href$jscomp$0))\n            ) : (styleQueue$jscomp$0 = {\n              precedence: stringToChunk(\n                escapeTextForBrowser(precedence$jscomp$0)\n              ),\n              rules: [],\n              hrefs: [stringToChunk(escapeTextForBrowser(href$jscomp$0))],\n              sheets: /* @__PURE__ */ new Map()\n            }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));\n            var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;\n            for (propKey$jscomp$9 in props)\n              if (hasOwnProperty2.call(props, propKey$jscomp$9)) {\n                var propValue$jscomp$9 = props[propKey$jscomp$9];\n                if (null != propValue$jscomp$9)\n                  switch (propKey$jscomp$9) {\n                    case \"children\":\n                      children$jscomp$7 = propValue$jscomp$9;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$6 = propValue$jscomp$9;\n                  }\n              }\n            var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;\n            \"function\" !== typeof child$jscomp$0 && \"symbol\" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(\n              stringToChunk(\n                (\"\" + child$jscomp$0).replace(styleRegex, styleReplacer)\n              )\n            );\n            pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);\n          }\n          styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);\n          textEmbedded && target$jscomp$0.push(textSeparator);\n          JSCompiler_inline_result$jscomp$6 = void 0;\n        }\n        return JSCompiler_inline_result$jscomp$6;\n      case \"meta\":\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)\n          var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(\n            target$jscomp$0,\n            props,\n            \"meta\"\n          );\n        else\n          textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$7 = isFallback ? null : \"string\" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, \"meta\") : \"viewport\" === props.name ? pushSelfClosing(renderState.viewportChunks, props, \"meta\") : pushSelfClosing(renderState.hoistableChunks, props, \"meta\");\n        return JSCompiler_inline_result$jscomp$7;\n      case \"listing\":\n      case \"pre\":\n        target$jscomp$0.push(startChunkForTag(type2));\n        var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;\n        for (propKey$jscomp$10 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$10)) {\n            var propValue$jscomp$10 = props[propKey$jscomp$10];\n            if (null != propValue$jscomp$10)\n              switch (propKey$jscomp$10) {\n                case \"children\":\n                  children$jscomp$8 = propValue$jscomp$10;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$7 = propValue$jscomp$10;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$10,\n                    propValue$jscomp$10\n                  );\n              }\n          }\n        target$jscomp$0.push(endOfStartTag);\n        if (null != innerHTML$jscomp$7) {\n          if (null != children$jscomp$8)\n            throw Error(\n              \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\"\n            );\n          if (\"object\" !== typeof innerHTML$jscomp$7 || !(\"__html\" in innerHTML$jscomp$7))\n            throw Error(\n              \"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.\"\n            );\n          var html2 = innerHTML$jscomp$7.__html;\n          null !== html2 && void 0 !== html2 && (\"string\" === typeof html2 && 0 < html2.length && \"\\n\" === html2[0] ? target$jscomp$0.push(leadingNewline, stringToChunk(html2)) : target$jscomp$0.push(stringToChunk(\"\" + html2)));\n        }\n        \"string\" === typeof children$jscomp$8 && \"\\n\" === children$jscomp$8[0] && target$jscomp$0.push(leadingNewline);\n        return children$jscomp$8;\n      case \"img\":\n        var src = props.src, srcSet = props.srcSet;\n        if (!(\"lazy\" === props.loading || !src && !srcSet || \"string\" !== typeof src && null != src || \"string\" !== typeof srcSet && null != srcSet) && \"low\" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && (\"string\" !== typeof src || \":\" !== src[4] || \"d\" !== src[0] && \"D\" !== src[0] || \"a\" !== src[1] && \"A\" !== src[1] || \"t\" !== src[2] && \"T\" !== src[2] || \"a\" !== src[3] && \"A\" !== src[3]) && (\"string\" !== typeof srcSet || \":\" !== srcSet[4] || \"d\" !== srcSet[0] && \"D\" !== srcSet[0] || \"a\" !== srcSet[1] && \"A\" !== srcSet[1] || \"t\" !== srcSet[2] && \"T\" !== srcSet[2] || \"a\" !== srcSet[3] && \"A\" !== srcSet[3])) {\n          var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n          if (resource$jscomp$1) {\n            if (\"high\" === props.fetchPriority || 10 > renderState.highImagePreloads.size)\n              promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);\n          } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {\n            resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n            var input2 = props.crossOrigin;\n            var JSCompiler_inline_result$jscomp$8 = \"string\" === typeof input2 ? \"use-credentials\" === input2 ? input2 : \"\" : void 0;\n            var headers = renderState.headers, header;\n            headers && 0 < headers.remainingCapacity && \"string\" !== typeof props.srcSet && (\"high\" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, \"image\", {\n              imageSrcSet: props.srcSet,\n              imageSizes: props.sizes,\n              crossOrigin: JSCompiler_inline_result$jscomp$8,\n              integrity: props.integrity,\n              nonce: props.nonce,\n              type: props.type,\n              fetchPriority: props.fetchPriority,\n              referrerPolicy: props.refererPolicy\n            }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += \", \"), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {\n              rel: \"preload\",\n              as: \"image\",\n              href: srcSet ? void 0 : src,\n              imageSrcSet: srcSet,\n              imageSizes: sizes,\n              crossOrigin: JSCompiler_inline_result$jscomp$8,\n              integrity: props.integrity,\n              type: props.type,\n              fetchPriority: props.fetchPriority,\n              referrerPolicy: props.referrerPolicy\n            }), \"high\" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n          }\n        }\n        return pushSelfClosing(target$jscomp$0, props, \"img\");\n      case \"base\":\n      case \"area\":\n      case \"br\":\n      case \"col\":\n      case \"embed\":\n      case \"hr\":\n      case \"keygen\":\n      case \"param\":\n      case \"source\":\n      case \"track\":\n      case \"wbr\":\n        return pushSelfClosing(target$jscomp$0, props, type2);\n      case \"annotation-xml\":\n      case \"color-profile\":\n      case \"font-face\":\n      case \"font-face-src\":\n      case \"font-face-uri\":\n      case \"font-face-format\":\n      case \"font-face-name\":\n      case \"missing-glyph\":\n        break;\n      case \"head\":\n        if (2 > formatContext.insertionMode) {\n          var preamble = preambleState || renderState.preamble;\n          if (preamble.headChunks)\n            throw Error(\"The `<head>` tag may only be rendered once.\");\n          preamble.headChunks = [];\n          var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n            preamble.headChunks,\n            props,\n            \"head\"\n          );\n        } else\n          JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n            target$jscomp$0,\n            props,\n            \"head\"\n          );\n        return JSCompiler_inline_result$jscomp$9;\n      case \"body\":\n        if (2 > formatContext.insertionMode) {\n          var preamble$jscomp$0 = preambleState || renderState.preamble;\n          if (preamble$jscomp$0.bodyChunks)\n            throw Error(\"The `<body>` tag may only be rendered once.\");\n          preamble$jscomp$0.bodyChunks = [];\n          var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n            preamble$jscomp$0.bodyChunks,\n            props,\n            \"body\"\n          );\n        } else\n          JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n            target$jscomp$0,\n            props,\n            \"body\"\n          );\n        return JSCompiler_inline_result$jscomp$10;\n      case \"html\":\n        if (0 === formatContext.insertionMode) {\n          var preamble$jscomp$1 = preambleState || renderState.preamble;\n          if (preamble$jscomp$1.htmlChunks)\n            throw Error(\"The `<html>` tag may only be rendered once.\");\n          preamble$jscomp$1.htmlChunks = [doctypeChunk];\n          var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n            preamble$jscomp$1.htmlChunks,\n            props,\n            \"html\"\n          );\n        } else\n          JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n            target$jscomp$0,\n            props,\n            \"html\"\n          );\n        return JSCompiler_inline_result$jscomp$11;\n      default:\n        if (-1 !== type2.indexOf(\"-\")) {\n          target$jscomp$0.push(startChunkForTag(type2));\n          var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;\n          for (propKey$jscomp$11 in props)\n            if (hasOwnProperty2.call(props, propKey$jscomp$11)) {\n              var propValue$jscomp$11 = props[propKey$jscomp$11];\n              if (null != propValue$jscomp$11) {\n                var attributeName = propKey$jscomp$11;\n                switch (propKey$jscomp$11) {\n                  case \"children\":\n                    children$jscomp$9 = propValue$jscomp$11;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$8 = propValue$jscomp$11;\n                    break;\n                  case \"style\":\n                    pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                    break;\n                  case \"suppressContentEditableWarning\":\n                  case \"suppressHydrationWarning\":\n                  case \"ref\":\n                    break;\n                  case \"className\":\n                    attributeName = \"class\";\n                  default:\n                    if (isAttributeNameSafe(propKey$jscomp$11) && \"function\" !== typeof propValue$jscomp$11 && \"symbol\" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {\n                      if (true === propValue$jscomp$11) propValue$jscomp$11 = \"\";\n                      else if (\"object\" === typeof propValue$jscomp$11) continue;\n                      target$jscomp$0.push(\n                        attributeSeparator,\n                        stringToChunk(attributeName),\n                        attributeAssign,\n                        stringToChunk(escapeTextForBrowser(propValue$jscomp$11)),\n                        attributeEnd\n                      );\n                    }\n                }\n              }\n            }\n          target$jscomp$0.push(endOfStartTag);\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);\n          return children$jscomp$9;\n        }\n    }\n    return pushStartGenericElement(target$jscomp$0, props, type2);\n  }\n  __name(pushStartInstance, \"pushStartInstance\");\n  var endTagCache = /* @__PURE__ */ new Map();\n  function endChunkForTag(tag) {\n    var chunk = endTagCache.get(tag);\n    void 0 === chunk && (chunk = stringToPrecomputedChunk(\"</\" + tag + \">\"), endTagCache.set(tag, chunk));\n    return chunk;\n  }\n  __name(endChunkForTag, \"endChunkForTag\");\n  function hoistPreambleState(renderState, preambleState) {\n    renderState = renderState.preamble;\n    null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);\n    null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);\n    null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);\n  }\n  __name(hoistPreambleState, \"hoistPreambleState\");\n  function writeBootstrap(destination, renderState) {\n    renderState = renderState.bootstrapChunks;\n    for (var i = 0; i < renderState.length - 1; i++)\n      writeChunk(destination, renderState[i]);\n    return i < renderState.length ? (i = renderState[i], renderState.length = 0, writeChunkAndReturn(destination, i)) : true;\n  }\n  __name(writeBootstrap, \"writeBootstrap\");\n  var placeholder1 = stringToPrecomputedChunk('<template id=\"'), placeholder2 = stringToPrecomputedChunk('\"></template>'), startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk(\n    '<!--$?--><template id=\"'\n  ), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\"), endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n  stringToPrecomputedChunk(' data-msg=\"');\n  stringToPrecomputedChunk(' data-stck=\"');\n  stringToPrecomputedChunk(' data-cstck=\"');\n  var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n  function writeStartPendingSuspenseBoundary(destination, renderState, id2) {\n    writeChunk(destination, startPendingSuspenseBoundary1);\n    if (null === id2)\n      throw Error(\n        \"An ID must have been assigned before we can complete the boundary.\"\n      );\n    writeChunk(destination, renderState.boundaryPrefix);\n    writeChunk(destination, stringToChunk(id2.toString(16)));\n    return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n  }\n  __name(writeStartPendingSuspenseBoundary, \"writeStartPendingSuspenseBoundary\");\n  var boundaryPreambleContributionChunkStart = stringToPrecomputedChunk(\"<!--\"), boundaryPreambleContributionChunkEnd = stringToPrecomputedChunk(\"-->\");\n  function writePreambleContribution(destination, preambleState) {\n    preambleState = preambleState.contribution;\n    0 !== preambleState && (writeChunk(destination, boundaryPreambleContributionChunkStart), writeChunk(destination, stringToChunk(\"\" + preambleState)), writeChunk(destination, boundaryPreambleContributionChunkEnd));\n  }\n  __name(writePreambleContribution, \"writePreambleContribution\");\n  var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"'), startSegmentHTML2 = stringToPrecomputedChunk('\">'), endSegmentHTML = stringToPrecomputedChunk(\"</div>\"), startSegmentSVG = stringToPrecomputedChunk(\n    '<svg aria-hidden=\"true\" style=\"display:none\" id=\"'\n  ), startSegmentSVG2 = stringToPrecomputedChunk('\">'), endSegmentSVG = stringToPrecomputedChunk(\"</svg>\"), startSegmentMathML = stringToPrecomputedChunk(\n    '<math aria-hidden=\"true\" style=\"display:none\" id=\"'\n  ), startSegmentMathML2 = stringToPrecomputedChunk('\">'), endSegmentMathML = stringToPrecomputedChunk(\"</math>\"), startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"'), startSegmentTable2 = stringToPrecomputedChunk('\">'), endSegmentTable = stringToPrecomputedChunk(\"</table>\"), startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"'), startSegmentTableBody2 = stringToPrecomputedChunk('\">'), endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"'), startSegmentTableRow2 = stringToPrecomputedChunk('\">'), endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\"), startSegmentColGroup = stringToPrecomputedChunk(\n    '<table hidden><colgroup id=\"'\n  ), startSegmentColGroup2 = stringToPrecomputedChunk('\">'), endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n  function writeStartSegment(destination, renderState, formatContext, id2) {\n    switch (formatContext.insertionMode) {\n      case 0:\n      case 1:\n      case 3:\n      case 2:\n        return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentHTML2);\n      case 4:\n        return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentSVG2);\n      case 5:\n        return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentMathML2);\n      case 6:\n        return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentTable2);\n      case 7:\n        return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentTableBody2);\n      case 8:\n        return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentTableRow2);\n      case 9:\n        return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id2.toString(16))), writeChunkAndReturn(destination, startSegmentColGroup2);\n      default:\n        throw Error(\"Unknown insertion mode. This is a bug in React.\");\n    }\n  }\n  __name(writeStartSegment, \"writeStartSegment\");\n  function writeEndSegment(destination, formatContext) {\n    switch (formatContext.insertionMode) {\n      case 0:\n      case 1:\n      case 3:\n      case 2:\n        return writeChunkAndReturn(destination, endSegmentHTML);\n      case 4:\n        return writeChunkAndReturn(destination, endSegmentSVG);\n      case 5:\n        return writeChunkAndReturn(destination, endSegmentMathML);\n      case 6:\n        return writeChunkAndReturn(destination, endSegmentTable);\n      case 7:\n        return writeChunkAndReturn(destination, endSegmentTableBody);\n      case 8:\n        return writeChunkAndReturn(destination, endSegmentTableRow);\n      case 9:\n        return writeChunkAndReturn(destination, endSegmentColGroup);\n      default:\n        throw Error(\"Unknown insertion mode. This is a bug in React.\");\n    }\n  }\n  __name(writeEndSegment, \"writeEndSegment\");\n  var completeSegmentScript1Full = stringToPrecomputedChunk(\n    '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"'\n  ), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"'), completeSegmentScript2 = stringToPrecomputedChunk('\",\"'), completeSegmentScriptEnd = stringToPrecomputedChunk('\")</script>');\n  stringToPrecomputedChunk('<template data-rsi=\"\" data-sid=\"');\n  stringToPrecomputedChunk('\" data-pid=\"');\n  var completeBoundaryScript1Full = stringToPrecomputedChunk(\n    '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"'\n  ), completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"'), completeBoundaryWithStylesScript1FullBoth = stringToPrecomputedChunk(\n    '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n  ), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(\n    '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n  ), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR(\"'), completeBoundaryScript2 = stringToPrecomputedChunk('\",\"'), completeBoundaryScript3a = stringToPrecomputedChunk('\",'), completeBoundaryScript3b = stringToPrecomputedChunk('\"'), completeBoundaryScriptEnd = stringToPrecomputedChunk(\")</script>\");\n  stringToPrecomputedChunk('<template data-rci=\"\" data-bid=\"');\n  stringToPrecomputedChunk('<template data-rri=\"\" data-bid=\"');\n  stringToPrecomputedChunk('\" data-sid=\"');\n  stringToPrecomputedChunk('\" data-sty=\"');\n  var clientRenderScript1Full = stringToPrecomputedChunk(\n    '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"'\n  ), clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"'), clientRenderScript1A = stringToPrecomputedChunk('\"'), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\"), clientRenderScriptEnd = stringToPrecomputedChunk(\")</script>\");\n  stringToPrecomputedChunk('<template data-rxi=\"\" data-bid=\"');\n  stringToPrecomputedChunk('\" data-dgst=\"');\n  stringToPrecomputedChunk('\" data-msg=\"');\n  stringToPrecomputedChunk('\" data-stck=\"');\n  stringToPrecomputedChunk('\" data-cstck=\"');\n  var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n  function escapeJSStringsForInstructionScripts(input2) {\n    return JSON.stringify(input2).replace(\n      regexForJSStringsInInstructionScripts,\n      function(match) {\n        switch (match) {\n          case \"<\":\n            return \"\\\\u003c\";\n          case \"\\u2028\":\n            return \"\\\\u2028\";\n          case \"\\u2029\":\n            return \"\\\\u2029\";\n          default:\n            throw Error(\n              \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n            );\n        }\n      }\n    );\n  }\n  __name(escapeJSStringsForInstructionScripts, \"escapeJSStringsForInstructionScripts\");\n  var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n  function escapeJSObjectForInstructionScripts(input2) {\n    return JSON.stringify(input2).replace(\n      regexForJSStringsInScripts,\n      function(match) {\n        switch (match) {\n          case \"&\":\n            return \"\\\\u0026\";\n          case \">\":\n            return \"\\\\u003e\";\n          case \"<\":\n            return \"\\\\u003c\";\n          case \"\\u2028\":\n            return \"\\\\u2028\";\n          case \"\\u2029\":\n            return \"\\\\u2029\";\n          default:\n            throw Error(\n              \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n            );\n        }\n      }\n    );\n  }\n  __name(escapeJSObjectForInstructionScripts, \"escapeJSObjectForInstructionScripts\");\n  var lateStyleTagResourceOpen1 = stringToPrecomputedChunk(\n    '<style media=\"not all\" data-precedence=\"'\n  ), lateStyleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'), lateStyleTagResourceOpen3 = stringToPrecomputedChunk('\">'), lateStyleTagTemplateClose = stringToPrecomputedChunk(\"</style>\"), currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true;\n  function flushStyleTagsLateForBoundary(styleQueue) {\n    var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i = 0;\n    if (hrefs.length) {\n      writeChunk(this, lateStyleTagResourceOpen1);\n      writeChunk(this, styleQueue.precedence);\n      for (writeChunk(this, lateStyleTagResourceOpen2); i < hrefs.length - 1; i++)\n        writeChunk(this, hrefs[i]), writeChunk(this, spaceSeparator);\n      writeChunk(this, hrefs[i]);\n      writeChunk(this, lateStyleTagResourceOpen3);\n      for (i = 0; i < rules.length; i++) writeChunk(this, rules[i]);\n      destinationHasCapacity = writeChunkAndReturn(\n        this,\n        lateStyleTagTemplateClose\n      );\n      currentlyRenderingBoundaryHasStylesToHoist = true;\n      rules.length = 0;\n      hrefs.length = 0;\n    }\n  }\n  __name(flushStyleTagsLateForBoundary, \"flushStyleTagsLateForBoundary\");\n  function hasStylesToHoist(stylesheet) {\n    return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = true : false;\n  }\n  __name(hasStylesToHoist, \"hasStylesToHoist\");\n  function writeHoistablesForBoundary(destination, hoistableState, renderState) {\n    currentlyRenderingBoundaryHasStylesToHoist = false;\n    destinationHasCapacity = true;\n    hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n    hoistableState.stylesheets.forEach(hasStylesToHoist);\n    currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);\n    return destinationHasCapacity;\n  }\n  __name(writeHoistablesForBoundary, \"writeHoistablesForBoundary\");\n  function flushResource(resource) {\n    for (var i = 0; i < resource.length; i++) writeChunk(this, resource[i]);\n    resource.length = 0;\n  }\n  __name(flushResource, \"flushResource\");\n  var stylesheetFlushingQueue = [];\n  function flushStyleInPreamble(stylesheet) {\n    pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n    for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n      writeChunk(this, stylesheetFlushingQueue[i]);\n    stylesheetFlushingQueue.length = 0;\n    stylesheet.state = 2;\n  }\n  __name(flushStyleInPreamble, \"flushStyleInPreamble\");\n  var styleTagResourceOpen1 = stringToPrecomputedChunk(\n    '<style data-precedence=\"'\n  ), styleTagResourceOpen2 = stringToPrecomputedChunk('\" data-href=\"'), spaceSeparator = stringToPrecomputedChunk(\" \"), styleTagResourceOpen3 = stringToPrecomputedChunk('\">'), styleTagResourceClose = stringToPrecomputedChunk(\"</style>\");\n  function flushStylesInPreamble(styleQueue) {\n    var hasStylesheets = 0 < styleQueue.sheets.size;\n    styleQueue.sheets.forEach(flushStyleInPreamble, this);\n    styleQueue.sheets.clear();\n    var rules = styleQueue.rules, hrefs = styleQueue.hrefs;\n    if (!hasStylesheets || hrefs.length) {\n      writeChunk(this, styleTagResourceOpen1);\n      writeChunk(this, styleQueue.precedence);\n      styleQueue = 0;\n      if (hrefs.length) {\n        for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)\n          writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);\n        writeChunk(this, hrefs[styleQueue]);\n      }\n      writeChunk(this, styleTagResourceOpen3);\n      for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n        writeChunk(this, rules[styleQueue]);\n      writeChunk(this, styleTagResourceClose);\n      rules.length = 0;\n      hrefs.length = 0;\n    }\n  }\n  __name(flushStylesInPreamble, \"flushStylesInPreamble\");\n  function preloadLateStyle(stylesheet) {\n    if (0 === stylesheet.state) {\n      stylesheet.state = 1;\n      var props = stylesheet.props;\n      pushLinkImpl(stylesheetFlushingQueue, {\n        rel: \"preload\",\n        as: \"style\",\n        href: stylesheet.props.href,\n        crossOrigin: props.crossOrigin,\n        fetchPriority: props.fetchPriority,\n        integrity: props.integrity,\n        media: props.media,\n        hrefLang: props.hrefLang,\n        referrerPolicy: props.referrerPolicy\n      });\n      for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)\n        writeChunk(this, stylesheetFlushingQueue[stylesheet]);\n      stylesheetFlushingQueue.length = 0;\n    }\n  }\n  __name(preloadLateStyle, \"preloadLateStyle\");\n  function preloadLateStyles(styleQueue) {\n    styleQueue.sheets.forEach(preloadLateStyle, this);\n    styleQueue.sheets.clear();\n  }\n  __name(preloadLateStyles, \"preloadLateStyles\");\n  var arrayFirstOpenBracket = stringToPrecomputedChunk(\"[\"), arraySubsequentOpenBracket = stringToPrecomputedChunk(\",[\"), arrayInterstitial = stringToPrecomputedChunk(\",\"), arrayCloseBracket = stringToPrecomputedChunk(\"]\");\n  function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n    writeChunk(destination, arrayFirstOpenBracket);\n    var nextArrayOpenBrackChunk = arrayFirstOpenBracket;\n    hoistableState.stylesheets.forEach(function(resource) {\n      if (2 !== resource.state)\n        if (3 === resource.state)\n          writeChunk(destination, nextArrayOpenBrackChunk), writeChunk(\n            destination,\n            stringToChunk(\n              escapeJSObjectForInstructionScripts(\"\" + resource.props.href)\n            )\n          ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n        else {\n          writeChunk(destination, nextArrayOpenBrackChunk);\n          var precedence = resource.props[\"data-precedence\"], props = resource.props, coercedHref = sanitizeURL(\"\" + resource.props.href);\n          writeChunk(\n            destination,\n            stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))\n          );\n          precedence = \"\" + precedence;\n          writeChunk(destination, arrayInterstitial);\n          writeChunk(\n            destination,\n            stringToChunk(escapeJSObjectForInstructionScripts(precedence))\n          );\n          for (var propKey in props)\n            if (hasOwnProperty2.call(props, propKey) && (precedence = props[propKey], null != precedence))\n              switch (propKey) {\n                case \"href\":\n                case \"rel\":\n                case \"precedence\":\n                case \"data-precedence\":\n                  break;\n                case \"children\":\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(\n                    \"link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\"\n                  );\n                default:\n                  writeStyleResourceAttributeInJS(\n                    destination,\n                    propKey,\n                    precedence\n                  );\n              }\n          writeChunk(destination, arrayCloseBracket);\n          nextArrayOpenBrackChunk = arraySubsequentOpenBracket;\n          resource.state = 3;\n        }\n    });\n    writeChunk(destination, arrayCloseBracket);\n  }\n  __name(writeStyleResourceDependenciesInJS, \"writeStyleResourceDependenciesInJS\");\n  function writeStyleResourceAttributeInJS(destination, name, value2) {\n    var attributeName = name.toLowerCase();\n    switch (typeof value2) {\n      case \"function\":\n      case \"symbol\":\n        return;\n    }\n    switch (name) {\n      case \"innerHTML\":\n      case \"dangerouslySetInnerHTML\":\n      case \"suppressContentEditableWarning\":\n      case \"suppressHydrationWarning\":\n      case \"style\":\n      case \"ref\":\n        return;\n      case \"className\":\n        attributeName = \"class\";\n        name = \"\" + value2;\n        break;\n      case \"hidden\":\n        if (false === value2) return;\n        name = \"\";\n        break;\n      case \"src\":\n      case \"href\":\n        value2 = sanitizeURL(value2);\n        name = \"\" + value2;\n        break;\n      default:\n        if (2 < name.length && (\"o\" === name[0] || \"O\" === name[0]) && (\"n\" === name[1] || \"N\" === name[1]) || !isAttributeNameSafe(name))\n          return;\n        name = \"\" + value2;\n    }\n    writeChunk(destination, arrayInterstitial);\n    writeChunk(\n      destination,\n      stringToChunk(escapeJSObjectForInstructionScripts(attributeName))\n    );\n    writeChunk(destination, arrayInterstitial);\n    writeChunk(\n      destination,\n      stringToChunk(escapeJSObjectForInstructionScripts(name))\n    );\n  }\n  __name(writeStyleResourceAttributeInJS, \"writeStyleResourceAttributeInJS\");\n  function createHoistableState() {\n    return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };\n  }\n  __name(createHoistableState, \"createHoistableState\");\n  function prefetchDNS(href) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (\"string\" === typeof href && href) {\n        if (!resumableState.dnsResources.hasOwnProperty(href)) {\n          resumableState.dnsResources[href] = null;\n          resumableState = renderState.headers;\n          var header, JSCompiler_temp;\n          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)\n            JSCompiler_temp = (header = \"<\" + (\"\" + href).replace(\n              regexForHrefInLinkHeaderURLContext,\n              escapeHrefForLinkHeaderURLContextReplacer\n            ) + \">; rel=dns-prefetch\", 0 <= (resumableState.remainingCapacity -= header.length + 2));\n          JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += \", \"), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: \"dns-prefetch\" }), renderState.preconnects.add(header));\n        }\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.D(href);\n  }\n  __name(prefetchDNS, \"prefetchDNS\");\n  function preconnect(href, crossOrigin) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (\"string\" === typeof href && href) {\n        var bucket = \"use-credentials\" === crossOrigin ? \"credentials\" : \"string\" === typeof crossOrigin ? \"anonymous\" : \"default\";\n        if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n          resumableState.connectResources[bucket][href] = null;\n          resumableState = renderState.headers;\n          var header, JSCompiler_temp;\n          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {\n            JSCompiler_temp = \"<\" + (\"\" + href).replace(\n              regexForHrefInLinkHeaderURLContext,\n              escapeHrefForLinkHeaderURLContextReplacer\n            ) + \">; rel=preconnect\";\n            if (\"string\" === typeof crossOrigin) {\n              var escapedCrossOrigin = (\"\" + crossOrigin).replace(\n                regexForLinkHeaderQuotedParamValueContext,\n                escapeStringForLinkHeaderQuotedParamValueContextReplacer\n              );\n              JSCompiler_temp += '; crossorigin=\"' + escapedCrossOrigin + '\"';\n            }\n            JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));\n          }\n          JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += \", \"), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {\n            rel: \"preconnect\",\n            href,\n            crossOrigin\n          }), renderState.preconnects.add(bucket));\n        }\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.C(href, crossOrigin);\n  }\n  __name(preconnect, \"preconnect\");\n  function preload(href, as2, options) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (as2 && href) {\n        switch (as2) {\n          case \"image\":\n            if (options) {\n              var imageSrcSet = options.imageSrcSet;\n              var imageSizes = options.imageSizes;\n              var fetchPriority = options.fetchPriority;\n            }\n            var key = imageSrcSet ? imageSrcSet + \"\\n\" + (imageSizes || \"\") : href;\n            if (resumableState.imageResources.hasOwnProperty(key)) return;\n            resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n            resumableState = renderState.headers;\n            var header;\n            resumableState && 0 < resumableState.remainingCapacity && \"string\" !== typeof imageSrcSet && \"high\" === fetchPriority && (header = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += \", \"), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(\n              resumableState,\n              assign(\n                { rel: \"preload\", href: imageSrcSet ? void 0 : href, as: as2 },\n                options\n              )\n            ), \"high\" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));\n            break;\n          case \"style\":\n            if (resumableState.styleResources.hasOwnProperty(href)) return;\n            imageSrcSet = [];\n            pushLinkImpl(\n              imageSrcSet,\n              assign({ rel: \"preload\", href, as: as2 }, options)\n            );\n            resumableState.styleResources[href] = !options || \"string\" !== typeof options.crossOrigin && \"string\" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];\n            renderState.preloads.stylesheets.set(href, imageSrcSet);\n            renderState.bulkPreloads.add(imageSrcSet);\n            break;\n          case \"script\":\n            if (resumableState.scriptResources.hasOwnProperty(href)) return;\n            imageSrcSet = [];\n            renderState.preloads.scripts.set(href, imageSrcSet);\n            renderState.bulkPreloads.add(imageSrcSet);\n            pushLinkImpl(\n              imageSrcSet,\n              assign({ rel: \"preload\", href, as: as2 }, options)\n            );\n            resumableState.scriptResources[href] = !options || \"string\" !== typeof options.crossOrigin && \"string\" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];\n            break;\n          default:\n            if (resumableState.unknownResources.hasOwnProperty(as2)) {\n              if (imageSrcSet = resumableState.unknownResources[as2], imageSrcSet.hasOwnProperty(href))\n                return;\n            } else\n              imageSrcSet = {}, resumableState.unknownResources[as2] = imageSrcSet;\n            imageSrcSet[href] = PRELOAD_NO_CREDS;\n            if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && \"font\" === as2 && (key = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))\n              renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += \", \"), resumableState.fontPreloads += key;\n            else\n              switch (resumableState = [], href = assign({ rel: \"preload\", href, as: as2 }, options), pushLinkImpl(resumableState, href), as2) {\n                case \"font\":\n                  renderState.fontPreloads.add(resumableState);\n                  break;\n                default:\n                  renderState.bulkPreloads.add(resumableState);\n              }\n        }\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.L(href, as2, options);\n  }\n  __name(preload, \"preload\");\n  function preloadModule(href, options) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (href) {\n        var as2 = options && \"string\" === typeof options.as ? options.as : \"script\";\n        switch (as2) {\n          case \"script\":\n            if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;\n            as2 = [];\n            resumableState.moduleScriptResources[href] = !options || \"string\" !== typeof options.crossOrigin && \"string\" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];\n            renderState.preloads.moduleScripts.set(href, as2);\n            break;\n          default:\n            if (resumableState.moduleUnknownResources.hasOwnProperty(as2)) {\n              var resources = resumableState.unknownResources[as2];\n              if (resources.hasOwnProperty(href)) return;\n            } else\n              resources = {}, resumableState.moduleUnknownResources[as2] = resources;\n            as2 = [];\n            resources[href] = PRELOAD_NO_CREDS;\n        }\n        pushLinkImpl(as2, assign({ rel: \"modulepreload\", href }, options));\n        renderState.bulkPreloads.add(as2);\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.m(href, options);\n  }\n  __name(preloadModule, \"preloadModule\");\n  function preinitStyle(href, precedence, options) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (href) {\n        precedence = precedence || \"default\";\n        var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;\n        null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {\n          precedence: stringToChunk(escapeTextForBrowser(precedence)),\n          rules: [],\n          hrefs: [],\n          sheets: /* @__PURE__ */ new Map()\n        }, renderState.styles.set(precedence, styleQueue)), precedence = {\n          state: 0,\n          props: assign(\n            { rel: \"stylesheet\", href, \"data-precedence\": precedence },\n            options\n          )\n        }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));\n      }\n    } else previousDispatcher.S(href, precedence, options);\n  }\n  __name(preinitStyle, \"preinitStyle\");\n  function preinitScript(src, options) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (src) {\n        var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;\n        null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));\n      }\n    } else previousDispatcher.X(src, options);\n  }\n  __name(preinitScript, \"preinitScript\");\n  function preinitModuleScript(src, options) {\n    var request = resolveRequest();\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (src) {\n        var resourceState = resumableState.moduleScriptResources.hasOwnProperty(\n          src\n        ) ? resumableState.moduleScriptResources[src] : void 0;\n        null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({ src, type: \"module\", async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));\n      }\n    } else previousDispatcher.M(src, options);\n  }\n  __name(preinitModuleScript, \"preinitModuleScript\");\n  function adoptPreloadCredentials(target, preloadState) {\n    null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n    null == target.integrity && (target.integrity = preloadState[1]);\n  }\n  __name(adoptPreloadCredentials, \"adoptPreloadCredentials\");\n  function getPreloadAsHeader(href, as2, params) {\n    href = (\"\" + href).replace(\n      regexForHrefInLinkHeaderURLContext,\n      escapeHrefForLinkHeaderURLContextReplacer\n    );\n    as2 = (\"\" + as2).replace(\n      regexForLinkHeaderQuotedParamValueContext,\n      escapeStringForLinkHeaderQuotedParamValueContextReplacer\n    );\n    as2 = \"<\" + href + '>; rel=preload; as=\"' + as2 + '\"';\n    for (var paramName in params)\n      hasOwnProperty2.call(params, paramName) && (href = params[paramName], \"string\" === typeof href && (as2 += \"; \" + paramName.toLowerCase() + '=\"' + (\"\" + href).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      ) + '\"'));\n    return as2;\n  }\n  __name(getPreloadAsHeader, \"getPreloadAsHeader\");\n  var regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g;\n  function escapeHrefForLinkHeaderURLContextReplacer(match) {\n    switch (match) {\n      case \"<\":\n        return \"%3C\";\n      case \">\":\n        return \"%3E\";\n      case \"\\n\":\n        return \"%0A\";\n      case \"\\r\":\n        return \"%0D\";\n      default:\n        throw Error(\n          \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n        );\n    }\n  }\n  __name(escapeHrefForLinkHeaderURLContextReplacer, \"escapeHrefForLinkHeaderURLContextReplacer\");\n  var regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g;\n  function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n    switch (match) {\n      case '\"':\n        return \"%22\";\n      case \"'\":\n        return \"%27\";\n      case \";\":\n        return \"%3B\";\n      case \",\":\n        return \"%2C\";\n      case \"\\n\":\n        return \"%0A\";\n      case \"\\r\":\n        return \"%0D\";\n      default:\n        throw Error(\n          \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n        );\n    }\n  }\n  __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, \"escapeStringForLinkHeaderQuotedParamValueContextReplacer\");\n  function hoistStyleQueueDependency(styleQueue) {\n    this.styles.add(styleQueue);\n  }\n  __name(hoistStyleQueueDependency, \"hoistStyleQueueDependency\");\n  function hoistStylesheetDependency(stylesheet) {\n    this.stylesheets.add(stylesheet);\n  }\n  __name(hoistStylesheetDependency, \"hoistStylesheetDependency\");\n  var bind2 = Function.prototype.bind, supportsRequestStorage = \"function\" === typeof AsyncLocalStorage, requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  function getComponentNameFromType(type2) {\n    if (null == type2) return null;\n    if (\"function\" === typeof type2)\n      return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;\n    if (\"string\" === typeof type2) return type2;\n    switch (type2) {\n      case REACT_FRAGMENT_TYPE:\n        return \"Fragment\";\n      case REACT_PROFILER_TYPE:\n        return \"Profiler\";\n      case REACT_STRICT_MODE_TYPE:\n        return \"StrictMode\";\n      case REACT_SUSPENSE_TYPE:\n        return \"Suspense\";\n      case REACT_SUSPENSE_LIST_TYPE:\n        return \"SuspenseList\";\n      case REACT_ACTIVITY_TYPE:\n        return \"Activity\";\n    }\n    if (\"object\" === typeof type2)\n      switch (type2.$$typeof) {\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_CONTEXT_TYPE:\n          return (type2.displayName || \"Context\") + \".Provider\";\n        case REACT_CONSUMER_TYPE:\n          return (type2._context.displayName || \"Context\") + \".Consumer\";\n        case REACT_FORWARD_REF_TYPE:\n          var innerType = type2.render;\n          type2 = type2.displayName;\n          type2 || (type2 = innerType.displayName || innerType.name || \"\", type2 = \"\" !== type2 ? \"ForwardRef(\" + type2 + \")\" : \"ForwardRef\");\n          return type2;\n        case REACT_MEMO_TYPE:\n          return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || \"Memo\";\n        case REACT_LAZY_TYPE:\n          innerType = type2._payload;\n          type2 = type2._init;\n          try {\n            return getComponentNameFromType(type2(innerType));\n          } catch (x) {\n          }\n      }\n    return null;\n  }\n  __name(getComponentNameFromType, \"getComponentNameFromType\");\n  var emptyContextObject = {}, currentActiveSnapshot = null;\n  function popToNearestCommonAncestor(prev, next) {\n    if (prev !== next) {\n      prev.context._currentValue = prev.parentValue;\n      prev = prev.parent;\n      var parentNext = next.parent;\n      if (null === prev) {\n        if (null !== parentNext)\n          throw Error(\n            \"The stacks must reach the root at the same time. This is a bug in React.\"\n          );\n      } else {\n        if (null === parentNext)\n          throw Error(\n            \"The stacks must reach the root at the same time. This is a bug in React.\"\n          );\n        popToNearestCommonAncestor(prev, parentNext);\n      }\n      next.context._currentValue = next.value;\n    }\n  }\n  __name(popToNearestCommonAncestor, \"popToNearestCommonAncestor\");\n  function popAllPrevious(prev) {\n    prev.context._currentValue = prev.parentValue;\n    prev = prev.parent;\n    null !== prev && popAllPrevious(prev);\n  }\n  __name(popAllPrevious, \"popAllPrevious\");\n  function pushAllNext(next) {\n    var parentNext = next.parent;\n    null !== parentNext && pushAllNext(parentNext);\n    next.context._currentValue = next.value;\n  }\n  __name(pushAllNext, \"pushAllNext\");\n  function popPreviousToCommonLevel(prev, next) {\n    prev.context._currentValue = prev.parentValue;\n    prev = prev.parent;\n    if (null === prev)\n      throw Error(\n        \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n      );\n    prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);\n  }\n  __name(popPreviousToCommonLevel, \"popPreviousToCommonLevel\");\n  function popNextToCommonLevel(prev, next) {\n    var parentNext = next.parent;\n    if (null === parentNext)\n      throw Error(\n        \"The depth must equal at least at zero before reaching the root. This is a bug in React.\"\n      );\n    prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);\n    next.context._currentValue = next.value;\n  }\n  __name(popNextToCommonLevel, \"popNextToCommonLevel\");\n  function switchContext(newSnapshot) {\n    var prev = currentActiveSnapshot;\n    prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);\n  }\n  __name(switchContext, \"switchContext\");\n  var classComponentUpdater = {\n    enqueueSetState: /* @__PURE__ */ __name(function(inst, payload) {\n      inst = inst._reactInternals;\n      null !== inst.queue && inst.queue.push(payload);\n    }, \"enqueueSetState\"),\n    enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload) {\n      inst = inst._reactInternals;\n      inst.replace = true;\n      inst.queue = [payload];\n    }, \"enqueueReplaceState\"),\n    enqueueForceUpdate: /* @__PURE__ */ __name(function() {\n    }, \"enqueueForceUpdate\")\n  }, emptyTreeContext = { id: 1, overflow: \"\" };\n  function pushTreeContext(baseContext, totalChildren, index) {\n    var baseIdWithLeadingBit = baseContext.id;\n    baseContext = baseContext.overflow;\n    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n    baseIdWithLeadingBit &= ~(1 << baseLength);\n    index += 1;\n    var length = 32 - clz32(totalChildren) + baseLength;\n    if (30 < length) {\n      var numberOfOverflowBits = baseLength - baseLength % 5;\n      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n      baseIdWithLeadingBit >>= numberOfOverflowBits;\n      baseLength -= numberOfOverflowBits;\n      return {\n        id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,\n        overflow: length + baseContext\n      };\n    }\n    return {\n      id: 1 << length | index << baseLength | baseIdWithLeadingBit,\n      overflow: baseContext\n    };\n  }\n  __name(pushTreeContext, \"pushTreeContext\");\n  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log4 = Math.log, LN2 = Math.LN2;\n  function clz32Fallback(x) {\n    x >>>= 0;\n    return 0 === x ? 32 : 31 - (log4(x) / LN2 | 0) | 0;\n  }\n  __name(clz32Fallback, \"clz32Fallback\");\n  var SuspenseException = Error(\n    \"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"\n  );\n  function noop$2() {\n  }\n  __name(noop$2, \"noop$2\");\n  function trackUsedThenable(thenableState2, thenable, index) {\n    index = thenableState2[index];\n    void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);\n    switch (thenable.status) {\n      case \"fulfilled\":\n        return thenable.value;\n      case \"rejected\":\n        throw thenable.reason;\n      default:\n        \"string\" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = \"pending\", thenableState2.then(\n          function(fulfilledValue) {\n            if (\"pending\" === thenable.status) {\n              var fulfilledThenable = thenable;\n              fulfilledThenable.status = \"fulfilled\";\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          function(error4) {\n            if (\"pending\" === thenable.status) {\n              var rejectedThenable = thenable;\n              rejectedThenable.status = \"rejected\";\n              rejectedThenable.reason = error4;\n            }\n          }\n        ));\n        switch (thenable.status) {\n          case \"fulfilled\":\n            return thenable.value;\n          case \"rejected\":\n            throw thenable.reason;\n        }\n        suspendedThenable = thenable;\n        throw SuspenseException;\n    }\n  }\n  __name(trackUsedThenable, \"trackUsedThenable\");\n  var suspendedThenable = null;\n  function getSuspendedThenable() {\n    if (null === suspendedThenable)\n      throw Error(\n        \"Expected a suspended thenable. This is a bug in React. Please file an issue.\"\n      );\n    var thenable = suspendedThenable;\n    suspendedThenable = null;\n    return thenable;\n  }\n  __name(getSuspendedThenable, \"getSuspendedThenable\");\n  function is2(x, y3) {\n    return x === y3 && (0 !== x || 1 / x === 1 / y3) || x !== x && y3 !== y3;\n  }\n  __name(is2, \"is\");\n  var objectIs = \"function\" === typeof Object.is ? Object.is : is2, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0;\n  function resolveCurrentlyRenderingComponent() {\n    if (null === currentlyRenderingComponent)\n      throw Error(\n        \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\"\n      );\n    return currentlyRenderingComponent;\n  }\n  __name(resolveCurrentlyRenderingComponent, \"resolveCurrentlyRenderingComponent\");\n  function createHook() {\n    if (0 < numberOfReRenders)\n      throw Error(\"Rendered more hooks than during the previous render\");\n    return { memoizedState: null, queue: null, next: null };\n  }\n  __name(createHook, \"createHook\");\n  function createWorkInProgressHook() {\n    null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);\n    return workInProgressHook;\n  }\n  __name(createWorkInProgressHook, \"createWorkInProgressHook\");\n  function getThenableStateAfterSuspending() {\n    var state = thenableState;\n    thenableState = null;\n    return state;\n  }\n  __name(getThenableStateAfterSuspending, \"getThenableStateAfterSuspending\");\n  function resetHooksState() {\n    currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;\n    didScheduleRenderPhaseUpdate = false;\n    firstWorkInProgressHook = null;\n    numberOfReRenders = 0;\n    workInProgressHook = renderPhaseUpdates = null;\n  }\n  __name(resetHooksState, \"resetHooksState\");\n  function basicStateReducer(state, action) {\n    return \"function\" === typeof action ? action(state) : action;\n  }\n  __name(basicStateReducer, \"basicStateReducer\");\n  function useReducer(reducer, initialArg, init2) {\n    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n    workInProgressHook = createWorkInProgressHook();\n    if (isReRender) {\n      var queue = workInProgressHook.queue;\n      initialArg = queue.dispatch;\n      if (null !== renderPhaseUpdates && (init2 = renderPhaseUpdates.get(queue), void 0 !== init2)) {\n        renderPhaseUpdates.delete(queue);\n        queue = workInProgressHook.memoizedState;\n        do\n          queue = reducer(queue, init2.action), init2 = init2.next;\n        while (null !== init2);\n        workInProgressHook.memoizedState = queue;\n        return [queue, initialArg];\n      }\n      return [workInProgressHook.memoizedState, initialArg];\n    }\n    reducer = reducer === basicStateReducer ? \"function\" === typeof initialArg ? initialArg() : initialArg : void 0 !== init2 ? init2(initialArg) : initialArg;\n    workInProgressHook.memoizedState = reducer;\n    reducer = workInProgressHook.queue = { last: null, dispatch: null };\n    reducer = reducer.dispatch = dispatchAction.bind(\n      null,\n      currentlyRenderingComponent,\n      reducer\n    );\n    return [workInProgressHook.memoizedState, reducer];\n  }\n  __name(useReducer, \"useReducer\");\n  function useMemo2(nextCreate, deps) {\n    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n    workInProgressHook = createWorkInProgressHook();\n    deps = void 0 === deps ? null : deps;\n    if (null !== workInProgressHook) {\n      var prevState = workInProgressHook.memoizedState;\n      if (null !== prevState && null !== deps) {\n        var prevDeps = prevState[1];\n        a: if (null === prevDeps) prevDeps = false;\n        else {\n          for (var i = 0; i < prevDeps.length && i < deps.length; i++)\n            if (!objectIs(deps[i], prevDeps[i])) {\n              prevDeps = false;\n              break a;\n            }\n          prevDeps = true;\n        }\n        if (prevDeps) return prevState[0];\n      }\n    }\n    nextCreate = nextCreate();\n    workInProgressHook.memoizedState = [nextCreate, deps];\n    return nextCreate;\n  }\n  __name(useMemo2, \"useMemo\");\n  function dispatchAction(componentIdentity, queue, action) {\n    if (25 <= numberOfReRenders)\n      throw Error(\n        \"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n      );\n    if (componentIdentity === currentlyRenderingComponent)\n      if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)\n        renderPhaseUpdates.set(queue, componentIdentity);\n      else {\n        for (queue = action; null !== queue.next; ) queue = queue.next;\n        queue.next = componentIdentity;\n      }\n  }\n  __name(dispatchAction, \"dispatchAction\");\n  function unsupportedStartTransition() {\n    throw Error(\"startTransition cannot be called during server rendering.\");\n  }\n  __name(unsupportedStartTransition, \"unsupportedStartTransition\");\n  function unsupportedSetOptimisticState() {\n    throw Error(\"Cannot update optimistic state while rendering.\");\n  }\n  __name(unsupportedSetOptimisticState, \"unsupportedSetOptimisticState\");\n  function useActionState(action, initialState, permalink) {\n    resolveCurrentlyRenderingComponent();\n    var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;\n    if (\"function\" === typeof action.$$FORM_ACTION) {\n      var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;\n      request = request.formState;\n      var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n      if (null !== request && \"function\" === typeof isSignatureEqual) {\n        var postbackKey = request[1];\n        isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? \"p\" + permalink : \"k\" + murmurhash3_32_gc(\n          JSON.stringify([componentKeyPath, null, actionStateHookIndex]),\n          0\n        ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));\n      }\n      var boundAction = action.bind(null, initialState);\n      action = /* @__PURE__ */ __name(function(payload) {\n        boundAction(payload);\n      }, \"action\");\n      \"function\" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {\n        prefix2 = boundAction.$$FORM_ACTION(prefix2);\n        void 0 !== permalink && (permalink += \"\", prefix2.action = permalink);\n        var formData = prefix2.data;\n        formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? \"p\" + permalink : \"k\" + murmurhash3_32_gc(\n          JSON.stringify([\n            componentKeyPath,\n            null,\n            actionStateHookIndex\n          ]),\n          0\n        )), formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n        return prefix2;\n      });\n      return [initialState, action, false];\n    }\n    var boundAction$22 = action.bind(null, initialState);\n    return [\n      initialState,\n      function(payload) {\n        boundAction$22(payload);\n      },\n      false\n    ];\n  }\n  __name(useActionState, \"useActionState\");\n  function unwrapThenable(thenable) {\n    var index = thenableIndexCounter;\n    thenableIndexCounter += 1;\n    null === thenableState && (thenableState = []);\n    return trackUsedThenable(thenableState, thenable, index);\n  }\n  __name(unwrapThenable, \"unwrapThenable\");\n  function unsupportedRefresh() {\n    throw Error(\"Cache cannot be refreshed during server rendering.\");\n  }\n  __name(unsupportedRefresh, \"unsupportedRefresh\");\n  function noop$1() {\n  }\n  __name(noop$1, \"noop$1\");\n  var HooksDispatcher = {\n    readContext: /* @__PURE__ */ __name(function(context2) {\n      return context2._currentValue;\n    }, \"readContext\"),\n    use: /* @__PURE__ */ __name(function(usable) {\n      if (null !== usable && \"object\" === typeof usable) {\n        if (\"function\" === typeof usable.then) return unwrapThenable(usable);\n        if (usable.$$typeof === REACT_CONTEXT_TYPE) return usable._currentValue;\n      }\n      throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }, \"use\"),\n    useContext: /* @__PURE__ */ __name(function(context2) {\n      resolveCurrentlyRenderingComponent();\n      return context2._currentValue;\n    }, \"useContext\"),\n    useMemo: useMemo2,\n    useReducer,\n    useRef: /* @__PURE__ */ __name(function(initialValue) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      var previousRef = workInProgressHook.memoizedState;\n      return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;\n    }, \"useRef\"),\n    useState: /* @__PURE__ */ __name(function(initialState) {\n      return useReducer(basicStateReducer, initialState);\n    }, \"useState\"),\n    useInsertionEffect: noop$1,\n    useLayoutEffect: noop$1,\n    useCallback: /* @__PURE__ */ __name(function(callback, deps) {\n      return useMemo2(function() {\n        return callback;\n      }, deps);\n    }, \"useCallback\"),\n    useImperativeHandle: noop$1,\n    useEffect: noop$1,\n    useDebugValue: noop$1,\n    useDeferredValue: /* @__PURE__ */ __name(function(value2, initialValue) {\n      resolveCurrentlyRenderingComponent();\n      return void 0 !== initialValue ? initialValue : value2;\n    }, \"useDeferredValue\"),\n    useTransition: /* @__PURE__ */ __name(function() {\n      resolveCurrentlyRenderingComponent();\n      return [false, unsupportedStartTransition];\n    }, \"useTransition\"),\n    useId: /* @__PURE__ */ __name(function() {\n      var JSCompiler_inline_result = currentlyRenderingTask.treeContext;\n      var overflow = JSCompiler_inline_result.overflow;\n      JSCompiler_inline_result = JSCompiler_inline_result.id;\n      JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;\n      var resumableState = currentResumableState;\n      if (null === resumableState)\n        throw Error(\n          \"Invalid hook call. Hooks can only be called inside of the body of a function component.\"\n        );\n      overflow = localIdCounter++;\n      JSCompiler_inline_result = \"\\xAB\" + resumableState.idPrefix + \"R\" + JSCompiler_inline_result;\n      0 < overflow && (JSCompiler_inline_result += \"H\" + overflow.toString(32));\n      return JSCompiler_inline_result + \"\\xBB\";\n    }, \"useId\"),\n    useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {\n      if (void 0 === getServerSnapshot)\n        throw Error(\n          \"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\"\n        );\n      return getServerSnapshot();\n    }, \"useSyncExternalStore\"),\n    useOptimistic: /* @__PURE__ */ __name(function(passthrough) {\n      resolveCurrentlyRenderingComponent();\n      return [passthrough, unsupportedSetOptimisticState];\n    }, \"useOptimistic\"),\n    useActionState,\n    useFormState: useActionState,\n    useHostTransitionStatus: /* @__PURE__ */ __name(function() {\n      resolveCurrentlyRenderingComponent();\n      return sharedNotPendingObject;\n    }, \"useHostTransitionStatus\"),\n    useMemoCache: /* @__PURE__ */ __name(function(size) {\n      for (var data = Array(size), i = 0; i < size; i++)\n        data[i] = REACT_MEMO_CACHE_SENTINEL;\n      return data;\n    }, \"useMemoCache\"),\n    useCacheRefresh: /* @__PURE__ */ __name(function() {\n      return unsupportedRefresh;\n    }, \"useCacheRefresh\")\n  }, currentResumableState = null, DefaultAsyncDispatcher = {\n    getCacheForType: /* @__PURE__ */ __name(function() {\n      throw Error(\"Not implemented.\");\n    }, \"getCacheForType\")\n  };\n  function prepareStackTrace(error4, structuredStackTrace) {\n    error4 = (error4.name || \"Error\") + \": \" + (error4.message || \"\");\n    for (var i = 0; i < structuredStackTrace.length; i++)\n      error4 += \"\\n    at \" + structuredStackTrace[i].toString();\n    return error4;\n  }\n  __name(prepareStackTrace, \"prepareStackTrace\");\n  var prefix, suffix;\n  function describeBuiltInComponentFrame(name) {\n    if (void 0 === prefix)\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || \"\";\n        suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n      }\n    return \"\\n\" + prefix + name + suffix;\n  }\n  __name(describeBuiltInComponentFrame, \"describeBuiltInComponentFrame\");\n  var reentry = false;\n  function describeNativeComponentFrame(fn2, construct) {\n    if (!fn2 || reentry) return \"\";\n    reentry = true;\n    var previousPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = prepareStackTrace;\n    try {\n      var RunInRootFrame = {\n        DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {\n          try {\n            if (construct) {\n              var Fake = /* @__PURE__ */ __name(function() {\n                throw Error();\n              }, \"Fake\");\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: /* @__PURE__ */ __name(function() {\n                  throw Error();\n                }, \"set\")\n              });\n              if (\"object\" === typeof Reflect && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  var control = x;\n                }\n                Reflect.construct(fn2, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x$24) {\n                  control = x$24;\n                }\n                fn2.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x$25) {\n                control = x$25;\n              }\n              (Fake = fn2()) && \"function\" === typeof Fake.catch && Fake.catch(function() {\n              });\n            }\n          } catch (sample) {\n            if (sample && control && \"string\" === typeof sample.stack)\n              return [sample.stack, control.stack];\n          }\n          return [null, null];\n        }, \"DetermineComponentFrameRoot\")\n      };\n      RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n      var namePropDescriptor = Object.getOwnPropertyDescriptor(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        \"name\"\n      );\n      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        \"name\",\n        { value: \"DetermineComponentFrameRoot\" }\n      );\n      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n      if (sampleStack && controlStack) {\n        var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes(\"DetermineComponentFrameRoot\"); )\n          RunInRootFrame++;\n        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(\n          \"DetermineComponentFrameRoot\"\n        ); )\n          namePropDescriptor++;\n        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)\n          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )\n            namePropDescriptor--;\n        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)\n          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\n              do\n                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n                  var frame = \"\\n\" + sampleLines[RunInRootFrame].replace(\" at new \", \" at \");\n                  fn2.displayName && frame.includes(\"<anonymous>\") && (frame = frame.replace(\"<anonymous>\", fn2.displayName));\n                  return frame;\n                }\n              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\n            }\n            break;\n          }\n      }\n    } finally {\n      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;\n    }\n    return (previousPrepareStackTrace = fn2 ? fn2.displayName || fn2.name : \"\") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : \"\";\n  }\n  __name(describeNativeComponentFrame, \"describeNativeComponentFrame\");\n  function describeComponentStackByType(type2) {\n    if (\"string\" === typeof type2) return describeBuiltInComponentFrame(type2);\n    if (\"function\" === typeof type2)\n      return type2.prototype && type2.prototype.isReactComponent ? describeNativeComponentFrame(type2, true) : describeNativeComponentFrame(type2, false);\n    if (\"object\" === typeof type2 && null !== type2) {\n      switch (type2.$$typeof) {\n        case REACT_FORWARD_REF_TYPE:\n          return describeNativeComponentFrame(type2.render, false);\n        case REACT_MEMO_TYPE:\n          return describeNativeComponentFrame(type2.type, false);\n        case REACT_LAZY_TYPE:\n          var lazyComponent = type2, payload = lazyComponent._payload;\n          lazyComponent = lazyComponent._init;\n          try {\n            type2 = lazyComponent(payload);\n          } catch (x) {\n            return describeBuiltInComponentFrame(\"Lazy\");\n          }\n          return describeComponentStackByType(type2);\n      }\n      if (\"string\" === typeof type2.name)\n        return payload = type2.env, describeBuiltInComponentFrame(\n          type2.name + (payload ? \" [\" + payload + \"]\" : \"\")\n        );\n    }\n    switch (type2) {\n      case REACT_SUSPENSE_LIST_TYPE:\n        return describeBuiltInComponentFrame(\"SuspenseList\");\n      case REACT_SUSPENSE_TYPE:\n        return describeBuiltInComponentFrame(\"Suspense\");\n    }\n    return \"\";\n  }\n  __name(describeComponentStackByType, \"describeComponentStackByType\");\n  function defaultErrorHandler(error4) {\n    if (\"object\" === typeof error4 && null !== error4 && \"string\" === typeof error4.environmentName) {\n      var JSCompiler_inline_result = error4.environmentName;\n      error4 = [error4].slice(0);\n      \"string\" === typeof error4[0] ? error4.splice(\n        0,\n        1,\n        \"\\x1B[0m\\x1B[7m%c%s\\x1B[0m%c \" + error4[0],\n        \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n        \" \" + JSCompiler_inline_result + \" \",\n        \"\"\n      ) : error4.splice(\n        0,\n        0,\n        \"\\x1B[0m\\x1B[7m%c%s\\x1B[0m%c \",\n        \"background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px\",\n        \" \" + JSCompiler_inline_result + \" \",\n        \"\"\n      );\n      error4.unshift(console);\n      JSCompiler_inline_result = bind2.apply(console.error, error4);\n      JSCompiler_inline_result();\n    } else console.error(error4);\n    return null;\n  }\n  __name(defaultErrorHandler, \"defaultErrorHandler\");\n  function noop3() {\n  }\n  __name(noop3, \"noop\");\n  function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n    var abortSet = /* @__PURE__ */ new Set();\n    this.destination = null;\n    this.flushScheduled = false;\n    this.resumableState = resumableState;\n    this.renderState = renderState;\n    this.rootFormatContext = rootFormatContext;\n    this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n    this.status = 10;\n    this.fatalError = null;\n    this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n    this.completedPreambleSegments = this.completedRootSegment = null;\n    this.abortableTasks = abortSet;\n    this.pingedTasks = [];\n    this.clientRenderedBoundaries = [];\n    this.completedBoundaries = [];\n    this.partialBoundaries = [];\n    this.trackedPostpones = null;\n    this.onError = void 0 === onError ? defaultErrorHandler : onError;\n    this.onPostpone = void 0 === onPostpone ? noop3 : onPostpone;\n    this.onAllReady = void 0 === onAllReady ? noop3 : onAllReady;\n    this.onShellReady = void 0 === onShellReady ? noop3 : onShellReady;\n    this.onShellError = void 0 === onShellError ? noop3 : onShellError;\n    this.onFatalError = void 0 === onFatalError ? noop3 : onFatalError;\n    this.formState = void 0 === formState ? null : formState;\n  }\n  __name(RequestInstance, \"RequestInstance\");\n  function createRequest2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n    resumableState = new RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    );\n    renderState = createPendingSegment(\n      resumableState,\n      0,\n      null,\n      rootFormatContext,\n      false,\n      false\n    );\n    renderState.parentFlushed = true;\n    children = createRenderTask(\n      resumableState,\n      null,\n      children,\n      -1,\n      null,\n      renderState,\n      null,\n      null,\n      resumableState.abortableTasks,\n      null,\n      rootFormatContext,\n      null,\n      emptyTreeContext,\n      null,\n      false\n    );\n    pushComponentStack(children);\n    resumableState.pingedTasks.push(children);\n    return resumableState;\n  }\n  __name(createRequest2, \"createRequest\");\n  function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {\n    children = createRequest2(\n      children,\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      void 0\n    );\n    children.trackedPostpones = {\n      workingMap: /* @__PURE__ */ new Map(),\n      rootNodes: [],\n      rootSlots: null\n    };\n    return children;\n  }\n  __name(createPrerenderRequest, \"createPrerenderRequest\");\n  var currentRequest = null;\n  function resolveRequest() {\n    if (currentRequest) return currentRequest;\n    if (supportsRequestStorage) {\n      var store = requestStorage.getStore();\n      if (store) return store;\n    }\n    return null;\n  }\n  __name(resolveRequest, \"resolveRequest\");\n  function pingTask(request, task) {\n    request.pingedTasks.push(task);\n    1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {\n      return performWork(request);\n    }) : setTimeout(function() {\n      return performWork(request);\n    }, 0));\n  }\n  __name(pingTask, \"pingTask\");\n  function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {\n    return {\n      status: 0,\n      rootSegmentID: -1,\n      parentFlushed: false,\n      pendingTasks: 0,\n      completedSegments: [],\n      byteSize: 0,\n      fallbackAbortableTasks,\n      errorDigest: null,\n      contentState: createHoistableState(),\n      fallbackState: createHoistableState(),\n      contentPreamble,\n      fallbackPreamble,\n      trackedContentKeyPath: null,\n      trackedFallbackNode: null\n    };\n  }\n  __name(createSuspenseBoundary, \"createSuspenseBoundary\");\n  function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, componentStack, isFallback) {\n    request.allPendingTasks++;\n    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;\n    var task = {\n      replay: null,\n      node,\n      childIndex,\n      ping: /* @__PURE__ */ __name(function() {\n        return pingTask(request, task);\n      }, \"ping\"),\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context: context2,\n      treeContext,\n      componentStack,\n      thenableState: thenableState2,\n      isFallback\n    };\n    abortSet.add(task);\n    return task;\n  }\n  __name(createRenderTask, \"createRenderTask\");\n  function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, componentStack, isFallback) {\n    request.allPendingTasks++;\n    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;\n    replay.pendingTasks++;\n    var task = {\n      replay,\n      node,\n      childIndex,\n      ping: /* @__PURE__ */ __name(function() {\n        return pingTask(request, task);\n      }, \"ping\"),\n      blockedBoundary,\n      blockedSegment: null,\n      blockedPreamble: null,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context: context2,\n      treeContext,\n      componentStack,\n      thenableState: thenableState2,\n      isFallback\n    };\n    abortSet.add(task);\n    return task;\n  }\n  __name(createReplayTask, \"createReplayTask\");\n  function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {\n    return {\n      status: 0,\n      parentFlushed: false,\n      id: -1,\n      index,\n      chunks: [],\n      children: [],\n      preambleChildren: [],\n      parentFormatContext,\n      boundary,\n      lastPushedText,\n      textEmbedded\n    };\n  }\n  __name(createPendingSegment, \"createPendingSegment\");\n  function pushComponentStack(task) {\n    var node = task.node;\n    if (\"object\" === typeof node && null !== node)\n      switch (node.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          task.componentStack = { parent: task.componentStack, type: node.type };\n      }\n  }\n  __name(pushComponentStack, \"pushComponentStack\");\n  function getThrownInfo(node$jscomp$0) {\n    var errorInfo = {};\n    node$jscomp$0 && Object.defineProperty(errorInfo, \"componentStack\", {\n      configurable: true,\n      enumerable: true,\n      get: /* @__PURE__ */ __name(function() {\n        try {\n          var info4 = \"\", node = node$jscomp$0;\n          do\n            info4 += describeComponentStackByType(node.type), node = node.parent;\n          while (node);\n          var JSCompiler_inline_result = info4;\n        } catch (x) {\n          JSCompiler_inline_result = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          value: JSCompiler_inline_result\n        });\n        return JSCompiler_inline_result;\n      }, \"get\")\n    });\n    return errorInfo;\n  }\n  __name(getThrownInfo, \"getThrownInfo\");\n  function logRecoverableError(request, error4, errorInfo) {\n    request = request.onError;\n    error4 = request(error4, errorInfo);\n    if (null == error4 || \"string\" === typeof error4) return error4;\n  }\n  __name(logRecoverableError, \"logRecoverableError\");\n  function fatalError(request, error4) {\n    var onShellError = request.onShellError, onFatalError = request.onFatalError;\n    onShellError(error4);\n    onFatalError(error4);\n    null !== request.destination ? (request.status = 14, closeWithError(request.destination, error4)) : (request.status = 13, request.fatalError = error4);\n  }\n  __name(fatalError, \"fatalError\");\n  function renderWithHooks(request, task, keyPath, Component, props, secondArg) {\n    var prevThenableState = task.thenableState;\n    task.thenableState = null;\n    currentlyRenderingComponent = {};\n    currentlyRenderingTask = task;\n    currentlyRenderingRequest = request;\n    currentlyRenderingKeyPath = keyPath;\n    actionStateCounter = localIdCounter = 0;\n    actionStateMatchingIndex = -1;\n    thenableIndexCounter = 0;\n    thenableState = prevThenableState;\n    for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate; )\n      didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);\n    resetHooksState();\n    return request;\n  }\n  __name(renderWithHooks, \"renderWithHooks\");\n  function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {\n    var didEmitActionStateMarkers = false;\n    if (0 !== actionStateCount && null !== request.formState) {\n      var segment = task.blockedSegment;\n      if (null !== segment) {\n        didEmitActionStateMarkers = true;\n        segment = segment.chunks;\n        for (var i = 0; i < actionStateCount; i++)\n          i === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);\n      }\n    }\n    actionStateCount = task.keyPath;\n    task.keyPath = keyPath;\n    hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);\n    task.keyPath = actionStateCount;\n  }\n  __name(finishFunctionComponent, \"finishFunctionComponent\");\n  function renderElement2(request, task, keyPath, type2, props, ref) {\n    if (\"function\" === typeof type2)\n      if (type2.prototype && type2.prototype.isReactComponent) {\n        var newProps = props;\n        if (\"ref\" in props) {\n          newProps = {};\n          for (var propName2 in props)\n            \"ref\" !== propName2 && (newProps[propName2] = props[propName2]);\n        }\n        var defaultProps = type2.defaultProps;\n        if (defaultProps) {\n          newProps === props && (newProps = assign({}, newProps, props));\n          for (var propName$33 in defaultProps)\n            void 0 === newProps[propName$33] && (newProps[propName$33] = defaultProps[propName$33]);\n        }\n        props = newProps;\n        newProps = emptyContextObject;\n        defaultProps = type2.contextType;\n        \"object\" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue);\n        newProps = new type2(props, newProps);\n        var initialState = void 0 !== newProps.state ? newProps.state : null;\n        newProps.updater = classComponentUpdater;\n        newProps.props = props;\n        newProps.state = initialState;\n        defaultProps = { queue: [], replace: false };\n        newProps._reactInternals = defaultProps;\n        ref = type2.contextType;\n        newProps.context = \"object\" === typeof ref && null !== ref ? ref._currentValue : emptyContextObject;\n        ref = type2.getDerivedStateFromProps;\n        \"function\" === typeof ref && (ref = ref(props, initialState), initialState = null === ref || void 0 === ref ? initialState : assign({}, initialState, ref), newProps.state = initialState);\n        if (\"function\" !== typeof type2.getDerivedStateFromProps && \"function\" !== typeof newProps.getSnapshotBeforeUpdate && (\"function\" === typeof newProps.UNSAFE_componentWillMount || \"function\" === typeof newProps.componentWillMount))\n          if (type2 = newProps.state, \"function\" === typeof newProps.componentWillMount && newProps.componentWillMount(), \"function\" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type2 !== newProps.state && classComponentUpdater.enqueueReplaceState(\n            newProps,\n            newProps.state,\n            null\n          ), null !== defaultProps.queue && 0 < defaultProps.queue.length)\n            if (type2 = defaultProps.queue, ref = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = false, ref && 1 === type2.length)\n              newProps.state = type2[0];\n            else {\n              defaultProps = ref ? type2[0] : newProps.state;\n              initialState = true;\n              for (ref = ref ? 1 : 0; ref < type2.length; ref++)\n                propName$33 = type2[ref], propName$33 = \"function\" === typeof propName$33 ? propName$33.call(newProps, defaultProps, props, void 0) : propName$33, null != propName$33 && (initialState ? (initialState = false, defaultProps = assign({}, defaultProps, propName$33)) : assign(defaultProps, propName$33));\n              newProps.state = defaultProps;\n            }\n          else defaultProps.queue = null;\n        type2 = newProps.render();\n        if (12 === request.status) throw null;\n        props = task.keyPath;\n        task.keyPath = keyPath;\n        renderNodeDestructive(request, task, type2, -1);\n        task.keyPath = props;\n      } else {\n        type2 = renderWithHooks(request, task, keyPath, type2, props, void 0);\n        if (12 === request.status) throw null;\n        finishFunctionComponent(\n          request,\n          task,\n          keyPath,\n          type2,\n          0 !== localIdCounter,\n          actionStateCounter,\n          actionStateMatchingIndex\n        );\n      }\n    else if (\"string\" === typeof type2)\n      if (newProps = task.blockedSegment, null === newProps)\n        newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type2, props), task.keyPath = keyPath, renderNode(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;\n      else {\n        ref = pushStartInstance(\n          newProps.chunks,\n          type2,\n          props,\n          request.resumableState,\n          request.renderState,\n          task.blockedPreamble,\n          task.hoistableState,\n          task.formatContext,\n          newProps.lastPushedText,\n          task.isFallback\n        );\n        newProps.lastPushedText = false;\n        defaultProps = task.formatContext;\n        initialState = task.keyPath;\n        task.keyPath = keyPath;\n        3 === (task.formatContext = getChildFormatContext(defaultProps, type2, props)).insertionMode ? (keyPath = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          false,\n          false\n        ), newProps.preambleChildren.push(keyPath), keyPath = createRenderTask(\n          request,\n          null,\n          ref,\n          -1,\n          task.blockedBoundary,\n          keyPath,\n          task.blockedPreamble,\n          task.hoistableState,\n          request.abortableTasks,\n          task.keyPath,\n          task.formatContext,\n          task.context,\n          task.treeContext,\n          task.componentStack,\n          task.isFallback\n        ), pushComponentStack(keyPath), request.pingedTasks.push(keyPath)) : renderNode(request, task, ref, -1);\n        task.formatContext = defaultProps;\n        task.keyPath = initialState;\n        a: {\n          task = newProps.chunks;\n          request = request.resumableState;\n          switch (type2) {\n            case \"title\":\n            case \"style\":\n            case \"script\":\n            case \"area\":\n            case \"base\":\n            case \"br\":\n            case \"col\":\n            case \"embed\":\n            case \"hr\":\n            case \"img\":\n            case \"input\":\n            case \"keygen\":\n            case \"link\":\n            case \"meta\":\n            case \"param\":\n            case \"source\":\n            case \"track\":\n            case \"wbr\":\n              break a;\n            case \"body\":\n              if (1 >= defaultProps.insertionMode) {\n                request.hasBody = true;\n                break a;\n              }\n              break;\n            case \"html\":\n              if (0 === defaultProps.insertionMode) {\n                request.hasHtml = true;\n                break a;\n              }\n              break;\n            case \"head\":\n              if (1 >= defaultProps.insertionMode) break a;\n          }\n          task.push(endChunkForTag(type2));\n        }\n        newProps.lastPushedText = false;\n      }\n    else {\n      switch (type2) {\n        case REACT_LEGACY_HIDDEN_TYPE:\n        case REACT_STRICT_MODE_TYPE:\n        case REACT_PROFILER_TYPE:\n        case REACT_FRAGMENT_TYPE:\n          type2 = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, props.children, -1);\n          task.keyPath = type2;\n          return;\n        case REACT_ACTIVITY_TYPE:\n          \"hidden\" !== props.mode && (type2 = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, props.children, -1), task.keyPath = type2);\n          return;\n        case REACT_SUSPENSE_LIST_TYPE:\n          type2 = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, props.children, -1);\n          task.keyPath = type2;\n          return;\n        case REACT_VIEW_TRANSITION_TYPE:\n        case REACT_SCOPE_TYPE:\n          throw Error(\"ReactDOMServer does not yet support scope components.\");\n        case REACT_SUSPENSE_TYPE:\n          a: if (null !== task.replay) {\n            type2 = task.keyPath;\n            task.keyPath = keyPath;\n            keyPath = props.children;\n            try {\n              renderNode(request, task, keyPath, -1);\n            } finally {\n              task.keyPath = type2;\n            }\n          } else {\n            type2 = task.keyPath;\n            var parentBoundary = task.blockedBoundary;\n            ref = task.blockedPreamble;\n            var parentHoistableState = task.hoistableState;\n            propName$33 = task.blockedSegment;\n            propName2 = props.fallback;\n            props = props.children;\n            var fallbackAbortSet = /* @__PURE__ */ new Set();\n            var newBoundary = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(\n              request,\n              fallbackAbortSet,\n              createPreambleState(),\n              createPreambleState()\n            ) : createSuspenseBoundary(request, fallbackAbortSet, null, null);\n            null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);\n            var boundarySegment = createPendingSegment(\n              request,\n              propName$33.chunks.length,\n              newBoundary,\n              task.formatContext,\n              false,\n              false\n            );\n            propName$33.children.push(boundarySegment);\n            propName$33.lastPushedText = false;\n            var contentRootSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              false,\n              false\n            );\n            contentRootSegment.parentFlushed = true;\n            if (null !== request.trackedPostpones) {\n              newProps = [keyPath[0], \"Suspense Fallback\", keyPath[2]];\n              defaultProps = [newProps[1], newProps[2], [], null];\n              request.trackedPostpones.workingMap.set(newProps, defaultProps);\n              newBoundary.trackedFallbackNode = defaultProps;\n              task.blockedSegment = boundarySegment;\n              task.blockedPreamble = newBoundary.fallbackPreamble;\n              task.keyPath = newProps;\n              boundarySegment.status = 6;\n              try {\n                renderNode(request, task, propName2, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = 1;\n              } catch (thrownValue) {\n                throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;\n              } finally {\n                task.blockedSegment = propName$33, task.blockedPreamble = ref, task.keyPath = type2;\n              }\n              task = createRenderTask(\n                request,\n                null,\n                props,\n                -1,\n                newBoundary,\n                contentRootSegment,\n                newBoundary.contentPreamble,\n                newBoundary.contentState,\n                task.abortSet,\n                keyPath,\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                task.isFallback\n              );\n              pushComponentStack(task);\n              request.pingedTasks.push(task);\n            } else {\n              task.blockedBoundary = newBoundary;\n              task.blockedPreamble = newBoundary.contentPreamble;\n              task.hoistableState = newBoundary.contentState;\n              task.blockedSegment = contentRootSegment;\n              task.keyPath = keyPath;\n              contentRootSegment.status = 6;\n              try {\n                if (renderNode(request, task, props, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = 1, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {\n                  newBoundary.status = 1;\n                  0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);\n                  break a;\n                }\n              } catch (thrownValue$28) {\n                newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$28), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(\n                  request,\n                  newProps,\n                  defaultProps\n                ), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);\n              } finally {\n                task.blockedBoundary = parentBoundary, task.blockedPreamble = ref, task.hoistableState = parentHoistableState, task.blockedSegment = propName$33, task.keyPath = type2;\n              }\n              task = createRenderTask(\n                request,\n                null,\n                propName2,\n                -1,\n                parentBoundary,\n                boundarySegment,\n                newBoundary.fallbackPreamble,\n                newBoundary.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                true\n              );\n              pushComponentStack(task);\n              request.pingedTasks.push(task);\n            }\n          }\n          return;\n      }\n      if (\"object\" === typeof type2 && null !== type2)\n        switch (type2.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            if (\"ref\" in props)\n              for (newBoundary in newProps = {}, props)\n                \"ref\" !== newBoundary && (newProps[newBoundary] = props[newBoundary]);\n            else newProps = props;\n            type2 = renderWithHooks(\n              request,\n              task,\n              keyPath,\n              type2.render,\n              newProps,\n              ref\n            );\n            finishFunctionComponent(\n              request,\n              task,\n              keyPath,\n              type2,\n              0 !== localIdCounter,\n              actionStateCounter,\n              actionStateMatchingIndex\n            );\n            return;\n          case REACT_MEMO_TYPE:\n            renderElement2(request, task, keyPath, type2.type, props, ref);\n            return;\n          case REACT_PROVIDER_TYPE:\n          case REACT_CONTEXT_TYPE:\n            defaultProps = props.children;\n            newProps = task.keyPath;\n            props = props.value;\n            initialState = type2._currentValue;\n            type2._currentValue = props;\n            ref = currentActiveSnapshot;\n            currentActiveSnapshot = type2 = {\n              parent: ref,\n              depth: null === ref ? 0 : ref.depth + 1,\n              context: type2,\n              parentValue: initialState,\n              value: props\n            };\n            task.context = type2;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, defaultProps, -1);\n            request = currentActiveSnapshot;\n            if (null === request)\n              throw Error(\n                \"Tried to pop a Context at the root of the app. This is a bug in React.\"\n              );\n            request.context._currentValue = request.parentValue;\n            request = currentActiveSnapshot = request.parent;\n            task.context = request;\n            task.keyPath = newProps;\n            return;\n          case REACT_CONSUMER_TYPE:\n            props = props.children;\n            type2 = props(type2._context._currentValue);\n            props = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, type2, -1);\n            task.keyPath = props;\n            return;\n          case REACT_LAZY_TYPE:\n            newProps = type2._init;\n            type2 = newProps(type2._payload);\n            if (12 === request.status) throw null;\n            renderElement2(request, task, keyPath, type2, props, ref);\n            return;\n        }\n      throw Error(\n        \"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + ((null == type2 ? type2 : typeof type2) + \".\")\n      );\n    }\n  }\n  __name(renderElement2, \"renderElement\");\n  function resumeNode(request, task, segmentId, node, childIndex) {\n    var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(\n      request,\n      0,\n      null,\n      task.formatContext,\n      false,\n      false\n    );\n    resumedSegment.id = segmentId;\n    resumedSegment.parentFlushed = true;\n    try {\n      task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = 1, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));\n    } finally {\n      task.replay = prevReplay, task.blockedSegment = null;\n    }\n  }\n  __name(resumeNode, \"resumeNode\");\n  function renderNodeDestructive(request, task, node, childIndex) {\n    null !== task.replay && \"number\" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);\n  }\n  __name(renderNodeDestructive, \"renderNodeDestructive\");\n  function retryNode(request, task) {\n    var node = task.node, childIndex = task.childIndex;\n    if (null !== node) {\n      if (\"object\" === typeof node) {\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type2 = node.type, key = node.key, props = node.props;\n            node = props.ref;\n            var ref = void 0 !== node ? node : null, name = getComponentNameFromType(type2), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;\n            key = [task.keyPath, name, keyOrIndex];\n            if (null !== task.replay)\n              a: {\n                var replay = task.replay;\n                childIndex = replay.nodes;\n                for (node = 0; node < childIndex.length; node++) {\n                  var node$jscomp$0 = childIndex[node];\n                  if (keyOrIndex === node$jscomp$0[1]) {\n                    if (4 === node$jscomp$0.length) {\n                      if (null !== name && name !== node$jscomp$0[0])\n                        throw Error(\n                          \"Expected the resume to render <\" + node$jscomp$0[0] + \"> in this slot but instead it rendered <\" + name + \">. The tree doesn't match so React will fallback to client rendering.\"\n                        );\n                      var childNodes = node$jscomp$0[2];\n                      name = node$jscomp$0[3];\n                      keyOrIndex = task.node;\n                      task.replay = {\n                        nodes: childNodes,\n                        slots: name,\n                        pendingTasks: 1\n                      };\n                      try {\n                        renderElement2(request, task, key, type2, props, ref);\n                        if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n                          throw Error(\n                            \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                          );\n                        task.replay.pendingTasks--;\n                      } catch (x) {\n                        if (\"object\" === typeof x && null !== x && (x === SuspenseException || \"function\" === typeof x.then))\n                          throw task.node === keyOrIndex && (task.replay = replay), x;\n                        task.replay.pendingTasks--;\n                        props = getThrownInfo(task.componentStack);\n                        key = task.blockedBoundary;\n                        type2 = x;\n                        props = logRecoverableError(request, type2, props);\n                        abortRemainingReplayNodes(\n                          request,\n                          key,\n                          childNodes,\n                          name,\n                          type2,\n                          props\n                        );\n                      }\n                      task.replay = replay;\n                    } else {\n                      if (type2 !== REACT_SUSPENSE_TYPE)\n                        throw Error(\n                          \"Expected the resume to render <Suspense> in this slot but instead it rendered <\" + (getComponentNameFromType(type2) || \"Unknown\") + \">. The tree doesn't match so React will fallback to client rendering.\"\n                        );\n                      b: {\n                        replay = void 0;\n                        type2 = node$jscomp$0[5];\n                        ref = node$jscomp$0[2];\n                        name = node$jscomp$0[3];\n                        keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];\n                        node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];\n                        var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();\n                        props = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(\n                          request,\n                          fallbackAbortSet,\n                          createPreambleState(),\n                          createPreambleState()\n                        ) : createSuspenseBoundary(\n                          request,\n                          fallbackAbortSet,\n                          null,\n                          null\n                        );\n                        props.parentFlushed = true;\n                        props.rootSegmentID = type2;\n                        task.blockedBoundary = props;\n                        task.hoistableState = props.contentState;\n                        task.keyPath = key;\n                        task.replay = {\n                          nodes: ref,\n                          slots: name,\n                          pendingTasks: 1\n                        };\n                        try {\n                          renderNode(request, task, content, -1);\n                          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n                            throw Error(\n                              \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                            );\n                          task.replay.pendingTasks--;\n                          if (0 === props.pendingTasks && 0 === props.status) {\n                            props.status = 1;\n                            request.completedBoundaries.push(props);\n                            break b;\n                          }\n                        } catch (error4) {\n                          props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(\n                            request,\n                            error4,\n                            childNodes\n                          ), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);\n                        } finally {\n                          task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;\n                        }\n                        task = createReplayTask(\n                          request,\n                          null,\n                          {\n                            nodes: keyOrIndex,\n                            slots: node$jscomp$0,\n                            pendingTasks: 0\n                          },\n                          fallback,\n                          -1,\n                          parentBoundary,\n                          props.fallbackState,\n                          fallbackAbortSet,\n                          [key[0], \"Suspense Fallback\", key[2]],\n                          task.formatContext,\n                          task.context,\n                          task.treeContext,\n                          task.componentStack,\n                          true\n                        );\n                        pushComponentStack(task);\n                        request.pingedTasks.push(task);\n                      }\n                    }\n                    childIndex.splice(node, 1);\n                    break a;\n                  }\n                }\n              }\n            else renderElement2(request, task, key, type2, props, ref);\n            return;\n          case REACT_PORTAL_TYPE:\n            throw Error(\n              \"Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.\"\n            );\n          case REACT_LAZY_TYPE:\n            childNodes = node._init;\n            node = childNodes(node._payload);\n            if (12 === request.status) throw null;\n            renderNodeDestructive(request, task, node, childIndex);\n            return;\n        }\n        if (isArrayImpl(node)) {\n          renderChildrenArray(request, task, node, childIndex);\n          return;\n        }\n        null === node || \"object\" !== typeof node ? childNodes = null : (childNodes = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node[\"@@iterator\"], childNodes = \"function\" === typeof childNodes ? childNodes : null);\n        if (childNodes && (childNodes = childNodes.call(node))) {\n          node = childNodes.next();\n          if (!node.done) {\n            props = [];\n            do\n              props.push(node.value), node = childNodes.next();\n            while (!node.done);\n            renderChildrenArray(request, task, props, childIndex);\n          }\n          return;\n        }\n        if (\"function\" === typeof node.then)\n          return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);\n        if (node.$$typeof === REACT_CONTEXT_TYPE)\n          return renderNodeDestructive(\n            request,\n            task,\n            node._currentValue,\n            childIndex\n          );\n        childIndex = Object.prototype.toString.call(node);\n        throw Error(\n          \"Objects are not valid as a React child (found: \" + (\"[object Object]\" === childIndex ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childIndex) + \"). If you meant to render a collection of children, use an array instead.\"\n        );\n      }\n      if (\"string\" === typeof node)\n        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(\n          childIndex.chunks,\n          node,\n          request.renderState,\n          childIndex.lastPushedText\n        ));\n      else if (\"number\" === typeof node || \"bigint\" === typeof node)\n        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(\n          childIndex.chunks,\n          \"\" + node,\n          request.renderState,\n          childIndex.lastPushedText\n        ));\n    }\n  }\n  __name(retryNode, \"retryNode\");\n  function renderChildrenArray(request, task, children, childIndex) {\n    var prevKeyPath = task.keyPath;\n    if (-1 !== childIndex && (task.keyPath = [task.keyPath, \"Fragment\", childIndex], null !== task.replay)) {\n      for (var replay = task.replay, replayNodes = replay.nodes, j3 = 0; j3 < replayNodes.length; j3++) {\n        var node = replayNodes[j3];\n        if (node[1] === childIndex) {\n          childIndex = node[2];\n          node = node[3];\n          task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n          try {\n            renderChildrenArray(request, task, children, -1);\n            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n              throw Error(\n                \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n              );\n            task.replay.pendingTasks--;\n          } catch (x) {\n            if (\"object\" === typeof x && null !== x && (x === SuspenseException || \"function\" === typeof x.then))\n              throw x;\n            task.replay.pendingTasks--;\n            children = getThrownInfo(task.componentStack);\n            var boundary = task.blockedBoundary, error4 = x;\n            children = logRecoverableError(request, error4, children);\n            abortRemainingReplayNodes(\n              request,\n              boundary,\n              childIndex,\n              node,\n              error4,\n              children\n            );\n          }\n          task.replay = replay;\n          replayNodes.splice(j3, 1);\n          break;\n        }\n      }\n      task.keyPath = prevKeyPath;\n      return;\n    }\n    replay = task.treeContext;\n    replayNodes = children.length;\n    if (null !== task.replay && (j3 = task.replay.slots, null !== j3 && \"object\" === typeof j3)) {\n      for (childIndex = 0; childIndex < replayNodes; childIndex++)\n        node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j3[childIndex], \"number\" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j3[childIndex]) : renderNode(request, task, node, childIndex);\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      return;\n    }\n    for (j3 = 0; j3 < replayNodes; j3++)\n      childIndex = children[j3], task.treeContext = pushTreeContext(replay, replayNodes, j3), renderNode(request, task, childIndex, j3);\n    task.treeContext = replay;\n    task.keyPath = prevKeyPath;\n  }\n  __name(renderChildrenArray, \"renderChildrenArray\");\n  function untrackBoundary(request, boundary) {\n    request = request.trackedPostpones;\n    null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));\n  }\n  __name(untrackBoundary, \"untrackBoundary\");\n  function spawnNewSuspendedReplayTask(request, task, thenableState2) {\n    return createReplayTask(\n      request,\n      thenableState2,\n      task.replay,\n      task.node,\n      task.childIndex,\n      task.blockedBoundary,\n      task.hoistableState,\n      task.abortSet,\n      task.keyPath,\n      task.formatContext,\n      task.context,\n      task.treeContext,\n      task.componentStack,\n      task.isFallback\n    );\n  }\n  __name(spawnNewSuspendedReplayTask, \"spawnNewSuspendedReplayTask\");\n  function spawnNewSuspendedRenderTask(request, task, thenableState2) {\n    var segment = task.blockedSegment, newSegment = createPendingSegment(\n      request,\n      segment.chunks.length,\n      null,\n      task.formatContext,\n      segment.lastPushedText,\n      true\n    );\n    segment.children.push(newSegment);\n    segment.lastPushedText = false;\n    return createRenderTask(\n      request,\n      thenableState2,\n      task.node,\n      task.childIndex,\n      task.blockedBoundary,\n      newSegment,\n      task.blockedPreamble,\n      task.hoistableState,\n      task.abortSet,\n      task.keyPath,\n      task.formatContext,\n      task.context,\n      task.treeContext,\n      task.componentStack,\n      task.isFallback\n    );\n  }\n  __name(spawnNewSuspendedRenderTask, \"spawnNewSuspendedRenderTask\");\n  function renderNode(request, task, node, childIndex) {\n    var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;\n    if (null === segment)\n      try {\n        return renderNodeDestructive(request, task, node, childIndex);\n      } catch (thrownValue) {\n        if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, \"object\" === typeof node && null !== node) {\n          if (\"function\" === typeof node.then) {\n            childIndex = getThenableStateAfterSuspending();\n            request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;\n            node.then(request, request);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n          if (\"Maximum call stack size exceeded\" === node.message) {\n            node = getThenableStateAfterSuspending();\n            node = spawnNewSuspendedReplayTask(request, task, node);\n            request.pingedTasks.push(node);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n        }\n      }\n    else {\n      var childrenLength = segment.children.length, chunkLength = segment.chunks.length;\n      try {\n        return renderNodeDestructive(request, task, node, childIndex);\n      } catch (thrownValue$48) {\n        if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$48 === SuspenseException ? getSuspendedThenable() : thrownValue$48, \"object\" === typeof node && null !== node) {\n          if (\"function\" === typeof node.then) {\n            childIndex = getThenableStateAfterSuspending();\n            request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;\n            node.then(request, request);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n          if (\"Maximum call stack size exceeded\" === node.message) {\n            node = getThenableStateAfterSuspending();\n            node = spawnNewSuspendedRenderTask(request, task, node);\n            request.pingedTasks.push(node);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n        }\n      }\n    }\n    task.formatContext = previousFormatContext;\n    task.context = previousContext;\n    task.keyPath = previousKeyPath;\n    task.treeContext = previousTreeContext;\n    switchContext(previousContext);\n    throw node;\n  }\n  __name(renderNode, \"renderNode\");\n  function abortTaskSoft(task) {\n    var boundary = task.blockedBoundary;\n    task = task.blockedSegment;\n    null !== task && (task.status = 3, finishedTask(this, boundary, task));\n  }\n  __name(abortTaskSoft, \"abortTaskSoft\");\n  function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error4, errorDigest$jscomp$0) {\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      if (4 === node.length)\n        abortRemainingReplayNodes(\n          request$jscomp$0,\n          boundary,\n          node[2],\n          node[3],\n          error4,\n          errorDigest$jscomp$0\n        );\n      else {\n        node = node[5];\n        var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(\n          request,\n          /* @__PURE__ */ new Set(),\n          null,\n          null\n        );\n        resumedBoundary.parentFlushed = true;\n        resumedBoundary.rootSegmentID = node;\n        resumedBoundary.status = 4;\n        resumedBoundary.errorDigest = errorDigest;\n        resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);\n      }\n    }\n    nodes.length = 0;\n    if (null !== slots) {\n      if (null === boundary)\n        throw Error(\n          \"We should not have any resumable nodes in the shell. This is a bug in React.\"\n        );\n      4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));\n      if (\"object\" === typeof slots) for (var index in slots) delete slots[index];\n    }\n  }\n  __name(abortRemainingReplayNodes, \"abortRemainingReplayNodes\");\n  function abortTask(task, request, error4) {\n    var boundary = task.blockedBoundary, segment = task.blockedSegment;\n    if (null !== segment) {\n      if (6 === segment.status) return;\n      segment.status = 3;\n    }\n    segment = getThrownInfo(task.componentStack);\n    if (null === boundary) {\n      if (13 !== request.status && 14 !== request.status) {\n        boundary = task.replay;\n        if (null === boundary) {\n          logRecoverableError(request, error4, segment);\n          fatalError(request, error4);\n          return;\n        }\n        boundary.pendingTasks--;\n        0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error4, segment), abortRemainingReplayNodes(\n          request,\n          null,\n          boundary.nodes,\n          boundary.slots,\n          error4,\n          task\n        ));\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      }\n    } else\n      boundary.pendingTasks--, 4 !== boundary.status && (boundary.status = 4, task = logRecoverableError(request, error4, segment), boundary.status = 4, boundary.errorDigest = task, untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n        return abortTask(fallbackTask, request, error4);\n      }), boundary.fallbackAbortableTasks.clear();\n    request.allPendingTasks--;\n    0 === request.allPendingTasks && completeAll(request);\n  }\n  __name(abortTask, \"abortTask\");\n  function safelyEmitEarlyPreloads(request, shellComplete) {\n    try {\n      var renderState = request.renderState, onHeaders = renderState.onHeaders;\n      if (onHeaders) {\n        var headers = renderState.headers;\n        if (headers) {\n          renderState.headers = null;\n          var linkHeader = headers.preconnects;\n          headers.fontPreloads && (linkHeader && (linkHeader += \", \"), linkHeader += headers.fontPreloads);\n          headers.highImagePreloads && (linkHeader && (linkHeader += \", \"), linkHeader += headers.highImagePreloads);\n          if (!shellComplete) {\n            var queueIter = renderState.styles.values(), queueStep = queueIter.next();\n            b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())\n              for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {\n                var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, \"style\", {\n                  crossOrigin: props$jscomp$0.crossOrigin,\n                  integrity: props$jscomp$0.integrity,\n                  nonce: props$jscomp$0.nonce,\n                  type: props$jscomp$0.type,\n                  fetchPriority: props$jscomp$0.fetchPriority,\n                  referrerPolicy: props$jscomp$0.referrerPolicy,\n                  media: props$jscomp$0.media\n                });\n                if (0 <= (headers.remainingCapacity -= header.length + 2))\n                  renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += \", \"), linkHeader += header, renderState.resets.style[key] = \"string\" === typeof props.crossOrigin || \"string\" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;\n                else break b;\n              }\n          }\n          linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n        }\n      }\n    } catch (error4) {\n      logRecoverableError(request, error4, {});\n    }\n  }\n  __name(safelyEmitEarlyPreloads, \"safelyEmitEarlyPreloads\");\n  function completeShell(request) {\n    null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);\n    null === request.trackedPostpones && preparePreamble(request);\n    request.onShellError = noop3;\n    request = request.onShellReady;\n    request();\n  }\n  __name(completeShell, \"completeShell\");\n  function completeAll(request) {\n    safelyEmitEarlyPreloads(\n      request,\n      null === request.trackedPostpones ? true : null === request.completedRootSegment || 5 !== request.completedRootSegment.status\n    );\n    preparePreamble(request);\n    request = request.onAllReady;\n    request();\n  }\n  __name(completeAll, \"completeAll\");\n  function queueCompletedSegment(boundary, segment) {\n    if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {\n      var childSegment = segment.children[0];\n      childSegment.id = segment.id;\n      childSegment.parentFlushed = true;\n      1 === childSegment.status && queueCompletedSegment(boundary, childSegment);\n    } else boundary.completedSegments.push(segment);\n  }\n  __name(queueCompletedSegment, \"queueCompletedSegment\");\n  function finishedTask(request, boundary, segment) {\n    if (null === boundary) {\n      if (null !== segment && segment.parentFlushed) {\n        if (null !== request.completedRootSegment)\n          throw Error(\n            \"There can only be one root segment. This is a bug in React.\"\n          );\n        request.completedRootSegment = segment;\n      }\n      request.pendingRootTasks--;\n      0 === request.pendingRootTasks && completeShell(request);\n    } else\n      boundary.pendingTasks--, 4 !== boundary.status && (0 === boundary.pendingTasks ? (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && 1 === segment.status && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status && (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && 1 === segment.status && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));\n    request.allPendingTasks--;\n    0 === request.allPendingTasks && completeAll(request);\n  }\n  __name(finishedTask, \"finishedTask\");\n  function performWork(request$jscomp$2) {\n    if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n      var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = HooksDispatcher;\n      var prevAsyncDispatcher = ReactSharedInternals.A;\n      ReactSharedInternals.A = DefaultAsyncDispatcher;\n      var prevRequest = currentRequest;\n      currentRequest = request$jscomp$2;\n      var prevResumableState = currentResumableState;\n      currentResumableState = request$jscomp$2.resumableState;\n      try {\n        var pingedTasks = request$jscomp$2.pingedTasks, i;\n        for (i = 0; i < pingedTasks.length; i++) {\n          var task = pingedTasks[i], request = request$jscomp$2, segment = task.blockedSegment;\n          if (null === segment) {\n            var request$jscomp$0 = request;\n            if (0 !== task.replay.pendingTasks) {\n              switchContext(task.context);\n              try {\n                \"number\" === typeof task.replay.slots ? resumeNode(\n                  request$jscomp$0,\n                  task,\n                  task.replay.slots,\n                  task.node,\n                  task.childIndex\n                ) : retryNode(request$jscomp$0, task);\n                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n                  throw Error(\n                    \"Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.\"\n                  );\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                finishedTask(request$jscomp$0, task.blockedBoundary, null);\n              } catch (thrownValue) {\n                resetHooksState();\n                var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;\n                if (\"object\" === typeof x && null !== x && \"function\" === typeof x.then) {\n                  var ping = task.ping;\n                  x.then(ping, ping);\n                  task.thenableState = getThenableStateAfterSuspending();\n                } else {\n                  task.replay.pendingTasks--;\n                  task.abortSet.delete(task);\n                  var errorInfo = getThrownInfo(task.componentStack);\n                  request = void 0;\n                  var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;\n                  request = logRecoverableError(\n                    request$jscomp$1,\n                    error$jscomp$0,\n                    errorInfo\n                  );\n                  abortRemainingReplayNodes(\n                    request$jscomp$1,\n                    boundary,\n                    replayNodes,\n                    resumeSlots,\n                    error$jscomp$0,\n                    request\n                  );\n                  request$jscomp$0.pendingRootTasks--;\n                  0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n                  request$jscomp$0.allPendingTasks--;\n                  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n                }\n              } finally {\n              }\n            }\n          } else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {\n            request$jscomp$1.status = 6;\n            switchContext(task.context);\n            var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;\n            try {\n              retryNode(request, task), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedTask(request, task.blockedBoundary, request$jscomp$1);\n            } catch (thrownValue) {\n              resetHooksState();\n              request$jscomp$1.children.length = childrenLength;\n              request$jscomp$1.chunks.length = chunkLength;\n              var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;\n              if (\"object\" === typeof x$jscomp$0 && null !== x$jscomp$0 && \"function\" === typeof x$jscomp$0.then) {\n                request$jscomp$1.status = 0;\n                task.thenableState = getThenableStateAfterSuspending();\n                var ping$jscomp$0 = task.ping;\n                x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n              } else {\n                var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);\n                task.abortSet.delete(task);\n                request$jscomp$1.status = 4;\n                var boundary$jscomp$0 = task.blockedBoundary;\n                request$jscomp$0 = logRecoverableError(\n                  request,\n                  x$jscomp$0,\n                  errorInfo$jscomp$0\n                );\n                null === boundary$jscomp$0 ? fatalError(request, x$jscomp$0) : (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status && (boundary$jscomp$0.status = 4, boundary$jscomp$0.errorDigest = request$jscomp$0, untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));\n                request.allPendingTasks--;\n                0 === request.allPendingTasks && completeAll(request);\n              }\n            } finally {\n            }\n          }\n        }\n        pingedTasks.splice(0, i);\n        null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);\n      } catch (error4) {\n        logRecoverableError(request$jscomp$2, error4, {}), fatalError(request$jscomp$2, error4);\n      } finally {\n        currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;\n      }\n    }\n  }\n  __name(performWork, \"performWork\");\n  function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {\n    segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);\n    for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)\n      pendingPreambles = preparePreambleFromSegment(\n        request,\n        segment.children[i],\n        collectedPreambleSegments\n      ) || pendingPreambles;\n    return pendingPreambles;\n  }\n  __name(preparePreambleFromSubtree, \"preparePreambleFromSubtree\");\n  function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {\n    var boundary = segment.boundary;\n    if (null === boundary)\n      return preparePreambleFromSubtree(\n        request,\n        segment,\n        collectedPreambleSegments\n      );\n    var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;\n    if (null === preamble || null === fallbackPreamble) return false;\n    switch (boundary.status) {\n      case 1:\n        hoistPreambleState(request.renderState, preamble);\n        segment = boundary.completedSegments[0];\n        if (!segment)\n          throw Error(\n            \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n          );\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      case 5:\n        if (null !== request.trackedPostpones) return true;\n      case 4:\n        if (1 === segment.status)\n          return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n      default:\n        return true;\n    }\n  }\n  __name(preparePreambleFromSegment, \"preparePreambleFromSegment\");\n  function preparePreamble(request) {\n    if (request.completedRootSegment && null === request.completedPreambleSegments) {\n      var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(\n        request,\n        request.completedRootSegment,\n        collectedPreambleSegments\n      ), preamble = request.renderState.preamble;\n      if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)\n        request.completedPreambleSegments = collectedPreambleSegments;\n    }\n  }\n  __name(preparePreamble, \"preparePreamble\");\n  function flushSubtree(request, destination, segment, hoistableState) {\n    segment.parentFlushed = true;\n    switch (segment.status) {\n      case 0:\n        segment.id = request.nextSegmentId++;\n      case 5:\n        return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = stringToChunk(hoistableState.toString(16)), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);\n      case 1:\n        segment.status = 2;\n        var r2 = true, chunks = segment.chunks, chunkIdx = 0;\n        segment = segment.children;\n        for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n          for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)\n            writeChunk(destination, chunks[chunkIdx]);\n          r2 = flushSegment(request, destination, r2, hoistableState);\n        }\n        for (; chunkIdx < chunks.length - 1; chunkIdx++)\n          writeChunk(destination, chunks[chunkIdx]);\n        chunkIdx < chunks.length && (r2 = writeChunkAndReturn(destination, chunks[chunkIdx]));\n        return r2;\n      default:\n        throw Error(\n          \"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\"\n        );\n    }\n  }\n  __name(flushSubtree, \"flushSubtree\");\n  function flushSegment(request, destination, segment, hoistableState) {\n    var boundary = segment.boundary;\n    if (null === boundary)\n      return flushSubtree(request, destination, segment, hoistableState);\n    boundary.parentFlushed = true;\n    if (4 === boundary.status) {\n      var errorDigest = boundary.errorDigest;\n      writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n      writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n      errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest))), writeChunk(\n        destination,\n        clientRenderedSuspenseBoundaryErrorAttrInterstitial\n      ));\n      writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n      flushSubtree(request, destination, segment, hoistableState);\n      (request = boundary.fallbackPreamble) && writePreambleContribution(destination, request);\n      return writeChunkAndReturn(destination, endSuspenseBoundary);\n    }\n    if (1 !== boundary.status)\n      return 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(\n        destination,\n        request.renderState,\n        boundary.rootSegmentID\n      ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(\n        hoistStylesheetDependency,\n        hoistableState\n      )), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);\n    if (boundary.byteSize > request.progressiveChunkSize)\n      return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(\n        destination,\n        request.renderState,\n        boundary.rootSegmentID\n      ), flushSubtree(request, destination, segment, hoistableState), writeChunkAndReturn(destination, endSuspenseBoundary);\n    hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n    writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n    segment = boundary.completedSegments;\n    if (1 !== segment.length)\n      throw Error(\n        \"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\"\n      );\n    flushSegment(request, destination, segment[0], hoistableState);\n    (request = boundary.contentPreamble) && writePreambleContribution(destination, request);\n    return writeChunkAndReturn(destination, endSuspenseBoundary);\n  }\n  __name(flushSegment, \"flushSegment\");\n  function flushSegmentContainer(request, destination, segment, hoistableState) {\n    writeStartSegment(\n      destination,\n      request.renderState,\n      segment.parentFormatContext,\n      segment.id\n    );\n    flushSegment(request, destination, segment, hoistableState);\n    return writeEndSegment(destination, segment.parentFormatContext);\n  }\n  __name(flushSegmentContainer, \"flushSegmentContainer\");\n  function flushCompletedBoundary(request, destination, boundary) {\n    for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)\n      flushPartiallyCompletedSegment(\n        request,\n        destination,\n        boundary,\n        completedSegments[i]\n      );\n    completedSegments.length = 0;\n    writeHoistablesForBoundary(\n      destination,\n      boundary.contentState,\n      request.renderState\n    );\n    completedSegments = request.resumableState;\n    request = request.renderState;\n    i = boundary.rootSegmentID;\n    boundary = boundary.contentState;\n    var requiresStyleInsertion = request.stylesToHoist;\n    request.stylesToHoist = false;\n    writeChunk(destination, request.startInlineScript);\n    requiresStyleInsertion ? 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 10, writeChunk(destination, completeBoundaryWithStylesScript1FullBoth)) : 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, writeChunk(destination, completeBoundaryWithStylesScript1FullPartial)) : writeChunk(destination, completeBoundaryWithStylesScript1Partial) : 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 2, writeChunk(destination, completeBoundaryScript1Full)) : writeChunk(destination, completeBoundaryScript1Partial);\n    completedSegments = stringToChunk(i.toString(16));\n    writeChunk(destination, request.boundaryPrefix);\n    writeChunk(destination, completedSegments);\n    writeChunk(destination, completeBoundaryScript2);\n    writeChunk(destination, request.segmentPrefix);\n    writeChunk(destination, completedSegments);\n    requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);\n    boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);\n    return writeBootstrap(destination, request) && boundary;\n  }\n  __name(flushCompletedBoundary, \"flushCompletedBoundary\");\n  function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n    if (2 === segment.status) return true;\n    var hoistableState = boundary.contentState, segmentID = segment.id;\n    if (-1 === segmentID) {\n      if (-1 === (segment.id = boundary.rootSegmentID))\n        throw Error(\n          \"A root segment ID must have been assigned by now. This is a bug in React.\"\n        );\n      return flushSegmentContainer(request, destination, segment, hoistableState);\n    }\n    if (segmentID === boundary.rootSegmentID)\n      return flushSegmentContainer(request, destination, segment, hoistableState);\n    flushSegmentContainer(request, destination, segment, hoistableState);\n    boundary = request.resumableState;\n    request = request.renderState;\n    writeChunk(destination, request.startInlineScript);\n    0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);\n    writeChunk(destination, request.segmentPrefix);\n    segmentID = stringToChunk(segmentID.toString(16));\n    writeChunk(destination, segmentID);\n    writeChunk(destination, completeSegmentScript2);\n    writeChunk(destination, request.placeholderPrefix);\n    writeChunk(destination, segmentID);\n    destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);\n    return destination;\n  }\n  __name(flushPartiallyCompletedSegment, \"flushPartiallyCompletedSegment\");\n  function flushCompletedQueues(request, destination) {\n    currentView = new Uint8Array(2048);\n    writtenBytes = 0;\n    try {\n      if (!(0 < request.pendingRootTasks)) {\n        var i, completedRootSegment = request.completedRootSegment;\n        if (null !== completedRootSegment) {\n          if (5 === completedRootSegment.status) return;\n          var completedPreambleSegments = request.completedPreambleSegments;\n          if (null === completedPreambleSegments) return;\n          var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;\n          if (htmlChunks) {\n            for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n              writeChunk(destination, htmlChunks[i$jscomp$0]);\n            if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                writeChunk(destination, headChunks[i$jscomp$0]);\n            else\n              writeChunk(destination, startChunkForTag(\"head\")), writeChunk(destination, endOfStartTag);\n          } else if (headChunks)\n            for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n              writeChunk(destination, headChunks[i$jscomp$0]);\n          var charsetChunks = renderState.charsetChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)\n            writeChunk(destination, charsetChunks[i$jscomp$0]);\n          charsetChunks.length = 0;\n          renderState.preconnects.forEach(flushResource, destination);\n          renderState.preconnects.clear();\n          var viewportChunks = renderState.viewportChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)\n            writeChunk(destination, viewportChunks[i$jscomp$0]);\n          viewportChunks.length = 0;\n          renderState.fontPreloads.forEach(flushResource, destination);\n          renderState.fontPreloads.clear();\n          renderState.highImagePreloads.forEach(flushResource, destination);\n          renderState.highImagePreloads.clear();\n          renderState.styles.forEach(flushStylesInPreamble, destination);\n          var importMapChunks = renderState.importMapChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)\n            writeChunk(destination, importMapChunks[i$jscomp$0]);\n          importMapChunks.length = 0;\n          renderState.bootstrapScripts.forEach(flushResource, destination);\n          renderState.scripts.forEach(flushResource, destination);\n          renderState.scripts.clear();\n          renderState.bulkPreloads.forEach(flushResource, destination);\n          renderState.bulkPreloads.clear();\n          var hoistableChunks = renderState.hoistableChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)\n            writeChunk(destination, hoistableChunks[i$jscomp$0]);\n          for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {\n            var segments = completedPreambleSegments[renderState];\n            for (preamble = 0; preamble < segments.length; preamble++)\n              flushSegment(request, destination, segments[preamble], null);\n          }\n          var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n          (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag(\"head\"));\n          var bodyChunks = preamble$jscomp$0.bodyChunks;\n          if (bodyChunks)\n            for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)\n              writeChunk(destination, bodyChunks[completedPreambleSegments]);\n          flushSegment(request, destination, completedRootSegment, null);\n          request.completedRootSegment = null;\n          writeBootstrap(destination, request.renderState);\n        }\n        var renderState$jscomp$0 = request.renderState;\n        completedRootSegment = 0;\n        var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n        for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)\n          writeChunk(destination, viewportChunks$jscomp$0[completedRootSegment]);\n        viewportChunks$jscomp$0.length = 0;\n        renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n        renderState$jscomp$0.preconnects.clear();\n        renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n        renderState$jscomp$0.fontPreloads.clear();\n        renderState$jscomp$0.highImagePreloads.forEach(\n          flushResource,\n          destination\n        );\n        renderState$jscomp$0.highImagePreloads.clear();\n        renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n        renderState$jscomp$0.scripts.forEach(flushResource, destination);\n        renderState$jscomp$0.scripts.clear();\n        renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n        renderState$jscomp$0.bulkPreloads.clear();\n        var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n        for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)\n          writeChunk(destination, hoistableChunks$jscomp$0[completedRootSegment]);\n        hoistableChunks$jscomp$0.length = 0;\n        var clientRenderedBoundaries = request.clientRenderedBoundaries;\n        for (i = 0; i < clientRenderedBoundaries.length; i++) {\n          var boundary = clientRenderedBoundaries[i];\n          renderState$jscomp$0 = destination;\n          var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id2 = boundary.rootSegmentID, errorDigest = boundary.errorDigest;\n          writeChunk(\n            renderState$jscomp$0,\n            renderState$jscomp$1.startInlineScript\n          );\n          0 === (resumableState.instructions & 4) ? (resumableState.instructions |= 4, writeChunk(renderState$jscomp$0, clientRenderScript1Full)) : writeChunk(renderState$jscomp$0, clientRenderScript1Partial);\n          writeChunk(renderState$jscomp$0, renderState$jscomp$1.boundaryPrefix);\n          writeChunk(renderState$jscomp$0, stringToChunk(id2.toString(16)));\n          writeChunk(renderState$jscomp$0, clientRenderScript1A);\n          errorDigest && (writeChunk(\n            renderState$jscomp$0,\n            clientRenderErrorScriptArgInterstitial\n          ), writeChunk(\n            renderState$jscomp$0,\n            stringToChunk(\n              escapeJSStringsForInstructionScripts(errorDigest || \"\")\n            )\n          ));\n          var JSCompiler_inline_result = writeChunkAndReturn(\n            renderState$jscomp$0,\n            clientRenderScriptEnd\n          );\n          if (!JSCompiler_inline_result) {\n            request.destination = null;\n            i++;\n            clientRenderedBoundaries.splice(0, i);\n            return;\n          }\n        }\n        clientRenderedBoundaries.splice(0, i);\n        var completedBoundaries = request.completedBoundaries;\n        for (i = 0; i < completedBoundaries.length; i++)\n          if (!flushCompletedBoundary(request, destination, completedBoundaries[i])) {\n            request.destination = null;\n            i++;\n            completedBoundaries.splice(0, i);\n            return;\n          }\n        completedBoundaries.splice(0, i);\n        completeWriting(destination);\n        currentView = new Uint8Array(2048);\n        writtenBytes = 0;\n        var partialBoundaries = request.partialBoundaries;\n        for (i = 0; i < partialBoundaries.length; i++) {\n          var boundary$51 = partialBoundaries[i];\n          a: {\n            clientRenderedBoundaries = request;\n            boundary = destination;\n            var completedSegments = boundary$51.completedSegments;\n            for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)\n              if (!flushPartiallyCompletedSegment(\n                clientRenderedBoundaries,\n                boundary,\n                boundary$51,\n                completedSegments[JSCompiler_inline_result]\n              )) {\n                JSCompiler_inline_result++;\n                completedSegments.splice(0, JSCompiler_inline_result);\n                var JSCompiler_inline_result$jscomp$0 = false;\n                break a;\n              }\n            completedSegments.splice(0, JSCompiler_inline_result);\n            JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n              boundary,\n              boundary$51.contentState,\n              clientRenderedBoundaries.renderState\n            );\n          }\n          if (!JSCompiler_inline_result$jscomp$0) {\n            request.destination = null;\n            i++;\n            partialBoundaries.splice(0, i);\n            return;\n          }\n        }\n        partialBoundaries.splice(0, i);\n        var largeBoundaries = request.completedBoundaries;\n        for (i = 0; i < largeBoundaries.length; i++)\n          if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {\n            request.destination = null;\n            i++;\n            largeBoundaries.splice(0, i);\n            return;\n          }\n        largeBoundaries.splice(0, i);\n      }\n    } finally {\n      0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i = request.resumableState, i.hasBody && writeChunk(destination, endChunkForTag(\"body\")), i.hasHtml && writeChunk(destination, endChunkForTag(\"html\")), completeWriting(destination), request.status = 14, destination.close(), request.destination = null) : completeWriting(destination);\n    }\n  }\n  __name(flushCompletedQueues, \"flushCompletedQueues\");\n  function startWork(request) {\n    request.flushScheduled = null !== request.destination;\n    supportsRequestStorage ? scheduleMicrotask(function() {\n      return requestStorage.run(request, performWork, request);\n    }) : scheduleMicrotask(function() {\n      return performWork(request);\n    });\n    setTimeout(function() {\n      10 === request.status && (request.status = 11);\n      null === request.trackedPostpones && (supportsRequestStorage ? requestStorage.run(\n        request,\n        enqueueEarlyPreloadsAfterInitialWork,\n        request\n      ) : enqueueEarlyPreloadsAfterInitialWork(request));\n    }, 0);\n  }\n  __name(startWork, \"startWork\");\n  function enqueueEarlyPreloadsAfterInitialWork(request) {\n    safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);\n  }\n  __name(enqueueEarlyPreloadsAfterInitialWork, \"enqueueEarlyPreloadsAfterInitialWork\");\n  function enqueueFlush(request) {\n    false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, setTimeout(function() {\n      var destination = request.destination;\n      destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;\n    }, 0));\n  }\n  __name(enqueueFlush, \"enqueueFlush\");\n  function startFlowing(request, destination) {\n    if (13 === request.status)\n      request.status = 14, closeWithError(destination, request.fatalError);\n    else if (14 !== request.status && null === request.destination) {\n      request.destination = destination;\n      try {\n        flushCompletedQueues(request, destination);\n      } catch (error4) {\n        logRecoverableError(request, error4, {}), fatalError(request, error4);\n      }\n    }\n  }\n  __name(startFlowing, \"startFlowing\");\n  function abort2(request, reason) {\n    if (11 === request.status || 10 === request.status) request.status = 12;\n    try {\n      var abortableTasks = request.abortableTasks;\n      if (0 < abortableTasks.size) {\n        var error4 = void 0 === reason ? Error(\"The render was aborted by the server without a reason.\") : \"object\" === typeof reason && null !== reason && \"function\" === typeof reason.then ? Error(\"The render was aborted by the server with a promise.\") : reason;\n        request.fatalError = error4;\n        abortableTasks.forEach(function(task) {\n          return abortTask(task, request, error4);\n        });\n        abortableTasks.clear();\n      }\n      null !== request.destination && flushCompletedQueues(request, request.destination);\n    } catch (error$53) {\n      logRecoverableError(request, error$53, {}), fatalError(request, error$53);\n    }\n  }\n  __name(abort2, \"abort\");\n  function ensureCorrectIsomorphicReactVersion() {\n    var isomorphicReactPackageVersion = React2.version;\n    if (\"19.1.0\" !== isomorphicReactPackageVersion)\n      throw Error(\n        'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' + (isomorphicReactPackageVersion + \"\\n  - react-dom:  19.1.0\\nLearn more: https://react.dev/warnings/version-mismatch\")\n      );\n  }\n  __name(ensureCorrectIsomorphicReactVersion, \"ensureCorrectIsomorphicReactVersion\");\n  ensureCorrectIsomorphicReactVersion();\n  ensureCorrectIsomorphicReactVersion();\n  reactDomServer_edge_production.prerender = function(children, options) {\n    return new Promise(function(resolve, reject) {\n      var onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;\n      onHeaders && (onHeadersImpl = /* @__PURE__ */ __name(function(headersDescriptor) {\n        onHeaders(new Headers(headersDescriptor));\n      }, \"onHeadersImpl\"));\n      var resources = createResumableState(\n        options ? options.identifierPrefix : void 0,\n        options ? options.unstable_externalRuntimeSrc : void 0,\n        options ? options.bootstrapScriptContent : void 0,\n        options ? options.bootstrapScripts : void 0,\n        options ? options.bootstrapModules : void 0\n      ), request = createPrerenderRequest(\n        children,\n        resources,\n        createRenderState(\n          resources,\n          void 0,\n          options ? options.unstable_externalRuntimeSrc : void 0,\n          options ? options.importMap : void 0,\n          onHeadersImpl,\n          options ? options.maxHeadersLength : void 0\n        ),\n        createRootFormatContext(options ? options.namespaceURI : void 0),\n        options ? options.progressiveChunkSize : void 0,\n        options ? options.onError : void 0,\n        function() {\n          var result = {\n            prelude: new ReadableStream(\n              {\n                type: \"bytes\",\n                pull: /* @__PURE__ */ __name(function(controller) {\n                  startFlowing(request, controller);\n                }, \"pull\"),\n                cancel: /* @__PURE__ */ __name(function(reason) {\n                  request.destination = null;\n                  abort2(request, reason);\n                }, \"cancel\")\n              },\n              { highWaterMark: 0 }\n            )\n          };\n          resolve(result);\n        },\n        void 0,\n        void 0,\n        reject,\n        options ? options.onPostpone : void 0\n      );\n      if (options && options.signal) {\n        var signal2 = options.signal;\n        if (signal2.aborted) abort2(request, signal2.reason);\n        else {\n          var listener = /* @__PURE__ */ __name(function() {\n            abort2(request, signal2.reason);\n            signal2.removeEventListener(\"abort\", listener);\n          }, \"listener\");\n          signal2.addEventListener(\"abort\", listener);\n        }\n      }\n      startWork(request);\n    });\n  };\n  reactDomServer_edge_production.renderToReadableStream = function(children, options) {\n    return new Promise(function(resolve, reject) {\n      var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {\n        onAllReady = res;\n        onFatalError = rej;\n      }), onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;\n      onHeaders && (onHeadersImpl = /* @__PURE__ */ __name(function(headersDescriptor) {\n        onHeaders(new Headers(headersDescriptor));\n      }, \"onHeadersImpl\"));\n      var resumableState = createResumableState(\n        options ? options.identifierPrefix : void 0,\n        options ? options.unstable_externalRuntimeSrc : void 0,\n        options ? options.bootstrapScriptContent : void 0,\n        options ? options.bootstrapScripts : void 0,\n        options ? options.bootstrapModules : void 0\n      ), request = createRequest2(\n        children,\n        resumableState,\n        createRenderState(\n          resumableState,\n          options ? options.nonce : void 0,\n          options ? options.unstable_externalRuntimeSrc : void 0,\n          options ? options.importMap : void 0,\n          onHeadersImpl,\n          options ? options.maxHeadersLength : void 0\n        ),\n        createRootFormatContext(options ? options.namespaceURI : void 0),\n        options ? options.progressiveChunkSize : void 0,\n        options ? options.onError : void 0,\n        onAllReady,\n        function() {\n          var stream = new ReadableStream(\n            {\n              type: \"bytes\",\n              pull: /* @__PURE__ */ __name(function(controller) {\n                startFlowing(request, controller);\n              }, \"pull\"),\n              cancel: /* @__PURE__ */ __name(function(reason) {\n                request.destination = null;\n                abort2(request, reason);\n              }, \"cancel\")\n            },\n            { highWaterMark: 0 }\n          );\n          stream.allReady = allReady;\n          resolve(stream);\n        },\n        function(error4) {\n          allReady.catch(function() {\n          });\n          reject(error4);\n        },\n        onFatalError,\n        options ? options.onPostpone : void 0,\n        options ? options.formState : void 0\n      );\n      if (options && options.signal) {\n        var signal2 = options.signal;\n        if (signal2.aborted) abort2(request, signal2.reason);\n        else {\n          var listener = /* @__PURE__ */ __name(function() {\n            abort2(request, signal2.reason);\n            signal2.removeEventListener(\"abort\", listener);\n          }, \"listener\");\n          signal2.addEventListener(\"abort\", listener);\n        }\n      }\n      startWork(request);\n    });\n  };\n  reactDomServer_edge_production.version = \"19.1.0\";\n  return reactDomServer_edge_production;\n}\nfunction requireReactDomServerLegacy_browser_production() {\n  if (hasRequiredReactDomServerLegacy_browser_production) return reactDomServerLegacy_browser_production;\n  hasRequiredReactDomServerLegacy_browser_production = 1;\n  var React2 = requireReact(), ReactDOM2 = requireReactDom();\n  function formatProdErrorMessage(code) {\n    var url = \"https://react.dev/errors/\" + code;\n    if (1 < arguments.length) {\n      url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n      for (var i = 2; i < arguments.length; i++)\n        url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n    }\n    return \"Minified React error #\" + code + \"; visit \" + url + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\";\n  }\n  __name(formatProdErrorMessage, \"formatProdErrorMessage\");\n  var REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_SCOPE_TYPE = Symbol.for(\"react.scope\"), REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\"), REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, isArrayImpl = Array.isArray;\n  function murmurhash3_32_gc(key, seed) {\n    var remainder = key.length & 3;\n    var bytes = key.length - remainder;\n    var h1 = seed;\n    for (seed = 0; seed < bytes; ) {\n      var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;\n      ++seed;\n      k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n      h1 = h1 << 13 | h1 >>> 19;\n      h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;\n      h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);\n    }\n    k1 = 0;\n    switch (remainder) {\n      case 3:\n        k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;\n      case 2:\n        k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;\n      case 1:\n        k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;\n    }\n    h1 ^= key.length;\n    h1 ^= h1 >>> 16;\n    h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;\n    h1 ^= h1 >>> 13;\n    h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;\n    return (h1 ^ h1 >>> 16) >>> 0;\n  }\n  __name(murmurhash3_32_gc, \"murmurhash3_32_gc\");\n  var assign = Object.assign, hasOwnProperty2 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n    \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};\n  function isAttributeNameSafe(attributeName) {\n    if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))\n      return true;\n    if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) return false;\n    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n      return validatedAttributeNameCache[attributeName] = true;\n    illegalAttributeNameCache[attributeName] = true;\n    return false;\n  }\n  __name(isAttributeNameSafe, \"isAttributeNameSafe\");\n  var unitlessNumbers = new Set(\n    \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n      \" \"\n    )\n  ), aliases = /* @__PURE__ */ new Map([\n    [\"acceptCharset\", \"accept-charset\"],\n    [\"htmlFor\", \"for\"],\n    [\"httpEquiv\", \"http-equiv\"],\n    [\"crossOrigin\", \"crossorigin\"],\n    [\"accentHeight\", \"accent-height\"],\n    [\"alignmentBaseline\", \"alignment-baseline\"],\n    [\"arabicForm\", \"arabic-form\"],\n    [\"baselineShift\", \"baseline-shift\"],\n    [\"capHeight\", \"cap-height\"],\n    [\"clipPath\", \"clip-path\"],\n    [\"clipRule\", \"clip-rule\"],\n    [\"colorInterpolation\", \"color-interpolation\"],\n    [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n    [\"colorProfile\", \"color-profile\"],\n    [\"colorRendering\", \"color-rendering\"],\n    [\"dominantBaseline\", \"dominant-baseline\"],\n    [\"enableBackground\", \"enable-background\"],\n    [\"fillOpacity\", \"fill-opacity\"],\n    [\"fillRule\", \"fill-rule\"],\n    [\"floodColor\", \"flood-color\"],\n    [\"floodOpacity\", \"flood-opacity\"],\n    [\"fontFamily\", \"font-family\"],\n    [\"fontSize\", \"font-size\"],\n    [\"fontSizeAdjust\", \"font-size-adjust\"],\n    [\"fontStretch\", \"font-stretch\"],\n    [\"fontStyle\", \"font-style\"],\n    [\"fontVariant\", \"font-variant\"],\n    [\"fontWeight\", \"font-weight\"],\n    [\"glyphName\", \"glyph-name\"],\n    [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n    [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n    [\"horizAdvX\", \"horiz-adv-x\"],\n    [\"horizOriginX\", \"horiz-origin-x\"],\n    [\"imageRendering\", \"image-rendering\"],\n    [\"letterSpacing\", \"letter-spacing\"],\n    [\"lightingColor\", \"lighting-color\"],\n    [\"markerEnd\", \"marker-end\"],\n    [\"markerMid\", \"marker-mid\"],\n    [\"markerStart\", \"marker-start\"],\n    [\"overlinePosition\", \"overline-position\"],\n    [\"overlineThickness\", \"overline-thickness\"],\n    [\"paintOrder\", \"paint-order\"],\n    [\"panose-1\", \"panose-1\"],\n    [\"pointerEvents\", \"pointer-events\"],\n    [\"renderingIntent\", \"rendering-intent\"],\n    [\"shapeRendering\", \"shape-rendering\"],\n    [\"stopColor\", \"stop-color\"],\n    [\"stopOpacity\", \"stop-opacity\"],\n    [\"strikethroughPosition\", \"strikethrough-position\"],\n    [\"strikethroughThickness\", \"strikethrough-thickness\"],\n    [\"strokeDasharray\", \"stroke-dasharray\"],\n    [\"strokeDashoffset\", \"stroke-dashoffset\"],\n    [\"strokeLinecap\", \"stroke-linecap\"],\n    [\"strokeLinejoin\", \"stroke-linejoin\"],\n    [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n    [\"strokeOpacity\", \"stroke-opacity\"],\n    [\"strokeWidth\", \"stroke-width\"],\n    [\"textAnchor\", \"text-anchor\"],\n    [\"textDecoration\", \"text-decoration\"],\n    [\"textRendering\", \"text-rendering\"],\n    [\"transformOrigin\", \"transform-origin\"],\n    [\"underlinePosition\", \"underline-position\"],\n    [\"underlineThickness\", \"underline-thickness\"],\n    [\"unicodeBidi\", \"unicode-bidi\"],\n    [\"unicodeRange\", \"unicode-range\"],\n    [\"unitsPerEm\", \"units-per-em\"],\n    [\"vAlphabetic\", \"v-alphabetic\"],\n    [\"vHanging\", \"v-hanging\"],\n    [\"vIdeographic\", \"v-ideographic\"],\n    [\"vMathematical\", \"v-mathematical\"],\n    [\"vectorEffect\", \"vector-effect\"],\n    [\"vertAdvY\", \"vert-adv-y\"],\n    [\"vertOriginX\", \"vert-origin-x\"],\n    [\"vertOriginY\", \"vert-origin-y\"],\n    [\"wordSpacing\", \"word-spacing\"],\n    [\"writingMode\", \"writing-mode\"],\n    [\"xmlnsXlink\", \"xmlns:xlink\"],\n    [\"xHeight\", \"x-height\"]\n  ]), matchHtmlRegExp = /[\"'&<>]/;\n  function escapeTextForBrowser(text) {\n    if (\"boolean\" === typeof text || \"number\" === typeof text || \"bigint\" === typeof text)\n      return \"\" + text;\n    text = \"\" + text;\n    var match = matchHtmlRegExp.exec(text);\n    if (match) {\n      var html2 = \"\", index, lastIndex = 0;\n      for (index = match.index; index < text.length; index++) {\n        switch (text.charCodeAt(index)) {\n          case 34:\n            match = \"&quot;\";\n            break;\n          case 38:\n            match = \"&amp;\";\n            break;\n          case 39:\n            match = \"&#x27;\";\n            break;\n          case 60:\n            match = \"&lt;\";\n            break;\n          case 62:\n            match = \"&gt;\";\n            break;\n          default:\n            continue;\n        }\n        lastIndex !== index && (html2 += text.slice(lastIndex, index));\n        lastIndex = index + 1;\n        html2 += match;\n      }\n      text = lastIndex !== index ? html2 + text.slice(lastIndex, index) : html2;\n    }\n    return text;\n  }\n  __name(escapeTextForBrowser, \"escapeTextForBrowser\");\n  var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i;\n  function sanitizeURL(url) {\n    return isJavaScriptProtocol.test(\"\" + url) ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\" : url;\n  }\n  __name(sanitizeURL, \"sanitizeURL\");\n  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {\n    pending: false,\n    data: null,\n    method: null,\n    action: null\n  }, previousDispatcher = ReactDOMSharedInternals.d;\n  ReactDOMSharedInternals.d = {\n    f: previousDispatcher.f,\n    r: previousDispatcher.r,\n    D: prefetchDNS,\n    C: preconnect,\n    L: preload,\n    m: preloadModule,\n    X: preinitScript,\n    S: preinitStyle,\n    M: preinitModuleScript\n  };\n  var PRELOAD_NO_CREDS = [], scriptRegex = /(<\\/|<)(s)(cript)/gi;\n  function scriptReplacer(match, prefix2, s2, suffix2) {\n    return \"\" + prefix2 + (\"s\" === s2 ? \"\\\\u0073\" : \"\\\\u0053\") + suffix2;\n  }\n  __name(scriptReplacer, \"scriptReplacer\");\n  function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n    return {\n      idPrefix: void 0 === identifierPrefix ? \"\" : identifierPrefix,\n      nextFormID: 0,\n      streamingFormat: 0,\n      bootstrapScriptContent,\n      bootstrapScripts,\n      bootstrapModules,\n      instructions: 0,\n      hasBody: false,\n      hasHtml: false,\n      unknownResources: {},\n      dnsResources: {},\n      connectResources: { default: {}, anonymous: {}, credentials: {} },\n      imageResources: {},\n      styleResources: {},\n      scriptResources: {},\n      moduleUnknownResources: {},\n      moduleScriptResources: {}\n    };\n  }\n  __name(createResumableState, \"createResumableState\");\n  function createPreambleState() {\n    return {\n      htmlChunks: null,\n      headChunks: null,\n      bodyChunks: null,\n      contribution: 0\n    };\n  }\n  __name(createPreambleState, \"createPreambleState\");\n  function createFormatContext(insertionMode, selectedValue, tagScope) {\n    return {\n      insertionMode,\n      selectedValue,\n      tagScope\n    };\n  }\n  __name(createFormatContext, \"createFormatContext\");\n  function getChildFormatContext(parentContext, type2, props) {\n    switch (type2) {\n      case \"noscript\":\n        return createFormatContext(2, null, parentContext.tagScope | 1);\n      case \"select\":\n        return createFormatContext(\n          2,\n          null != props.value ? props.value : props.defaultValue,\n          parentContext.tagScope\n        );\n      case \"svg\":\n        return createFormatContext(4, null, parentContext.tagScope);\n      case \"picture\":\n        return createFormatContext(2, null, parentContext.tagScope | 2);\n      case \"math\":\n        return createFormatContext(5, null, parentContext.tagScope);\n      case \"foreignObject\":\n        return createFormatContext(2, null, parentContext.tagScope);\n      case \"table\":\n        return createFormatContext(6, null, parentContext.tagScope);\n      case \"thead\":\n      case \"tbody\":\n      case \"tfoot\":\n        return createFormatContext(7, null, parentContext.tagScope);\n      case \"colgroup\":\n        return createFormatContext(9, null, parentContext.tagScope);\n      case \"tr\":\n        return createFormatContext(8, null, parentContext.tagScope);\n      case \"head\":\n        if (2 > parentContext.insertionMode)\n          return createFormatContext(3, null, parentContext.tagScope);\n        break;\n      case \"html\":\n        if (0 === parentContext.insertionMode)\n          return createFormatContext(1, null, parentContext.tagScope);\n    }\n    return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, parentContext.tagScope) : parentContext;\n  }\n  __name(getChildFormatContext, \"getChildFormatContext\");\n  var styleNameCache = /* @__PURE__ */ new Map();\n  function pushStyleAttribute(target, style2) {\n    if (\"object\" !== typeof style2) throw Error(formatProdErrorMessage(62));\n    var isFirst = true, styleName;\n    for (styleName in style2)\n      if (hasOwnProperty2.call(style2, styleName)) {\n        var styleValue = style2[styleName];\n        if (null != styleValue && \"boolean\" !== typeof styleValue && \"\" !== styleValue) {\n          if (0 === styleName.indexOf(\"--\")) {\n            var nameChunk = escapeTextForBrowser(styleName);\n            styleValue = escapeTextForBrowser((\"\" + styleValue).trim());\n          } else\n            nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = escapeTextForBrowser(\n              styleName.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\")\n            ), styleNameCache.set(styleName, nameChunk)), styleValue = \"number\" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? \"\" + styleValue : styleValue + \"px\" : escapeTextForBrowser((\"\" + styleValue).trim());\n          isFirst ? (isFirst = false, target.push(' style=\"', nameChunk, \":\", styleValue)) : target.push(\";\", nameChunk, \":\", styleValue);\n        }\n      }\n    isFirst || target.push('\"');\n  }\n  __name(pushStyleAttribute, \"pushStyleAttribute\");\n  function pushBooleanAttribute(target, name, value2) {\n    value2 && \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\" \", name, '=\"\"');\n  }\n  __name(pushBooleanAttribute, \"pushBooleanAttribute\");\n  function pushStringAttribute(target, name, value2) {\n    \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && \"boolean\" !== typeof value2 && target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n  }\n  __name(pushStringAttribute, \"pushStringAttribute\");\n  var actionJavaScriptURL = escapeTextForBrowser(\n    \"javascript:throw new Error('React form unexpectedly submitted.')\"\n  );\n  function pushAdditionalFormField(value2, key) {\n    this.push('<input type=\"hidden\"');\n    validateAdditionalFormField(value2);\n    pushStringAttribute(this, \"name\", key);\n    pushStringAttribute(this, \"value\", value2);\n    this.push(\"/>\");\n  }\n  __name(pushAdditionalFormField, \"pushAdditionalFormField\");\n  function validateAdditionalFormField(value2) {\n    if (\"string\" !== typeof value2) throw Error(formatProdErrorMessage(480));\n  }\n  __name(validateAdditionalFormField, \"validateAdditionalFormField\");\n  function getCustomFormFields(resumableState, formAction) {\n    if (\"function\" === typeof formAction.$$FORM_ACTION) {\n      var id2 = resumableState.nextFormID++;\n      resumableState = resumableState.idPrefix + id2;\n      try {\n        var customFields = formAction.$$FORM_ACTION(resumableState);\n        if (customFields) {\n          var formData = customFields.data;\n          null != formData && formData.forEach(validateAdditionalFormField);\n        }\n        return customFields;\n      } catch (x) {\n        if (\"object\" === typeof x && null !== x && \"function\" === typeof x.then)\n          throw x;\n      }\n    }\n    return null;\n  }\n  __name(getCustomFormFields, \"getCustomFormFields\");\n  function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {\n    var formData = null;\n    if (\"function\" === typeof formAction) {\n      var customFields = getCustomFormFields(resumableState, formAction);\n      null !== customFields ? (name = customFields.name, formAction = customFields.action || \"\", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(\" \", \"formAction\", '=\"', actionJavaScriptURL, '\"'), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));\n    }\n    null != name && pushAttribute(target, \"name\", name);\n    null != formAction && pushAttribute(target, \"formAction\", formAction);\n    null != formEncType && pushAttribute(target, \"formEncType\", formEncType);\n    null != formMethod && pushAttribute(target, \"formMethod\", formMethod);\n    null != formTarget && pushAttribute(target, \"formTarget\", formTarget);\n    return formData;\n  }\n  __name(pushFormActionAttribute, \"pushFormActionAttribute\");\n  function pushAttribute(target, name, value2) {\n    switch (name) {\n      case \"className\":\n        pushStringAttribute(target, \"class\", value2);\n        break;\n      case \"tabIndex\":\n        pushStringAttribute(target, \"tabindex\", value2);\n        break;\n      case \"dir\":\n      case \"role\":\n      case \"viewBox\":\n      case \"width\":\n      case \"height\":\n        pushStringAttribute(target, name, value2);\n        break;\n      case \"style\":\n        pushStyleAttribute(target, value2);\n        break;\n      case \"src\":\n      case \"href\":\n        if (\"\" === value2) break;\n      case \"action\":\n      case \"formAction\":\n        if (null == value2 || \"function\" === typeof value2 || \"symbol\" === typeof value2 || \"boolean\" === typeof value2)\n          break;\n        value2 = sanitizeURL(\"\" + value2);\n        target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n        break;\n      case \"defaultValue\":\n      case \"defaultChecked\":\n      case \"innerHTML\":\n      case \"suppressContentEditableWarning\":\n      case \"suppressHydrationWarning\":\n      case \"ref\":\n        break;\n      case \"autoFocus\":\n      case \"multiple\":\n      case \"muted\":\n        pushBooleanAttribute(target, name.toLowerCase(), value2);\n        break;\n      case \"xlinkHref\":\n        if (\"function\" === typeof value2 || \"symbol\" === typeof value2 || \"boolean\" === typeof value2)\n          break;\n        value2 = sanitizeURL(\"\" + value2);\n        target.push(\" \", \"xlink:href\", '=\"', escapeTextForBrowser(value2), '\"');\n        break;\n      case \"contentEditable\":\n      case \"spellCheck\":\n      case \"draggable\":\n      case \"value\":\n      case \"autoReverse\":\n      case \"externalResourcesRequired\":\n      case \"focusable\":\n      case \"preserveAlpha\":\n        \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n        break;\n      case \"inert\":\n      case \"allowFullScreen\":\n      case \"async\":\n      case \"autoPlay\":\n      case \"controls\":\n      case \"default\":\n      case \"defer\":\n      case \"disabled\":\n      case \"disablePictureInPicture\":\n      case \"disableRemotePlayback\":\n      case \"formNoValidate\":\n      case \"hidden\":\n      case \"loop\":\n      case \"noModule\":\n      case \"noValidate\":\n      case \"open\":\n      case \"playsInline\":\n      case \"readOnly\":\n      case \"required\":\n      case \"reversed\":\n      case \"scoped\":\n      case \"seamless\":\n      case \"itemScope\":\n        value2 && \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\" \", name, '=\"\"');\n        break;\n      case \"capture\":\n      case \"download\":\n        true === value2 ? target.push(\" \", name, '=\"\"') : false !== value2 && \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n        break;\n      case \"cols\":\n      case \"rows\":\n      case \"size\":\n      case \"span\":\n        \"function\" !== typeof value2 && \"symbol\" !== typeof value2 && !isNaN(value2) && 1 <= value2 && target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n        break;\n      case \"rowSpan\":\n      case \"start\":\n        \"function\" === typeof value2 || \"symbol\" === typeof value2 || isNaN(value2) || target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n        break;\n      case \"xlinkActuate\":\n        pushStringAttribute(target, \"xlink:actuate\", value2);\n        break;\n      case \"xlinkArcrole\":\n        pushStringAttribute(target, \"xlink:arcrole\", value2);\n        break;\n      case \"xlinkRole\":\n        pushStringAttribute(target, \"xlink:role\", value2);\n        break;\n      case \"xlinkShow\":\n        pushStringAttribute(target, \"xlink:show\", value2);\n        break;\n      case \"xlinkTitle\":\n        pushStringAttribute(target, \"xlink:title\", value2);\n        break;\n      case \"xlinkType\":\n        pushStringAttribute(target, \"xlink:type\", value2);\n        break;\n      case \"xmlBase\":\n        pushStringAttribute(target, \"xml:base\", value2);\n        break;\n      case \"xmlLang\":\n        pushStringAttribute(target, \"xml:lang\", value2);\n        break;\n      case \"xmlSpace\":\n        pushStringAttribute(target, \"xml:space\", value2);\n        break;\n      default:\n        if (!(2 < name.length) || \"o\" !== name[0] && \"O\" !== name[0] || \"n\" !== name[1] && \"N\" !== name[1]) {\n          if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {\n            switch (typeof value2) {\n              case \"function\":\n              case \"symbol\":\n                return;\n              case \"boolean\":\n                var prefix$8 = name.toLowerCase().slice(0, 5);\n                if (\"data-\" !== prefix$8 && \"aria-\" !== prefix$8) return;\n            }\n            target.push(\" \", name, '=\"', escapeTextForBrowser(value2), '\"');\n          }\n        }\n    }\n  }\n  __name(pushAttribute, \"pushAttribute\");\n  function pushInnerHTML(target, innerHTML, children) {\n    if (null != innerHTML) {\n      if (null != children) throw Error(formatProdErrorMessage(60));\n      if (\"object\" !== typeof innerHTML || !(\"__html\" in innerHTML))\n        throw Error(formatProdErrorMessage(61));\n      innerHTML = innerHTML.__html;\n      null !== innerHTML && void 0 !== innerHTML && target.push(\"\" + innerHTML);\n    }\n  }\n  __name(pushInnerHTML, \"pushInnerHTML\");\n  function flattenOptionChildren(children) {\n    var content = \"\";\n    React2.Children.forEach(children, function(child) {\n      null != child && (content += child);\n    });\n    return content;\n  }\n  __name(flattenOptionChildren, \"flattenOptionChildren\");\n  function injectFormReplayingRuntime(resumableState, renderState) {\n    0 === (resumableState.instructions & 16) && (resumableState.instructions |= 16, renderState.bootstrapChunks.unshift(\n      renderState.startInlineScript,\n      `addEventListener(\"submit\",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute(\"formAction\");null!=f&&(e=f,b=null)}\"javascript:throw new Error('React form unexpectedly submitted.')\"===e&&(a.preventDefault(),b?(a=document.createElement(\"input\"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`,\n      \"</script>\"\n    ));\n  }\n  __name(injectFormReplayingRuntime, \"injectFormReplayingRuntime\");\n  function pushLinkImpl(target, props) {\n    target.push(startChunkForTag(\"link\"));\n    for (var propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              throw Error(formatProdErrorMessage(399, \"link\"));\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(\"/>\");\n    return null;\n  }\n  __name(pushLinkImpl, \"pushLinkImpl\");\n  var styleRegex = /(<\\/|<)(s)(tyle)/gi;\n  function styleReplacer(match, prefix2, s2, suffix2) {\n    return \"\" + prefix2 + (\"s\" === s2 ? \"\\\\73 \" : \"\\\\53 \") + suffix2;\n  }\n  __name(styleReplacer, \"styleReplacer\");\n  function pushSelfClosing(target, props, tag) {\n    target.push(startChunkForTag(tag));\n    for (var propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              throw Error(formatProdErrorMessage(399, tag));\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(\"/>\");\n    return null;\n  }\n  __name(pushSelfClosing, \"pushSelfClosing\");\n  function pushTitleImpl(target, props) {\n    target.push(startChunkForTag(\"title\"));\n    var children = null, innerHTML = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              children = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(\">\");\n    props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;\n    \"function\" !== typeof props && \"symbol\" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser(\"\" + props));\n    pushInnerHTML(target, innerHTML, children);\n    target.push(endChunkForTag(\"title\"));\n    return null;\n  }\n  __name(pushTitleImpl, \"pushTitleImpl\");\n  function pushScriptImpl(target, props) {\n    target.push(startChunkForTag(\"script\"));\n    var children = null, innerHTML = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              children = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(\">\");\n    pushInnerHTML(target, innerHTML, children);\n    \"string\" === typeof children && target.push((\"\" + children).replace(scriptRegex, scriptReplacer));\n    target.push(endChunkForTag(\"script\"));\n    return null;\n  }\n  __name(pushScriptImpl, \"pushScriptImpl\");\n  function pushStartSingletonElement(target, props, tag) {\n    target.push(startChunkForTag(tag));\n    var innerHTML = tag = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              tag = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(\">\");\n    pushInnerHTML(target, innerHTML, tag);\n    return tag;\n  }\n  __name(pushStartSingletonElement, \"pushStartSingletonElement\");\n  function pushStartGenericElement(target, props, tag) {\n    target.push(startChunkForTag(tag));\n    var innerHTML = tag = null, propKey;\n    for (propKey in props)\n      if (hasOwnProperty2.call(props, propKey)) {\n        var propValue = props[propKey];\n        if (null != propValue)\n          switch (propKey) {\n            case \"children\":\n              tag = propValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              innerHTML = propValue;\n              break;\n            default:\n              pushAttribute(target, propKey, propValue);\n          }\n      }\n    target.push(\">\");\n    pushInnerHTML(target, innerHTML, tag);\n    return \"string\" === typeof tag ? (target.push(escapeTextForBrowser(tag)), null) : tag;\n  }\n  __name(pushStartGenericElement, \"pushStartGenericElement\");\n  var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();\n  function startChunkForTag(tag) {\n    var tagStartChunk = validatedTagCache.get(tag);\n    if (void 0 === tagStartChunk) {\n      if (!VALID_TAG_REGEX.test(tag))\n        throw Error(formatProdErrorMessage(65, tag));\n      tagStartChunk = \"<\" + tag;\n      validatedTagCache.set(tag, tagStartChunk);\n    }\n    return tagStartChunk;\n  }\n  __name(startChunkForTag, \"startChunkForTag\");\n  function pushStartInstance(target$jscomp$0, type2, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded, isFallback) {\n    switch (type2) {\n      case \"div\":\n      case \"span\":\n      case \"svg\":\n      case \"path\":\n        break;\n      case \"a\":\n        target$jscomp$0.push(startChunkForTag(\"a\"));\n        var children = null, innerHTML = null, propKey;\n        for (propKey in props)\n          if (hasOwnProperty2.call(props, propKey)) {\n            var propValue = props[propKey];\n            if (null != propValue)\n              switch (propKey) {\n                case \"children\":\n                  children = propValue;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML = propValue;\n                  break;\n                case \"href\":\n                  \"\" === propValue ? pushStringAttribute(target$jscomp$0, \"href\", \"\") : pushAttribute(target$jscomp$0, propKey, propValue);\n                  break;\n                default:\n                  pushAttribute(target$jscomp$0, propKey, propValue);\n              }\n          }\n        target$jscomp$0.push(\">\");\n        pushInnerHTML(target$jscomp$0, innerHTML, children);\n        if (\"string\" === typeof children) {\n          target$jscomp$0.push(escapeTextForBrowser(children));\n          var JSCompiler_inline_result = null;\n        } else JSCompiler_inline_result = children;\n        return JSCompiler_inline_result;\n      case \"g\":\n      case \"p\":\n      case \"li\":\n        break;\n      case \"select\":\n        target$jscomp$0.push(startChunkForTag(\"select\"));\n        var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;\n        for (propKey$jscomp$0 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$0)) {\n            var propValue$jscomp$0 = props[propKey$jscomp$0];\n            if (null != propValue$jscomp$0)\n              switch (propKey$jscomp$0) {\n                case \"children\":\n                  children$jscomp$0 = propValue$jscomp$0;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$0 = propValue$jscomp$0;\n                  break;\n                case \"defaultValue\":\n                case \"value\":\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$0,\n                    propValue$jscomp$0\n                  );\n              }\n          }\n        target$jscomp$0.push(\">\");\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);\n        return children$jscomp$0;\n      case \"option\":\n        var selectedValue = formatContext.selectedValue;\n        target$jscomp$0.push(startChunkForTag(\"option\"));\n        var children$jscomp$1 = null, value2 = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;\n        for (propKey$jscomp$1 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$1)) {\n            var propValue$jscomp$1 = props[propKey$jscomp$1];\n            if (null != propValue$jscomp$1)\n              switch (propKey$jscomp$1) {\n                case \"children\":\n                  children$jscomp$1 = propValue$jscomp$1;\n                  break;\n                case \"selected\":\n                  selected = propValue$jscomp$1;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$1 = propValue$jscomp$1;\n                  break;\n                case \"value\":\n                  value2 = propValue$jscomp$1;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$1,\n                    propValue$jscomp$1\n                  );\n              }\n          }\n        if (null != selectedValue) {\n          var stringValue = null !== value2 ? \"\" + value2 : flattenOptionChildren(children$jscomp$1);\n          if (isArrayImpl(selectedValue))\n            for (var i = 0; i < selectedValue.length; i++) {\n              if (\"\" + selectedValue[i] === stringValue) {\n                target$jscomp$0.push(' selected=\"\"');\n                break;\n              }\n            }\n          else\n            \"\" + selectedValue === stringValue && target$jscomp$0.push(' selected=\"\"');\n        } else selected && target$jscomp$0.push(' selected=\"\"');\n        target$jscomp$0.push(\">\");\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);\n        return children$jscomp$1;\n      case \"textarea\":\n        target$jscomp$0.push(startChunkForTag(\"textarea\"));\n        var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;\n        for (propKey$jscomp$2 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$2)) {\n            var propValue$jscomp$2 = props[propKey$jscomp$2];\n            if (null != propValue$jscomp$2)\n              switch (propKey$jscomp$2) {\n                case \"children\":\n                  children$jscomp$2 = propValue$jscomp$2;\n                  break;\n                case \"value\":\n                  value$jscomp$0 = propValue$jscomp$2;\n                  break;\n                case \"defaultValue\":\n                  defaultValue = propValue$jscomp$2;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(formatProdErrorMessage(91));\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$2,\n                    propValue$jscomp$2\n                  );\n              }\n          }\n        null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);\n        target$jscomp$0.push(\">\");\n        if (null != children$jscomp$2) {\n          if (null != value$jscomp$0) throw Error(formatProdErrorMessage(92));\n          if (isArrayImpl(children$jscomp$2)) {\n            if (1 < children$jscomp$2.length)\n              throw Error(formatProdErrorMessage(93));\n            value$jscomp$0 = \"\" + children$jscomp$2[0];\n          }\n          value$jscomp$0 = \"\" + children$jscomp$2;\n        }\n        \"string\" === typeof value$jscomp$0 && \"\\n\" === value$jscomp$0[0] && target$jscomp$0.push(\"\\n\");\n        null !== value$jscomp$0 && target$jscomp$0.push(escapeTextForBrowser(\"\" + value$jscomp$0));\n        return null;\n      case \"input\":\n        target$jscomp$0.push(startChunkForTag(\"input\"));\n        var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;\n        for (propKey$jscomp$3 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$3)) {\n            var propValue$jscomp$3 = props[propKey$jscomp$3];\n            if (null != propValue$jscomp$3)\n              switch (propKey$jscomp$3) {\n                case \"children\":\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(formatProdErrorMessage(399, \"input\"));\n                case \"name\":\n                  name = propValue$jscomp$3;\n                  break;\n                case \"formAction\":\n                  formAction = propValue$jscomp$3;\n                  break;\n                case \"formEncType\":\n                  formEncType = propValue$jscomp$3;\n                  break;\n                case \"formMethod\":\n                  formMethod = propValue$jscomp$3;\n                  break;\n                case \"formTarget\":\n                  formTarget = propValue$jscomp$3;\n                  break;\n                case \"defaultChecked\":\n                  defaultChecked = propValue$jscomp$3;\n                  break;\n                case \"defaultValue\":\n                  defaultValue$jscomp$0 = propValue$jscomp$3;\n                  break;\n                case \"checked\":\n                  checked = propValue$jscomp$3;\n                  break;\n                case \"value\":\n                  value$jscomp$1 = propValue$jscomp$3;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$3,\n                    propValue$jscomp$3\n                  );\n              }\n          }\n        var formData = pushFormActionAttribute(\n          target$jscomp$0,\n          resumableState,\n          renderState,\n          formAction,\n          formEncType,\n          formMethod,\n          formTarget,\n          name\n        );\n        null !== checked ? pushBooleanAttribute(target$jscomp$0, \"checked\", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, \"checked\", defaultChecked);\n        null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, \"value\", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, \"value\", defaultValue$jscomp$0);\n        target$jscomp$0.push(\"/>\");\n        null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);\n        return null;\n      case \"button\":\n        target$jscomp$0.push(startChunkForTag(\"button\"));\n        var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;\n        for (propKey$jscomp$4 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$4)) {\n            var propValue$jscomp$4 = props[propKey$jscomp$4];\n            if (null != propValue$jscomp$4)\n              switch (propKey$jscomp$4) {\n                case \"children\":\n                  children$jscomp$3 = propValue$jscomp$4;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$2 = propValue$jscomp$4;\n                  break;\n                case \"name\":\n                  name$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formAction\":\n                  formAction$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formEncType\":\n                  formEncType$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formMethod\":\n                  formMethod$jscomp$0 = propValue$jscomp$4;\n                  break;\n                case \"formTarget\":\n                  formTarget$jscomp$0 = propValue$jscomp$4;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$4,\n                    propValue$jscomp$4\n                  );\n              }\n          }\n        var formData$jscomp$0 = pushFormActionAttribute(\n          target$jscomp$0,\n          resumableState,\n          renderState,\n          formAction$jscomp$0,\n          formEncType$jscomp$0,\n          formMethod$jscomp$0,\n          formTarget$jscomp$0,\n          name$jscomp$0\n        );\n        target$jscomp$0.push(\">\");\n        null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);\n        if (\"string\" === typeof children$jscomp$3) {\n          target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));\n          var JSCompiler_inline_result$jscomp$0 = null;\n        } else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;\n        return JSCompiler_inline_result$jscomp$0;\n      case \"form\":\n        target$jscomp$0.push(startChunkForTag(\"form\"));\n        var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;\n        for (propKey$jscomp$5 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$5)) {\n            var propValue$jscomp$5 = props[propKey$jscomp$5];\n            if (null != propValue$jscomp$5)\n              switch (propKey$jscomp$5) {\n                case \"children\":\n                  children$jscomp$4 = propValue$jscomp$5;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$3 = propValue$jscomp$5;\n                  break;\n                case \"action\":\n                  formAction$jscomp$1 = propValue$jscomp$5;\n                  break;\n                case \"encType\":\n                  formEncType$jscomp$1 = propValue$jscomp$5;\n                  break;\n                case \"method\":\n                  formMethod$jscomp$1 = propValue$jscomp$5;\n                  break;\n                case \"target\":\n                  formTarget$jscomp$1 = propValue$jscomp$5;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$5,\n                    propValue$jscomp$5\n                  );\n              }\n          }\n        var formData$jscomp$1 = null, formActionName = null;\n        if (\"function\" === typeof formAction$jscomp$1) {\n          var customFields = getCustomFormFields(\n            resumableState,\n            formAction$jscomp$1\n          );\n          null !== customFields ? (formAction$jscomp$1 = customFields.action || \"\", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(\n            \" \",\n            \"action\",\n            '=\"',\n            actionJavaScriptURL,\n            '\"'\n          ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));\n        }\n        null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, \"action\", formAction$jscomp$1);\n        null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, \"encType\", formEncType$jscomp$1);\n        null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, \"method\", formMethod$jscomp$1);\n        null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, \"target\", formTarget$jscomp$1);\n        target$jscomp$0.push(\">\");\n        null !== formActionName && (target$jscomp$0.push('<input type=\"hidden\"'), pushStringAttribute(target$jscomp$0, \"name\", formActionName), target$jscomp$0.push(\"/>\"), null != formData$jscomp$1 && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);\n        if (\"string\" === typeof children$jscomp$4) {\n          target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));\n          var JSCompiler_inline_result$jscomp$1 = null;\n        } else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;\n        return JSCompiler_inline_result$jscomp$1;\n      case \"menuitem\":\n        target$jscomp$0.push(startChunkForTag(\"menuitem\"));\n        for (var propKey$jscomp$6 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$6)) {\n            var propValue$jscomp$6 = props[propKey$jscomp$6];\n            if (null != propValue$jscomp$6)\n              switch (propKey$jscomp$6) {\n                case \"children\":\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(formatProdErrorMessage(400));\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$6,\n                    propValue$jscomp$6\n                  );\n              }\n          }\n        target$jscomp$0.push(\">\");\n        return null;\n      case \"object\":\n        target$jscomp$0.push(startChunkForTag(\"object\"));\n        var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;\n        for (propKey$jscomp$7 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$7)) {\n            var propValue$jscomp$7 = props[propKey$jscomp$7];\n            if (null != propValue$jscomp$7)\n              switch (propKey$jscomp$7) {\n                case \"children\":\n                  children$jscomp$5 = propValue$jscomp$7;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$4 = propValue$jscomp$7;\n                  break;\n                case \"data\":\n                  var sanitizedValue = sanitizeURL(\"\" + propValue$jscomp$7);\n                  if (\"\" === sanitizedValue) break;\n                  target$jscomp$0.push(\n                    \" \",\n                    \"data\",\n                    '=\"',\n                    escapeTextForBrowser(sanitizedValue),\n                    '\"'\n                  );\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$7,\n                    propValue$jscomp$7\n                  );\n              }\n          }\n        target$jscomp$0.push(\">\");\n        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);\n        if (\"string\" === typeof children$jscomp$5) {\n          target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));\n          var JSCompiler_inline_result$jscomp$2 = null;\n        } else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;\n        return JSCompiler_inline_result$jscomp$2;\n      case \"title\":\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)\n          var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(\n            target$jscomp$0,\n            props\n          );\n        else\n          isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);\n        return JSCompiler_inline_result$jscomp$3;\n      case \"link\":\n        var rel = props.rel, href = props.href, precedence = props.precedence;\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || \"string\" !== typeof rel || \"string\" !== typeof href || \"\" === href) {\n          pushLinkImpl(target$jscomp$0, props);\n          var JSCompiler_inline_result$jscomp$4 = null;\n        } else if (\"stylesheet\" === props.rel)\n          if (\"string\" !== typeof precedence || null != props.disabled || props.onLoad || props.onError)\n            JSCompiler_inline_result$jscomp$4 = pushLinkImpl(\n              target$jscomp$0,\n              props\n            );\n          else {\n            var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;\n            if (null !== resourceState) {\n              resumableState.styleResources[href] = null;\n              styleQueue || (styleQueue = {\n                precedence: escapeTextForBrowser(precedence),\n                rules: [],\n                hrefs: [],\n                sheets: /* @__PURE__ */ new Map()\n              }, renderState.styles.set(precedence, styleQueue));\n              var resource = {\n                state: 0,\n                props: assign({}, props, {\n                  \"data-precedence\": props.precedence,\n                  precedence: null\n                })\n              };\n              if (resourceState) {\n                2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);\n                var preloadResource = renderState.preloads.stylesheets.get(href);\n                preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;\n              }\n              styleQueue.sheets.set(href, resource);\n              hoistableState && hoistableState.stylesheets.add(resource);\n            } else if (styleQueue) {\n              var resource$9 = styleQueue.sheets.get(href);\n              resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);\n            }\n            textEmbedded && target$jscomp$0.push(\"<!-- -->\");\n            JSCompiler_inline_result$jscomp$4 = null;\n          }\n        else\n          props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(\n            target$jscomp$0,\n            props\n          ) : (textEmbedded && target$jscomp$0.push(\"<!-- -->\"), JSCompiler_inline_result$jscomp$4 = isFallback ? null : pushLinkImpl(renderState.hoistableChunks, props));\n        return JSCompiler_inline_result$jscomp$4;\n      case \"script\":\n        var asyncProp = props.async;\n        if (\"string\" !== typeof props.src || !props.src || !asyncProp || \"function\" === typeof asyncProp || \"symbol\" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)\n          var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(\n            target$jscomp$0,\n            props\n          );\n        else {\n          var key = props.src;\n          if (\"module\" === props.type) {\n            var resources = resumableState.moduleScriptResources;\n            var preloads = renderState.preloads.moduleScripts;\n          } else\n            resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;\n          var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;\n          if (null !== resourceState$jscomp$0) {\n            resources[key] = null;\n            var scriptProps = props;\n            if (resourceState$jscomp$0) {\n              2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));\n              var preloadResource$jscomp$0 = preloads.get(key);\n              preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);\n            }\n            var resource$jscomp$0 = [];\n            renderState.scripts.add(resource$jscomp$0);\n            pushScriptImpl(resource$jscomp$0, scriptProps);\n          }\n          textEmbedded && target$jscomp$0.push(\"<!-- -->\");\n          JSCompiler_inline_result$jscomp$5 = null;\n        }\n        return JSCompiler_inline_result$jscomp$5;\n      case \"style\":\n        var precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href;\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp || \"string\" !== typeof precedence$jscomp$0 || \"string\" !== typeof href$jscomp$0 || \"\" === href$jscomp$0) {\n          target$jscomp$0.push(startChunkForTag(\"style\"));\n          var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;\n          for (propKey$jscomp$8 in props)\n            if (hasOwnProperty2.call(props, propKey$jscomp$8)) {\n              var propValue$jscomp$8 = props[propKey$jscomp$8];\n              if (null != propValue$jscomp$8)\n                switch (propKey$jscomp$8) {\n                  case \"children\":\n                    children$jscomp$6 = propValue$jscomp$8;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$5 = propValue$jscomp$8;\n                    break;\n                  default:\n                    pushAttribute(\n                      target$jscomp$0,\n                      propKey$jscomp$8,\n                      propValue$jscomp$8\n                    );\n                }\n            }\n          target$jscomp$0.push(\">\");\n          var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;\n          \"function\" !== typeof child && \"symbol\" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push((\"\" + child).replace(styleRegex, styleReplacer));\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);\n          target$jscomp$0.push(endChunkForTag(\"style\"));\n          var JSCompiler_inline_result$jscomp$6 = null;\n        } else {\n          var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);\n          if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {\n            resumableState.styleResources[href$jscomp$0] = null;\n            styleQueue$jscomp$0 ? styleQueue$jscomp$0.hrefs.push(\n              escapeTextForBrowser(href$jscomp$0)\n            ) : (styleQueue$jscomp$0 = {\n              precedence: escapeTextForBrowser(precedence$jscomp$0),\n              rules: [],\n              hrefs: [escapeTextForBrowser(href$jscomp$0)],\n              sheets: /* @__PURE__ */ new Map()\n            }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));\n            var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;\n            for (propKey$jscomp$9 in props)\n              if (hasOwnProperty2.call(props, propKey$jscomp$9)) {\n                var propValue$jscomp$9 = props[propKey$jscomp$9];\n                if (null != propValue$jscomp$9)\n                  switch (propKey$jscomp$9) {\n                    case \"children\":\n                      children$jscomp$7 = propValue$jscomp$9;\n                      break;\n                    case \"dangerouslySetInnerHTML\":\n                      innerHTML$jscomp$6 = propValue$jscomp$9;\n                  }\n              }\n            var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;\n            \"function\" !== typeof child$jscomp$0 && \"symbol\" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(\n              (\"\" + child$jscomp$0).replace(styleRegex, styleReplacer)\n            );\n            pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);\n          }\n          styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);\n          textEmbedded && target$jscomp$0.push(\"<!-- -->\");\n          JSCompiler_inline_result$jscomp$6 = void 0;\n        }\n        return JSCompiler_inline_result$jscomp$6;\n      case \"meta\":\n        if (4 === formatContext.insertionMode || formatContext.tagScope & 1 || null != props.itemProp)\n          var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(\n            target$jscomp$0,\n            props,\n            \"meta\"\n          );\n        else\n          textEmbedded && target$jscomp$0.push(\"<!-- -->\"), JSCompiler_inline_result$jscomp$7 = isFallback ? null : \"string\" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, \"meta\") : \"viewport\" === props.name ? pushSelfClosing(renderState.viewportChunks, props, \"meta\") : pushSelfClosing(renderState.hoistableChunks, props, \"meta\");\n        return JSCompiler_inline_result$jscomp$7;\n      case \"listing\":\n      case \"pre\":\n        target$jscomp$0.push(startChunkForTag(type2));\n        var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;\n        for (propKey$jscomp$10 in props)\n          if (hasOwnProperty2.call(props, propKey$jscomp$10)) {\n            var propValue$jscomp$10 = props[propKey$jscomp$10];\n            if (null != propValue$jscomp$10)\n              switch (propKey$jscomp$10) {\n                case \"children\":\n                  children$jscomp$8 = propValue$jscomp$10;\n                  break;\n                case \"dangerouslySetInnerHTML\":\n                  innerHTML$jscomp$7 = propValue$jscomp$10;\n                  break;\n                default:\n                  pushAttribute(\n                    target$jscomp$0,\n                    propKey$jscomp$10,\n                    propValue$jscomp$10\n                  );\n              }\n          }\n        target$jscomp$0.push(\">\");\n        if (null != innerHTML$jscomp$7) {\n          if (null != children$jscomp$8) throw Error(formatProdErrorMessage(60));\n          if (\"object\" !== typeof innerHTML$jscomp$7 || !(\"__html\" in innerHTML$jscomp$7))\n            throw Error(formatProdErrorMessage(61));\n          var html2 = innerHTML$jscomp$7.__html;\n          null !== html2 && void 0 !== html2 && (\"string\" === typeof html2 && 0 < html2.length && \"\\n\" === html2[0] ? target$jscomp$0.push(\"\\n\", html2) : target$jscomp$0.push(\"\" + html2));\n        }\n        \"string\" === typeof children$jscomp$8 && \"\\n\" === children$jscomp$8[0] && target$jscomp$0.push(\"\\n\");\n        return children$jscomp$8;\n      case \"img\":\n        var src = props.src, srcSet = props.srcSet;\n        if (!(\"lazy\" === props.loading || !src && !srcSet || \"string\" !== typeof src && null != src || \"string\" !== typeof srcSet && null != srcSet) && \"low\" !== props.fetchPriority && false === !!(formatContext.tagScope & 3) && (\"string\" !== typeof src || \":\" !== src[4] || \"d\" !== src[0] && \"D\" !== src[0] || \"a\" !== src[1] && \"A\" !== src[1] || \"t\" !== src[2] && \"T\" !== src[2] || \"a\" !== src[3] && \"A\" !== src[3]) && (\"string\" !== typeof srcSet || \":\" !== srcSet[4] || \"d\" !== srcSet[0] && \"D\" !== srcSet[0] || \"a\" !== srcSet[1] && \"A\" !== srcSet[1] || \"t\" !== srcSet[2] && \"T\" !== srcSet[2] || \"a\" !== srcSet[3] && \"A\" !== srcSet[3])) {\n          var sizes = \"string\" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + \"\\n\" + (sizes || \"\") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);\n          if (resource$jscomp$1) {\n            if (\"high\" === props.fetchPriority || 10 > renderState.highImagePreloads.size)\n              promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);\n          } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {\n            resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;\n            var input2 = props.crossOrigin;\n            var JSCompiler_inline_result$jscomp$8 = \"string\" === typeof input2 ? \"use-credentials\" === input2 ? input2 : \"\" : void 0;\n            var headers = renderState.headers, header;\n            headers && 0 < headers.remainingCapacity && \"string\" !== typeof props.srcSet && (\"high\" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, \"image\", {\n              imageSrcSet: props.srcSet,\n              imageSizes: props.sizes,\n              crossOrigin: JSCompiler_inline_result$jscomp$8,\n              integrity: props.integrity,\n              nonce: props.nonce,\n              type: props.type,\n              fetchPriority: props.fetchPriority,\n              referrerPolicy: props.refererPolicy\n            }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += \", \"), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {\n              rel: \"preload\",\n              as: \"image\",\n              href: srcSet ? void 0 : src,\n              imageSrcSet: srcSet,\n              imageSizes: sizes,\n              crossOrigin: JSCompiler_inline_result$jscomp$8,\n              integrity: props.integrity,\n              type: props.type,\n              fetchPriority: props.fetchPriority,\n              referrerPolicy: props.referrerPolicy\n            }), \"high\" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));\n          }\n        }\n        return pushSelfClosing(target$jscomp$0, props, \"img\");\n      case \"base\":\n      case \"area\":\n      case \"br\":\n      case \"col\":\n      case \"embed\":\n      case \"hr\":\n      case \"keygen\":\n      case \"param\":\n      case \"source\":\n      case \"track\":\n      case \"wbr\":\n        return pushSelfClosing(target$jscomp$0, props, type2);\n      case \"annotation-xml\":\n      case \"color-profile\":\n      case \"font-face\":\n      case \"font-face-src\":\n      case \"font-face-uri\":\n      case \"font-face-format\":\n      case \"font-face-name\":\n      case \"missing-glyph\":\n        break;\n      case \"head\":\n        if (2 > formatContext.insertionMode) {\n          var preamble = preambleState || renderState.preamble;\n          if (preamble.headChunks)\n            throw Error(formatProdErrorMessage(545, \"`<head>`\"));\n          preamble.headChunks = [];\n          var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(\n            preamble.headChunks,\n            props,\n            \"head\"\n          );\n        } else\n          JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(\n            target$jscomp$0,\n            props,\n            \"head\"\n          );\n        return JSCompiler_inline_result$jscomp$9;\n      case \"body\":\n        if (2 > formatContext.insertionMode) {\n          var preamble$jscomp$0 = preambleState || renderState.preamble;\n          if (preamble$jscomp$0.bodyChunks)\n            throw Error(formatProdErrorMessage(545, \"`<body>`\"));\n          preamble$jscomp$0.bodyChunks = [];\n          var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(\n            preamble$jscomp$0.bodyChunks,\n            props,\n            \"body\"\n          );\n        } else\n          JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(\n            target$jscomp$0,\n            props,\n            \"body\"\n          );\n        return JSCompiler_inline_result$jscomp$10;\n      case \"html\":\n        if (0 === formatContext.insertionMode) {\n          var preamble$jscomp$1 = preambleState || renderState.preamble;\n          if (preamble$jscomp$1.htmlChunks)\n            throw Error(formatProdErrorMessage(545, \"`<html>`\"));\n          preamble$jscomp$1.htmlChunks = [\"\"];\n          var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(\n            preamble$jscomp$1.htmlChunks,\n            props,\n            \"html\"\n          );\n        } else\n          JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(\n            target$jscomp$0,\n            props,\n            \"html\"\n          );\n        return JSCompiler_inline_result$jscomp$11;\n      default:\n        if (-1 !== type2.indexOf(\"-\")) {\n          target$jscomp$0.push(startChunkForTag(type2));\n          var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;\n          for (propKey$jscomp$11 in props)\n            if (hasOwnProperty2.call(props, propKey$jscomp$11)) {\n              var propValue$jscomp$11 = props[propKey$jscomp$11];\n              if (null != propValue$jscomp$11) {\n                var attributeName = propKey$jscomp$11;\n                switch (propKey$jscomp$11) {\n                  case \"children\":\n                    children$jscomp$9 = propValue$jscomp$11;\n                    break;\n                  case \"dangerouslySetInnerHTML\":\n                    innerHTML$jscomp$8 = propValue$jscomp$11;\n                    break;\n                  case \"style\":\n                    pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);\n                    break;\n                  case \"suppressContentEditableWarning\":\n                  case \"suppressHydrationWarning\":\n                  case \"ref\":\n                    break;\n                  case \"className\":\n                    attributeName = \"class\";\n                  default:\n                    if (isAttributeNameSafe(propKey$jscomp$11) && \"function\" !== typeof propValue$jscomp$11 && \"symbol\" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {\n                      if (true === propValue$jscomp$11) propValue$jscomp$11 = \"\";\n                      else if (\"object\" === typeof propValue$jscomp$11) continue;\n                      target$jscomp$0.push(\n                        \" \",\n                        attributeName,\n                        '=\"',\n                        escapeTextForBrowser(propValue$jscomp$11),\n                        '\"'\n                      );\n                    }\n                }\n              }\n            }\n          target$jscomp$0.push(\">\");\n          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);\n          return children$jscomp$9;\n        }\n    }\n    return pushStartGenericElement(target$jscomp$0, props, type2);\n  }\n  __name(pushStartInstance, \"pushStartInstance\");\n  var endTagCache = /* @__PURE__ */ new Map();\n  function endChunkForTag(tag) {\n    var chunk = endTagCache.get(tag);\n    void 0 === chunk && (chunk = \"</\" + tag + \">\", endTagCache.set(tag, chunk));\n    return chunk;\n  }\n  __name(endChunkForTag, \"endChunkForTag\");\n  function hoistPreambleState(renderState, preambleState) {\n    renderState = renderState.preamble;\n    null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks, preambleState.contribution |= 1);\n    null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks, preambleState.contribution |= 4);\n    null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks, preambleState.contribution |= 2);\n  }\n  __name(hoistPreambleState, \"hoistPreambleState\");\n  function writeBootstrap(destination, renderState) {\n    renderState = renderState.bootstrapChunks;\n    for (var i = 0; i < renderState.length - 1; i++)\n      destination.push(renderState[i]);\n    return i < renderState.length ? (i = renderState[i], renderState.length = 0, destination.push(i)) : true;\n  }\n  __name(writeBootstrap, \"writeBootstrap\");\n  function writeStartPendingSuspenseBoundary(destination, renderState, id2) {\n    destination.push('<!--$?--><template id=\"');\n    if (null === id2) throw Error(formatProdErrorMessage(395));\n    destination.push(renderState.boundaryPrefix);\n    renderState = id2.toString(16);\n    destination.push(renderState);\n    return destination.push('\"></template>');\n  }\n  __name(writeStartPendingSuspenseBoundary, \"writeStartPendingSuspenseBoundary\");\n  function writePreambleContribution(destination, preambleState) {\n    preambleState = preambleState.contribution;\n    0 !== preambleState && (destination.push(\"<!--\"), destination.push(\"\" + preambleState), destination.push(\"-->\"));\n  }\n  __name(writePreambleContribution, \"writePreambleContribution\");\n  function writeStartSegment(destination, renderState, formatContext, id2) {\n    switch (formatContext.insertionMode) {\n      case 0:\n      case 1:\n      case 3:\n      case 2:\n        return destination.push('<div hidden id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      case 4:\n        return destination.push('<svg aria-hidden=\"true\" style=\"display:none\" id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      case 5:\n        return destination.push('<math aria-hidden=\"true\" style=\"display:none\" id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      case 6:\n        return destination.push('<table hidden id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      case 7:\n        return destination.push('<table hidden><tbody id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      case 8:\n        return destination.push('<table hidden><tr id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      case 9:\n        return destination.push('<table hidden><colgroup id=\"'), destination.push(renderState.segmentPrefix), renderState = id2.toString(16), destination.push(renderState), destination.push('\">');\n      default:\n        throw Error(formatProdErrorMessage(397));\n    }\n  }\n  __name(writeStartSegment, \"writeStartSegment\");\n  function writeEndSegment(destination, formatContext) {\n    switch (formatContext.insertionMode) {\n      case 0:\n      case 1:\n      case 3:\n      case 2:\n        return destination.push(\"</div>\");\n      case 4:\n        return destination.push(\"</svg>\");\n      case 5:\n        return destination.push(\"</math>\");\n      case 6:\n        return destination.push(\"</table>\");\n      case 7:\n        return destination.push(\"</tbody></table>\");\n      case 8:\n        return destination.push(\"</tr></table>\");\n      case 9:\n        return destination.push(\"</colgroup></table>\");\n      default:\n        throw Error(formatProdErrorMessage(397));\n    }\n  }\n  __name(writeEndSegment, \"writeEndSegment\");\n  var regexForJSStringsInInstructionScripts = /[<\\u2028\\u2029]/g;\n  function escapeJSStringsForInstructionScripts(input2) {\n    return JSON.stringify(input2).replace(\n      regexForJSStringsInInstructionScripts,\n      function(match) {\n        switch (match) {\n          case \"<\":\n            return \"\\\\u003c\";\n          case \"\\u2028\":\n            return \"\\\\u2028\";\n          case \"\\u2029\":\n            return \"\\\\u2029\";\n          default:\n            throw Error(\n              \"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n            );\n        }\n      }\n    );\n  }\n  __name(escapeJSStringsForInstructionScripts, \"escapeJSStringsForInstructionScripts\");\n  var regexForJSStringsInScripts = /[&><\\u2028\\u2029]/g;\n  function escapeJSObjectForInstructionScripts(input2) {\n    return JSON.stringify(input2).replace(\n      regexForJSStringsInScripts,\n      function(match) {\n        switch (match) {\n          case \"&\":\n            return \"\\\\u0026\";\n          case \">\":\n            return \"\\\\u003e\";\n          case \"<\":\n            return \"\\\\u003c\";\n          case \"\\u2028\":\n            return \"\\\\u2028\";\n          case \"\\u2029\":\n            return \"\\\\u2029\";\n          default:\n            throw Error(\n              \"escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n            );\n        }\n      }\n    );\n  }\n  __name(escapeJSObjectForInstructionScripts, \"escapeJSObjectForInstructionScripts\");\n  var currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true;\n  function flushStyleTagsLateForBoundary(styleQueue) {\n    var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i = 0;\n    if (hrefs.length) {\n      this.push('<style media=\"not all\" data-precedence=\"');\n      this.push(styleQueue.precedence);\n      for (this.push('\" data-href=\"'); i < hrefs.length - 1; i++)\n        this.push(hrefs[i]), this.push(\" \");\n      this.push(hrefs[i]);\n      this.push('\">');\n      for (i = 0; i < rules.length; i++) this.push(rules[i]);\n      destinationHasCapacity = this.push(\"</style>\");\n      currentlyRenderingBoundaryHasStylesToHoist = true;\n      rules.length = 0;\n      hrefs.length = 0;\n    }\n  }\n  __name(flushStyleTagsLateForBoundary, \"flushStyleTagsLateForBoundary\");\n  function hasStylesToHoist(stylesheet) {\n    return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = true : false;\n  }\n  __name(hasStylesToHoist, \"hasStylesToHoist\");\n  function writeHoistablesForBoundary(destination, hoistableState, renderState) {\n    currentlyRenderingBoundaryHasStylesToHoist = false;\n    destinationHasCapacity = true;\n    hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);\n    hoistableState.stylesheets.forEach(hasStylesToHoist);\n    currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);\n    return destinationHasCapacity;\n  }\n  __name(writeHoistablesForBoundary, \"writeHoistablesForBoundary\");\n  function flushResource(resource) {\n    for (var i = 0; i < resource.length; i++) this.push(resource[i]);\n    resource.length = 0;\n  }\n  __name(flushResource, \"flushResource\");\n  var stylesheetFlushingQueue = [];\n  function flushStyleInPreamble(stylesheet) {\n    pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);\n    for (var i = 0; i < stylesheetFlushingQueue.length; i++)\n      this.push(stylesheetFlushingQueue[i]);\n    stylesheetFlushingQueue.length = 0;\n    stylesheet.state = 2;\n  }\n  __name(flushStyleInPreamble, \"flushStyleInPreamble\");\n  function flushStylesInPreamble(styleQueue) {\n    var hasStylesheets = 0 < styleQueue.sheets.size;\n    styleQueue.sheets.forEach(flushStyleInPreamble, this);\n    styleQueue.sheets.clear();\n    var rules = styleQueue.rules, hrefs = styleQueue.hrefs;\n    if (!hasStylesheets || hrefs.length) {\n      this.push('<style data-precedence=\"');\n      this.push(styleQueue.precedence);\n      styleQueue = 0;\n      if (hrefs.length) {\n        for (this.push('\" data-href=\"'); styleQueue < hrefs.length - 1; styleQueue++)\n          this.push(hrefs[styleQueue]), this.push(\" \");\n        this.push(hrefs[styleQueue]);\n      }\n      this.push('\">');\n      for (styleQueue = 0; styleQueue < rules.length; styleQueue++)\n        this.push(rules[styleQueue]);\n      this.push(\"</style>\");\n      rules.length = 0;\n      hrefs.length = 0;\n    }\n  }\n  __name(flushStylesInPreamble, \"flushStylesInPreamble\");\n  function preloadLateStyle(stylesheet) {\n    if (0 === stylesheet.state) {\n      stylesheet.state = 1;\n      var props = stylesheet.props;\n      pushLinkImpl(stylesheetFlushingQueue, {\n        rel: \"preload\",\n        as: \"style\",\n        href: stylesheet.props.href,\n        crossOrigin: props.crossOrigin,\n        fetchPriority: props.fetchPriority,\n        integrity: props.integrity,\n        media: props.media,\n        hrefLang: props.hrefLang,\n        referrerPolicy: props.referrerPolicy\n      });\n      for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)\n        this.push(stylesheetFlushingQueue[stylesheet]);\n      stylesheetFlushingQueue.length = 0;\n    }\n  }\n  __name(preloadLateStyle, \"preloadLateStyle\");\n  function preloadLateStyles(styleQueue) {\n    styleQueue.sheets.forEach(preloadLateStyle, this);\n    styleQueue.sheets.clear();\n  }\n  __name(preloadLateStyles, \"preloadLateStyles\");\n  function writeStyleResourceDependenciesInJS(destination, hoistableState) {\n    destination.push(\"[\");\n    var nextArrayOpenBrackChunk = \"[\";\n    hoistableState.stylesheets.forEach(function(resource) {\n      if (2 !== resource.state)\n        if (3 === resource.state)\n          destination.push(nextArrayOpenBrackChunk), resource = escapeJSObjectForInstructionScripts(\n            \"\" + resource.props.href\n          ), destination.push(resource), destination.push(\"]\"), nextArrayOpenBrackChunk = \",[\";\n        else {\n          destination.push(nextArrayOpenBrackChunk);\n          var precedence = resource.props[\"data-precedence\"], props = resource.props, coercedHref = sanitizeURL(\"\" + resource.props.href);\n          coercedHref = escapeJSObjectForInstructionScripts(coercedHref);\n          destination.push(coercedHref);\n          precedence = \"\" + precedence;\n          destination.push(\",\");\n          precedence = escapeJSObjectForInstructionScripts(precedence);\n          destination.push(precedence);\n          for (var propKey in props)\n            if (hasOwnProperty2.call(props, propKey) && (precedence = props[propKey], null != precedence))\n              switch (propKey) {\n                case \"href\":\n                case \"rel\":\n                case \"precedence\":\n                case \"data-precedence\":\n                  break;\n                case \"children\":\n                case \"dangerouslySetInnerHTML\":\n                  throw Error(formatProdErrorMessage(399, \"link\"));\n                default:\n                  writeStyleResourceAttributeInJS(\n                    destination,\n                    propKey,\n                    precedence\n                  );\n              }\n          destination.push(\"]\");\n          nextArrayOpenBrackChunk = \",[\";\n          resource.state = 3;\n        }\n    });\n    destination.push(\"]\");\n  }\n  __name(writeStyleResourceDependenciesInJS, \"writeStyleResourceDependenciesInJS\");\n  function writeStyleResourceAttributeInJS(destination, name, value2) {\n    var attributeName = name.toLowerCase();\n    switch (typeof value2) {\n      case \"function\":\n      case \"symbol\":\n        return;\n    }\n    switch (name) {\n      case \"innerHTML\":\n      case \"dangerouslySetInnerHTML\":\n      case \"suppressContentEditableWarning\":\n      case \"suppressHydrationWarning\":\n      case \"style\":\n      case \"ref\":\n        return;\n      case \"className\":\n        attributeName = \"class\";\n        name = \"\" + value2;\n        break;\n      case \"hidden\":\n        if (false === value2) return;\n        name = \"\";\n        break;\n      case \"src\":\n      case \"href\":\n        value2 = sanitizeURL(value2);\n        name = \"\" + value2;\n        break;\n      default:\n        if (2 < name.length && (\"o\" === name[0] || \"O\" === name[0]) && (\"n\" === name[1] || \"N\" === name[1]) || !isAttributeNameSafe(name))\n          return;\n        name = \"\" + value2;\n    }\n    destination.push(\",\");\n    attributeName = escapeJSObjectForInstructionScripts(attributeName);\n    destination.push(attributeName);\n    destination.push(\",\");\n    attributeName = escapeJSObjectForInstructionScripts(name);\n    destination.push(attributeName);\n  }\n  __name(writeStyleResourceAttributeInJS, \"writeStyleResourceAttributeInJS\");\n  function createHoistableState() {\n    return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set() };\n  }\n  __name(createHoistableState, \"createHoistableState\");\n  function prefetchDNS(href) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (\"string\" === typeof href && href) {\n        if (!resumableState.dnsResources.hasOwnProperty(href)) {\n          resumableState.dnsResources[href] = null;\n          resumableState = renderState.headers;\n          var header, JSCompiler_temp;\n          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)\n            JSCompiler_temp = (header = \"<\" + (\"\" + href).replace(\n              regexForHrefInLinkHeaderURLContext,\n              escapeHrefForLinkHeaderURLContextReplacer\n            ) + \">; rel=dns-prefetch\", 0 <= (resumableState.remainingCapacity -= header.length + 2));\n          JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += \", \"), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: \"dns-prefetch\" }), renderState.preconnects.add(header));\n        }\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.D(href);\n  }\n  __name(prefetchDNS, \"prefetchDNS\");\n  function preconnect(href, crossOrigin) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (\"string\" === typeof href && href) {\n        var bucket = \"use-credentials\" === crossOrigin ? \"credentials\" : \"string\" === typeof crossOrigin ? \"anonymous\" : \"default\";\n        if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {\n          resumableState.connectResources[bucket][href] = null;\n          resumableState = renderState.headers;\n          var header, JSCompiler_temp;\n          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {\n            JSCompiler_temp = \"<\" + (\"\" + href).replace(\n              regexForHrefInLinkHeaderURLContext,\n              escapeHrefForLinkHeaderURLContextReplacer\n            ) + \">; rel=preconnect\";\n            if (\"string\" === typeof crossOrigin) {\n              var escapedCrossOrigin = (\"\" + crossOrigin).replace(\n                regexForLinkHeaderQuotedParamValueContext,\n                escapeStringForLinkHeaderQuotedParamValueContextReplacer\n              );\n              JSCompiler_temp += '; crossorigin=\"' + escapedCrossOrigin + '\"';\n            }\n            JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));\n          }\n          JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += \", \"), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {\n            rel: \"preconnect\",\n            href,\n            crossOrigin\n          }), renderState.preconnects.add(bucket));\n        }\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.C(href, crossOrigin);\n  }\n  __name(preconnect, \"preconnect\");\n  function preload(href, as2, options) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (as2 && href) {\n        switch (as2) {\n          case \"image\":\n            if (options) {\n              var imageSrcSet = options.imageSrcSet;\n              var imageSizes = options.imageSizes;\n              var fetchPriority = options.fetchPriority;\n            }\n            var key = imageSrcSet ? imageSrcSet + \"\\n\" + (imageSizes || \"\") : href;\n            if (resumableState.imageResources.hasOwnProperty(key)) return;\n            resumableState.imageResources[key] = PRELOAD_NO_CREDS;\n            resumableState = renderState.headers;\n            var header;\n            resumableState && 0 < resumableState.remainingCapacity && \"string\" !== typeof imageSrcSet && \"high\" === fetchPriority && (header = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += \", \"), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(\n              resumableState,\n              assign(\n                { rel: \"preload\", href: imageSrcSet ? void 0 : href, as: as2 },\n                options\n              )\n            ), \"high\" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));\n            break;\n          case \"style\":\n            if (resumableState.styleResources.hasOwnProperty(href)) return;\n            imageSrcSet = [];\n            pushLinkImpl(\n              imageSrcSet,\n              assign({ rel: \"preload\", href, as: as2 }, options)\n            );\n            resumableState.styleResources[href] = !options || \"string\" !== typeof options.crossOrigin && \"string\" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];\n            renderState.preloads.stylesheets.set(href, imageSrcSet);\n            renderState.bulkPreloads.add(imageSrcSet);\n            break;\n          case \"script\":\n            if (resumableState.scriptResources.hasOwnProperty(href)) return;\n            imageSrcSet = [];\n            renderState.preloads.scripts.set(href, imageSrcSet);\n            renderState.bulkPreloads.add(imageSrcSet);\n            pushLinkImpl(\n              imageSrcSet,\n              assign({ rel: \"preload\", href, as: as2 }, options)\n            );\n            resumableState.scriptResources[href] = !options || \"string\" !== typeof options.crossOrigin && \"string\" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];\n            break;\n          default:\n            if (resumableState.unknownResources.hasOwnProperty(as2)) {\n              if (imageSrcSet = resumableState.unknownResources[as2], imageSrcSet.hasOwnProperty(href))\n                return;\n            } else\n              imageSrcSet = {}, resumableState.unknownResources[as2] = imageSrcSet;\n            imageSrcSet[href] = PRELOAD_NO_CREDS;\n            if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && \"font\" === as2 && (key = getPreloadAsHeader(href, as2, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))\n              renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += \", \"), resumableState.fontPreloads += key;\n            else\n              switch (resumableState = [], href = assign({ rel: \"preload\", href, as: as2 }, options), pushLinkImpl(resumableState, href), as2) {\n                case \"font\":\n                  renderState.fontPreloads.add(resumableState);\n                  break;\n                default:\n                  renderState.bulkPreloads.add(resumableState);\n              }\n        }\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.L(href, as2, options);\n  }\n  __name(preload, \"preload\");\n  function preloadModule(href, options) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (href) {\n        var as2 = options && \"string\" === typeof options.as ? options.as : \"script\";\n        switch (as2) {\n          case \"script\":\n            if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;\n            as2 = [];\n            resumableState.moduleScriptResources[href] = !options || \"string\" !== typeof options.crossOrigin && \"string\" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];\n            renderState.preloads.moduleScripts.set(href, as2);\n            break;\n          default:\n            if (resumableState.moduleUnknownResources.hasOwnProperty(as2)) {\n              var resources = resumableState.unknownResources[as2];\n              if (resources.hasOwnProperty(href)) return;\n            } else\n              resources = {}, resumableState.moduleUnknownResources[as2] = resources;\n            as2 = [];\n            resources[href] = PRELOAD_NO_CREDS;\n        }\n        pushLinkImpl(as2, assign({ rel: \"modulepreload\", href }, options));\n        renderState.bulkPreloads.add(as2);\n        enqueueFlush(request);\n      }\n    } else previousDispatcher.m(href, options);\n  }\n  __name(preloadModule, \"preloadModule\");\n  function preinitStyle(href, precedence, options) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (href) {\n        precedence = precedence || \"default\";\n        var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;\n        null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {\n          precedence: escapeTextForBrowser(precedence),\n          rules: [],\n          hrefs: [],\n          sheets: /* @__PURE__ */ new Map()\n        }, renderState.styles.set(precedence, styleQueue)), precedence = {\n          state: 0,\n          props: assign(\n            { rel: \"stylesheet\", href, \"data-precedence\": precedence },\n            options\n          )\n        }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));\n      }\n    } else previousDispatcher.S(href, precedence, options);\n  }\n  __name(preinitStyle, \"preinitStyle\");\n  function preinitScript(src, options) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (src) {\n        var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;\n        null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));\n      }\n    } else previousDispatcher.X(src, options);\n  }\n  __name(preinitScript, \"preinitScript\");\n  function preinitModuleScript(src, options) {\n    var request = currentRequest ? currentRequest : null;\n    if (request) {\n      var resumableState = request.resumableState, renderState = request.renderState;\n      if (src) {\n        var resourceState = resumableState.moduleScriptResources.hasOwnProperty(\n          src\n        ) ? resumableState.moduleScriptResources[src] : void 0;\n        null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({ src, type: \"module\", async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));\n      }\n    } else previousDispatcher.M(src, options);\n  }\n  __name(preinitModuleScript, \"preinitModuleScript\");\n  function adoptPreloadCredentials(target, preloadState) {\n    null == target.crossOrigin && (target.crossOrigin = preloadState[0]);\n    null == target.integrity && (target.integrity = preloadState[1]);\n  }\n  __name(adoptPreloadCredentials, \"adoptPreloadCredentials\");\n  function getPreloadAsHeader(href, as2, params) {\n    href = (\"\" + href).replace(\n      regexForHrefInLinkHeaderURLContext,\n      escapeHrefForLinkHeaderURLContextReplacer\n    );\n    as2 = (\"\" + as2).replace(\n      regexForLinkHeaderQuotedParamValueContext,\n      escapeStringForLinkHeaderQuotedParamValueContextReplacer\n    );\n    as2 = \"<\" + href + '>; rel=preload; as=\"' + as2 + '\"';\n    for (var paramName in params)\n      hasOwnProperty2.call(params, paramName) && (href = params[paramName], \"string\" === typeof href && (as2 += \"; \" + paramName.toLowerCase() + '=\"' + (\"\" + href).replace(\n        regexForLinkHeaderQuotedParamValueContext,\n        escapeStringForLinkHeaderQuotedParamValueContextReplacer\n      ) + '\"'));\n    return as2;\n  }\n  __name(getPreloadAsHeader, \"getPreloadAsHeader\");\n  var regexForHrefInLinkHeaderURLContext = /[<>\\r\\n]/g;\n  function escapeHrefForLinkHeaderURLContextReplacer(match) {\n    switch (match) {\n      case \"<\":\n        return \"%3C\";\n      case \">\":\n        return \"%3E\";\n      case \"\\n\":\n        return \"%0A\";\n      case \"\\r\":\n        return \"%0D\";\n      default:\n        throw Error(\n          \"escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n        );\n    }\n  }\n  __name(escapeHrefForLinkHeaderURLContextReplacer, \"escapeHrefForLinkHeaderURLContextReplacer\");\n  var regexForLinkHeaderQuotedParamValueContext = /[\"';,\\r\\n]/g;\n  function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {\n    switch (match) {\n      case '\"':\n        return \"%22\";\n      case \"'\":\n        return \"%27\";\n      case \";\":\n        return \"%3B\";\n      case \",\":\n        return \"%2C\";\n      case \"\\n\":\n        return \"%0A\";\n      case \"\\r\":\n        return \"%0D\";\n      default:\n        throw Error(\n          \"escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\"\n        );\n    }\n  }\n  __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, \"escapeStringForLinkHeaderQuotedParamValueContextReplacer\");\n  function hoistStyleQueueDependency(styleQueue) {\n    this.styles.add(styleQueue);\n  }\n  __name(hoistStyleQueueDependency, \"hoistStyleQueueDependency\");\n  function hoistStylesheetDependency(stylesheet) {\n    this.stylesheets.add(stylesheet);\n  }\n  __name(hoistStylesheetDependency, \"hoistStylesheetDependency\");\n  function createRenderState(resumableState, generateStaticMarkup) {\n    var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;\n    void 0 !== bootstrapScriptContent && bootstrapChunks.push(\n      \"<script>\",\n      (\"\" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer),\n      \"</script>\"\n    );\n    bootstrapScriptContent = idPrefix + \"P:\";\n    var JSCompiler_object_inline_segmentPrefix_1542 = idPrefix + \"S:\";\n    idPrefix += \"B:\";\n    var JSCompiler_object_inline_preamble_1545 = createPreambleState(), JSCompiler_object_inline_preconnects_1555 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_fontPreloads_1556 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_highImagePreloads_1557 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_styles_1558 = /* @__PURE__ */ new Map(), JSCompiler_object_inline_bootstrapScripts_1559 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_scripts_1560 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_bulkPreloads_1561 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_preloads_1562 = {\n      images: /* @__PURE__ */ new Map(),\n      stylesheets: /* @__PURE__ */ new Map(),\n      scripts: /* @__PURE__ */ new Map(),\n      moduleScripts: /* @__PURE__ */ new Map()\n    };\n    if (void 0 !== bootstrapScripts)\n      for (var i = 0; i < bootstrapScripts.length; i++) {\n        var scriptConfig = bootstrapScripts[i], src, crossOrigin = void 0, integrity = void 0, props = {\n          rel: \"preload\",\n          as: \"script\",\n          fetchPriority: \"low\",\n          nonce: void 0\n        };\n        \"string\" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = \"string\" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = \"string\" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : \"use-credentials\" === scriptConfig.crossOrigin ? \"use-credentials\" : \"\");\n        scriptConfig = resumableState;\n        var href = src;\n        scriptConfig.scriptResources[href] = null;\n        scriptConfig.moduleScriptResources[href] = null;\n        scriptConfig = [];\n        pushLinkImpl(scriptConfig, props);\n        JSCompiler_object_inline_bootstrapScripts_1559.add(scriptConfig);\n        bootstrapChunks.push('<script src=\"', escapeTextForBrowser(src));\n        \"string\" === typeof integrity && bootstrapChunks.push('\" integrity=\"', escapeTextForBrowser(integrity));\n        \"string\" === typeof crossOrigin && bootstrapChunks.push(\n          '\" crossorigin=\"',\n          escapeTextForBrowser(crossOrigin)\n        );\n        bootstrapChunks.push('\" async=\"\"></script>');\n      }\n    if (void 0 !== bootstrapModules)\n      for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)\n        props = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {\n          rel: \"modulepreload\",\n          fetchPriority: \"low\",\n          nonce: void 0\n        }, \"string\" === typeof props ? integrity.href = i = props : (integrity.href = i = props.src, integrity.integrity = crossOrigin = \"string\" === typeof props.integrity ? props.integrity : void 0, integrity.crossOrigin = src = \"string\" === typeof props || null == props.crossOrigin ? void 0 : \"use-credentials\" === props.crossOrigin ? \"use-credentials\" : \"\"), props = resumableState, scriptConfig = i, props.scriptResources[scriptConfig] = null, props.moduleScriptResources[scriptConfig] = null, props = [], pushLinkImpl(props, integrity), JSCompiler_object_inline_bootstrapScripts_1559.add(props), bootstrapChunks.push(\n          '<script type=\"module\" src=\"',\n          escapeTextForBrowser(i)\n        ), \"string\" === typeof crossOrigin && bootstrapChunks.push(\n          '\" integrity=\"',\n          escapeTextForBrowser(crossOrigin)\n        ), \"string\" === typeof src && bootstrapChunks.push('\" crossorigin=\"', escapeTextForBrowser(src)), bootstrapChunks.push('\" async=\"\"></script>');\n    return {\n      placeholderPrefix: bootstrapScriptContent,\n      segmentPrefix: JSCompiler_object_inline_segmentPrefix_1542,\n      boundaryPrefix: idPrefix,\n      startInlineScript: \"<script>\",\n      preamble: JSCompiler_object_inline_preamble_1545,\n      externalRuntimeScript: null,\n      bootstrapChunks,\n      importMapChunks: [],\n      onHeaders: void 0,\n      headers: null,\n      resets: {\n        font: {},\n        dns: {},\n        connect: { default: {}, anonymous: {}, credentials: {} },\n        image: {},\n        style: {}\n      },\n      charsetChunks: [],\n      viewportChunks: [],\n      hoistableChunks: [],\n      preconnects: JSCompiler_object_inline_preconnects_1555,\n      fontPreloads: JSCompiler_object_inline_fontPreloads_1556,\n      highImagePreloads: JSCompiler_object_inline_highImagePreloads_1557,\n      styles: JSCompiler_object_inline_styles_1558,\n      bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1559,\n      scripts: JSCompiler_object_inline_scripts_1560,\n      bulkPreloads: JSCompiler_object_inline_bulkPreloads_1561,\n      preloads: JSCompiler_object_inline_preloads_1562,\n      stylesToHoist: false,\n      generateStaticMarkup\n    };\n  }\n  __name(createRenderState, \"createRenderState\");\n  function pushTextInstance(target, text, renderState, textEmbedded) {\n    if (renderState.generateStaticMarkup)\n      return target.push(escapeTextForBrowser(text)), false;\n    \"\" === text ? target = textEmbedded : (textEmbedded && target.push(\"<!-- -->\"), target.push(escapeTextForBrowser(text)), target = true);\n    return target;\n  }\n  __name(pushTextInstance, \"pushTextInstance\");\n  function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {\n    renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push(\"<!-- -->\");\n  }\n  __name(pushSegmentFinale, \"pushSegmentFinale\");\n  var bind2 = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n  function getComponentNameFromType(type2) {\n    if (null == type2) return null;\n    if (\"function\" === typeof type2)\n      return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;\n    if (\"string\" === typeof type2) return type2;\n    switch (type2) {\n      case REACT_FRAGMENT_TYPE:\n        return \"Fragment\";\n      case REACT_PROFILER_TYPE:\n        return \"Profiler\";\n      case REACT_STRICT_MODE_TYPE:\n        return \"StrictMode\";\n      case REACT_SUSPENSE_TYPE:\n        return \"Suspense\";\n      case REACT_SUSPENSE_LIST_TYPE:\n        return \"SuspenseList\";\n      case REACT_ACTIVITY_TYPE:\n        return \"Activity\";\n    }\n    if (\"object\" === typeof type2)\n      switch (type2.$$typeof) {\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_CONTEXT_TYPE:\n          return (type2.displayName || \"Context\") + \".Provider\";\n        case REACT_CONSUMER_TYPE:\n          return (type2._context.displayName || \"Context\") + \".Consumer\";\n        case REACT_FORWARD_REF_TYPE:\n          var innerType = type2.render;\n          type2 = type2.displayName;\n          type2 || (type2 = innerType.displayName || innerType.name || \"\", type2 = \"\" !== type2 ? \"ForwardRef(\" + type2 + \")\" : \"ForwardRef\");\n          return type2;\n        case REACT_MEMO_TYPE:\n          return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || \"Memo\";\n        case REACT_LAZY_TYPE:\n          innerType = type2._payload;\n          type2 = type2._init;\n          try {\n            return getComponentNameFromType(type2(innerType));\n          } catch (x) {\n          }\n      }\n    return null;\n  }\n  __name(getComponentNameFromType, \"getComponentNameFromType\");\n  var emptyContextObject = {}, currentActiveSnapshot = null;\n  function popToNearestCommonAncestor(prev, next) {\n    if (prev !== next) {\n      prev.context._currentValue2 = prev.parentValue;\n      prev = prev.parent;\n      var parentNext = next.parent;\n      if (null === prev) {\n        if (null !== parentNext) throw Error(formatProdErrorMessage(401));\n      } else {\n        if (null === parentNext) throw Error(formatProdErrorMessage(401));\n        popToNearestCommonAncestor(prev, parentNext);\n      }\n      next.context._currentValue2 = next.value;\n    }\n  }\n  __name(popToNearestCommonAncestor, \"popToNearestCommonAncestor\");\n  function popAllPrevious(prev) {\n    prev.context._currentValue2 = prev.parentValue;\n    prev = prev.parent;\n    null !== prev && popAllPrevious(prev);\n  }\n  __name(popAllPrevious, \"popAllPrevious\");\n  function pushAllNext(next) {\n    var parentNext = next.parent;\n    null !== parentNext && pushAllNext(parentNext);\n    next.context._currentValue2 = next.value;\n  }\n  __name(pushAllNext, \"pushAllNext\");\n  function popPreviousToCommonLevel(prev, next) {\n    prev.context._currentValue2 = prev.parentValue;\n    prev = prev.parent;\n    if (null === prev) throw Error(formatProdErrorMessage(402));\n    prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);\n  }\n  __name(popPreviousToCommonLevel, \"popPreviousToCommonLevel\");\n  function popNextToCommonLevel(prev, next) {\n    var parentNext = next.parent;\n    if (null === parentNext) throw Error(formatProdErrorMessage(402));\n    prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);\n    next.context._currentValue2 = next.value;\n  }\n  __name(popNextToCommonLevel, \"popNextToCommonLevel\");\n  function switchContext(newSnapshot) {\n    var prev = currentActiveSnapshot;\n    prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);\n  }\n  __name(switchContext, \"switchContext\");\n  var classComponentUpdater = {\n    enqueueSetState: /* @__PURE__ */ __name(function(inst, payload) {\n      inst = inst._reactInternals;\n      null !== inst.queue && inst.queue.push(payload);\n    }, \"enqueueSetState\"),\n    enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload) {\n      inst = inst._reactInternals;\n      inst.replace = true;\n      inst.queue = [payload];\n    }, \"enqueueReplaceState\"),\n    enqueueForceUpdate: /* @__PURE__ */ __name(function() {\n    }, \"enqueueForceUpdate\")\n  }, emptyTreeContext = { id: 1, overflow: \"\" };\n  function pushTreeContext(baseContext, totalChildren, index) {\n    var baseIdWithLeadingBit = baseContext.id;\n    baseContext = baseContext.overflow;\n    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n    baseIdWithLeadingBit &= ~(1 << baseLength);\n    index += 1;\n    var length = 32 - clz32(totalChildren) + baseLength;\n    if (30 < length) {\n      var numberOfOverflowBits = baseLength - baseLength % 5;\n      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n      baseIdWithLeadingBit >>= numberOfOverflowBits;\n      baseLength -= numberOfOverflowBits;\n      return {\n        id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,\n        overflow: length + baseContext\n      };\n    }\n    return {\n      id: 1 << length | index << baseLength | baseIdWithLeadingBit,\n      overflow: baseContext\n    };\n  }\n  __name(pushTreeContext, \"pushTreeContext\");\n  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log4 = Math.log, LN2 = Math.LN2;\n  function clz32Fallback(x) {\n    x >>>= 0;\n    return 0 === x ? 32 : 31 - (log4(x) / LN2 | 0) | 0;\n  }\n  __name(clz32Fallback, \"clz32Fallback\");\n  var SuspenseException = Error(formatProdErrorMessage(460));\n  function noop$2() {\n  }\n  __name(noop$2, \"noop$2\");\n  function trackUsedThenable(thenableState2, thenable, index) {\n    index = thenableState2[index];\n    void 0 === index ? thenableState2.push(thenable) : index !== thenable && (thenable.then(noop$2, noop$2), thenable = index);\n    switch (thenable.status) {\n      case \"fulfilled\":\n        return thenable.value;\n      case \"rejected\":\n        throw thenable.reason;\n      default:\n        \"string\" === typeof thenable.status ? thenable.then(noop$2, noop$2) : (thenableState2 = thenable, thenableState2.status = \"pending\", thenableState2.then(\n          function(fulfilledValue) {\n            if (\"pending\" === thenable.status) {\n              var fulfilledThenable = thenable;\n              fulfilledThenable.status = \"fulfilled\";\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          function(error4) {\n            if (\"pending\" === thenable.status) {\n              var rejectedThenable = thenable;\n              rejectedThenable.status = \"rejected\";\n              rejectedThenable.reason = error4;\n            }\n          }\n        ));\n        switch (thenable.status) {\n          case \"fulfilled\":\n            return thenable.value;\n          case \"rejected\":\n            throw thenable.reason;\n        }\n        suspendedThenable = thenable;\n        throw SuspenseException;\n    }\n  }\n  __name(trackUsedThenable, \"trackUsedThenable\");\n  var suspendedThenable = null;\n  function getSuspendedThenable() {\n    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\n    var thenable = suspendedThenable;\n    suspendedThenable = null;\n    return thenable;\n  }\n  __name(getSuspendedThenable, \"getSuspendedThenable\");\n  function is2(x, y3) {\n    return x === y3 && (0 !== x || 1 / x === 1 / y3) || x !== x && y3 !== y3;\n  }\n  __name(is2, \"is\");\n  var objectIs = \"function\" === typeof Object.is ? Object.is : is2, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0;\n  function resolveCurrentlyRenderingComponent() {\n    if (null === currentlyRenderingComponent)\n      throw Error(formatProdErrorMessage(321));\n    return currentlyRenderingComponent;\n  }\n  __name(resolveCurrentlyRenderingComponent, \"resolveCurrentlyRenderingComponent\");\n  function createHook() {\n    if (0 < numberOfReRenders) throw Error(formatProdErrorMessage(312));\n    return { memoizedState: null, queue: null, next: null };\n  }\n  __name(createHook, \"createHook\");\n  function createWorkInProgressHook() {\n    null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);\n    return workInProgressHook;\n  }\n  __name(createWorkInProgressHook, \"createWorkInProgressHook\");\n  function getThenableStateAfterSuspending() {\n    var state = thenableState;\n    thenableState = null;\n    return state;\n  }\n  __name(getThenableStateAfterSuspending, \"getThenableStateAfterSuspending\");\n  function resetHooksState() {\n    currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;\n    didScheduleRenderPhaseUpdate = false;\n    firstWorkInProgressHook = null;\n    numberOfReRenders = 0;\n    workInProgressHook = renderPhaseUpdates = null;\n  }\n  __name(resetHooksState, \"resetHooksState\");\n  function basicStateReducer(state, action) {\n    return \"function\" === typeof action ? action(state) : action;\n  }\n  __name(basicStateReducer, \"basicStateReducer\");\n  function useReducer(reducer, initialArg, init2) {\n    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n    workInProgressHook = createWorkInProgressHook();\n    if (isReRender) {\n      var queue = workInProgressHook.queue;\n      initialArg = queue.dispatch;\n      if (null !== renderPhaseUpdates && (init2 = renderPhaseUpdates.get(queue), void 0 !== init2)) {\n        renderPhaseUpdates.delete(queue);\n        queue = workInProgressHook.memoizedState;\n        do\n          queue = reducer(queue, init2.action), init2 = init2.next;\n        while (null !== init2);\n        workInProgressHook.memoizedState = queue;\n        return [queue, initialArg];\n      }\n      return [workInProgressHook.memoizedState, initialArg];\n    }\n    reducer = reducer === basicStateReducer ? \"function\" === typeof initialArg ? initialArg() : initialArg : void 0 !== init2 ? init2(initialArg) : initialArg;\n    workInProgressHook.memoizedState = reducer;\n    reducer = workInProgressHook.queue = { last: null, dispatch: null };\n    reducer = reducer.dispatch = dispatchAction.bind(\n      null,\n      currentlyRenderingComponent,\n      reducer\n    );\n    return [workInProgressHook.memoizedState, reducer];\n  }\n  __name(useReducer, \"useReducer\");\n  function useMemo2(nextCreate, deps) {\n    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n    workInProgressHook = createWorkInProgressHook();\n    deps = void 0 === deps ? null : deps;\n    if (null !== workInProgressHook) {\n      var prevState = workInProgressHook.memoizedState;\n      if (null !== prevState && null !== deps) {\n        var prevDeps = prevState[1];\n        a: if (null === prevDeps) prevDeps = false;\n        else {\n          for (var i = 0; i < prevDeps.length && i < deps.length; i++)\n            if (!objectIs(deps[i], prevDeps[i])) {\n              prevDeps = false;\n              break a;\n            }\n          prevDeps = true;\n        }\n        if (prevDeps) return prevState[0];\n      }\n    }\n    nextCreate = nextCreate();\n    workInProgressHook.memoizedState = [nextCreate, deps];\n    return nextCreate;\n  }\n  __name(useMemo2, \"useMemo\");\n  function dispatchAction(componentIdentity, queue, action) {\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\n    if (componentIdentity === currentlyRenderingComponent)\n      if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)\n        renderPhaseUpdates.set(queue, componentIdentity);\n      else {\n        for (queue = action; null !== queue.next; ) queue = queue.next;\n        queue.next = componentIdentity;\n      }\n  }\n  __name(dispatchAction, \"dispatchAction\");\n  function unsupportedStartTransition() {\n    throw Error(formatProdErrorMessage(394));\n  }\n  __name(unsupportedStartTransition, \"unsupportedStartTransition\");\n  function unsupportedSetOptimisticState() {\n    throw Error(formatProdErrorMessage(479));\n  }\n  __name(unsupportedSetOptimisticState, \"unsupportedSetOptimisticState\");\n  function useActionState(action, initialState, permalink) {\n    resolveCurrentlyRenderingComponent();\n    var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;\n    if (\"function\" === typeof action.$$FORM_ACTION) {\n      var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;\n      request = request.formState;\n      var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;\n      if (null !== request && \"function\" === typeof isSignatureEqual) {\n        var postbackKey = request[1];\n        isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? \"p\" + permalink : \"k\" + murmurhash3_32_gc(\n          JSON.stringify([componentKeyPath, null, actionStateHookIndex]),\n          0\n        ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));\n      }\n      var boundAction = action.bind(null, initialState);\n      action = /* @__PURE__ */ __name(function(payload) {\n        boundAction(payload);\n      }, \"action\");\n      \"function\" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {\n        prefix2 = boundAction.$$FORM_ACTION(prefix2);\n        void 0 !== permalink && (permalink += \"\", prefix2.action = permalink);\n        var formData = prefix2.data;\n        formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? \"p\" + permalink : \"k\" + murmurhash3_32_gc(\n          JSON.stringify([\n            componentKeyPath,\n            null,\n            actionStateHookIndex\n          ]),\n          0\n        )), formData.append(\"$ACTION_KEY\", nextPostbackStateKey));\n        return prefix2;\n      });\n      return [initialState, action, false];\n    }\n    var boundAction$22 = action.bind(null, initialState);\n    return [\n      initialState,\n      function(payload) {\n        boundAction$22(payload);\n      },\n      false\n    ];\n  }\n  __name(useActionState, \"useActionState\");\n  function unwrapThenable(thenable) {\n    var index = thenableIndexCounter;\n    thenableIndexCounter += 1;\n    null === thenableState && (thenableState = []);\n    return trackUsedThenable(thenableState, thenable, index);\n  }\n  __name(unwrapThenable, \"unwrapThenable\");\n  function unsupportedRefresh() {\n    throw Error(formatProdErrorMessage(393));\n  }\n  __name(unsupportedRefresh, \"unsupportedRefresh\");\n  function noop$1() {\n  }\n  __name(noop$1, \"noop$1\");\n  var HooksDispatcher = {\n    readContext: /* @__PURE__ */ __name(function(context2) {\n      return context2._currentValue2;\n    }, \"readContext\"),\n    use: /* @__PURE__ */ __name(function(usable) {\n      if (null !== usable && \"object\" === typeof usable) {\n        if (\"function\" === typeof usable.then) return unwrapThenable(usable);\n        if (usable.$$typeof === REACT_CONTEXT_TYPE)\n          return usable._currentValue2;\n      }\n      throw Error(formatProdErrorMessage(438, String(usable)));\n    }, \"use\"),\n    useContext: /* @__PURE__ */ __name(function(context2) {\n      resolveCurrentlyRenderingComponent();\n      return context2._currentValue2;\n    }, \"useContext\"),\n    useMemo: useMemo2,\n    useReducer,\n    useRef: /* @__PURE__ */ __name(function(initialValue) {\n      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n      workInProgressHook = createWorkInProgressHook();\n      var previousRef = workInProgressHook.memoizedState;\n      return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;\n    }, \"useRef\"),\n    useState: /* @__PURE__ */ __name(function(initialState) {\n      return useReducer(basicStateReducer, initialState);\n    }, \"useState\"),\n    useInsertionEffect: noop$1,\n    useLayoutEffect: noop$1,\n    useCallback: /* @__PURE__ */ __name(function(callback, deps) {\n      return useMemo2(function() {\n        return callback;\n      }, deps);\n    }, \"useCallback\"),\n    useImperativeHandle: noop$1,\n    useEffect: noop$1,\n    useDebugValue: noop$1,\n    useDeferredValue: /* @__PURE__ */ __name(function(value2, initialValue) {\n      resolveCurrentlyRenderingComponent();\n      return void 0 !== initialValue ? initialValue : value2;\n    }, \"useDeferredValue\"),\n    useTransition: /* @__PURE__ */ __name(function() {\n      resolveCurrentlyRenderingComponent();\n      return [false, unsupportedStartTransition];\n    }, \"useTransition\"),\n    useId: /* @__PURE__ */ __name(function() {\n      var JSCompiler_inline_result = currentlyRenderingTask.treeContext;\n      var overflow = JSCompiler_inline_result.overflow;\n      JSCompiler_inline_result = JSCompiler_inline_result.id;\n      JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;\n      var resumableState = currentResumableState;\n      if (null === resumableState) throw Error(formatProdErrorMessage(404));\n      overflow = localIdCounter++;\n      JSCompiler_inline_result = \"\\xAB\" + resumableState.idPrefix + \"R\" + JSCompiler_inline_result;\n      0 < overflow && (JSCompiler_inline_result += \"H\" + overflow.toString(32));\n      return JSCompiler_inline_result + \"\\xBB\";\n    }, \"useId\"),\n    useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {\n      if (void 0 === getServerSnapshot)\n        throw Error(formatProdErrorMessage(407));\n      return getServerSnapshot();\n    }, \"useSyncExternalStore\"),\n    useOptimistic: /* @__PURE__ */ __name(function(passthrough) {\n      resolveCurrentlyRenderingComponent();\n      return [passthrough, unsupportedSetOptimisticState];\n    }, \"useOptimistic\"),\n    useActionState,\n    useFormState: useActionState,\n    useHostTransitionStatus: /* @__PURE__ */ __name(function() {\n      resolveCurrentlyRenderingComponent();\n      return sharedNotPendingObject;\n    }, \"useHostTransitionStatus\"),\n    useMemoCache: /* @__PURE__ */ __name(function(size) {\n      for (var data = Array(size), i = 0; i < size; i++)\n        data[i] = REACT_MEMO_CACHE_SENTINEL;\n      return data;\n    }, \"useMemoCache\"),\n    useCacheRefresh: /* @__PURE__ */ __name(function() {\n      return unsupportedRefresh;\n    }, \"useCacheRefresh\")\n  }, currentResumableState = null, DefaultAsyncDispatcher = {\n    getCacheForType: /* @__PURE__ */ __name(function() {\n      throw Error(formatProdErrorMessage(248));\n    }, \"getCacheForType\")\n  }, prefix, suffix;\n  function describeBuiltInComponentFrame(name) {\n    if (void 0 === prefix)\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || \"\";\n        suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n      }\n    return \"\\n\" + prefix + name + suffix;\n  }\n  __name(describeBuiltInComponentFrame, \"describeBuiltInComponentFrame\");\n  var reentry = false;\n  function describeNativeComponentFrame(fn2, construct) {\n    if (!fn2 || reentry) return \"\";\n    reentry = true;\n    var previousPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = void 0;\n    try {\n      var RunInRootFrame = {\n        DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {\n          try {\n            if (construct) {\n              var Fake = /* @__PURE__ */ __name(function() {\n                throw Error();\n              }, \"Fake\");\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: /* @__PURE__ */ __name(function() {\n                  throw Error();\n                }, \"set\")\n              });\n              if (\"object\" === typeof Reflect && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  var control = x;\n                }\n                Reflect.construct(fn2, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x$24) {\n                  control = x$24;\n                }\n                fn2.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x$25) {\n                control = x$25;\n              }\n              (Fake = fn2()) && \"function\" === typeof Fake.catch && Fake.catch(function() {\n              });\n            }\n          } catch (sample) {\n            if (sample && control && \"string\" === typeof sample.stack)\n              return [sample.stack, control.stack];\n          }\n          return [null, null];\n        }, \"DetermineComponentFrameRoot\")\n      };\n      RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n      var namePropDescriptor = Object.getOwnPropertyDescriptor(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        \"name\"\n      );\n      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        \"name\",\n        { value: \"DetermineComponentFrameRoot\" }\n      );\n      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n      if (sampleStack && controlStack) {\n        var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes(\"DetermineComponentFrameRoot\"); )\n          RunInRootFrame++;\n        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(\n          \"DetermineComponentFrameRoot\"\n        ); )\n          namePropDescriptor++;\n        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)\n          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )\n            namePropDescriptor--;\n        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)\n          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\n              do\n                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n                  var frame = \"\\n\" + sampleLines[RunInRootFrame].replace(\" at new \", \" at \");\n                  fn2.displayName && frame.includes(\"<anonymous>\") && (frame = frame.replace(\"<anonymous>\", fn2.displayName));\n                  return frame;\n                }\n              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\n            }\n            break;\n          }\n      }\n    } finally {\n      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;\n    }\n    return (previousPrepareStackTrace = fn2 ? fn2.displayName || fn2.name : \"\") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : \"\";\n  }\n  __name(describeNativeComponentFrame, \"describeNativeComponentFrame\");\n  function describeComponentStackByType(type2) {\n    if (\"string\" === typeof type2) return describeBuiltInComponentFrame(type2);\n    if (\"function\" === typeof type2)\n      return type2.prototype && type2.prototype.isReactComponent ? describeNativeComponentFrame(type2, true) : describeNativeComponentFrame(type2, false);\n    if (\"object\" === typeof type2 && null !== type2) {\n      switch (type2.$$typeof) {\n        case REACT_FORWARD_REF_TYPE:\n          return describeNativeComponentFrame(type2.render, false);\n        case REACT_MEMO_TYPE:\n          return describeNativeComponentFrame(type2.type, false);\n        case REACT_LAZY_TYPE:\n          var lazyComponent = type2, payload = lazyComponent._payload;\n          lazyComponent = lazyComponent._init;\n          try {\n            type2 = lazyComponent(payload);\n          } catch (x) {\n            return describeBuiltInComponentFrame(\"Lazy\");\n          }\n          return describeComponentStackByType(type2);\n      }\n      if (\"string\" === typeof type2.name)\n        return payload = type2.env, describeBuiltInComponentFrame(\n          type2.name + (payload ? \" [\" + payload + \"]\" : \"\")\n        );\n    }\n    switch (type2) {\n      case REACT_SUSPENSE_LIST_TYPE:\n        return describeBuiltInComponentFrame(\"SuspenseList\");\n      case REACT_SUSPENSE_TYPE:\n        return describeBuiltInComponentFrame(\"Suspense\");\n    }\n    return \"\";\n  }\n  __name(describeComponentStackByType, \"describeComponentStackByType\");\n  function defaultErrorHandler(error4) {\n    if (\"object\" === typeof error4 && null !== error4 && \"string\" === typeof error4.environmentName) {\n      var JSCompiler_inline_result = error4.environmentName;\n      error4 = [error4].slice(0);\n      \"string\" === typeof error4[0] ? error4.splice(\n        0,\n        1,\n        \"[%s] \" + error4[0],\n        \" \" + JSCompiler_inline_result + \" \"\n      ) : error4.splice(0, 0, \"[%s] \", \" \" + JSCompiler_inline_result + \" \");\n      error4.unshift(console);\n      JSCompiler_inline_result = bind2.apply(console.error, error4);\n      JSCompiler_inline_result();\n    } else console.error(error4);\n    return null;\n  }\n  __name(defaultErrorHandler, \"defaultErrorHandler\");\n  function noop3() {\n  }\n  __name(noop3, \"noop\");\n  function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n    var abortSet = /* @__PURE__ */ new Set();\n    this.destination = null;\n    this.flushScheduled = false;\n    this.resumableState = resumableState;\n    this.renderState = renderState;\n    this.rootFormatContext = rootFormatContext;\n    this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;\n    this.status = 10;\n    this.fatalError = null;\n    this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;\n    this.completedPreambleSegments = this.completedRootSegment = null;\n    this.abortableTasks = abortSet;\n    this.pingedTasks = [];\n    this.clientRenderedBoundaries = [];\n    this.completedBoundaries = [];\n    this.partialBoundaries = [];\n    this.trackedPostpones = null;\n    this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;\n    this.onPostpone = void 0 === onPostpone ? noop3 : onPostpone;\n    this.onAllReady = void 0 === onAllReady ? noop3 : onAllReady;\n    this.onShellReady = void 0 === onShellReady ? noop3 : onShellReady;\n    this.onShellError = void 0 === onShellError ? noop3 : onShellError;\n    this.onFatalError = void 0 === onFatalError ? noop3 : onFatalError;\n    this.formState = void 0 === formState ? null : formState;\n  }\n  __name(RequestInstance, \"RequestInstance\");\n  function createRequest2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {\n    resumableState = new RequestInstance(\n      resumableState,\n      renderState,\n      rootFormatContext,\n      progressiveChunkSize,\n      onError2,\n      onAllReady,\n      onShellReady,\n      onShellError,\n      onFatalError,\n      onPostpone,\n      formState\n    );\n    renderState = createPendingSegment(\n      resumableState,\n      0,\n      null,\n      rootFormatContext,\n      false,\n      false\n    );\n    renderState.parentFlushed = true;\n    children = createRenderTask(\n      resumableState,\n      null,\n      children,\n      -1,\n      null,\n      renderState,\n      null,\n      null,\n      resumableState.abortableTasks,\n      null,\n      rootFormatContext,\n      null,\n      emptyTreeContext,\n      null,\n      false\n    );\n    pushComponentStack(children);\n    resumableState.pingedTasks.push(children);\n    return resumableState;\n  }\n  __name(createRequest2, \"createRequest\");\n  var currentRequest = null;\n  function pingTask(request, task) {\n    request.pingedTasks.push(task);\n    1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));\n  }\n  __name(pingTask, \"pingTask\");\n  function createSuspenseBoundary(request, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {\n    return {\n      status: 0,\n      rootSegmentID: -1,\n      parentFlushed: false,\n      pendingTasks: 0,\n      completedSegments: [],\n      byteSize: 0,\n      fallbackAbortableTasks,\n      errorDigest: null,\n      contentState: createHoistableState(),\n      fallbackState: createHoistableState(),\n      contentPreamble,\n      fallbackPreamble,\n      trackedContentKeyPath: null,\n      trackedFallbackNode: null\n    };\n  }\n  __name(createSuspenseBoundary, \"createSuspenseBoundary\");\n  function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, componentStack, isFallback) {\n    request.allPendingTasks++;\n    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;\n    var task = {\n      replay: null,\n      node,\n      childIndex,\n      ping: /* @__PURE__ */ __name(function() {\n        return pingTask(request, task);\n      }, \"ping\"),\n      blockedBoundary,\n      blockedSegment,\n      blockedPreamble,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context: context2,\n      treeContext,\n      componentStack,\n      thenableState: thenableState2,\n      isFallback\n    };\n    abortSet.add(task);\n    return task;\n  }\n  __name(createRenderTask, \"createRenderTask\");\n  function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context2, treeContext, componentStack, isFallback) {\n    request.allPendingTasks++;\n    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;\n    replay.pendingTasks++;\n    var task = {\n      replay,\n      node,\n      childIndex,\n      ping: /* @__PURE__ */ __name(function() {\n        return pingTask(request, task);\n      }, \"ping\"),\n      blockedBoundary,\n      blockedSegment: null,\n      blockedPreamble: null,\n      hoistableState,\n      abortSet,\n      keyPath,\n      formatContext,\n      context: context2,\n      treeContext,\n      componentStack,\n      thenableState: thenableState2,\n      isFallback\n    };\n    abortSet.add(task);\n    return task;\n  }\n  __name(createReplayTask, \"createReplayTask\");\n  function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {\n    return {\n      status: 0,\n      parentFlushed: false,\n      id: -1,\n      index,\n      chunks: [],\n      children: [],\n      preambleChildren: [],\n      parentFormatContext,\n      boundary,\n      lastPushedText,\n      textEmbedded\n    };\n  }\n  __name(createPendingSegment, \"createPendingSegment\");\n  function pushComponentStack(task) {\n    var node = task.node;\n    if (\"object\" === typeof node && null !== node)\n      switch (node.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          task.componentStack = { parent: task.componentStack, type: node.type };\n      }\n  }\n  __name(pushComponentStack, \"pushComponentStack\");\n  function getThrownInfo(node$jscomp$0) {\n    var errorInfo = {};\n    node$jscomp$0 && Object.defineProperty(errorInfo, \"componentStack\", {\n      configurable: true,\n      enumerable: true,\n      get: /* @__PURE__ */ __name(function() {\n        try {\n          var info4 = \"\", node = node$jscomp$0;\n          do\n            info4 += describeComponentStackByType(node.type), node = node.parent;\n          while (node);\n          var JSCompiler_inline_result = info4;\n        } catch (x) {\n          JSCompiler_inline_result = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n        Object.defineProperty(errorInfo, \"componentStack\", {\n          value: JSCompiler_inline_result\n        });\n        return JSCompiler_inline_result;\n      }, \"get\")\n    });\n    return errorInfo;\n  }\n  __name(getThrownInfo, \"getThrownInfo\");\n  function logRecoverableError(request, error4, errorInfo) {\n    request = request.onError;\n    error4 = request(error4, errorInfo);\n    if (null == error4 || \"string\" === typeof error4) return error4;\n  }\n  __name(logRecoverableError, \"logRecoverableError\");\n  function fatalError(request, error4) {\n    var onShellError = request.onShellError, onFatalError = request.onFatalError;\n    onShellError(error4);\n    onFatalError(error4);\n    null !== request.destination ? (request.status = 14, request.destination.destroy(error4)) : (request.status = 13, request.fatalError = error4);\n  }\n  __name(fatalError, \"fatalError\");\n  function renderWithHooks(request, task, keyPath, Component, props, secondArg) {\n    var prevThenableState = task.thenableState;\n    task.thenableState = null;\n    currentlyRenderingComponent = {};\n    currentlyRenderingTask = task;\n    currentlyRenderingRequest = request;\n    currentlyRenderingKeyPath = keyPath;\n    actionStateCounter = localIdCounter = 0;\n    actionStateMatchingIndex = -1;\n    thenableIndexCounter = 0;\n    thenableState = prevThenableState;\n    for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate; )\n      didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);\n    resetHooksState();\n    return request;\n  }\n  __name(renderWithHooks, \"renderWithHooks\");\n  function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {\n    var didEmitActionStateMarkers = false;\n    if (0 !== actionStateCount && null !== request.formState) {\n      var segment = task.blockedSegment;\n      if (null !== segment) {\n        didEmitActionStateMarkers = true;\n        segment = segment.chunks;\n        for (var i = 0; i < actionStateCount; i++)\n          i === actionStateMatchingIndex2 ? segment.push(\"<!--F!-->\") : segment.push(\"<!--F-->\");\n      }\n    }\n    actionStateCount = task.keyPath;\n    task.keyPath = keyPath;\n    hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);\n    task.keyPath = actionStateCount;\n  }\n  __name(finishFunctionComponent, \"finishFunctionComponent\");\n  function renderElement2(request, task, keyPath, type2, props, ref) {\n    if (\"function\" === typeof type2)\n      if (type2.prototype && type2.prototype.isReactComponent) {\n        var newProps = props;\n        if (\"ref\" in props) {\n          newProps = {};\n          for (var propName2 in props)\n            \"ref\" !== propName2 && (newProps[propName2] = props[propName2]);\n        }\n        var defaultProps = type2.defaultProps;\n        if (defaultProps) {\n          newProps === props && (newProps = assign({}, newProps, props));\n          for (var propName$33 in defaultProps)\n            void 0 === newProps[propName$33] && (newProps[propName$33] = defaultProps[propName$33]);\n        }\n        props = newProps;\n        newProps = emptyContextObject;\n        defaultProps = type2.contextType;\n        \"object\" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue2);\n        newProps = new type2(props, newProps);\n        var initialState = void 0 !== newProps.state ? newProps.state : null;\n        newProps.updater = classComponentUpdater;\n        newProps.props = props;\n        newProps.state = initialState;\n        defaultProps = { queue: [], replace: false };\n        newProps._reactInternals = defaultProps;\n        ref = type2.contextType;\n        newProps.context = \"object\" === typeof ref && null !== ref ? ref._currentValue2 : emptyContextObject;\n        ref = type2.getDerivedStateFromProps;\n        \"function\" === typeof ref && (ref = ref(props, initialState), initialState = null === ref || void 0 === ref ? initialState : assign({}, initialState, ref), newProps.state = initialState);\n        if (\"function\" !== typeof type2.getDerivedStateFromProps && \"function\" !== typeof newProps.getSnapshotBeforeUpdate && (\"function\" === typeof newProps.UNSAFE_componentWillMount || \"function\" === typeof newProps.componentWillMount))\n          if (type2 = newProps.state, \"function\" === typeof newProps.componentWillMount && newProps.componentWillMount(), \"function\" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type2 !== newProps.state && classComponentUpdater.enqueueReplaceState(\n            newProps,\n            newProps.state,\n            null\n          ), null !== defaultProps.queue && 0 < defaultProps.queue.length)\n            if (type2 = defaultProps.queue, ref = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = false, ref && 1 === type2.length)\n              newProps.state = type2[0];\n            else {\n              defaultProps = ref ? type2[0] : newProps.state;\n              initialState = true;\n              for (ref = ref ? 1 : 0; ref < type2.length; ref++)\n                propName$33 = type2[ref], propName$33 = \"function\" === typeof propName$33 ? propName$33.call(newProps, defaultProps, props, void 0) : propName$33, null != propName$33 && (initialState ? (initialState = false, defaultProps = assign({}, defaultProps, propName$33)) : assign(defaultProps, propName$33));\n              newProps.state = defaultProps;\n            }\n          else defaultProps.queue = null;\n        type2 = newProps.render();\n        if (12 === request.status) throw null;\n        props = task.keyPath;\n        task.keyPath = keyPath;\n        renderNodeDestructive(request, task, type2, -1);\n        task.keyPath = props;\n      } else {\n        type2 = renderWithHooks(request, task, keyPath, type2, props, void 0);\n        if (12 === request.status) throw null;\n        finishFunctionComponent(\n          request,\n          task,\n          keyPath,\n          type2,\n          0 !== localIdCounter,\n          actionStateCounter,\n          actionStateMatchingIndex\n        );\n      }\n    else if (\"string\" === typeof type2)\n      if (newProps = task.blockedSegment, null === newProps)\n        newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type2, props), task.keyPath = keyPath, renderNode(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;\n      else {\n        ref = pushStartInstance(\n          newProps.chunks,\n          type2,\n          props,\n          request.resumableState,\n          request.renderState,\n          task.blockedPreamble,\n          task.hoistableState,\n          task.formatContext,\n          newProps.lastPushedText,\n          task.isFallback\n        );\n        newProps.lastPushedText = false;\n        defaultProps = task.formatContext;\n        initialState = task.keyPath;\n        task.keyPath = keyPath;\n        3 === (task.formatContext = getChildFormatContext(defaultProps, type2, props)).insertionMode ? (keyPath = createPendingSegment(\n          request,\n          0,\n          null,\n          task.formatContext,\n          false,\n          false\n        ), newProps.preambleChildren.push(keyPath), keyPath = createRenderTask(\n          request,\n          null,\n          ref,\n          -1,\n          task.blockedBoundary,\n          keyPath,\n          task.blockedPreamble,\n          task.hoistableState,\n          request.abortableTasks,\n          task.keyPath,\n          task.formatContext,\n          task.context,\n          task.treeContext,\n          task.componentStack,\n          task.isFallback\n        ), pushComponentStack(keyPath), request.pingedTasks.push(keyPath)) : renderNode(request, task, ref, -1);\n        task.formatContext = defaultProps;\n        task.keyPath = initialState;\n        a: {\n          task = newProps.chunks;\n          request = request.resumableState;\n          switch (type2) {\n            case \"title\":\n            case \"style\":\n            case \"script\":\n            case \"area\":\n            case \"base\":\n            case \"br\":\n            case \"col\":\n            case \"embed\":\n            case \"hr\":\n            case \"img\":\n            case \"input\":\n            case \"keygen\":\n            case \"link\":\n            case \"meta\":\n            case \"param\":\n            case \"source\":\n            case \"track\":\n            case \"wbr\":\n              break a;\n            case \"body\":\n              if (1 >= defaultProps.insertionMode) {\n                request.hasBody = true;\n                break a;\n              }\n              break;\n            case \"html\":\n              if (0 === defaultProps.insertionMode) {\n                request.hasHtml = true;\n                break a;\n              }\n              break;\n            case \"head\":\n              if (1 >= defaultProps.insertionMode) break a;\n          }\n          task.push(endChunkForTag(type2));\n        }\n        newProps.lastPushedText = false;\n      }\n    else {\n      switch (type2) {\n        case REACT_LEGACY_HIDDEN_TYPE:\n        case REACT_STRICT_MODE_TYPE:\n        case REACT_PROFILER_TYPE:\n        case REACT_FRAGMENT_TYPE:\n          type2 = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, props.children, -1);\n          task.keyPath = type2;\n          return;\n        case REACT_ACTIVITY_TYPE:\n          \"hidden\" !== props.mode && (type2 = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, props.children, -1), task.keyPath = type2);\n          return;\n        case REACT_SUSPENSE_LIST_TYPE:\n          type2 = task.keyPath;\n          task.keyPath = keyPath;\n          renderNodeDestructive(request, task, props.children, -1);\n          task.keyPath = type2;\n          return;\n        case REACT_VIEW_TRANSITION_TYPE:\n        case REACT_SCOPE_TYPE:\n          throw Error(formatProdErrorMessage(343));\n        case REACT_SUSPENSE_TYPE:\n          a: if (null !== task.replay) {\n            type2 = task.keyPath;\n            task.keyPath = keyPath;\n            keyPath = props.children;\n            try {\n              renderNode(request, task, keyPath, -1);\n            } finally {\n              task.keyPath = type2;\n            }\n          } else {\n            type2 = task.keyPath;\n            var parentBoundary = task.blockedBoundary;\n            ref = task.blockedPreamble;\n            var parentHoistableState = task.hoistableState;\n            propName$33 = task.blockedSegment;\n            propName2 = props.fallback;\n            props = props.children;\n            var fallbackAbortSet = /* @__PURE__ */ new Set();\n            var newBoundary = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(\n              request,\n              fallbackAbortSet,\n              createPreambleState(),\n              createPreambleState()\n            ) : createSuspenseBoundary(request, fallbackAbortSet, null, null);\n            null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);\n            var boundarySegment = createPendingSegment(\n              request,\n              propName$33.chunks.length,\n              newBoundary,\n              task.formatContext,\n              false,\n              false\n            );\n            propName$33.children.push(boundarySegment);\n            propName$33.lastPushedText = false;\n            var contentRootSegment = createPendingSegment(\n              request,\n              0,\n              null,\n              task.formatContext,\n              false,\n              false\n            );\n            contentRootSegment.parentFlushed = true;\n            if (null !== request.trackedPostpones) {\n              newProps = [keyPath[0], \"Suspense Fallback\", keyPath[2]];\n              defaultProps = [newProps[1], newProps[2], [], null];\n              request.trackedPostpones.workingMap.set(newProps, defaultProps);\n              newBoundary.trackedFallbackNode = defaultProps;\n              task.blockedSegment = boundarySegment;\n              task.blockedPreamble = newBoundary.fallbackPreamble;\n              task.keyPath = newProps;\n              boundarySegment.status = 6;\n              try {\n                renderNode(request, task, propName2, -1), pushSegmentFinale(\n                  boundarySegment.chunks,\n                  request.renderState,\n                  boundarySegment.lastPushedText,\n                  boundarySegment.textEmbedded\n                ), boundarySegment.status = 1;\n              } catch (thrownValue) {\n                throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;\n              } finally {\n                task.blockedSegment = propName$33, task.blockedPreamble = ref, task.keyPath = type2;\n              }\n              task = createRenderTask(\n                request,\n                null,\n                props,\n                -1,\n                newBoundary,\n                contentRootSegment,\n                newBoundary.contentPreamble,\n                newBoundary.contentState,\n                task.abortSet,\n                keyPath,\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                task.isFallback\n              );\n              pushComponentStack(task);\n              request.pingedTasks.push(task);\n            } else {\n              task.blockedBoundary = newBoundary;\n              task.blockedPreamble = newBoundary.contentPreamble;\n              task.hoistableState = newBoundary.contentState;\n              task.blockedSegment = contentRootSegment;\n              task.keyPath = keyPath;\n              contentRootSegment.status = 6;\n              try {\n                if (renderNode(request, task, props, -1), pushSegmentFinale(\n                  contentRootSegment.chunks,\n                  request.renderState,\n                  contentRootSegment.lastPushedText,\n                  contentRootSegment.textEmbedded\n                ), contentRootSegment.status = 1, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {\n                  newBoundary.status = 1;\n                  0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);\n                  break a;\n                }\n              } catch (thrownValue$28) {\n                newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$28), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(\n                  request,\n                  newProps,\n                  defaultProps\n                ), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);\n              } finally {\n                task.blockedBoundary = parentBoundary, task.blockedPreamble = ref, task.hoistableState = parentHoistableState, task.blockedSegment = propName$33, task.keyPath = type2;\n              }\n              task = createRenderTask(\n                request,\n                null,\n                propName2,\n                -1,\n                parentBoundary,\n                boundarySegment,\n                newBoundary.fallbackPreamble,\n                newBoundary.fallbackState,\n                fallbackAbortSet,\n                [keyPath[0], \"Suspense Fallback\", keyPath[2]],\n                task.formatContext,\n                task.context,\n                task.treeContext,\n                task.componentStack,\n                true\n              );\n              pushComponentStack(task);\n              request.pingedTasks.push(task);\n            }\n          }\n          return;\n      }\n      if (\"object\" === typeof type2 && null !== type2)\n        switch (type2.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            if (\"ref\" in props)\n              for (newBoundary in newProps = {}, props)\n                \"ref\" !== newBoundary && (newProps[newBoundary] = props[newBoundary]);\n            else newProps = props;\n            type2 = renderWithHooks(\n              request,\n              task,\n              keyPath,\n              type2.render,\n              newProps,\n              ref\n            );\n            finishFunctionComponent(\n              request,\n              task,\n              keyPath,\n              type2,\n              0 !== localIdCounter,\n              actionStateCounter,\n              actionStateMatchingIndex\n            );\n            return;\n          case REACT_MEMO_TYPE:\n            renderElement2(request, task, keyPath, type2.type, props, ref);\n            return;\n          case REACT_PROVIDER_TYPE:\n          case REACT_CONTEXT_TYPE:\n            defaultProps = props.children;\n            newProps = task.keyPath;\n            props = props.value;\n            initialState = type2._currentValue2;\n            type2._currentValue2 = props;\n            ref = currentActiveSnapshot;\n            currentActiveSnapshot = type2 = {\n              parent: ref,\n              depth: null === ref ? 0 : ref.depth + 1,\n              context: type2,\n              parentValue: initialState,\n              value: props\n            };\n            task.context = type2;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, defaultProps, -1);\n            request = currentActiveSnapshot;\n            if (null === request) throw Error(formatProdErrorMessage(403));\n            request.context._currentValue2 = request.parentValue;\n            request = currentActiveSnapshot = request.parent;\n            task.context = request;\n            task.keyPath = newProps;\n            return;\n          case REACT_CONSUMER_TYPE:\n            props = props.children;\n            type2 = props(type2._context._currentValue2);\n            props = task.keyPath;\n            task.keyPath = keyPath;\n            renderNodeDestructive(request, task, type2, -1);\n            task.keyPath = props;\n            return;\n          case REACT_LAZY_TYPE:\n            newProps = type2._init;\n            type2 = newProps(type2._payload);\n            if (12 === request.status) throw null;\n            renderElement2(request, task, keyPath, type2, props, ref);\n            return;\n        }\n      throw Error(\n        formatProdErrorMessage(130, null == type2 ? type2 : typeof type2, \"\")\n      );\n    }\n  }\n  __name(renderElement2, \"renderElement\");\n  function resumeNode(request, task, segmentId, node, childIndex) {\n    var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(\n      request,\n      0,\n      null,\n      task.formatContext,\n      false,\n      false\n    );\n    resumedSegment.id = segmentId;\n    resumedSegment.parentFlushed = true;\n    try {\n      task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = 1, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));\n    } finally {\n      task.replay = prevReplay, task.blockedSegment = null;\n    }\n  }\n  __name(resumeNode, \"resumeNode\");\n  function renderNodeDestructive(request, task, node, childIndex) {\n    null !== task.replay && \"number\" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);\n  }\n  __name(renderNodeDestructive, \"renderNodeDestructive\");\n  function retryNode(request, task) {\n    var node = task.node, childIndex = task.childIndex;\n    if (null !== node) {\n      if (\"object\" === typeof node) {\n        switch (node.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            var type2 = node.type, key = node.key, props = node.props;\n            node = props.ref;\n            var ref = void 0 !== node ? node : null, name = getComponentNameFromType(type2), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;\n            key = [task.keyPath, name, keyOrIndex];\n            if (null !== task.replay)\n              a: {\n                var replay = task.replay;\n                childIndex = replay.nodes;\n                for (node = 0; node < childIndex.length; node++) {\n                  var node$jscomp$0 = childIndex[node];\n                  if (keyOrIndex === node$jscomp$0[1]) {\n                    if (4 === node$jscomp$0.length) {\n                      if (null !== name && name !== node$jscomp$0[0])\n                        throw Error(\n                          formatProdErrorMessage(490, node$jscomp$0[0], name)\n                        );\n                      var childNodes = node$jscomp$0[2];\n                      name = node$jscomp$0[3];\n                      keyOrIndex = task.node;\n                      task.replay = {\n                        nodes: childNodes,\n                        slots: name,\n                        pendingTasks: 1\n                      };\n                      try {\n                        renderElement2(request, task, key, type2, props, ref);\n                        if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n                          throw Error(formatProdErrorMessage(488));\n                        task.replay.pendingTasks--;\n                      } catch (x) {\n                        if (\"object\" === typeof x && null !== x && (x === SuspenseException || \"function\" === typeof x.then))\n                          throw task.node === keyOrIndex && (task.replay = replay), x;\n                        task.replay.pendingTasks--;\n                        props = getThrownInfo(task.componentStack);\n                        key = task.blockedBoundary;\n                        type2 = x;\n                        props = logRecoverableError(request, type2, props);\n                        abortRemainingReplayNodes(\n                          request,\n                          key,\n                          childNodes,\n                          name,\n                          type2,\n                          props\n                        );\n                      }\n                      task.replay = replay;\n                    } else {\n                      if (type2 !== REACT_SUSPENSE_TYPE)\n                        throw Error(\n                          formatProdErrorMessage(\n                            490,\n                            \"Suspense\",\n                            getComponentNameFromType(type2) || \"Unknown\"\n                          )\n                        );\n                      b: {\n                        replay = void 0;\n                        type2 = node$jscomp$0[5];\n                        ref = node$jscomp$0[2];\n                        name = node$jscomp$0[3];\n                        keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];\n                        node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];\n                        var prevKeyPath = task.keyPath, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();\n                        props = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(\n                          request,\n                          fallbackAbortSet,\n                          createPreambleState(),\n                          createPreambleState()\n                        ) : createSuspenseBoundary(\n                          request,\n                          fallbackAbortSet,\n                          null,\n                          null\n                        );\n                        props.parentFlushed = true;\n                        props.rootSegmentID = type2;\n                        task.blockedBoundary = props;\n                        task.hoistableState = props.contentState;\n                        task.keyPath = key;\n                        task.replay = {\n                          nodes: ref,\n                          slots: name,\n                          pendingTasks: 1\n                        };\n                        try {\n                          renderNode(request, task, content, -1);\n                          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n                            throw Error(formatProdErrorMessage(488));\n                          task.replay.pendingTasks--;\n                          if (0 === props.pendingTasks && 0 === props.status) {\n                            props.status = 1;\n                            request.completedBoundaries.push(props);\n                            break b;\n                          }\n                        } catch (error4) {\n                          props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(\n                            request,\n                            error4,\n                            childNodes\n                          ), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);\n                        } finally {\n                          task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath;\n                        }\n                        task = createReplayTask(\n                          request,\n                          null,\n                          {\n                            nodes: keyOrIndex,\n                            slots: node$jscomp$0,\n                            pendingTasks: 0\n                          },\n                          fallback,\n                          -1,\n                          parentBoundary,\n                          props.fallbackState,\n                          fallbackAbortSet,\n                          [key[0], \"Suspense Fallback\", key[2]],\n                          task.formatContext,\n                          task.context,\n                          task.treeContext,\n                          task.componentStack,\n                          true\n                        );\n                        pushComponentStack(task);\n                        request.pingedTasks.push(task);\n                      }\n                    }\n                    childIndex.splice(node, 1);\n                    break a;\n                  }\n                }\n              }\n            else renderElement2(request, task, key, type2, props, ref);\n            return;\n          case REACT_PORTAL_TYPE:\n            throw Error(formatProdErrorMessage(257));\n          case REACT_LAZY_TYPE:\n            childNodes = node._init;\n            node = childNodes(node._payload);\n            if (12 === request.status) throw null;\n            renderNodeDestructive(request, task, node, childIndex);\n            return;\n        }\n        if (isArrayImpl(node)) {\n          renderChildrenArray(request, task, node, childIndex);\n          return;\n        }\n        null === node || \"object\" !== typeof node ? childNodes = null : (childNodes = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node[\"@@iterator\"], childNodes = \"function\" === typeof childNodes ? childNodes : null);\n        if (childNodes && (childNodes = childNodes.call(node))) {\n          node = childNodes.next();\n          if (!node.done) {\n            props = [];\n            do\n              props.push(node.value), node = childNodes.next();\n            while (!node.done);\n            renderChildrenArray(request, task, props, childIndex);\n          }\n          return;\n        }\n        if (\"function\" === typeof node.then)\n          return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);\n        if (node.$$typeof === REACT_CONTEXT_TYPE)\n          return renderNodeDestructive(\n            request,\n            task,\n            node._currentValue2,\n            childIndex\n          );\n        childIndex = Object.prototype.toString.call(node);\n        throw Error(\n          formatProdErrorMessage(\n            31,\n            \"[object Object]\" === childIndex ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childIndex\n          )\n        );\n      }\n      if (\"string\" === typeof node)\n        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(\n          childIndex.chunks,\n          node,\n          request.renderState,\n          childIndex.lastPushedText\n        ));\n      else if (\"number\" === typeof node || \"bigint\" === typeof node)\n        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(\n          childIndex.chunks,\n          \"\" + node,\n          request.renderState,\n          childIndex.lastPushedText\n        ));\n    }\n  }\n  __name(retryNode, \"retryNode\");\n  function renderChildrenArray(request, task, children, childIndex) {\n    var prevKeyPath = task.keyPath;\n    if (-1 !== childIndex && (task.keyPath = [task.keyPath, \"Fragment\", childIndex], null !== task.replay)) {\n      for (var replay = task.replay, replayNodes = replay.nodes, j3 = 0; j3 < replayNodes.length; j3++) {\n        var node = replayNodes[j3];\n        if (node[1] === childIndex) {\n          childIndex = node[2];\n          node = node[3];\n          task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };\n          try {\n            renderChildrenArray(request, task, children, -1);\n            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n              throw Error(formatProdErrorMessage(488));\n            task.replay.pendingTasks--;\n          } catch (x) {\n            if (\"object\" === typeof x && null !== x && (x === SuspenseException || \"function\" === typeof x.then))\n              throw x;\n            task.replay.pendingTasks--;\n            children = getThrownInfo(task.componentStack);\n            var boundary = task.blockedBoundary, error4 = x;\n            children = logRecoverableError(request, error4, children);\n            abortRemainingReplayNodes(\n              request,\n              boundary,\n              childIndex,\n              node,\n              error4,\n              children\n            );\n          }\n          task.replay = replay;\n          replayNodes.splice(j3, 1);\n          break;\n        }\n      }\n      task.keyPath = prevKeyPath;\n      return;\n    }\n    replay = task.treeContext;\n    replayNodes = children.length;\n    if (null !== task.replay && (j3 = task.replay.slots, null !== j3 && \"object\" === typeof j3)) {\n      for (childIndex = 0; childIndex < replayNodes; childIndex++)\n        node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j3[childIndex], \"number\" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j3[childIndex]) : renderNode(request, task, node, childIndex);\n      task.treeContext = replay;\n      task.keyPath = prevKeyPath;\n      return;\n    }\n    for (j3 = 0; j3 < replayNodes; j3++)\n      childIndex = children[j3], task.treeContext = pushTreeContext(replay, replayNodes, j3), renderNode(request, task, childIndex, j3);\n    task.treeContext = replay;\n    task.keyPath = prevKeyPath;\n  }\n  __name(renderChildrenArray, \"renderChildrenArray\");\n  function untrackBoundary(request, boundary) {\n    request = request.trackedPostpones;\n    null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));\n  }\n  __name(untrackBoundary, \"untrackBoundary\");\n  function spawnNewSuspendedReplayTask(request, task, thenableState2) {\n    return createReplayTask(\n      request,\n      thenableState2,\n      task.replay,\n      task.node,\n      task.childIndex,\n      task.blockedBoundary,\n      task.hoistableState,\n      task.abortSet,\n      task.keyPath,\n      task.formatContext,\n      task.context,\n      task.treeContext,\n      task.componentStack,\n      task.isFallback\n    );\n  }\n  __name(spawnNewSuspendedReplayTask, \"spawnNewSuspendedReplayTask\");\n  function spawnNewSuspendedRenderTask(request, task, thenableState2) {\n    var segment = task.blockedSegment, newSegment = createPendingSegment(\n      request,\n      segment.chunks.length,\n      null,\n      task.formatContext,\n      segment.lastPushedText,\n      true\n    );\n    segment.children.push(newSegment);\n    segment.lastPushedText = false;\n    return createRenderTask(\n      request,\n      thenableState2,\n      task.node,\n      task.childIndex,\n      task.blockedBoundary,\n      newSegment,\n      task.blockedPreamble,\n      task.hoistableState,\n      task.abortSet,\n      task.keyPath,\n      task.formatContext,\n      task.context,\n      task.treeContext,\n      task.componentStack,\n      task.isFallback\n    );\n  }\n  __name(spawnNewSuspendedRenderTask, \"spawnNewSuspendedRenderTask\");\n  function renderNode(request, task, node, childIndex) {\n    var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;\n    if (null === segment)\n      try {\n        return renderNodeDestructive(request, task, node, childIndex);\n      } catch (thrownValue) {\n        if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, \"object\" === typeof node && null !== node) {\n          if (\"function\" === typeof node.then) {\n            childIndex = getThenableStateAfterSuspending();\n            request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;\n            node.then(request, request);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n          if (\"Maximum call stack size exceeded\" === node.message) {\n            node = getThenableStateAfterSuspending();\n            node = spawnNewSuspendedReplayTask(request, task, node);\n            request.pingedTasks.push(node);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n        }\n      }\n    else {\n      var childrenLength = segment.children.length, chunkLength = segment.chunks.length;\n      try {\n        return renderNodeDestructive(request, task, node, childIndex);\n      } catch (thrownValue$48) {\n        if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$48 === SuspenseException ? getSuspendedThenable() : thrownValue$48, \"object\" === typeof node && null !== node) {\n          if (\"function\" === typeof node.then) {\n            childIndex = getThenableStateAfterSuspending();\n            request = spawnNewSuspendedRenderTask(request, task, childIndex).ping;\n            node.then(request, request);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n          if (\"Maximum call stack size exceeded\" === node.message) {\n            node = getThenableStateAfterSuspending();\n            node = spawnNewSuspendedRenderTask(request, task, node);\n            request.pingedTasks.push(node);\n            task.formatContext = previousFormatContext;\n            task.context = previousContext;\n            task.keyPath = previousKeyPath;\n            task.treeContext = previousTreeContext;\n            task.componentStack = previousComponentStack;\n            switchContext(previousContext);\n            return;\n          }\n        }\n      }\n    }\n    task.formatContext = previousFormatContext;\n    task.context = previousContext;\n    task.keyPath = previousKeyPath;\n    task.treeContext = previousTreeContext;\n    switchContext(previousContext);\n    throw node;\n  }\n  __name(renderNode, \"renderNode\");\n  function abortTaskSoft(task) {\n    var boundary = task.blockedBoundary;\n    task = task.blockedSegment;\n    null !== task && (task.status = 3, finishedTask(this, boundary, task));\n  }\n  __name(abortTaskSoft, \"abortTaskSoft\");\n  function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error4, errorDigest$jscomp$0) {\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      if (4 === node.length)\n        abortRemainingReplayNodes(\n          request$jscomp$0,\n          boundary,\n          node[2],\n          node[3],\n          error4,\n          errorDigest$jscomp$0\n        );\n      else {\n        node = node[5];\n        var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(\n          request,\n          /* @__PURE__ */ new Set(),\n          null,\n          null\n        );\n        resumedBoundary.parentFlushed = true;\n        resumedBoundary.rootSegmentID = node;\n        resumedBoundary.status = 4;\n        resumedBoundary.errorDigest = errorDigest;\n        resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);\n      }\n    }\n    nodes.length = 0;\n    if (null !== slots) {\n      if (null === boundary) throw Error(formatProdErrorMessage(487));\n      4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));\n      if (\"object\" === typeof slots) for (var index in slots) delete slots[index];\n    }\n  }\n  __name(abortRemainingReplayNodes, \"abortRemainingReplayNodes\");\n  function abortTask(task, request, error4) {\n    var boundary = task.blockedBoundary, segment = task.blockedSegment;\n    if (null !== segment) {\n      if (6 === segment.status) return;\n      segment.status = 3;\n    }\n    segment = getThrownInfo(task.componentStack);\n    if (null === boundary) {\n      if (13 !== request.status && 14 !== request.status) {\n        boundary = task.replay;\n        if (null === boundary) {\n          logRecoverableError(request, error4, segment);\n          fatalError(request, error4);\n          return;\n        }\n        boundary.pendingTasks--;\n        0 === boundary.pendingTasks && 0 < boundary.nodes.length && (task = logRecoverableError(request, error4, segment), abortRemainingReplayNodes(\n          request,\n          null,\n          boundary.nodes,\n          boundary.slots,\n          error4,\n          task\n        ));\n        request.pendingRootTasks--;\n        0 === request.pendingRootTasks && completeShell(request);\n      }\n    } else\n      boundary.pendingTasks--, 4 !== boundary.status && (boundary.status = 4, task = logRecoverableError(request, error4, segment), boundary.status = 4, boundary.errorDigest = task, untrackBoundary(request, boundary), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary)), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n        return abortTask(fallbackTask, request, error4);\n      }), boundary.fallbackAbortableTasks.clear();\n    request.allPendingTasks--;\n    0 === request.allPendingTasks && completeAll(request);\n  }\n  __name(abortTask, \"abortTask\");\n  function safelyEmitEarlyPreloads(request, shellComplete) {\n    try {\n      var renderState = request.renderState, onHeaders = renderState.onHeaders;\n      if (onHeaders) {\n        var headers = renderState.headers;\n        if (headers) {\n          renderState.headers = null;\n          var linkHeader = headers.preconnects;\n          headers.fontPreloads && (linkHeader && (linkHeader += \", \"), linkHeader += headers.fontPreloads);\n          headers.highImagePreloads && (linkHeader && (linkHeader += \", \"), linkHeader += headers.highImagePreloads);\n          if (!shellComplete) {\n            var queueIter = renderState.styles.values(), queueStep = queueIter.next();\n            b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())\n              for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {\n                var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, \"style\", {\n                  crossOrigin: props$jscomp$0.crossOrigin,\n                  integrity: props$jscomp$0.integrity,\n                  nonce: props$jscomp$0.nonce,\n                  type: props$jscomp$0.type,\n                  fetchPriority: props$jscomp$0.fetchPriority,\n                  referrerPolicy: props$jscomp$0.referrerPolicy,\n                  media: props$jscomp$0.media\n                });\n                if (0 <= (headers.remainingCapacity -= header.length + 2))\n                  renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += \", \"), linkHeader += header, renderState.resets.style[key] = \"string\" === typeof props.crossOrigin || \"string\" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;\n                else break b;\n              }\n          }\n          linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});\n        }\n      }\n    } catch (error4) {\n      logRecoverableError(request, error4, {});\n    }\n  }\n  __name(safelyEmitEarlyPreloads, \"safelyEmitEarlyPreloads\");\n  function completeShell(request) {\n    null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);\n    null === request.trackedPostpones && preparePreamble(request);\n    request.onShellError = noop3;\n    request = request.onShellReady;\n    request();\n  }\n  __name(completeShell, \"completeShell\");\n  function completeAll(request) {\n    safelyEmitEarlyPreloads(\n      request,\n      null === request.trackedPostpones ? true : null === request.completedRootSegment || 5 !== request.completedRootSegment.status\n    );\n    preparePreamble(request);\n    request = request.onAllReady;\n    request();\n  }\n  __name(completeAll, \"completeAll\");\n  function queueCompletedSegment(boundary, segment) {\n    if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {\n      var childSegment = segment.children[0];\n      childSegment.id = segment.id;\n      childSegment.parentFlushed = true;\n      1 === childSegment.status && queueCompletedSegment(boundary, childSegment);\n    } else boundary.completedSegments.push(segment);\n  }\n  __name(queueCompletedSegment, \"queueCompletedSegment\");\n  function finishedTask(request, boundary, segment) {\n    if (null === boundary) {\n      if (null !== segment && segment.parentFlushed) {\n        if (null !== request.completedRootSegment)\n          throw Error(formatProdErrorMessage(389));\n        request.completedRootSegment = segment;\n      }\n      request.pendingRootTasks--;\n      0 === request.pendingRootTasks && completeShell(request);\n    } else\n      boundary.pendingTasks--, 4 !== boundary.status && (0 === boundary.pendingTasks ? (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && 1 === segment.status && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status && (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request))) : null !== segment && segment.parentFlushed && 1 === segment.status && (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)));\n    request.allPendingTasks--;\n    0 === request.allPendingTasks && completeAll(request);\n  }\n  __name(finishedTask, \"finishedTask\");\n  function performWork(request$jscomp$2) {\n    if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n      var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = HooksDispatcher;\n      var prevAsyncDispatcher = ReactSharedInternals.A;\n      ReactSharedInternals.A = DefaultAsyncDispatcher;\n      var prevRequest = currentRequest;\n      currentRequest = request$jscomp$2;\n      var prevResumableState = currentResumableState;\n      currentResumableState = request$jscomp$2.resumableState;\n      try {\n        var pingedTasks = request$jscomp$2.pingedTasks, i;\n        for (i = 0; i < pingedTasks.length; i++) {\n          var task = pingedTasks[i], request = request$jscomp$2, segment = task.blockedSegment;\n          if (null === segment) {\n            var request$jscomp$0 = request;\n            if (0 !== task.replay.pendingTasks) {\n              switchContext(task.context);\n              try {\n                \"number\" === typeof task.replay.slots ? resumeNode(\n                  request$jscomp$0,\n                  task,\n                  task.replay.slots,\n                  task.node,\n                  task.childIndex\n                ) : retryNode(request$jscomp$0, task);\n                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)\n                  throw Error(formatProdErrorMessage(488));\n                task.replay.pendingTasks--;\n                task.abortSet.delete(task);\n                finishedTask(request$jscomp$0, task.blockedBoundary, null);\n              } catch (thrownValue) {\n                resetHooksState();\n                var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;\n                if (\"object\" === typeof x && null !== x && \"function\" === typeof x.then) {\n                  var ping = task.ping;\n                  x.then(ping, ping);\n                  task.thenableState = getThenableStateAfterSuspending();\n                } else {\n                  task.replay.pendingTasks--;\n                  task.abortSet.delete(task);\n                  var errorInfo = getThrownInfo(task.componentStack);\n                  request = void 0;\n                  var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;\n                  request = logRecoverableError(\n                    request$jscomp$1,\n                    error$jscomp$0,\n                    errorInfo\n                  );\n                  abortRemainingReplayNodes(\n                    request$jscomp$1,\n                    boundary,\n                    replayNodes,\n                    resumeSlots,\n                    error$jscomp$0,\n                    request\n                  );\n                  request$jscomp$0.pendingRootTasks--;\n                  0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n                  request$jscomp$0.allPendingTasks--;\n                  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n                }\n              } finally {\n              }\n            }\n          } else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {\n            request$jscomp$1.status = 6;\n            switchContext(task.context);\n            var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;\n            try {\n              retryNode(request, task), pushSegmentFinale(\n                request$jscomp$1.chunks,\n                request.renderState,\n                request$jscomp$1.lastPushedText,\n                request$jscomp$1.textEmbedded\n              ), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedTask(request, task.blockedBoundary, request$jscomp$1);\n            } catch (thrownValue) {\n              resetHooksState();\n              request$jscomp$1.children.length = childrenLength;\n              request$jscomp$1.chunks.length = chunkLength;\n              var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;\n              if (\"object\" === typeof x$jscomp$0 && null !== x$jscomp$0 && \"function\" === typeof x$jscomp$0.then) {\n                request$jscomp$1.status = 0;\n                task.thenableState = getThenableStateAfterSuspending();\n                var ping$jscomp$0 = task.ping;\n                x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);\n              } else {\n                var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);\n                task.abortSet.delete(task);\n                request$jscomp$1.status = 4;\n                var boundary$jscomp$0 = task.blockedBoundary;\n                request$jscomp$0 = logRecoverableError(\n                  request,\n                  x$jscomp$0,\n                  errorInfo$jscomp$0\n                );\n                null === boundary$jscomp$0 ? fatalError(request, x$jscomp$0) : (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status && (boundary$jscomp$0.status = 4, boundary$jscomp$0.errorDigest = request$jscomp$0, untrackBoundary(request, boundary$jscomp$0), boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request)));\n                request.allPendingTasks--;\n                0 === request.allPendingTasks && completeAll(request);\n              }\n            } finally {\n            }\n          }\n        }\n        pingedTasks.splice(0, i);\n        null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);\n      } catch (error4) {\n        logRecoverableError(request$jscomp$2, error4, {}), fatalError(request$jscomp$2, error4);\n      } finally {\n        currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;\n      }\n    }\n  }\n  __name(performWork, \"performWork\");\n  function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {\n    segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);\n    for (var pendingPreambles = false, i = 0; i < segment.children.length; i++)\n      pendingPreambles = preparePreambleFromSegment(\n        request,\n        segment.children[i],\n        collectedPreambleSegments\n      ) || pendingPreambles;\n    return pendingPreambles;\n  }\n  __name(preparePreambleFromSubtree, \"preparePreambleFromSubtree\");\n  function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {\n    var boundary = segment.boundary;\n    if (null === boundary)\n      return preparePreambleFromSubtree(\n        request,\n        segment,\n        collectedPreambleSegments\n      );\n    var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;\n    if (null === preamble || null === fallbackPreamble) return false;\n    switch (boundary.status) {\n      case 1:\n        hoistPreambleState(request.renderState, preamble);\n        segment = boundary.completedSegments[0];\n        if (!segment) throw Error(formatProdErrorMessage(391));\n        return preparePreambleFromSubtree(\n          request,\n          segment,\n          collectedPreambleSegments\n        );\n      case 5:\n        if (null !== request.trackedPostpones) return true;\n      case 4:\n        if (1 === segment.status)\n          return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(\n            request,\n            segment,\n            collectedPreambleSegments\n          );\n      default:\n        return true;\n    }\n  }\n  __name(preparePreambleFromSegment, \"preparePreambleFromSegment\");\n  function preparePreamble(request) {\n    if (request.completedRootSegment && null === request.completedPreambleSegments) {\n      var collectedPreambleSegments = [], hasPendingPreambles = preparePreambleFromSegment(\n        request,\n        request.completedRootSegment,\n        collectedPreambleSegments\n      ), preamble = request.renderState.preamble;\n      if (false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks)\n        request.completedPreambleSegments = collectedPreambleSegments;\n    }\n  }\n  __name(preparePreamble, \"preparePreamble\");\n  function flushSubtree(request, destination, segment, hoistableState) {\n    segment.parentFlushed = true;\n    switch (segment.status) {\n      case 0:\n        segment.id = request.nextSegmentId++;\n      case 5:\n        return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push('<template id=\"'), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push('\"></template>');\n      case 1:\n        segment.status = 2;\n        var r2 = true, chunks = segment.chunks, chunkIdx = 0;\n        segment = segment.children;\n        for (var childIdx = 0; childIdx < segment.length; childIdx++) {\n          for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)\n            destination.push(chunks[chunkIdx]);\n          r2 = flushSegment(request, destination, r2, hoistableState);\n        }\n        for (; chunkIdx < chunks.length - 1; chunkIdx++)\n          destination.push(chunks[chunkIdx]);\n        chunkIdx < chunks.length && (r2 = destination.push(chunks[chunkIdx]));\n        return r2;\n      default:\n        throw Error(formatProdErrorMessage(390));\n    }\n  }\n  __name(flushSubtree, \"flushSubtree\");\n  function flushSegment(request, destination, segment, hoistableState) {\n    var boundary = segment.boundary;\n    if (null === boundary)\n      return flushSubtree(request, destination, segment, hoistableState);\n    boundary.parentFlushed = true;\n    if (4 === boundary.status) {\n      if (!request.renderState.generateStaticMarkup) {\n        var errorDigest = boundary.errorDigest;\n        destination.push(\"<!--$!-->\");\n        destination.push(\"<template\");\n        errorDigest && (destination.push(' data-dgst=\"'), errorDigest = escapeTextForBrowser(errorDigest), destination.push(errorDigest), destination.push('\"'));\n        destination.push(\"></template>\");\n      }\n      flushSubtree(request, destination, segment, hoistableState);\n      request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.fallbackPreamble) && writePreambleContribution(destination, request), destination = destination.push(\"<!--/$-->\"));\n      return destination;\n    }\n    if (1 !== boundary.status)\n      return 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(\n        destination,\n        request.renderState,\n        boundary.rootSegmentID\n      ), hoistableState && (boundary = boundary.fallbackState, boundary.styles.forEach(hoistStyleQueueDependency, hoistableState), boundary.stylesheets.forEach(\n        hoistStylesheetDependency,\n        hoistableState\n      )), flushSubtree(request, destination, segment, hoistableState), destination.push(\"<!--/$-->\");\n    if (boundary.byteSize > request.progressiveChunkSize)\n      return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(\n        destination,\n        request.renderState,\n        boundary.rootSegmentID\n      ), flushSubtree(request, destination, segment, hoistableState), destination.push(\"<!--/$-->\");\n    hoistableState && (segment = boundary.contentState, segment.styles.forEach(hoistStyleQueueDependency, hoistableState), segment.stylesheets.forEach(hoistStylesheetDependency, hoistableState));\n    request.renderState.generateStaticMarkup || destination.push(\"<!--$-->\");\n    segment = boundary.completedSegments;\n    if (1 !== segment.length) throw Error(formatProdErrorMessage(391));\n    flushSegment(request, destination, segment[0], hoistableState);\n    request.renderState.generateStaticMarkup ? destination = true : ((request = boundary.contentPreamble) && writePreambleContribution(destination, request), destination = destination.push(\"<!--/$-->\"));\n    return destination;\n  }\n  __name(flushSegment, \"flushSegment\");\n  function flushSegmentContainer(request, destination, segment, hoistableState) {\n    writeStartSegment(\n      destination,\n      request.renderState,\n      segment.parentFormatContext,\n      segment.id\n    );\n    flushSegment(request, destination, segment, hoistableState);\n    return writeEndSegment(destination, segment.parentFormatContext);\n  }\n  __name(flushSegmentContainer, \"flushSegmentContainer\");\n  function flushCompletedBoundary(request, destination, boundary) {\n    for (var completedSegments = boundary.completedSegments, i = 0; i < completedSegments.length; i++)\n      flushPartiallyCompletedSegment(\n        request,\n        destination,\n        boundary,\n        completedSegments[i]\n      );\n    completedSegments.length = 0;\n    writeHoistablesForBoundary(\n      destination,\n      boundary.contentState,\n      request.renderState\n    );\n    completedSegments = request.resumableState;\n    request = request.renderState;\n    i = boundary.rootSegmentID;\n    boundary = boundary.contentState;\n    var requiresStyleInsertion = request.stylesToHoist;\n    request.stylesToHoist = false;\n    destination.push(request.startInlineScript);\n    requiresStyleInsertion ? 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 10, destination.push(\n      '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n    )) : 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, destination.push(\n      '$RM=new Map;\\n$RR=function(t,u,y){function v(n){this._p=null;n()}for(var w=$RC,p=$RM,q=new Map,r=document,g,b,h=r.querySelectorAll(\"link[data-precedence],style[data-precedence]\"),x=[],k=0;b=h[k++];)\"not all\"===b.getAttribute(\"media\")?x.push(b):(\"LINK\"===b.tagName&&p.set(b.getAttribute(\"href\"),b),q.set(b.dataset.precedence,g=b));b=0;h=[];var l,a;for(k=!0;;){if(k){var e=y[b++];if(!e){k=!1;b=0;continue}var c=!1,m=0;var d=e[m++];if(a=p.get(d)){var f=a._p;c=!0}else{a=r.createElement(\"link\");a.href=\\nd;a.rel=\"stylesheet\";for(a.dataset.precedence=l=e[m++];f=e[m++];)a.setAttribute(f,e[m++]);f=a._p=new Promise(function(n,z){a.onload=v.bind(a,n);a.onerror=v.bind(a,z)});p.set(d,a)}d=a.getAttribute(\"media\");!f||d&&!matchMedia(d).matches||h.push(f);if(c)continue}else{a=x[b++];if(!a)break;l=a.getAttribute(\"data-precedence\");a.removeAttribute(\"media\")}c=q.get(l)||g;c===g&&(g=a);q.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=r.head,c.insertBefore(a,c.firstChild))}Promise.all(h).then(w.bind(null,\\nt,u,\"\"),w.bind(null,t,u,\"Resource failed to load\"))};$RR(\"'\n    )) : destination.push('$RR(\"') : 0 === (completedSegments.instructions & 2) ? (completedSegments.instructions |= 2, destination.push(\n      '$RC=function(b,c,e){c=document.getElementById(c);c.parentNode.removeChild(c);var a=document.getElementById(b);if(a){b=a.previousSibling;if(e)b.data=\"$!\",a.setAttribute(\"data-dgst\",e);else{e=b.parentNode;a=b.nextSibling;var f=0;do{if(a&&8===a.nodeType){var d=a.data;if(\"/$\"===d)if(0===f)break;else f--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||f++}d=a.nextSibling;e.removeChild(a);a=d}while(a);for(;c.firstChild;)e.insertBefore(c.firstChild,a);b.data=\"$\"}b._reactRetry&&b._reactRetry()}};$RC(\"'\n    )) : destination.push('$RC(\"');\n    completedSegments = i.toString(16);\n    destination.push(request.boundaryPrefix);\n    destination.push(completedSegments);\n    destination.push('\",\"');\n    destination.push(request.segmentPrefix);\n    destination.push(completedSegments);\n    requiresStyleInsertion ? (destination.push('\",'), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push('\"');\n    boundary = destination.push(\")</script>\");\n    return writeBootstrap(destination, request) && boundary;\n  }\n  __name(flushCompletedBoundary, \"flushCompletedBoundary\");\n  function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n    if (2 === segment.status) return true;\n    var hoistableState = boundary.contentState, segmentID = segment.id;\n    if (-1 === segmentID) {\n      if (-1 === (segment.id = boundary.rootSegmentID))\n        throw Error(formatProdErrorMessage(392));\n      return flushSegmentContainer(request, destination, segment, hoistableState);\n    }\n    if (segmentID === boundary.rootSegmentID)\n      return flushSegmentContainer(request, destination, segment, hoistableState);\n    flushSegmentContainer(request, destination, segment, hoistableState);\n    boundary = request.resumableState;\n    request = request.renderState;\n    destination.push(request.startInlineScript);\n    0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, destination.push(\n      '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(\"'\n    )) : destination.push('$RS(\"');\n    destination.push(request.segmentPrefix);\n    segmentID = segmentID.toString(16);\n    destination.push(segmentID);\n    destination.push('\",\"');\n    destination.push(request.placeholderPrefix);\n    destination.push(segmentID);\n    destination = destination.push('\")</script>');\n    return destination;\n  }\n  __name(flushPartiallyCompletedSegment, \"flushPartiallyCompletedSegment\");\n  function flushCompletedQueues(request, destination) {\n    try {\n      if (!(0 < request.pendingRootTasks)) {\n        var i, completedRootSegment = request.completedRootSegment;\n        if (null !== completedRootSegment) {\n          if (5 === completedRootSegment.status) return;\n          var completedPreambleSegments = request.completedPreambleSegments;\n          if (null === completedPreambleSegments) return;\n          var renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;\n          if (htmlChunks) {\n            for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)\n              destination.push(htmlChunks[i$jscomp$0]);\n            if (headChunks)\n              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n                destination.push(headChunks[i$jscomp$0]);\n            else {\n              var chunk = startChunkForTag(\"head\");\n              destination.push(chunk);\n              destination.push(\">\");\n            }\n          } else if (headChunks)\n            for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)\n              destination.push(headChunks[i$jscomp$0]);\n          var charsetChunks = renderState.charsetChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)\n            destination.push(charsetChunks[i$jscomp$0]);\n          charsetChunks.length = 0;\n          renderState.preconnects.forEach(flushResource, destination);\n          renderState.preconnects.clear();\n          var viewportChunks = renderState.viewportChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)\n            destination.push(viewportChunks[i$jscomp$0]);\n          viewportChunks.length = 0;\n          renderState.fontPreloads.forEach(flushResource, destination);\n          renderState.fontPreloads.clear();\n          renderState.highImagePreloads.forEach(flushResource, destination);\n          renderState.highImagePreloads.clear();\n          renderState.styles.forEach(flushStylesInPreamble, destination);\n          var importMapChunks = renderState.importMapChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)\n            destination.push(importMapChunks[i$jscomp$0]);\n          importMapChunks.length = 0;\n          renderState.bootstrapScripts.forEach(flushResource, destination);\n          renderState.scripts.forEach(flushResource, destination);\n          renderState.scripts.clear();\n          renderState.bulkPreloads.forEach(flushResource, destination);\n          renderState.bulkPreloads.clear();\n          var hoistableChunks = renderState.hoistableChunks;\n          for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)\n            destination.push(hoistableChunks[i$jscomp$0]);\n          for (renderState = hoistableChunks.length = 0; renderState < completedPreambleSegments.length; renderState++) {\n            var segments = completedPreambleSegments[renderState];\n            for (preamble = 0; preamble < segments.length; preamble++)\n              flushSegment(request, destination, segments[preamble], null);\n          }\n          var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;\n          if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {\n            var chunk$jscomp$0 = endChunkForTag(\"head\");\n            destination.push(chunk$jscomp$0);\n          }\n          var bodyChunks = preamble$jscomp$0.bodyChunks;\n          if (bodyChunks)\n            for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)\n              destination.push(bodyChunks[completedPreambleSegments]);\n          flushSegment(request, destination, completedRootSegment, null);\n          request.completedRootSegment = null;\n          writeBootstrap(destination, request.renderState);\n        }\n        var renderState$jscomp$0 = request.renderState;\n        completedRootSegment = 0;\n        var viewportChunks$jscomp$0 = renderState$jscomp$0.viewportChunks;\n        for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)\n          destination.push(viewportChunks$jscomp$0[completedRootSegment]);\n        viewportChunks$jscomp$0.length = 0;\n        renderState$jscomp$0.preconnects.forEach(flushResource, destination);\n        renderState$jscomp$0.preconnects.clear();\n        renderState$jscomp$0.fontPreloads.forEach(flushResource, destination);\n        renderState$jscomp$0.fontPreloads.clear();\n        renderState$jscomp$0.highImagePreloads.forEach(\n          flushResource,\n          destination\n        );\n        renderState$jscomp$0.highImagePreloads.clear();\n        renderState$jscomp$0.styles.forEach(preloadLateStyles, destination);\n        renderState$jscomp$0.scripts.forEach(flushResource, destination);\n        renderState$jscomp$0.scripts.clear();\n        renderState$jscomp$0.bulkPreloads.forEach(flushResource, destination);\n        renderState$jscomp$0.bulkPreloads.clear();\n        var hoistableChunks$jscomp$0 = renderState$jscomp$0.hoistableChunks;\n        for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)\n          destination.push(hoistableChunks$jscomp$0[completedRootSegment]);\n        hoistableChunks$jscomp$0.length = 0;\n        var clientRenderedBoundaries = request.clientRenderedBoundaries;\n        for (i = 0; i < clientRenderedBoundaries.length; i++) {\n          var boundary = clientRenderedBoundaries[i];\n          renderState$jscomp$0 = destination;\n          var resumableState = request.resumableState, renderState$jscomp$1 = request.renderState, id2 = boundary.rootSegmentID, errorDigest = boundary.errorDigest;\n          renderState$jscomp$0.push(renderState$jscomp$1.startInlineScript);\n          0 === (resumableState.instructions & 4) ? (resumableState.instructions |= 4, renderState$jscomp$0.push(\n            '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX(\"'\n          )) : renderState$jscomp$0.push('$RX(\"');\n          renderState$jscomp$0.push(renderState$jscomp$1.boundaryPrefix);\n          var chunk$jscomp$1 = id2.toString(16);\n          renderState$jscomp$0.push(chunk$jscomp$1);\n          renderState$jscomp$0.push('\"');\n          if (errorDigest) {\n            renderState$jscomp$0.push(\",\");\n            var chunk$jscomp$2 = escapeJSStringsForInstructionScripts(\n              errorDigest || \"\"\n            );\n            renderState$jscomp$0.push(chunk$jscomp$2);\n          }\n          var JSCompiler_inline_result = renderState$jscomp$0.push(\")</script>\");\n          if (!JSCompiler_inline_result) {\n            request.destination = null;\n            i++;\n            clientRenderedBoundaries.splice(0, i);\n            return;\n          }\n        }\n        clientRenderedBoundaries.splice(0, i);\n        var completedBoundaries = request.completedBoundaries;\n        for (i = 0; i < completedBoundaries.length; i++)\n          if (!flushCompletedBoundary(request, destination, completedBoundaries[i])) {\n            request.destination = null;\n            i++;\n            completedBoundaries.splice(0, i);\n            return;\n          }\n        completedBoundaries.splice(0, i);\n        var partialBoundaries = request.partialBoundaries;\n        for (i = 0; i < partialBoundaries.length; i++) {\n          var boundary$51 = partialBoundaries[i];\n          a: {\n            clientRenderedBoundaries = request;\n            boundary = destination;\n            var completedSegments = boundary$51.completedSegments;\n            for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)\n              if (!flushPartiallyCompletedSegment(\n                clientRenderedBoundaries,\n                boundary,\n                boundary$51,\n                completedSegments[JSCompiler_inline_result]\n              )) {\n                JSCompiler_inline_result++;\n                completedSegments.splice(0, JSCompiler_inline_result);\n                var JSCompiler_inline_result$jscomp$0 = false;\n                break a;\n              }\n            completedSegments.splice(0, JSCompiler_inline_result);\n            JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n              boundary,\n              boundary$51.contentState,\n              clientRenderedBoundaries.renderState\n            );\n          }\n          if (!JSCompiler_inline_result$jscomp$0) {\n            request.destination = null;\n            i++;\n            partialBoundaries.splice(0, i);\n            return;\n          }\n        }\n        partialBoundaries.splice(0, i);\n        var largeBoundaries = request.completedBoundaries;\n        for (i = 0; i < largeBoundaries.length; i++)\n          if (!flushCompletedBoundary(request, destination, largeBoundaries[i])) {\n            request.destination = null;\n            i++;\n            largeBoundaries.splice(0, i);\n            return;\n          }\n        largeBoundaries.splice(0, i);\n      }\n    } finally {\n      0 === request.allPendingTasks && 0 === request.pingedTasks.length && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i = request.resumableState, i.hasBody && (partialBoundaries = endChunkForTag(\"body\"), destination.push(partialBoundaries)), i.hasHtml && (i = endChunkForTag(\"html\"), destination.push(i)), request.status = 14, destination.push(null), request.destination = null);\n    }\n  }\n  __name(flushCompletedQueues, \"flushCompletedQueues\");\n  function enqueueFlush(request) {\n    if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {\n      request.flushScheduled = true;\n      var destination = request.destination;\n      destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;\n    }\n  }\n  __name(enqueueFlush, \"enqueueFlush\");\n  function startFlowing(request, destination) {\n    if (13 === request.status)\n      request.status = 14, destination.destroy(request.fatalError);\n    else if (14 !== request.status && null === request.destination) {\n      request.destination = destination;\n      try {\n        flushCompletedQueues(request, destination);\n      } catch (error4) {\n        logRecoverableError(request, error4, {}), fatalError(request, error4);\n      }\n    }\n  }\n  __name(startFlowing, \"startFlowing\");\n  function abort2(request, reason) {\n    if (11 === request.status || 10 === request.status) request.status = 12;\n    try {\n      var abortableTasks = request.abortableTasks;\n      if (0 < abortableTasks.size) {\n        var error4 = void 0 === reason ? Error(formatProdErrorMessage(432)) : \"object\" === typeof reason && null !== reason && \"function\" === typeof reason.then ? Error(formatProdErrorMessage(530)) : reason;\n        request.fatalError = error4;\n        abortableTasks.forEach(function(task) {\n          return abortTask(task, request, error4);\n        });\n        abortableTasks.clear();\n      }\n      null !== request.destination && flushCompletedQueues(request, request.destination);\n    } catch (error$53) {\n      logRecoverableError(request, error$53, {}), fatalError(request, error$53);\n    }\n  }\n  __name(abort2, \"abort\");\n  function onError() {\n  }\n  __name(onError, \"onError\");\n  function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {\n    var didFatal = false, fatalError2 = null, result = \"\", readyToStream = false;\n    options = createResumableState(options ? options.identifierPrefix : void 0);\n    children = createRequest2(\n      children,\n      options,\n      createRenderState(options, generateStaticMarkup),\n      createFormatContext(0, null, 0),\n      Infinity,\n      onError,\n      void 0,\n      function() {\n        readyToStream = true;\n      },\n      void 0,\n      void 0,\n      void 0\n    );\n    children.flushScheduled = null !== children.destination;\n    performWork(children);\n    10 === children.status && (children.status = 11);\n    null === children.trackedPostpones && safelyEmitEarlyPreloads(children, 0 === children.pendingRootTasks);\n    abort2(children, abortReason);\n    startFlowing(children, {\n      push: /* @__PURE__ */ __name(function(chunk) {\n        null !== chunk && (result += chunk);\n        return true;\n      }, \"push\"),\n      destroy: /* @__PURE__ */ __name(function(error4) {\n        didFatal = true;\n        fatalError2 = error4;\n      }, \"destroy\")\n    });\n    if (didFatal && fatalError2 !== abortReason) throw fatalError2;\n    if (!readyToStream) throw Error(formatProdErrorMessage(426));\n    return result;\n  }\n  __name(renderToStringImpl, \"renderToStringImpl\");\n  reactDomServerLegacy_browser_production.renderToStaticMarkup = function(children, options) {\n    return renderToStringImpl(\n      children,\n      options,\n      true,\n      'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n    );\n  };\n  reactDomServerLegacy_browser_production.renderToString = function(children, options) {\n    return renderToStringImpl(\n      children,\n      options,\n      false,\n      'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n    );\n  };\n  reactDomServerLegacy_browser_production.version = \"19.1.0\";\n  return reactDomServerLegacy_browser_production;\n}\nfunction requireServer_edge() {\n  if (hasRequiredServer_edge) return server_edge;\n  hasRequiredServer_edge = 1;\n  var b3;\n  var l2;\n  {\n    b3 = requireReactDomServer_edge_production();\n    l2 = requireReactDomServerLegacy_browser_production();\n  }\n  server_edge.version = b3.version;\n  server_edge.renderToReadableStream = b3.renderToReadableStream;\n  server_edge.renderToString = l2.renderToString;\n  server_edge.renderToStaticMarkup = l2.renderToStaticMarkup;\n  if (b3.resume) {\n    server_edge.resume = b3.resume;\n  }\n  return server_edge;\n}\nfunction getContext(rendererContextResult) {\n  if (contexts.has(rendererContextResult)) {\n    return contexts.get(rendererContextResult);\n  }\n  const ctx = {\n    currentIndex: 0,\n    get id() {\n      return ID_PREFIX + this.currentIndex.toString();\n    }\n  };\n  contexts.set(rendererContextResult, ctx);\n  return ctx;\n}\nfunction incrementId(rendererContextResult) {\n  const ctx = getContext(rendererContextResult);\n  const id2 = ctx.id;\n  ctx.currentIndex++;\n  return id2;\n}\nasync function check(Component, props, children) {\n  if (typeof Component === \"object\") {\n    return Component[\"$$typeof\"].toString().slice(\"Symbol(\".length).startsWith(\"react\");\n  }\n  if (typeof Component !== \"function\") return false;\n  if (Component.name === \"QwikComponent\") return false;\n  if (typeof Component === \"function\" && Component[\"$$typeof\"] === Symbol.for(\"react.forward_ref\"))\n    return false;\n  if (Component.prototype != null && typeof Component.prototype.render === \"function\") {\n    return React.Component.isPrototypeOf(Component) || React.PureComponent.isPrototypeOf(Component);\n  }\n  let isReactComponent = false;\n  function Tester(...args) {\n    try {\n      const vnode = Component(...args);\n      if (vnode && (vnode[\"$$typeof\"] === reactTypeof || vnode[\"$$typeof\"] === reactTransitionalTypeof)) {\n        isReactComponent = true;\n      }\n    } catch {\n    }\n    return React.createElement(\"div\");\n  }\n  __name(Tester, \"Tester\");\n  await renderToStaticMarkup.call(this, Tester, props, children);\n  return isReactComponent;\n}\nasync function getNodeWritable() {\n  let nodeStreamBuiltinModuleName = \"node:stream\";\n  let { Writable: Writable2 } = await import(\n    /* @vite-ignore */\n    nodeStreamBuiltinModuleName\n  );\n  return Writable2;\n}\nfunction needsHydration(metadata) {\n  return metadata?.astroStaticSlot ? !!metadata.hydrate : true;\n}\nasync function renderToStaticMarkup(Component, props, { default: children, ...slotted }, metadata) {\n  let prefix;\n  if (this && this.result) {\n    prefix = incrementId(this.result);\n  }\n  const attrs = { prefix };\n  delete props[\"class\"];\n  const slots = {};\n  for (const [key, value2] of Object.entries(slotted)) {\n    const name = slotName(key);\n    slots[name] = React.createElement(static_html_default, {\n      hydrate: needsHydration(metadata),\n      value: value2,\n      name\n    });\n  }\n  const newProps = {\n    ...props,\n    ...slots\n  };\n  const newChildren = children ?? props.children;\n  if (newChildren != null) {\n    newProps.children = React.createElement(static_html_default, {\n      hydrate: needsHydration(metadata),\n      value: newChildren\n    });\n  }\n  const formState = this ? await getFormState(this) : void 0;\n  if (formState) {\n    attrs[\"data-action-result\"] = JSON.stringify(formState[0]);\n    attrs[\"data-action-key\"] = formState[1];\n    attrs[\"data-action-name\"] = formState[2];\n  }\n  const vnode = React.createElement(Component, newProps);\n  const renderOptions = {\n    identifierPrefix: prefix,\n    formState\n  };\n  let html2;\n  if (\"renderToReadableStream\" in ReactDOM) {\n    html2 = await renderToReadableStreamAsync(vnode, renderOptions);\n  } else {\n    html2 = await renderToPipeableStreamAsync(vnode, renderOptions);\n  }\n  return { html: html2, attrs };\n}\nasync function getFormState({\n  result\n}) {\n  const { request, actionResult } = result;\n  if (!actionResult) return void 0;\n  if (!isFormRequest(request.headers.get(\"content-type\"))) return void 0;\n  const { searchParams } = new URL(request.url);\n  const formData = await request.clone().formData();\n  const actionKey = formData.get(\"$ACTION_KEY\")?.toString();\n  const actionName = searchParams.get(\"_action\");\n  if (!actionKey || !actionName) return void 0;\n  return [actionResult, actionKey, actionName];\n}\nasync function renderToPipeableStreamAsync(vnode, options) {\n  const Writable2 = await getNodeWritable();\n  let html2 = \"\";\n  return new Promise((resolve, reject) => {\n    let error4 = void 0;\n    let stream = ReactDOM.renderToPipeableStream(vnode, {\n      ...options,\n      onError(err) {\n        error4 = err;\n        reject(error4);\n      },\n      onAllReady() {\n        stream.pipe(\n          new Writable2({\n            write(chunk, _encoding, callback) {\n              html2 += chunk.toString(\"utf-8\");\n              callback();\n            },\n            destroy() {\n              resolve(html2);\n            }\n          })\n        );\n      }\n    });\n  });\n}\nasync function readResult(stream) {\n  const reader = stream.getReader();\n  let result = \"\";\n  const decoder3 = new TextDecoder(\"utf-8\");\n  while (true) {\n    const { done, value: value2 } = await reader.read();\n    if (done) {\n      if (value2) {\n        result += decoder3.decode(value2);\n      } else {\n        decoder3.decode(new Uint8Array());\n      }\n      return result;\n    }\n    result += decoder3.decode(value2, { stream: true });\n  }\n}\nasync function renderToReadableStreamAsync(vnode, options) {\n  return await readResult(await ReactDOM.renderToReadableStream(vnode, options));\n}\nfunction isFormRequest(contentType) {\n  const type2 = contentType?.split(\";\")[0].toLowerCase();\n  return formContentTypes.some((t) => type2 === t);\n}\nvar react, react_production, hasRequiredReact_production, hasRequiredReact, reactExports, React, server_edge, reactDomServer_edge_production, reactDom, reactDom_production, hasRequiredReactDom_production, hasRequiredReactDom, hasRequiredReactDomServer_edge_production, reactDomServerLegacy_browser_production, hasRequiredReactDomServerLegacy_browser_production, hasRequiredServer_edge, server_edgeExports, ReactDOM, contexts, ID_PREFIX, StaticHtml, static_html_default, slotName, reactTypeof, reactTransitionalTypeof, formContentTypes, renderer, server_default, renderers;\nvar init_renderers = __esm({\n  \"dist/_worker.js/renderers.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    react = { exports: {} };\n    react_production = {};\n    __name(requireReact_production, \"requireReact_production\");\n    __name(requireReact, \"requireReact\");\n    reactExports = requireReact();\n    React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);\n    server_edge = {};\n    reactDomServer_edge_production = {};\n    reactDom = { exports: {} };\n    reactDom_production = {};\n    __name(requireReactDom_production, \"requireReactDom_production\");\n    __name(requireReactDom, \"requireReactDom\");\n    __name(requireReactDomServer_edge_production, \"requireReactDomServer_edge_production\");\n    reactDomServerLegacy_browser_production = {};\n    __name(requireReactDomServerLegacy_browser_production, \"requireReactDomServerLegacy_browser_production\");\n    __name(requireServer_edge, \"requireServer_edge\");\n    server_edgeExports = requireServer_edge();\n    ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(server_edgeExports);\n    contexts = /* @__PURE__ */ new WeakMap();\n    ID_PREFIX = \"r\";\n    __name(getContext, \"getContext\");\n    __name(incrementId, \"incrementId\");\n    StaticHtml = /* @__PURE__ */ __name(({\n      value: value2,\n      name,\n      hydrate = true\n    }) => {\n      if (!value2) return null;\n      const tagName = hydrate ? \"astro-slot\" : \"astro-static-slot\";\n      return reactExports.createElement(tagName, {\n        name,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: { __html: value2 }\n      });\n    }, \"StaticHtml\");\n    StaticHtml.shouldComponentUpdate = () => false;\n    static_html_default = StaticHtml;\n    slotName = /* @__PURE__ */ __name((str) => str.trim().replace(/[-_]([a-z])/g, (_3, w3) => w3.toUpperCase()), \"slotName\");\n    reactTypeof = Symbol.for(\"react.element\");\n    reactTransitionalTypeof = Symbol.for(\"react.transitional.element\");\n    __name(check, \"check\");\n    __name(getNodeWritable, \"getNodeWritable\");\n    __name(needsHydration, \"needsHydration\");\n    __name(renderToStaticMarkup, \"renderToStaticMarkup\");\n    __name(getFormState, \"getFormState\");\n    __name(renderToPipeableStreamAsync, \"renderToPipeableStreamAsync\");\n    __name(readResult, \"readResult\");\n    __name(renderToReadableStreamAsync, \"renderToReadableStreamAsync\");\n    formContentTypes = [\"application/x-www-form-urlencoded\", \"multipart/form-data\"];\n    __name(isFormRequest, \"isFormRequest\");\n    renderer = {\n      name: \"@astrojs/react\",\n      check,\n      renderToStaticMarkup,\n      supportsAstroStaticSlot: true\n    };\n    server_default = renderer;\n    renderers = [Object.assign({ \"name\": \"@astrojs/react\", \"clientEntrypoint\": \"@astrojs/react/client.js\", \"serverEntrypoint\": \"@astrojs/react/server.js\" }, { ssr: server_default })];\n  }\n});\n\n// dist/_worker.js/chunks/astro-designed-error-pages_DuwJl2PN.mjs\nfunction is_primitive(thing) {\n  return Object(thing) !== thing;\n}\nfunction is_plain_object(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === object_proto_names;\n}\nfunction get_type(thing) {\n  return Object.prototype.toString.call(thing).slice(8, -1);\n}\nfunction get_escaped_char(char) {\n  switch (char) {\n    case '\"':\n      return '\\\\\"';\n    case \"<\":\n      return \"\\\\u003C\";\n    case \"\\\\\":\n      return \"\\\\\\\\\";\n    case \"\\n\":\n      return \"\\\\n\";\n    case \"\\r\":\n      return \"\\\\r\";\n    case \"\t\":\n      return \"\\\\t\";\n    case \"\\b\":\n      return \"\\\\b\";\n    case \"\\f\":\n      return \"\\\\f\";\n    case \"\\u2028\":\n      return \"\\\\u2028\";\n    case \"\\u2029\":\n      return \"\\\\u2029\";\n    default:\n      return char < \" \" ? `\\\\u${char.charCodeAt(0).toString(16).padStart(4, \"0\")}` : \"\";\n  }\n}\nfunction stringify_string(str) {\n  let result = \"\";\n  let last_pos = 0;\n  const len = str.length;\n  for (let i = 0; i < len; i += 1) {\n    const char = str[i];\n    const replacement = get_escaped_char(char);\n    if (replacement) {\n      result += str.slice(last_pos, i) + replacement;\n      last_pos = i + 1;\n    }\n  }\n  return `\"${last_pos === 0 ? str : result + str.slice(last_pos)}\"`;\n}\nfunction enumerable_symbols(object2) {\n  return Object.getOwnPropertySymbols(object2).filter(\n    (symbol) => Object.getOwnPropertyDescriptor(object2, symbol).enumerable\n  );\n}\nfunction stringify_key(key) {\n  return is_identifier.test(key) ? \".\" + key : \"[\" + JSON.stringify(key) + \"]\";\n}\nfunction encode64(arraybuffer) {\n  const dv = new DataView(arraybuffer);\n  let binaryString = \"\";\n  for (let i = 0; i < arraybuffer.byteLength; i++) {\n    binaryString += String.fromCharCode(dv.getUint8(i));\n  }\n  return binaryToAscii(binaryString);\n}\nfunction decode64(string2) {\n  const binaryString = asciiToBinary(string2);\n  const arraybuffer = new ArrayBuffer(binaryString.length);\n  const dv = new DataView(arraybuffer);\n  for (let i = 0; i < arraybuffer.byteLength; i++) {\n    dv.setUint8(i, binaryString.charCodeAt(i));\n  }\n  return arraybuffer;\n}\nfunction asciiToBinary(data) {\n  if (data.length % 4 === 0) {\n    data = data.replace(/==?$/, \"\");\n  }\n  let output = \"\";\n  let buffer = 0;\n  let accumulatedBits = 0;\n  for (let i = 0; i < data.length; i++) {\n    buffer <<= 6;\n    buffer |= KEY_STRING.indexOf(data[i]);\n    accumulatedBits += 6;\n    if (accumulatedBits === 24) {\n      output += String.fromCharCode((buffer & 16711680) >> 16);\n      output += String.fromCharCode((buffer & 65280) >> 8);\n      output += String.fromCharCode(buffer & 255);\n      buffer = accumulatedBits = 0;\n    }\n  }\n  if (accumulatedBits === 12) {\n    buffer >>= 4;\n    output += String.fromCharCode(buffer);\n  } else if (accumulatedBits === 18) {\n    buffer >>= 2;\n    output += String.fromCharCode((buffer & 65280) >> 8);\n    output += String.fromCharCode(buffer & 255);\n  }\n  return output;\n}\nfunction binaryToAscii(str) {\n  let out = \"\";\n  for (let i = 0; i < str.length; i += 3) {\n    const groupsOfSix = [void 0, void 0, void 0, void 0];\n    groupsOfSix[0] = str.charCodeAt(i) >> 2;\n    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;\n    if (str.length > i + 1) {\n      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;\n      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;\n    }\n    if (str.length > i + 2) {\n      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;\n      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;\n    }\n    for (let j3 = 0; j3 < groupsOfSix.length; j3++) {\n      if (typeof groupsOfSix[j3] === \"undefined\") {\n        out += \"=\";\n      } else {\n        out += KEY_STRING[groupsOfSix[j3]];\n      }\n    }\n  }\n  return out;\n}\nfunction parse(serialized, revivers) {\n  return unflatten(JSON.parse(serialized), revivers);\n}\nfunction unflatten(parsed, revivers) {\n  if (typeof parsed === \"number\") return hydrate(parsed, true);\n  if (!Array.isArray(parsed) || parsed.length === 0) {\n    throw new Error(\"Invalid input\");\n  }\n  const values = (\n    /** @type {any[]} */\n    parsed\n  );\n  const hydrated = Array(values.length);\n  function hydrate(index, standalone = false) {\n    if (index === UNDEFINED) return void 0;\n    if (index === NAN) return NaN;\n    if (index === POSITIVE_INFINITY) return Infinity;\n    if (index === NEGATIVE_INFINITY) return -Infinity;\n    if (index === NEGATIVE_ZERO) return -0;\n    if (standalone) throw new Error(`Invalid input`);\n    if (index in hydrated) return hydrated[index];\n    const value2 = values[index];\n    if (!value2 || typeof value2 !== \"object\") {\n      hydrated[index] = value2;\n    } else if (Array.isArray(value2)) {\n      if (typeof value2[0] === \"string\") {\n        const type2 = value2[0];\n        const reviver = revivers?.[type2];\n        if (reviver) {\n          return hydrated[index] = reviver(hydrate(value2[1]));\n        }\n        switch (type2) {\n          case \"Date\":\n            hydrated[index] = new Date(value2[1]);\n            break;\n          case \"Set\":\n            const set2 = /* @__PURE__ */ new Set();\n            hydrated[index] = set2;\n            for (let i = 1; i < value2.length; i += 1) {\n              set2.add(hydrate(value2[i]));\n            }\n            break;\n          case \"Map\":\n            const map2 = /* @__PURE__ */ new Map();\n            hydrated[index] = map2;\n            for (let i = 1; i < value2.length; i += 2) {\n              map2.set(hydrate(value2[i]), hydrate(value2[i + 1]));\n            }\n            break;\n          case \"RegExp\":\n            hydrated[index] = new RegExp(value2[1], value2[2]);\n            break;\n          case \"Object\":\n            hydrated[index] = Object(value2[1]);\n            break;\n          case \"BigInt\":\n            hydrated[index] = BigInt(value2[1]);\n            break;\n          case \"null\":\n            const obj = /* @__PURE__ */ Object.create(null);\n            hydrated[index] = obj;\n            for (let i = 1; i < value2.length; i += 2) {\n              obj[value2[i]] = hydrate(value2[i + 1]);\n            }\n            break;\n          case \"Int8Array\":\n          case \"Uint8Array\":\n          case \"Uint8ClampedArray\":\n          case \"Int16Array\":\n          case \"Uint16Array\":\n          case \"Int32Array\":\n          case \"Uint32Array\":\n          case \"Float32Array\":\n          case \"Float64Array\":\n          case \"BigInt64Array\":\n          case \"BigUint64Array\": {\n            const TypedArrayConstructor = globalThis[type2];\n            const base64 = value2[1];\n            const arraybuffer = decode64(base64);\n            const typedArray = new TypedArrayConstructor(arraybuffer);\n            hydrated[index] = typedArray;\n            break;\n          }\n          case \"ArrayBuffer\": {\n            const base64 = value2[1];\n            const arraybuffer = decode64(base64);\n            hydrated[index] = arraybuffer;\n            break;\n          }\n          default:\n            throw new Error(`Unknown type ${type2}`);\n        }\n      } else {\n        const array2 = new Array(value2.length);\n        hydrated[index] = array2;\n        for (let i = 0; i < value2.length; i += 1) {\n          const n27 = value2[i];\n          if (n27 === HOLE) continue;\n          array2[i] = hydrate(n27);\n        }\n      }\n    } else {\n      const object2 = {};\n      hydrated[index] = object2;\n      for (const key in value2) {\n        const n27 = value2[key];\n        object2[key] = hydrate(n27);\n      }\n    }\n    return hydrated[index];\n  }\n  __name(hydrate, \"hydrate\");\n  return hydrate(0);\n}\nfunction stringify(value2, reducers) {\n  const stringified = [];\n  const indexes = /* @__PURE__ */ new Map();\n  const custom = [];\n  if (reducers) {\n    for (const key of Object.getOwnPropertyNames(reducers)) {\n      custom.push({ key, fn: reducers[key] });\n    }\n  }\n  const keys2 = [];\n  let p2 = 0;\n  function flatten2(thing) {\n    if (typeof thing === \"function\") {\n      throw new DevalueError(`Cannot stringify a function`, keys2);\n    }\n    if (indexes.has(thing)) return indexes.get(thing);\n    if (thing === void 0) return UNDEFINED;\n    if (Number.isNaN(thing)) return NAN;\n    if (thing === Infinity) return POSITIVE_INFINITY;\n    if (thing === -Infinity) return NEGATIVE_INFINITY;\n    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;\n    const index2 = p2++;\n    indexes.set(thing, index2);\n    for (const { key, fn: fn2 } of custom) {\n      const value3 = fn2(thing);\n      if (value3) {\n        stringified[index2] = `[\"${key}\",${flatten2(value3)}]`;\n        return index2;\n      }\n    }\n    let str = \"\";\n    if (is_primitive(thing)) {\n      str = stringify_primitive(thing);\n    } else {\n      const type2 = get_type(thing);\n      switch (type2) {\n        case \"Number\":\n        case \"String\":\n        case \"Boolean\":\n          str = `[\"Object\",${stringify_primitive(thing)}]`;\n          break;\n        case \"BigInt\":\n          str = `[\"BigInt\",${thing}]`;\n          break;\n        case \"Date\":\n          const valid = !isNaN(thing.getDate());\n          str = `[\"Date\",\"${valid ? thing.toISOString() : \"\"}\"]`;\n          break;\n        case \"RegExp\":\n          const { source, flags } = thing;\n          str = flags ? `[\"RegExp\",${stringify_string(source)},\"${flags}\"]` : `[\"RegExp\",${stringify_string(source)}]`;\n          break;\n        case \"Array\":\n          str = \"[\";\n          for (let i = 0; i < thing.length; i += 1) {\n            if (i > 0) str += \",\";\n            if (i in thing) {\n              keys2.push(`[${i}]`);\n              str += flatten2(thing[i]);\n              keys2.pop();\n            } else {\n              str += HOLE;\n            }\n          }\n          str += \"]\";\n          break;\n        case \"Set\":\n          str = '[\"Set\"';\n          for (const value3 of thing) {\n            str += `,${flatten2(value3)}`;\n          }\n          str += \"]\";\n          break;\n        case \"Map\":\n          str = '[\"Map\"';\n          for (const [key, value3] of thing) {\n            keys2.push(\n              `.get(${is_primitive(key) ? stringify_primitive(key) : \"...\"})`\n            );\n            str += `,${flatten2(key)},${flatten2(value3)}`;\n            keys2.pop();\n          }\n          str += \"]\";\n          break;\n        case \"Int8Array\":\n        case \"Uint8Array\":\n        case \"Uint8ClampedArray\":\n        case \"Int16Array\":\n        case \"Uint16Array\":\n        case \"Int32Array\":\n        case \"Uint32Array\":\n        case \"Float32Array\":\n        case \"Float64Array\":\n        case \"BigInt64Array\":\n        case \"BigUint64Array\": {\n          const typedArray = thing;\n          const base64 = encode64(typedArray.buffer);\n          str = '[\"' + type2 + '\",\"' + base64 + '\"]';\n          break;\n        }\n        case \"ArrayBuffer\": {\n          const arraybuffer = thing;\n          const base64 = encode64(arraybuffer);\n          str = `[\"ArrayBuffer\",\"${base64}\"]`;\n          break;\n        }\n        default:\n          if (!is_plain_object(thing)) {\n            throw new DevalueError(\n              `Cannot stringify arbitrary non-POJOs`,\n              keys2\n            );\n          }\n          if (enumerable_symbols(thing).length > 0) {\n            throw new DevalueError(\n              `Cannot stringify POJOs with symbolic keys`,\n              keys2\n            );\n          }\n          if (Object.getPrototypeOf(thing) === null) {\n            str = '[\"null\"';\n            for (const key in thing) {\n              keys2.push(stringify_key(key));\n              str += `,${stringify_string(key)},${flatten2(thing[key])}`;\n              keys2.pop();\n            }\n            str += \"]\";\n          } else {\n            str = \"{\";\n            let started = false;\n            for (const key in thing) {\n              if (started) str += \",\";\n              started = true;\n              keys2.push(stringify_key(key));\n              str += `${stringify_string(key)}:${flatten2(thing[key])}`;\n              keys2.pop();\n            }\n            str += \"}\";\n          }\n      }\n    }\n    stringified[index2] = str;\n    return index2;\n  }\n  __name(flatten2, \"flatten\");\n  const index = flatten2(value2);\n  if (index < 0) return `${index}`;\n  return `[${stringified.join(\",\")}]`;\n}\nfunction stringify_primitive(thing) {\n  const type2 = typeof thing;\n  if (type2 === \"string\") return stringify_string(thing);\n  if (thing instanceof String) return stringify_string(thing.toString());\n  if (thing === void 0) return UNDEFINED.toString();\n  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();\n  if (type2 === \"bigint\") return `[\"BigInt\",\"${thing}\"]`;\n  return String(thing);\n}\nfunction isActionError(error4) {\n  return typeof error4 === \"object\" && error4 != null && \"type\" in error4 && error4.type === \"AstroActionError\";\n}\nfunction isInputError(error4) {\n  return typeof error4 === \"object\" && error4 != null && \"type\" in error4 && error4.type === \"AstroActionInputError\" && \"issues\" in error4 && Array.isArray(error4.issues);\n}\nfunction getActionQueryString(name) {\n  const searchParams = new URLSearchParams({ [ACTION_QUERY_PARAMS$1.actionName]: name });\n  return `?${searchParams.toString()}`;\n}\nfunction serializeActionResult(res) {\n  if (res.error) {\n    if (Object.assign(__vite_import_meta_env__, { _: process.env._ })?.DEV) {\n      actionResultErrorStack.set(res.error.stack);\n    }\n    let body2;\n    if (res.error instanceof ActionInputError) {\n      body2 = {\n        type: res.error.type,\n        issues: res.error.issues,\n        fields: res.error.fields\n      };\n    } else {\n      body2 = {\n        ...res.error,\n        message: res.error.message\n      };\n    }\n    return {\n      type: \"error\",\n      status: res.error.status,\n      contentType: \"application/json\",\n      body: JSON.stringify(body2)\n    };\n  }\n  if (res.data === void 0) {\n    return {\n      type: \"empty\",\n      status: 204\n    };\n  }\n  let body;\n  try {\n    body = stringify(res.data, {\n      // Add support for URL objects\n      URL: /* @__PURE__ */ __name((value2) => value2 instanceof URL && value2.href, \"URL\")\n    });\n  } catch (e) {\n    let hint = ActionsReturnedInvalidDataError.hint;\n    if (res.data instanceof Response) {\n      hint = REDIRECT_STATUS_CODES.includes(res.data.status) ? \"If you need to redirect when the action succeeds, trigger a redirect where the action is called. See the Actions guide for server and client redirect examples: https://docs.astro.build/en/guides/actions.\" : \"If you need to return a Response object, try using a server endpoint instead. See https://docs.astro.build/en/guides/endpoints/#server-endpoints-api-routes\";\n    }\n    throw new AstroError({\n      ...ActionsReturnedInvalidDataError,\n      message: ActionsReturnedInvalidDataError.message(String(e)),\n      hint\n    });\n  }\n  return {\n    type: \"data\",\n    status: 200,\n    contentType: \"application/json+devalue\",\n    body\n  };\n}\nfunction deserializeActionResult(res) {\n  if (res.type === \"error\") {\n    let json;\n    try {\n      json = JSON.parse(res.body);\n    } catch {\n      return {\n        data: void 0,\n        error: new ActionError({\n          message: res.body,\n          code: \"INTERNAL_SERVER_ERROR\"\n        })\n      };\n    }\n    if (Object.assign(__vite_import_meta_env__, { _: process.env._ })?.PROD) {\n      return { error: ActionError.fromJson(json), data: void 0 };\n    } else {\n      const error4 = ActionError.fromJson(json);\n      error4.stack = actionResultErrorStack.get();\n      return {\n        error: error4,\n        data: void 0\n      };\n    }\n  }\n  if (res.type === \"empty\") {\n    return { data: void 0, error: void 0 };\n  }\n  return {\n    data: parse(res.body, {\n      URL: /* @__PURE__ */ __name((href) => new URL(href), \"URL\")\n    }),\n    error: void 0\n  };\n}\nfunction requireDist() {\n  if (hasRequiredDist) return dist;\n  hasRequiredDist = 1;\n  Object.defineProperty(dist, \"__esModule\", { value: true });\n  dist.parse = parse3;\n  dist.serialize = serialize2;\n  const cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n  const cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n  const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n  const pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n  const __toString = Object.prototype.toString;\n  const NullObject = /* @__PURE__ */ (() => {\n    const C2 = /* @__PURE__ */ __name(function() {\n    }, \"C\");\n    C2.prototype = /* @__PURE__ */ Object.create(null);\n    return C2;\n  })();\n  function parse3(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    if (len < 2)\n      return obj;\n    const dec = options?.decode || decode2;\n    let index = 0;\n    do {\n      const eqIdx = str.indexOf(\"=\", index);\n      if (eqIdx === -1)\n        break;\n      const colonIdx = str.indexOf(\";\", index);\n      const endIdx = colonIdx === -1 ? len : colonIdx;\n      if (eqIdx > endIdx) {\n        index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n        continue;\n      }\n      const keyStartIdx = startIndex(str, index, eqIdx);\n      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n      const key = str.slice(keyStartIdx, keyEndIdx);\n      if (obj[key] === void 0) {\n        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n        let valEndIdx = endIndex(str, endIdx, valStartIdx);\n        const value2 = dec(str.slice(valStartIdx, valEndIdx));\n        obj[key] = value2;\n      }\n      index = endIdx + 1;\n    } while (index < len);\n    return obj;\n  }\n  __name(parse3, \"parse\");\n  function startIndex(str, index, max) {\n    do {\n      const code = str.charCodeAt(index);\n      if (code !== 32 && code !== 9)\n        return index;\n    } while (++index < max);\n    return max;\n  }\n  __name(startIndex, \"startIndex\");\n  function endIndex(str, index, min) {\n    while (index > min) {\n      const code = str.charCodeAt(--index);\n      if (code !== 32 && code !== 9)\n        return index + 1;\n    }\n    return min;\n  }\n  __name(endIndex, \"endIndex\");\n  function serialize2(name, val, options) {\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(name)) {\n      throw new TypeError(`argument name is invalid: ${name}`);\n    }\n    const value2 = enc(val);\n    if (!cookieValueRegExp.test(value2)) {\n      throw new TypeError(`argument val is invalid: ${val}`);\n    }\n    let str = name + \"=\" + value2;\n    if (!options)\n      return str;\n    if (options.maxAge !== void 0) {\n      if (!Number.isInteger(options.maxAge)) {\n        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n      }\n      str += \"; Max-Age=\" + options.maxAge;\n    }\n    if (options.domain) {\n      if (!domainValueRegExp.test(options.domain)) {\n        throw new TypeError(`option domain is invalid: ${options.domain}`);\n      }\n      str += \"; Domain=\" + options.domain;\n    }\n    if (options.path) {\n      if (!pathValueRegExp.test(options.path)) {\n        throw new TypeError(`option path is invalid: ${options.path}`);\n      }\n      str += \"; Path=\" + options.path;\n    }\n    if (options.expires) {\n      if (!isDate2(options.expires) || !Number.isFinite(options.expires.valueOf())) {\n        throw new TypeError(`option expires is invalid: ${options.expires}`);\n      }\n      str += \"; Expires=\" + options.expires.toUTCString();\n    }\n    if (options.httpOnly) {\n      str += \"; HttpOnly\";\n    }\n    if (options.secure) {\n      str += \"; Secure\";\n    }\n    if (options.partitioned) {\n      str += \"; Partitioned\";\n    }\n    if (options.priority) {\n      const priority = typeof options.priority === \"string\" ? options.priority.toLowerCase() : void 0;\n      switch (priority) {\n        case \"low\":\n          str += \"; Priority=Low\";\n          break;\n        case \"medium\":\n          str += \"; Priority=Medium\";\n          break;\n        case \"high\":\n          str += \"; Priority=High\";\n          break;\n        default:\n          throw new TypeError(`option priority is invalid: ${options.priority}`);\n      }\n    }\n    if (options.sameSite) {\n      const sameSite = typeof options.sameSite === \"string\" ? options.sameSite.toLowerCase() : options.sameSite;\n      switch (sameSite) {\n        case true:\n        case \"strict\":\n          str += \"; SameSite=Strict\";\n          break;\n        case \"lax\":\n          str += \"; SameSite=Lax\";\n          break;\n        case \"none\":\n          str += \"; SameSite=None\";\n          break;\n        default:\n          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n      }\n    }\n    return str;\n  }\n  __name(serialize2, \"serialize\");\n  function decode2(str) {\n    if (str.indexOf(\"%\") === -1)\n      return str;\n    try {\n      return decodeURIComponent(str);\n    } catch (e) {\n      return str;\n    }\n  }\n  __name(decode2, \"decode\");\n  function isDate2(val) {\n    return __toString.call(val) === \"[object Date]\";\n  }\n  __name(isDate2, \"isDate\");\n  return dist;\n}\nfunction template({\n  title: title3,\n  pathname,\n  statusCode = 404,\n  tabTitle,\n  body\n}) {\n  return `<!doctype html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>${tabTitle}</title>\n\t\t<style>\n\t\t\t:root {\n\t\t\t\t--gray-10: hsl(258, 7%, 10%);\n\t\t\t\t--gray-20: hsl(258, 7%, 20%);\n\t\t\t\t--gray-30: hsl(258, 7%, 30%);\n\t\t\t\t--gray-40: hsl(258, 7%, 40%);\n\t\t\t\t--gray-50: hsl(258, 7%, 50%);\n\t\t\t\t--gray-60: hsl(258, 7%, 60%);\n\t\t\t\t--gray-70: hsl(258, 7%, 70%);\n\t\t\t\t--gray-80: hsl(258, 7%, 80%);\n\t\t\t\t--gray-90: hsl(258, 7%, 90%);\n\t\t\t\t--black: #13151A;\n\t\t\t\t--accent-light: #E0CCFA;\n\t\t\t}\n\n\t\t\t* {\n\t\t\t\tbox-sizing: border-box;\n\t\t\t}\n\n\t\t\thtml {\n\t\t\t\tbackground: var(--black);\n\t\t\t\tcolor-scheme: dark;\n\t\t\t\taccent-color: var(--accent-light);\n\t\t\t}\n\n\t\t\tbody {\n\t\t\t\tbackground-color: var(--gray-10);\n\t\t\t\tcolor: var(--gray-80);\n\t\t\t\tfont-family: ui-monospace, Menlo, Monaco, \"Cascadia Mono\", \"Segoe UI Mono\", \"Roboto Mono\", \"Oxygen Mono\", \"Ubuntu Monospace\", \"Source Code Pro\", \"Fira Mono\", \"Droid Sans Mono\", \"Courier New\", monospace;\n\t\t\t\tline-height: 1.5;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\ta {\n\t\t\t\tcolor: var(--accent-light);\n\t\t\t}\n\n\t\t\t.center {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column;\n\t\t\t\tjustify-content: center;\n\t\t\t\talign-items: center;\n\t\t\t\theight: 100vh;\n\t\t\t\twidth: 100vw;\n\t\t\t}\n\n\t\t\th1 {\n\t\t\t\tmargin-bottom: 8px;\n\t\t\t\tcolor: white;\n\t\t\t\tfont-family: system-ui, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n\t\t\t\tfont-weight: 700;\n\t\t\t\tmargin-top: 1rem;\n\t\t\t\tmargin-bottom: 0;\n\t\t\t}\n\n\t\t\t.statusCode {\n\t\t\t\tcolor: var(--accent-light);\n\t\t\t}\n\n\t\t\t.astro-icon {\n\t\t\t\theight: 124px;\n\t\t\t\twidth: 124px;\n\t\t\t}\n\n\t\t\tpre, code {\n\t\t\t\tpadding: 2px 8px;\n\t\t\t\tbackground: rgba(0,0,0, 0.25);\n\t\t\t\tborder: 1px solid rgba(255,255,255, 0.25);\n\t\t\t\tborder-radius: 4px;\n\t\t\t\tfont-size: 1.2em;\n\t\t\t\tmargin-top: 0;\n\t\t\t\tmax-width: 60em;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<main class=\"center\">\n\t\t\t<svg class=\"astro-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"80\" viewBox=\"0 0 64 80\" fill=\"none\"> <path d=\"M20.5253 67.6322C16.9291 64.3531 15.8793 57.4632 17.3776 52.4717C19.9755 55.6188 23.575 56.6157 27.3035 57.1784C33.0594 58.0468 38.7122 57.722 44.0592 55.0977C44.6709 54.7972 45.2362 54.3978 45.9045 53.9931C46.4062 55.4451 46.5368 56.9109 46.3616 58.4028C45.9355 62.0362 44.1228 64.8429 41.2397 66.9705C40.0868 67.8215 38.8669 68.5822 37.6762 69.3846C34.0181 71.8508 33.0285 74.7426 34.403 78.9491C34.4357 79.0516 34.4649 79.1541 34.5388 79.4042C32.6711 78.5705 31.3069 77.3565 30.2674 75.7604C29.1694 74.0757 28.6471 72.2121 28.6196 70.1957C28.6059 69.2144 28.6059 68.2244 28.4736 67.257C28.1506 64.8985 27.0406 63.8425 24.9496 63.7817C22.8036 63.7192 21.106 65.0426 20.6559 67.1268C20.6215 67.2865 20.5717 67.4446 20.5218 67.6304L20.5253 67.6322Z\" fill=\"white\"/> <path d=\"M20.5253 67.6322C16.9291 64.3531 15.8793 57.4632 17.3776 52.4717C19.9755 55.6188 23.575 56.6157 27.3035 57.1784C33.0594 58.0468 38.7122 57.722 44.0592 55.0977C44.6709 54.7972 45.2362 54.3978 45.9045 53.9931C46.4062 55.4451 46.5368 56.9109 46.3616 58.4028C45.9355 62.0362 44.1228 64.8429 41.2397 66.9705C40.0868 67.8215 38.8669 68.5822 37.6762 69.3846C34.0181 71.8508 33.0285 74.7426 34.403 78.9491C34.4357 79.0516 34.4649 79.1541 34.5388 79.4042C32.6711 78.5705 31.3069 77.3565 30.2674 75.7604C29.1694 74.0757 28.6471 72.2121 28.6196 70.1957C28.6059 69.2144 28.6059 68.2244 28.4736 67.257C28.1506 64.8985 27.0406 63.8425 24.9496 63.7817C22.8036 63.7192 21.106 65.0426 20.6559 67.1268C20.6215 67.2865 20.5717 67.4446 20.5218 67.6304L20.5253 67.6322Z\" fill=\"url(#paint0_linear_738_686)\"/> <path d=\"M0 51.6401C0 51.6401 10.6488 46.4654 21.3274 46.4654L29.3786 21.6102C29.6801 20.4082 30.5602 19.5913 31.5538 19.5913C32.5474 19.5913 33.4275 20.4082 33.7289 21.6102L41.7802 46.4654C54.4274 46.4654 63.1076 51.6401 63.1076 51.6401C63.1076 51.6401 45.0197 2.48776 44.9843 2.38914C44.4652 0.935933 43.5888 0 42.4073 0H20.7022C19.5206 0 18.6796 0.935933 18.1251 2.38914C18.086 2.4859 0 51.6401 0 51.6401Z\" fill=\"white\"/> <defs> <linearGradient id=\"paint0_linear_738_686\" x1=\"31.554\" y1=\"75.4423\" x2=\"39.7462\" y2=\"48.376\" gradientUnits=\"userSpaceOnUse\"> <stop stop-color=\"#D83333\"/> <stop offset=\"1\" stop-color=\"#F041FF\"/> </linearGradient> </defs> </svg>\n\t\t\t<h1>${statusCode ? `<span class=\"statusCode\">${statusCode}: </span> ` : \"\"}<span class=\"statusMessage\">${title3}</span></h1>\n\t\t\t${body || `\n\t\t\t\t<pre>Path: ${escape(pathname)}</pre>\n\t\t\t`}\n\t\t\t</main>\n\t</body>\n</html>`;\n}\nfunction ensure404Route(manifest2) {\n  if (!manifest2.routes.some((route) => route.route === \"/404\")) {\n    manifest2.routes.push(DEFAULT_404_ROUTE);\n  }\n  return manifest2;\n}\nasync function default404Page({ pathname }) {\n  return new Response(\n    template({\n      statusCode: 404,\n      title: \"Not found\",\n      tabTitle: \"404: Not Found\",\n      pathname\n    }),\n    { status: 404, headers: { \"Content-Type\": \"text/html\" } }\n  );\n}\nvar ImportType, E, DevalueError, object_proto_names, is_identifier, KEY_STRING, UNDEFINED, HOLE, NAN, POSITIVE_INFINITY, NEGATIVE_INFINITY, NEGATIVE_ZERO, ACTION_QUERY_PARAMS$1, ACTION_RPC_ROUTE_PATTERN, __vite_import_meta_env__, ACTION_QUERY_PARAMS, codeToStatusMap, statusToCodeMap, ActionError, ActionInputError, actionResultErrorStack, dist, hasRequiredDist, distExports, DEFAULT_404_ROUTE, default404Instance;\nvar init_astro_designed_error_pages_DuwJl2PN = __esm({\n  \"dist/_worker.js/chunks/astro-designed-error-pages_DuwJl2PN.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    !function(A3) {\n      A3[A3.Static = 1] = \"Static\", A3[A3.Dynamic = 2] = \"Dynamic\", A3[A3.ImportMeta = 3] = \"ImportMeta\", A3[A3.StaticSourcePhase = 4] = \"StaticSourcePhase\", A3[A3.DynamicSourcePhase = 5] = \"DynamicSourcePhase\", A3[A3.StaticDeferPhase = 6] = \"StaticDeferPhase\", A3[A3.DynamicDeferPhase = 7] = \"DynamicDeferPhase\";\n    }(ImportType || (ImportType = {}));\n    1 === new Uint8Array(new Uint16Array([1]).buffer)[0];\n    E = /* @__PURE__ */ __name(() => {\n      return A3 = \"AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKzkQwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQuFDAEKf0EAQQAoArAKIgBBDGoiATYCsApBARApIQJBACgCsAohAwJAAkACQAJAAkACQAJAAkAgAkEuRw0AQQAgA0ECajYCsAoCQEEBECkiAkHkAEYNAAJAIAJB8wBGDQAgAkHtAEcNB0EAKAKwCiICQQJqQZwIQQYQLw0HAkBBACgCnAoiAxAqDQAgAy8BAEEuRg0ICyAAIAAgAkEIakEAKALUCRABDwtBACgCsAoiAkECakGiCEEKEC8NBgJAQQAoApwKIgMQKg0AIAMvAQBBLkYNBwtBACEEQQAgAkEMajYCsApBASEFQQUhBkEBECkhAkEAIQdBASEIDAILQQAoArAKIgIpAAJC5YCYg9CMgDlSDQUCQEEAKAKcCiIDECoNACADLwEAQS5GDQYLQQAhBEEAIAJBCmo2ArAKQQIhCEEHIQZBASEHQQEQKSECQQEhBQwBCwJAAkACQAJAIAJB8wBHDQAgAyABTQ0AIANBAmpBoghBChAvDQACQCADLwEMIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAgsgBEGgAUYNAQtBACEHQQchBkEBIQQgAkHkAEYNAQwCC0EAIQRBACADQQxqIgI2ArAKQQEhBUEBECkhCQJAQQAoArAKIgYgAkYNAEHmACECAkAgCUHmAEYNAEEFIQZBACEHQQEhCCAJIQIMBAtBACEHQQEhCCAGQQJqQawIQQYQLw0EIAYvAQgQIEUNBAtBACEHQQAgAzYCsApBByEGQQEhBEEAIQVBACEIIAkhAgwCCyADIABBCmpNDQBBACEIQeQAIQICQCADKQACQuWAmIPQjIA5Ug0AAkACQCADLwEKIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAQtBACEIIARBoAFHDQELQQAhBUEAIANBCmo2ArAKQSohAkEBIQdBAiEIQQEQKSIJQSpGDQRBACADNgKwCkEBIQRBACEHQQAhCCAJIQIMAgsgAyEGQQAhBwwCC0EAIQVBACEICwJAIAJBKEcNAEEAKAKkCkEALwGYCiICQQN0aiIDQQAoArAKNgIEQQAgAkEBajsBmAogA0EFNgIAQQAoApwKLwEAQS5GDQRBAEEAKAKwCiIDQQJqNgKwCkEBECkhAiAAQQAoArAKQQAgAxABAkACQCAFDQBBACgC8AkhAQwBC0EAKALwCSIBIAY2AhwLQQBBAC8BlgoiA0EBajsBlgpBACgCqAogA0ECdGogATYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKwCkF+ajYCsAoPCyACEBpBAEEAKAKwCkECaiICNgKwCgJAAkACQEEBEClBV2oOBAECAgACC0EAQQAoArAKQQJqNgKwCkEBECkaQQAoAvAJIgMgAjYCBCADQQE6ABggA0EAKAKwCiICNgIQQQAgAkF+ajYCsAoPC0EAKALwCSIDIAI2AgQgA0EBOgAYQQBBAC8BmApBf2o7AZgKIANBACgCsApBAmo2AgxBAEEALwGWCkF/ajsBlgoPC0EAQQAoArAKQX5qNgKwCg8LAkAgBEEBcyACQfsAR3INAEEAKAKwCiECQQAvAZgKDQUDQAJAAkACQCACQQAoArQKTw0AQQEQKSICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKwCkECajYCsAoLQQEQKSEDQQAoArAKIQICQCADQeYARw0AIAJBAmpBrAhBBhAvDQcLQQAgAkEIajYCsAoCQEEBECkiAkEiRg0AIAJBJ0cNBwsgACACQQAQKw8LIAIQGgtBAEEAKAKwCkECaiICNgKwCgwACwsCQAJAIAJBWWoOBAMBAQMACyACQSJGDQILQQAoArAKIQYLIAYgAUcNAEEAIABBCmo2ArAKDwsgAkEqRyAHcQ0DQQAvAZgKQf//A3ENA0EAKAKwCiECQQAoArQKIQEDQCACIAFPDQECQAJAIAIvAQAiA0EnRg0AIANBIkcNAQsgACADIAgQKw8LQQAgAkECaiICNgKwCgwACwsQJQsPC0EAIAJBfmo2ArAKDwtBAEEAKAKwCkF+ajYCsAoLRwEDf0EAKAKwCkECaiEAQQAoArQKIQECQANAIAAiAkF+aiABTw0BIAJBAmohACACLwEAQXZqDgQBAAABAAsLQQAgAjYCsAoLmAEBA39BAEEAKAKwCiIBQQJqNgKwCiABQQZqIQFBACgCtAohAgNAAkACQAJAIAFBfGogAk8NACABQX5qLwEAIQMCQAJAIAANACADQSpGDQEgA0F2ag4EAgQEAgQLIANBKkcNAwsgAS8BAEEvRw0CQQAgAUF+ajYCsAoMAQsgAUF+aiEBC0EAIAE2ArAKDwsgAUECaiEBDAALC4gBAQR/QQAoArAKIQFBACgCtAohAgJAAkADQCABIgNBAmohASADIAJPDQEgAS8BACIEIABGDQICQCAEQdwARg0AIARBdmoOBAIBAQIBCyADQQRqIQEgAy8BBEENRw0AIANBBmogASADLwEGQQpGGyEBDAALC0EAIAE2ArAKECUPC0EAIAE2ArAKC2wBAX8CQAJAIABBX2oiAUEFSw0AQQEgAXRBMXENAQsgAEFGakH//wNxQQZJDQAgAEEpRyAAQVhqQf//A3FBB0lxDQACQCAAQaV/ag4EAQAAAQALIABB/QBHIABBhX9qQf//A3FBBElxDwtBAQsuAQF/QQEhAQJAIABBpglBBRAdDQAgAEGWCEEDEB0NACAAQbAJQQIQHSEBCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALcCSIFSQ0AIAAgASACEC8NAAJAIAAgBUcNAEEBDwsgBBAmIQMLIAMLgwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQbwJQQYQHQ8LIABBfmovAQBBPUYPCyAAQX5qQbQJQQQQHQ8LIABBfmpByAlBAxAdDwtBACEBCyABC7QDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQAJAIAAvAQBBnH9qDhQAAQIJCQkJAwkJBAUJCQYJBwkJCAkLAkACQCAAQX5qLwEAQZd/ag4EAAoKAQoLIABBfGpByghBAhAdDwsgAEF8akHOCEEDEB0PCwJAAkACQCAAQX5qLwEAQY1/ag4DAAECCgsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCiAAQXpqQeUAECcPCyAAQXpqQeMAECcPCyAAQXxqQdQIQQQQHQ8LIABBfGpB3AhBBhAdDwsgAEF+ai8BAEHvAEcNBiAAQXxqLwEAQeUARw0GAkAgAEF6ai8BACICQfAARg0AIAJB4wBHDQcgAEF4akHoCEEGEB0PCyAAQXhqQfQIQQIQHQ8LIABBfmpB+AhBBBAdDwtBASEBIABBfmoiAEHpABAnDQQgAEGACUEFEB0PCyAAQX5qQeQAECcPCyAAQX5qQYoJQQcQHQ8LIABBfmpBmAlBBBAdDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECcPCyAAQXxqQaAJQQMQHSEBCyABCzQBAX9BASEBAkAgAEF3akH//wNxQQVJDQAgAEGAAXJBoAFGDQAgAEEuRyAAEChxIQELIAELMAEBfwJAAkAgAEF3aiIBQRdLDQBBASABdEGNgIAEcQ0BCyAAQaABRg0AQQAPC0EBC04BAn9BACEBAkACQCAALwEAIgJB5QBGDQAgAkHrAEcNASAAQX5qQfgIQQQQHQ8LIABBfmovAQBB9QBHDQAgAEF8akHcCEEGEB0hAQsgAQveAQEEf0EAKAKwCiEAQQAoArQKIQECQAJAAkADQCAAIgJBAmohACACIAFPDQECQAJAAkAgAC8BACIDQaR/ag4FAgMDAwEACyADQSRHDQIgAi8BBEH7AEcNAkEAIAJBBGoiADYCsApBAEEALwGYCiICQQFqOwGYCkEAKAKkCiACQQN0aiICQQQ2AgAgAiAANgIEDwtBACAANgKwCkEAQQAvAZgKQX9qIgA7AZgKQQAoAqQKIABB//8DcUEDdGooAgBBA0cNAwwECyACQQRqIQAMAAsLQQAgADYCsAoLECULC3ABAn8CQAJAA0BBAEEAKAKwCiIAQQJqIgE2ArAKIABBACgCtApPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLhoMAQtBACAAQQRqNgKwCgwACwsQJQsLNQEBf0EAQQE6APwJQQAoArAKIQBBAEEAKAK0CkECajYCsApBACAAQQAoAtwJa0EBdTYCkAoLQwECf0EBIQECQCAALwEAIgJBd2pB//8DcUEFSQ0AIAJBgAFyQaABRg0AQQAhASACEChFDQAgAkEuRyAAECpyDwsgAQs9AQJ/QQAhAgJAQQAoAtwJIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQICECCyACC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC5wBAQN/QQAoArAKIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAYDAILIAAQGQwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQIUUNAwwBCyACQaABRw0CC0EAQQAoArAKIgNBAmoiATYCsAogA0EAKAK0CkkNAAsLIAILMQEBf0EAIQECQCAALwEAQS5HDQAgAEF+ai8BAEEuRw0AIABBfGovAQBBLkYhAQsgAQumBAEBfwJAIAFBIkYNACABQSdGDQAQJQ8LQQAoArAKIQMgARAaIAAgA0ECakEAKAKwCkEAKALQCRABAkAgAkEBSA0AQQAoAvAJQQRBBiACQQFGGzYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQIMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhAiABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIAJBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiACECA0BBACACQQJqNgKwCgJAAkACQEEBECkiAkEiRg0AIAJBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQIMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSECDAELIAIQLCECCwJAIAJBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAkEiRg0AIAJBJ0YNAEEAIAE2ArAKDwsgAhAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAkEsRg0AIAJB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiECDAELC0EAKALwCSIBIAA2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=\", \"undefined\" != typeof Buffer ? Buffer.from(A3, \"base64\") : Uint8Array.from(atob(A3), (A4) => A4.charCodeAt(0));\n      var A3;\n    }, \"E\");\n    WebAssembly.compile(E()).then(WebAssembly.instantiate).then(({ exports: A3 }) => {\n    });\n    DevalueError = class extends Error {\n      static {\n        __name(this, \"DevalueError\");\n      }\n      /**\n       * @param {string} message\n       * @param {string[]} keys\n       */\n      constructor(message, keys2) {\n        super(message);\n        this.name = \"DevalueError\";\n        this.path = keys2.join(\"\");\n      }\n    };\n    __name(is_primitive, \"is_primitive\");\n    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(\n      Object.prototype\n    ).sort().join(\"\\0\");\n    __name(is_plain_object, \"is_plain_object\");\n    __name(get_type, \"get_type\");\n    __name(get_escaped_char, \"get_escaped_char\");\n    __name(stringify_string, \"stringify_string\");\n    __name(enumerable_symbols, \"enumerable_symbols\");\n    is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n    __name(stringify_key, \"stringify_key\");\n    __name(encode64, \"encode64\");\n    __name(decode64, \"decode64\");\n    KEY_STRING = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    __name(asciiToBinary, \"asciiToBinary\");\n    __name(binaryToAscii, \"binaryToAscii\");\n    UNDEFINED = -1;\n    HOLE = -2;\n    NAN = -3;\n    POSITIVE_INFINITY = -4;\n    NEGATIVE_INFINITY = -5;\n    NEGATIVE_ZERO = -6;\n    __name(parse, \"parse\");\n    __name(unflatten, \"unflatten\");\n    __name(stringify, \"stringify\");\n    __name(stringify_primitive, \"stringify_primitive\");\n    ACTION_QUERY_PARAMS$1 = {\n      actionName: \"_action\"\n    };\n    ACTION_RPC_ROUTE_PATTERN = \"/_actions/[...path]\";\n    __vite_import_meta_env__ = { \"ASSETS_PREFIX\": void 0, \"BASE_URL\": \"/\", \"DEV\": false, \"MODE\": \"production\", \"PROD\": true, \"SITE\": void 0, \"SSR\": true };\n    ACTION_QUERY_PARAMS = ACTION_QUERY_PARAMS$1;\n    codeToStatusMap = {\n      // Implemented from IANA HTTP Status Code Registry\n      // https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n      BAD_REQUEST: 400,\n      UNAUTHORIZED: 401,\n      PAYMENT_REQUIRED: 402,\n      FORBIDDEN: 403,\n      NOT_FOUND: 404,\n      METHOD_NOT_ALLOWED: 405,\n      NOT_ACCEPTABLE: 406,\n      PROXY_AUTHENTICATION_REQUIRED: 407,\n      REQUEST_TIMEOUT: 408,\n      CONFLICT: 409,\n      GONE: 410,\n      LENGTH_REQUIRED: 411,\n      PRECONDITION_FAILED: 412,\n      CONTENT_TOO_LARGE: 413,\n      URI_TOO_LONG: 414,\n      UNSUPPORTED_MEDIA_TYPE: 415,\n      RANGE_NOT_SATISFIABLE: 416,\n      EXPECTATION_FAILED: 417,\n      MISDIRECTED_REQUEST: 421,\n      UNPROCESSABLE_CONTENT: 422,\n      LOCKED: 423,\n      FAILED_DEPENDENCY: 424,\n      TOO_EARLY: 425,\n      UPGRADE_REQUIRED: 426,\n      PRECONDITION_REQUIRED: 428,\n      TOO_MANY_REQUESTS: 429,\n      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n      UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n      INTERNAL_SERVER_ERROR: 500,\n      NOT_IMPLEMENTED: 501,\n      BAD_GATEWAY: 502,\n      SERVICE_UNAVAILABLE: 503,\n      GATEWAY_TIMEOUT: 504,\n      HTTP_VERSION_NOT_SUPPORTED: 505,\n      VARIANT_ALSO_NEGOTIATES: 506,\n      INSUFFICIENT_STORAGE: 507,\n      LOOP_DETECTED: 508,\n      NETWORK_AUTHENTICATION_REQUIRED: 511\n    };\n    statusToCodeMap = Object.entries(codeToStatusMap).reduce(\n      // reverse the key-value pairs\n      (acc, [key, value2]) => ({ ...acc, [value2]: key }),\n      {}\n    );\n    ActionError = class _ActionError extends Error {\n      static {\n        __name(this, \"ActionError\");\n      }\n      type = \"AstroActionError\";\n      code = \"INTERNAL_SERVER_ERROR\";\n      status = 500;\n      constructor(params) {\n        super(params.message);\n        this.code = params.code;\n        this.status = _ActionError.codeToStatus(params.code);\n        if (params.stack) {\n          this.stack = params.stack;\n        }\n      }\n      static codeToStatus(code) {\n        return codeToStatusMap[code];\n      }\n      static statusToCode(status) {\n        return statusToCodeMap[status] ?? \"INTERNAL_SERVER_ERROR\";\n      }\n      static fromJson(body) {\n        if (isInputError(body)) {\n          return new ActionInputError(body.issues);\n        }\n        if (isActionError(body)) {\n          return new _ActionError(body);\n        }\n        return new _ActionError({\n          code: \"INTERNAL_SERVER_ERROR\"\n        });\n      }\n    };\n    __name(isActionError, \"isActionError\");\n    __name(isInputError, \"isInputError\");\n    ActionInputError = class extends ActionError {\n      static {\n        __name(this, \"ActionInputError\");\n      }\n      type = \"AstroActionInputError\";\n      // We don't expose all ZodError properties.\n      // Not all properties will serialize from server to client,\n      // and we don't want to import the full ZodError object into the client.\n      issues;\n      fields;\n      constructor(issues) {\n        super({\n          message: `Failed to validate: ${JSON.stringify(issues, null, 2)}`,\n          code: \"BAD_REQUEST\"\n        });\n        this.issues = issues;\n        this.fields = {};\n        for (const issue of issues) {\n          if (issue.path.length > 0) {\n            const key = issue.path[0].toString();\n            this.fields[key] ??= [];\n            this.fields[key]?.push(issue.message);\n          }\n        }\n      }\n    };\n    __name(getActionQueryString, \"getActionQueryString\");\n    __name(serializeActionResult, \"serializeActionResult\");\n    __name(deserializeActionResult, \"deserializeActionResult\");\n    actionResultErrorStack = /* @__PURE__ */ (/* @__PURE__ */ __name(function actionResultErrorStackFn() {\n      let errorStack;\n      return {\n        set(stack) {\n          errorStack = stack;\n        },\n        get() {\n          return errorStack;\n        }\n      };\n    }, \"actionResultErrorStackFn\"))();\n    dist = {};\n    __name(requireDist, \"requireDist\");\n    distExports = requireDist();\n    __name(template, \"template\");\n    DEFAULT_404_ROUTE = {\n      component: DEFAULT_404_COMPONENT,\n      generate: /* @__PURE__ */ __name(() => \"\", \"generate\"),\n      params: [],\n      pattern: /\\/404/,\n      prerender: false,\n      pathname: \"/404\",\n      segments: [[{ content: \"404\", dynamic: false, spread: false }]],\n      type: \"page\",\n      route: \"/404\",\n      fallbackRoutes: [],\n      isIndex: false,\n      origin: \"internal\"\n    };\n    __name(ensure404Route, \"ensure404Route\");\n    __name(default404Page, \"default404Page\");\n    default404Page.isAstroComponentFactory = true;\n    default404Instance = {\n      default: default404Page\n    };\n  }\n});\n\n// dist/_worker.js/chunks/index_Bos_IFPf.mjs\nfunction hasContentType(contentType, expected) {\n  const type2 = contentType.split(\";\")[0].toLowerCase();\n  return expected.some((t) => type2 === t);\n}\nfunction appendForwardSlash(path) {\n  return path.endsWith(\"/\") ? path : path + \"/\";\n}\nfunction prependForwardSlash(path) {\n  return path[0] === \"/\" ? path : \"/\" + path;\n}\nfunction collapseDuplicateTrailingSlashes(path, trailingSlash) {\n  if (!path) {\n    return path;\n  }\n  return path.replace(MANY_TRAILING_SLASHES, trailingSlash ? \"/\" : \"\") || \"/\";\n}\nfunction removeTrailingForwardSlash(path) {\n  return path.endsWith(\"/\") ? path.slice(0, path.length - 1) : path;\n}\nfunction removeLeadingForwardSlash(path) {\n  return path.startsWith(\"/\") ? path.substring(1) : path;\n}\nfunction trimSlashes(path) {\n  return path.replace(/^\\/|\\/$/g, \"\");\n}\nfunction isString(path) {\n  return typeof path === \"string\" || path instanceof String;\n}\nfunction joinPaths(...paths) {\n  return paths.filter(isString).map((path, i) => {\n    if (i === 0) {\n      return removeTrailingForwardSlash(path);\n    } else if (i === paths.length - 1) {\n      return removeLeadingForwardSlash(path);\n    } else {\n      return trimSlashes(path);\n    }\n  }).join(\"/\");\n}\nfunction slash(path) {\n  return path.replace(/\\\\/g, \"/\");\n}\nfunction fileExtension(path) {\n  const ext = path.split(\".\").pop();\n  return ext !== path ? `.${ext}` : \"\";\n}\nfunction hasFileExtension(path) {\n  return WITH_FILE_EXT.test(path);\n}\nfunction hasActionPayload(locals) {\n  return \"_actionPayload\" in locals;\n}\nfunction createGetActionResult(locals) {\n  return (actionFn) => {\n    if (!hasActionPayload(locals) || actionFn.toString() !== getActionQueryString(locals._actionPayload.actionName)) {\n      return void 0;\n    }\n    return deserializeActionResult(locals._actionPayload.actionResult);\n  };\n}\nfunction createCallAction(context2) {\n  return (baseAction, input2) => {\n    Reflect.set(context2, ACTION_API_CONTEXT_SYMBOL, true);\n    const action = baseAction.bind(context2);\n    return action(input2);\n  };\n}\nfunction shouldAppendForwardSlash(trailingSlash, buildFormat) {\n  switch (trailingSlash) {\n    case \"always\":\n      return true;\n    case \"never\":\n      return false;\n    case \"ignore\": {\n      switch (buildFormat) {\n        case \"directory\":\n          return true;\n        case \"preserve\":\n        case \"file\":\n          return false;\n      }\n    }\n  }\n}\nfunction redirectIsExternal(redirect) {\n  if (typeof redirect === \"string\") {\n    return redirect.startsWith(\"http://\") || redirect.startsWith(\"https://\");\n  } else {\n    return redirect.destination.startsWith(\"http://\") || redirect.destination.startsWith(\"https://\");\n  }\n}\nasync function renderRedirect(renderContext) {\n  const {\n    request: { method },\n    routeData\n  } = renderContext;\n  const { redirect, redirectRoute } = routeData;\n  const status = redirectRoute && typeof redirect === \"object\" ? redirect.status : method === \"GET\" ? 301 : 308;\n  const headers = { location: encodeURI(redirectRouteGenerate(renderContext)) };\n  if (redirect && redirectIsExternal(redirect)) {\n    if (typeof redirect === \"string\") {\n      return Response.redirect(redirect, status);\n    } else {\n      return Response.redirect(redirect.destination, status);\n    }\n  }\n  return new Response(null, { status, headers });\n}\nfunction redirectRouteGenerate(renderContext) {\n  const {\n    params,\n    routeData: { redirect, redirectRoute }\n  } = renderContext;\n  if (typeof redirectRoute !== \"undefined\") {\n    return redirectRoute?.generate(params) || redirectRoute?.pathname || \"/\";\n  } else if (typeof redirect === \"string\") {\n    if (redirectIsExternal(redirect)) {\n      return redirect;\n    } else {\n      let target = redirect;\n      for (const param of Object.keys(params)) {\n        const paramValue = params[param];\n        target = target.replace(`[${param}]`, paramValue).replace(`[...${param}]`, paramValue);\n      }\n      return target;\n    }\n  } else if (typeof redirect === \"undefined\") {\n    return \"/\";\n  }\n  return redirect.destination;\n}\nfunction badRequest(reason) {\n  return new Response(null, {\n    status: 400,\n    statusText: \"Bad request: \" + reason\n  });\n}\nasync function getRequestData(request) {\n  switch (request.method) {\n    case \"GET\": {\n      const url = new URL(request.url);\n      const params = url.searchParams;\n      if (!params.has(\"s\") || !params.has(\"e\") || !params.has(\"p\")) {\n        return badRequest(\"Missing required query parameters.\");\n      }\n      const rawSlots = params.get(\"s\");\n      try {\n        return {\n          componentExport: params.get(\"e\"),\n          encryptedProps: params.get(\"p\"),\n          slots: JSON.parse(rawSlots)\n        };\n      } catch {\n        return badRequest(\"Invalid slots format.\");\n      }\n    }\n    case \"POST\": {\n      try {\n        const raw2 = await request.text();\n        const data = JSON.parse(raw2);\n        return data;\n      } catch {\n        return badRequest(\"Request format is invalid.\");\n      }\n    }\n    default: {\n      return new Response(null, { status: 405 });\n    }\n  }\n}\nfunction createEndpoint(manifest2) {\n  const page7 = /* @__PURE__ */ __name(async (result) => {\n    const params = result.params;\n    if (!params.name) {\n      return new Response(null, {\n        status: 400,\n        statusText: \"Bad request\"\n      });\n    }\n    const componentId = params.name;\n    const data = await getRequestData(result.request);\n    if (data instanceof Response) {\n      return data;\n    }\n    const imp = manifest2.serverIslandMap?.get(componentId);\n    if (!imp) {\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not found\"\n      });\n    }\n    const key = await manifest2.key;\n    const encryptedProps = data.encryptedProps;\n    const propString = encryptedProps === \"\" ? \"{}\" : await decryptString(key, encryptedProps);\n    const props = JSON.parse(propString);\n    const componentModule = await imp();\n    let Component = componentModule[data.componentExport];\n    const slots = {};\n    for (const prop in data.slots) {\n      slots[prop] = createSlotValueFromString(data.slots[prop]);\n    }\n    result.response.headers.set(\"X-Robots-Tag\", \"noindex\");\n    if (isAstroComponentFactory(Component)) {\n      const ServerIsland = Component;\n      Component = /* @__PURE__ */ __name(function(...args) {\n        return ServerIsland.apply(this, args);\n      }, \"Component\");\n      Object.assign(Component, ServerIsland);\n      Component.propagation = \"self\";\n    }\n    return renderTemplate`${renderComponent(result, \"Component\", Component, props, slots)}`;\n  }, \"page\");\n  page7.isAstroComponentFactory = true;\n  const instance = {\n    default: page7,\n    partial: true\n  };\n  return instance;\n}\nfunction matchRoute(pathname, manifest2) {\n  return manifest2.routes.find((route) => {\n    return route.pattern.test(pathname) || route.fallbackRoutes.some((fallbackRoute) => fallbackRoute.pattern.test(pathname));\n  });\n}\nfunction isRoute404(route) {\n  return ROUTE404_RE.test(route);\n}\nfunction isRoute500(route) {\n  return ROUTE500_RE.test(route);\n}\nfunction isRoute404or500(route) {\n  return isRoute404(route.route) || isRoute500(route.route);\n}\nfunction isRouteServerIsland(route) {\n  return route.component === SERVER_ISLAND_COMPONENT;\n}\nfunction isRequestServerIsland(request, base = \"\") {\n  const url = new URL(request.url);\n  const pathname = base === \"/\" ? url.pathname.slice(base.length) : url.pathname.slice(base.length + 1);\n  return pathname.startsWith(SERVER_ISLAND_BASE_PREFIX);\n}\nfunction requestIs404Or500(request, base = \"\") {\n  const url = new URL(request.url);\n  const pathname = url.pathname.slice(base.length);\n  return isRoute404(pathname) || isRoute500(pathname);\n}\nfunction isRouteExternalRedirect(route) {\n  return !!(route.type === \"redirect\" && route.redirect && redirectIsExternal(route.redirect));\n}\nfunction requestHasLocale(locales) {\n  return function(context2) {\n    return pathHasLocale(context2.url.pathname, locales);\n  };\n}\nfunction pathHasLocale(path, locales) {\n  const segments = path.split(\"/\");\n  for (const segment of segments) {\n    for (const locale of locales) {\n      if (typeof locale === \"string\") {\n        if (normalizeTheLocale(segment) === normalizeTheLocale(locale)) {\n          return true;\n        }\n      } else if (segment === locale.path) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction getPathByLocale(locale, locales) {\n  for (const loopLocale of locales) {\n    if (typeof loopLocale === \"string\") {\n      if (loopLocale === locale) {\n        return loopLocale;\n      }\n    } else {\n      for (const code of loopLocale.codes) {\n        if (code === locale) {\n          return loopLocale.path;\n        }\n      }\n    }\n  }\n  throw new AstroError(i18nNoLocaleFoundInPath);\n}\nfunction normalizeTheLocale(locale) {\n  return locale.replaceAll(\"_\", \"-\").toLowerCase();\n}\nfunction getAllCodes(locales) {\n  const result = [];\n  for (const loopLocale of locales) {\n    if (typeof loopLocale === \"string\") {\n      result.push(loopLocale);\n    } else {\n      result.push(...loopLocale.codes);\n    }\n  }\n  return result;\n}\nfunction redirectToDefaultLocale({\n  trailingSlash,\n  format: format2,\n  base,\n  defaultLocale\n}) {\n  return function(context2, statusCode) {\n    if (shouldAppendForwardSlash(trailingSlash, format2)) {\n      return context2.redirect(`${appendForwardSlash(joinPaths(base, defaultLocale))}`, statusCode);\n    } else {\n      return context2.redirect(`${joinPaths(base, defaultLocale)}`, statusCode);\n    }\n  };\n}\nfunction notFound({ base, locales, fallback }) {\n  return function(context2, response) {\n    if (response?.headers.get(REROUTE_DIRECTIVE_HEADER) === \"no\" && typeof fallback === \"undefined\") {\n      return response;\n    }\n    const url = context2.url;\n    const isRoot = url.pathname === base + \"/\" || url.pathname === base;\n    if (!(isRoot || pathHasLocale(url.pathname, locales))) {\n      if (response) {\n        response.headers.set(REROUTE_DIRECTIVE_HEADER, \"no\");\n        return new Response(response.body, {\n          status: 404,\n          headers: response.headers\n        });\n      } else {\n        return new Response(null, {\n          status: 404,\n          headers: {\n            [REROUTE_DIRECTIVE_HEADER]: \"no\"\n          }\n        });\n      }\n    }\n    return void 0;\n  };\n}\nfunction redirectToFallback({\n  fallback,\n  locales,\n  defaultLocale,\n  strategy,\n  base,\n  fallbackType\n}) {\n  return async function(context2, response) {\n    if (response.status >= 300 && fallback) {\n      const fallbackKeys = fallback ? Object.keys(fallback) : [];\n      const segments = context2.url.pathname.split(\"/\");\n      const urlLocale = segments.find((segment) => {\n        for (const locale of locales) {\n          if (typeof locale === \"string\") {\n            if (locale === segment) {\n              return true;\n            }\n          } else if (locale.path === segment) {\n            return true;\n          }\n        }\n        return false;\n      });\n      if (urlLocale && fallbackKeys.includes(urlLocale)) {\n        const fallbackLocale = fallback[urlLocale];\n        const pathFallbackLocale = getPathByLocale(fallbackLocale, locales);\n        let newPathname;\n        if (pathFallbackLocale === defaultLocale && strategy === \"pathname-prefix-other-locales\") {\n          if (context2.url.pathname.includes(`${base}`)) {\n            newPathname = context2.url.pathname.replace(`/${urlLocale}`, ``);\n          } else {\n            newPathname = context2.url.pathname.replace(`/${urlLocale}`, `/`);\n          }\n        } else {\n          newPathname = context2.url.pathname.replace(`/${urlLocale}`, `/${pathFallbackLocale}`);\n        }\n        if (fallbackType === \"rewrite\") {\n          return await context2.rewrite(newPathname + context2.url.search);\n        } else {\n          return context2.redirect(newPathname + context2.url.search);\n        }\n      }\n    }\n    return response;\n  };\n}\nfunction parseLocale(header) {\n  if (header === \"*\") {\n    return [{ locale: header, qualityValue: void 0 }];\n  }\n  const result = [];\n  const localeValues = header.split(\",\").map((str) => str.trim());\n  for (const localeValue of localeValues) {\n    const split = localeValue.split(\";\").map((str) => str.trim());\n    const localeName = split[0];\n    const qualityValue = split[1];\n    if (!split) {\n      continue;\n    }\n    if (qualityValue && qualityValue.startsWith(\"q=\")) {\n      const qualityValueAsFloat = Number.parseFloat(qualityValue.slice(\"q=\".length));\n      if (Number.isNaN(qualityValueAsFloat) || qualityValueAsFloat > 1) {\n        result.push({\n          locale: localeName,\n          qualityValue: void 0\n        });\n      } else {\n        result.push({\n          locale: localeName,\n          qualityValue: qualityValueAsFloat\n        });\n      }\n    } else {\n      result.push({\n        locale: localeName,\n        qualityValue: void 0\n      });\n    }\n  }\n  return result;\n}\nfunction sortAndFilterLocales(browserLocaleList, locales) {\n  const normalizedLocales = getAllCodes(locales).map(normalizeTheLocale);\n  return browserLocaleList.filter((browserLocale) => {\n    if (browserLocale.locale !== \"*\") {\n      return normalizedLocales.includes(normalizeTheLocale(browserLocale.locale));\n    }\n    return true;\n  }).sort((a2, b3) => {\n    if (a2.qualityValue && b3.qualityValue) {\n      return Math.sign(b3.qualityValue - a2.qualityValue);\n    }\n    return 0;\n  });\n}\nfunction computePreferredLocale(request, locales) {\n  const acceptHeader = request.headers.get(\"Accept-Language\");\n  let result = void 0;\n  if (acceptHeader) {\n    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);\n    const firstResult = browserLocaleList.at(0);\n    if (firstResult && firstResult.locale !== \"*\") {\n      for (const currentLocale of locales) {\n        if (typeof currentLocale === \"string\") {\n          if (normalizeTheLocale(currentLocale) === normalizeTheLocale(firstResult.locale)) {\n            result = currentLocale;\n            break;\n          }\n        } else {\n          for (const currentCode of currentLocale.codes) {\n            if (normalizeTheLocale(currentCode) === normalizeTheLocale(firstResult.locale)) {\n              result = currentCode;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction computePreferredLocaleList(request, locales) {\n  const acceptHeader = request.headers.get(\"Accept-Language\");\n  let result = [];\n  if (acceptHeader) {\n    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);\n    if (browserLocaleList.length === 1 && browserLocaleList.at(0).locale === \"*\") {\n      return getAllCodes(locales);\n    } else if (browserLocaleList.length > 0) {\n      for (const browserLocale of browserLocaleList) {\n        for (const loopLocale of locales) {\n          if (typeof loopLocale === \"string\") {\n            if (normalizeTheLocale(loopLocale) === normalizeTheLocale(browserLocale.locale)) {\n              result.push(loopLocale);\n            }\n          } else {\n            for (const code of loopLocale.codes) {\n              if (code === browserLocale.locale) {\n                result.push(code);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction computeCurrentLocale(pathname, locales, defaultLocale) {\n  for (const segment of pathname.split(\"/\")) {\n    for (const locale of locales) {\n      if (typeof locale === \"string\") {\n        if (!segment.includes(locale)) continue;\n        if (normalizeTheLocale(locale) === normalizeTheLocale(segment)) {\n          return locale;\n        }\n      } else {\n        if (locale.path === segment) {\n          return locale.codes.at(0);\n        } else {\n          for (const code of locale.codes) {\n            if (normalizeTheLocale(code) === normalizeTheLocale(segment)) {\n              return code;\n            }\n          }\n        }\n      }\n    }\n  }\n  for (const locale of locales) {\n    if (typeof locale === \"string\") {\n      if (locale === defaultLocale) {\n        return locale;\n      }\n    } else {\n      if (locale.path === defaultLocale) {\n        return locale.codes.at(0);\n      }\n    }\n  }\n}\nfunction attachCookiesToResponse(response, cookies) {\n  Reflect.set(response, astroCookiesSymbol, cookies);\n}\nfunction getCookiesFromResponse(response) {\n  let cookies = Reflect.get(response, astroCookiesSymbol);\n  if (cookies != null) {\n    return cookies;\n  } else {\n    return void 0;\n  }\n}\nfunction* getSetCookiesFromResponse(response) {\n  const cookies = getCookiesFromResponse(response);\n  if (!cookies) {\n    return [];\n  }\n  for (const headerValue of AstroCookies.consume(cookies)) {\n    yield headerValue;\n  }\n  return [];\n}\nfunction createRequest({\n  url,\n  headers,\n  method = \"GET\",\n  body = void 0,\n  logger,\n  isPrerendered = false,\n  routePattern,\n  init: init2\n}) {\n  const headersObj = isPrerendered ? void 0 : headers instanceof Headers ? headers : new Headers(\n    // Filter out HTTP/2 pseudo-headers. These are internally-generated headers added to all HTTP/2 requests with trusted metadata about the request.\n    // Examples include `:method`, `:scheme`, `:authority`, and `:path`.\n    // They are always prefixed with a colon to distinguish them from other headers, and it is an error to add the to a Headers object manually.\n    // See https://httpwg.org/specs/rfc7540.html#HttpRequest\n    Object.entries(headers).filter(([name]) => !name.startsWith(\":\"))\n  );\n  if (typeof url === \"string\") url = new URL(url);\n  if (isPrerendered) {\n    url.search = \"\";\n  }\n  const request = new Request(url, {\n    method,\n    headers: headersObj,\n    // body is made available only if the request is for a page that will be on-demand rendered\n    body: isPrerendered ? null : body,\n    ...init2\n  });\n  if (isPrerendered) {\n    let _headers = request.headers;\n    const { value: value2, writable, ...headersDesc } = Object.getOwnPropertyDescriptor(request, \"headers\") || {};\n    Object.defineProperty(request, \"headers\", {\n      ...headersDesc,\n      get() {\n        logger.warn(\n          null,\n          `\\`Astro.request.headers\\` was used when rendering the route \\`${routePattern}'\\`. \\`Astro.request.headers\\` is not available on prerendered pages. If you need access to request headers, make sure that the page is server-rendered using \\`export const prerender = false;\\` or by setting \\`output\\` to \\`\"server\"\\` in your Astro config to make all your pages server-rendered by default.`\n        );\n        return _headers;\n      },\n      set(newHeaders) {\n        _headers = newHeaders;\n      }\n    });\n  }\n  return request;\n}\nfunction findRouteToRewrite({\n  payload,\n  routes,\n  request,\n  trailingSlash,\n  buildFormat,\n  base\n}) {\n  let newUrl = void 0;\n  if (payload instanceof URL) {\n    newUrl = payload;\n  } else if (payload instanceof Request) {\n    newUrl = new URL(payload.url);\n  } else {\n    newUrl = new URL(payload, new URL(request.url).origin);\n  }\n  let pathname = newUrl.pathname;\n  const shouldAppendSlash = shouldAppendForwardSlash(trailingSlash, buildFormat);\n  if (base !== \"/\") {\n    const isBasePathRequest = newUrl.pathname === base || newUrl.pathname === removeTrailingForwardSlash(base);\n    if (isBasePathRequest) {\n      pathname = shouldAppendSlash ? \"/\" : \"\";\n    } else if (newUrl.pathname.startsWith(base)) {\n      pathname = shouldAppendSlash ? appendForwardSlash(newUrl.pathname) : removeTrailingForwardSlash(newUrl.pathname);\n      pathname = pathname.slice(base.length);\n    }\n  }\n  if (!pathname.startsWith(\"/\") && shouldAppendSlash && newUrl.pathname.endsWith(\"/\")) {\n    pathname = prependForwardSlash(pathname);\n  }\n  if (pathname === \"/\" && base !== \"/\" && !shouldAppendSlash) {\n    pathname = \"\";\n  }\n  if (base !== \"/\" && (pathname === \"\" || pathname === \"/\") && !shouldAppendSlash) {\n    newUrl.pathname = removeTrailingForwardSlash(base);\n  } else {\n    newUrl.pathname = joinPaths(...[base, pathname].filter(Boolean));\n  }\n  const decodedPathname = decodeURI(pathname);\n  let foundRoute;\n  for (const route of routes) {\n    if (route.pattern.test(decodedPathname)) {\n      foundRoute = route;\n      break;\n    }\n  }\n  if (foundRoute) {\n    return {\n      routeData: foundRoute,\n      newUrl,\n      pathname: decodedPathname\n    };\n  } else {\n    const custom404 = routes.find((route) => route.route === \"/404\");\n    if (custom404) {\n      return { routeData: custom404, newUrl, pathname };\n    } else {\n      return { routeData: DEFAULT_404_ROUTE, newUrl, pathname };\n    }\n  }\n}\nfunction copyRequest(newUrl, oldRequest, isPrerendered, logger, routePattern) {\n  if (oldRequest.bodyUsed) {\n    throw new AstroError(RewriteWithBodyUsed);\n  }\n  return createRequest({\n    url: newUrl,\n    method: oldRequest.method,\n    body: oldRequest.body,\n    isPrerendered,\n    logger,\n    headers: isPrerendered ? {} : oldRequest.headers,\n    routePattern,\n    init: {\n      referrer: oldRequest.referrer,\n      referrerPolicy: oldRequest.referrerPolicy,\n      mode: oldRequest.mode,\n      credentials: oldRequest.credentials,\n      cache: oldRequest.cache,\n      redirect: oldRequest.redirect,\n      integrity: oldRequest.integrity,\n      signal: oldRequest.signal,\n      keepalive: oldRequest.keepalive,\n      // https://fetch.spec.whatwg.org/#dom-request-duplex\n      // @ts-expect-error It isn't part of the types, but undici accepts it and it allows to carry over the body to a new request\n      duplex: \"half\"\n    }\n  });\n}\nfunction setOriginPathname(request, pathname) {\n  Reflect.set(request, originPathnameSymbol, encodeURIComponent(pathname));\n}\nfunction getOriginPathname(request) {\n  const origin = Reflect.get(request, originPathnameSymbol);\n  if (origin) {\n    return decodeURIComponent(origin);\n  }\n  return new URL(request.url).pathname;\n}\nfunction getActionContext(context2) {\n  const callerInfo = getCallerInfo(context2);\n  const actionResultAlreadySet = Boolean(context2.locals._actionPayload);\n  let action = void 0;\n  if (callerInfo && context2.request.method === \"POST\" && !actionResultAlreadySet) {\n    action = {\n      calledFrom: callerInfo.from,\n      name: callerInfo.name,\n      handler: /* @__PURE__ */ __name(async () => {\n        const pipeline = Reflect.get(context2, apiContextRoutesSymbol);\n        const callerInfoName = shouldAppendForwardSlash(\n          pipeline.manifest.trailingSlash,\n          pipeline.manifest.buildFormat\n        ) ? removeTrailingForwardSlash(callerInfo.name) : callerInfo.name;\n        const baseAction = await pipeline.getAction(callerInfoName);\n        let input2;\n        try {\n          input2 = await parseRequestBody(context2.request);\n        } catch (e) {\n          if (e instanceof TypeError) {\n            return { data: void 0, error: new ActionError({ code: \"UNSUPPORTED_MEDIA_TYPE\" }) };\n          }\n          throw e;\n        }\n        const omitKeys = [\"props\", \"getActionResult\", \"callAction\", \"redirect\"];\n        const actionAPIContext = Object.create(\n          Object.getPrototypeOf(context2),\n          Object.fromEntries(\n            Object.entries(Object.getOwnPropertyDescriptors(context2)).filter(\n              ([key]) => !omitKeys.includes(key)\n            )\n          )\n        );\n        Reflect.set(actionAPIContext, ACTION_API_CONTEXT_SYMBOL, true);\n        const handler = baseAction.bind(actionAPIContext);\n        return handler(input2);\n      }, \"handler\")\n    };\n  }\n  function setActionResult(actionName, actionResult) {\n    context2.locals._actionPayload = {\n      actionResult,\n      actionName\n    };\n  }\n  __name(setActionResult, \"setActionResult\");\n  return {\n    action,\n    setActionResult,\n    serializeActionResult,\n    deserializeActionResult\n  };\n}\nfunction getCallerInfo(ctx) {\n  if (ctx.routePattern === ACTION_RPC_ROUTE_PATTERN) {\n    return { from: \"rpc\", name: ctx.url.pathname.replace(/^.*\\/_actions\\//, \"\") };\n  }\n  const queryParam = ctx.url.searchParams.get(ACTION_QUERY_PARAMS.actionName);\n  if (queryParam) {\n    return { from: \"form\", name: queryParam };\n  }\n  return void 0;\n}\nasync function parseRequestBody(request) {\n  const contentType = request.headers.get(\"content-type\");\n  const contentLength = request.headers.get(\"Content-Length\");\n  if (!contentType) return void 0;\n  if (hasContentType(contentType, formContentTypes2)) {\n    return await request.clone().formData();\n  }\n  if (hasContentType(contentType, [\"application/json\"])) {\n    return contentLength === \"0\" ? void 0 : await request.clone().json();\n  }\n  throw new TypeError(\"Unsupported content type\");\n}\nasync function callMiddleware(onRequest2, apiContext, responseFunction) {\n  let nextCalled = false;\n  let responseFunctionPromise = void 0;\n  const next = /* @__PURE__ */ __name(async (payload) => {\n    nextCalled = true;\n    responseFunctionPromise = responseFunction(apiContext, payload);\n    return responseFunctionPromise;\n  }, \"next\");\n  let middlewarePromise = onRequest2(apiContext, next);\n  return await Promise.resolve(middlewarePromise).then(async (value2) => {\n    if (nextCalled) {\n      if (typeof value2 !== \"undefined\") {\n        if (value2 instanceof Response === false) {\n          throw new AstroError(MiddlewareNotAResponse);\n        }\n        return value2;\n      } else {\n        if (responseFunctionPromise) {\n          return responseFunctionPromise;\n        } else {\n          throw new AstroError(MiddlewareNotAResponse);\n        }\n      }\n    } else if (typeof value2 === \"undefined\") {\n      throw new AstroError(MiddlewareNoDataOrNextCalled);\n    } else if (value2 instanceof Response === false) {\n      throw new AstroError(MiddlewareNotAResponse);\n    } else {\n      return value2;\n    }\n  });\n}\nfunction validateGetStaticPathsParameter([key, value2], route) {\n  if (!VALID_PARAM_TYPES.includes(typeof value2)) {\n    throw new AstroError({\n      ...GetStaticPathsInvalidRouteParam,\n      message: GetStaticPathsInvalidRouteParam.message(key, value2, typeof value2),\n      location: {\n        file: route\n      }\n    });\n  }\n}\nfunction validateDynamicRouteModule(mod, {\n  ssr,\n  route\n}) {\n  if ((!ssr || route.prerender) && !mod.getStaticPaths) {\n    throw new AstroError({\n      ...GetStaticPathsRequired,\n      location: { file: route.component }\n    });\n  }\n}\nfunction validateGetStaticPathsResult(result, logger, route) {\n  if (!Array.isArray(result)) {\n    throw new AstroError({\n      ...InvalidGetStaticPathsReturn,\n      message: InvalidGetStaticPathsReturn.message(typeof result),\n      location: {\n        file: route.component\n      }\n    });\n  }\n  result.forEach((pathObject) => {\n    if (typeof pathObject === \"object\" && Array.isArray(pathObject) || pathObject === null) {\n      throw new AstroError({\n        ...InvalidGetStaticPathsEntry,\n        message: InvalidGetStaticPathsEntry.message(\n          Array.isArray(pathObject) ? \"array\" : typeof pathObject\n        )\n      });\n    }\n    if (pathObject.params === void 0 || pathObject.params === null || pathObject.params && Object.keys(pathObject.params).length === 0) {\n      throw new AstroError({\n        ...GetStaticPathsExpectedParams,\n        location: {\n          file: route.component\n        }\n      });\n    }\n    for (const [key, val] of Object.entries(pathObject.params)) {\n      if (!(typeof val === \"undefined\" || typeof val === \"string\" || typeof val === \"number\")) {\n        logger.warn(\n          \"router\",\n          `getStaticPaths() returned an invalid path param: \"${key}\". A string, number or undefined value was expected, but got \\`${JSON.stringify(\n            val\n          )}\\`.`\n        );\n      }\n      if (typeof val === \"string\" && val === \"\") {\n        logger.warn(\n          \"router\",\n          `getStaticPaths() returned an invalid path param: \"${key}\". \\`undefined\\` expected for an optional param, but got empty string.`\n        );\n      }\n    }\n  });\n}\nfunction stringifyParams(params, route) {\n  const validatedParams = Object.entries(params).reduce((acc, next) => {\n    validateGetStaticPathsParameter(next, route.component);\n    const [key, value2] = next;\n    if (value2 !== void 0) {\n      acc[key] = typeof value2 === \"string\" ? trimSlashes(value2) : value2.toString();\n    }\n    return acc;\n  }, {});\n  return route.generate(validatedParams);\n}\nfunction generatePaginateFunction(routeMatch, base) {\n  return /* @__PURE__ */ __name(function paginateUtility(data, args = {}) {\n    let { pageSize: _pageSize, params: _params, props: _props } = args;\n    const pageSize = _pageSize || 10;\n    const paramName = \"page\";\n    const additionalParams = _params || {};\n    const additionalProps = _props || {};\n    let includesFirstPageNumber;\n    if (routeMatch.params.includes(`...${paramName}`)) {\n      includesFirstPageNumber = false;\n    } else if (routeMatch.params.includes(`${paramName}`)) {\n      includesFirstPageNumber = true;\n    } else {\n      throw new AstroError({\n        ...PageNumberParamNotFound,\n        message: PageNumberParamNotFound.message(paramName)\n      });\n    }\n    const lastPage = Math.max(1, Math.ceil(data.length / pageSize));\n    const result = [...Array(lastPage).keys()].map((num) => {\n      const pageNum = num + 1;\n      const start = pageSize === Infinity ? 0 : (pageNum - 1) * pageSize;\n      const end = Math.min(start + pageSize, data.length);\n      const params = {\n        ...additionalParams,\n        [paramName]: includesFirstPageNumber || pageNum > 1 ? String(pageNum) : void 0\n      };\n      const current = addRouteBase(routeMatch.generate({ ...params }), base);\n      const next = pageNum === lastPage ? void 0 : addRouteBase(routeMatch.generate({ ...params, page: String(pageNum + 1) }), base);\n      const prev = pageNum === 1 ? void 0 : addRouteBase(\n        routeMatch.generate({\n          ...params,\n          page: !includesFirstPageNumber && pageNum - 1 === 1 ? void 0 : String(pageNum - 1)\n        }),\n        base\n      );\n      const first = pageNum === 1 ? void 0 : addRouteBase(\n        routeMatch.generate({\n          ...params,\n          page: includesFirstPageNumber ? \"1\" : void 0\n        }),\n        base\n      );\n      const last2 = pageNum === lastPage ? void 0 : addRouteBase(routeMatch.generate({ ...params, page: String(lastPage) }), base);\n      return {\n        params,\n        props: {\n          ...additionalProps,\n          page: {\n            data: data.slice(start, end),\n            start,\n            end: end - 1,\n            size: pageSize,\n            total: data.length,\n            currentPage: pageNum,\n            lastPage,\n            url: { current, next, prev, first, last: last2 }\n          }\n        }\n      };\n    });\n    return result;\n  }, \"paginateUtility\");\n}\nfunction addRouteBase(route, base) {\n  let routeWithBase = joinPaths(base, route);\n  if (routeWithBase === \"\") routeWithBase = \"/\";\n  return routeWithBase;\n}\nasync function callGetStaticPaths({\n  mod,\n  route,\n  routeCache,\n  logger,\n  ssr,\n  base\n}) {\n  const cached = routeCache.get(route);\n  if (!mod) {\n    throw new Error(\"This is an error caused by Astro and not your code. Please file an issue.\");\n  }\n  if (cached?.staticPaths) {\n    return cached.staticPaths;\n  }\n  validateDynamicRouteModule(mod, { ssr, route });\n  if (ssr && !route.prerender) {\n    const entry = Object.assign([], { keyed: /* @__PURE__ */ new Map() });\n    routeCache.set(route, { ...cached, staticPaths: entry });\n    return entry;\n  }\n  let staticPaths = [];\n  if (!mod.getStaticPaths) {\n    throw new Error(\"Unexpected Error.\");\n  }\n  staticPaths = await mod.getStaticPaths({\n    // Q: Why the cast?\n    // A: So users downstream can have nicer typings, we have to make some sacrifice in our internal typings, which necessitate a cast here\n    paginate: generatePaginateFunction(route, base)\n  });\n  validateGetStaticPathsResult(staticPaths, logger, route);\n  const keyedStaticPaths = staticPaths;\n  keyedStaticPaths.keyed = /* @__PURE__ */ new Map();\n  for (const sp of keyedStaticPaths) {\n    const paramsKey = stringifyParams(sp.params, route);\n    keyedStaticPaths.keyed.set(paramsKey, sp);\n  }\n  routeCache.set(route, { ...cached, staticPaths: keyedStaticPaths });\n  return keyedStaticPaths;\n}\nfunction findPathItemByKey(staticPaths, params, route, logger) {\n  const paramsKey = stringifyParams(params, route);\n  const matchedStaticPath = staticPaths.keyed.get(paramsKey);\n  if (matchedStaticPath) {\n    return matchedStaticPath;\n  }\n  logger.debug(\"router\", `findPathItemByKey() - Unexpected cache miss looking for ${paramsKey}`);\n}\nfunction routeIsRedirect(route) {\n  return route?.type === \"redirect\";\n}\nfunction routeIsFallback(route) {\n  return route?.type === \"fallback\";\n}\nasync function getProps(opts) {\n  const { logger, mod, routeData: route, routeCache, pathname, serverLike, base } = opts;\n  if (!route || route.pathname) {\n    return {};\n  }\n  if (routeIsRedirect(route) || routeIsFallback(route) || route.component === DEFAULT_404_COMPONENT) {\n    return {};\n  }\n  const staticPaths = await callGetStaticPaths({\n    mod,\n    route,\n    routeCache,\n    logger,\n    ssr: serverLike,\n    base\n  });\n  const params = getParams(route, pathname);\n  const matchedStaticPath = findPathItemByKey(staticPaths, params, route, logger);\n  if (!matchedStaticPath && (serverLike ? route.prerender : true)) {\n    throw new AstroError({\n      ...NoMatchingStaticPathFound,\n      message: NoMatchingStaticPathFound.message(pathname),\n      hint: NoMatchingStaticPathFound.hint([route.component])\n    });\n  }\n  if (mod) {\n    validatePrerenderEndpointCollision(route, mod, params);\n  }\n  const props = matchedStaticPath?.props ? { ...matchedStaticPath.props } : {};\n  return props;\n}\nfunction getParams(route, pathname) {\n  if (!route.params.length) return {};\n  const paramsMatch = route.pattern.exec(pathname) || route.fallbackRoutes.map((fallbackRoute) => fallbackRoute.pattern.exec(pathname)).find((x) => x);\n  if (!paramsMatch) return {};\n  const params = {};\n  route.params.forEach((key, i) => {\n    if (key.startsWith(\"...\")) {\n      params[key.slice(3)] = paramsMatch[i + 1] ? paramsMatch[i + 1] : void 0;\n    } else {\n      params[key] = paramsMatch[i + 1];\n    }\n  });\n  return params;\n}\nfunction validatePrerenderEndpointCollision(route, mod, params) {\n  if (route.type === \"endpoint\" && mod.getStaticPaths) {\n    const lastSegment = route.segments[route.segments.length - 1];\n    const paramValues = Object.values(params);\n    const lastParam = paramValues[paramValues.length - 1];\n    if (lastSegment.length === 1 && lastSegment[0].dynamic && lastParam === void 0) {\n      throw new AstroError({\n        ...PrerenderDynamicEndpointPathCollide,\n        message: PrerenderDynamicEndpointPathCollide.message(route.route),\n        hint: PrerenderDynamicEndpointPathCollide.hint(route.component),\n        location: {\n          file: route.component\n        }\n      });\n    }\n  }\n}\nfunction getFunctionExpression(slot) {\n  if (!slot) return;\n  const expressions = slot?.expressions?.filter((e) => isRenderInstruction(e) === false);\n  if (expressions?.length !== 1) return;\n  return expressions[0];\n}\nfunction jsonParseTransform(key, value2) {\n  if (key === \"__proto__\" || key === \"constructor\" && value2 && typeof value2 === \"object\" && \"prototype\" in value2) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value2;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value2, options = {}) {\n  if (typeof value2 !== \"string\") {\n    return value2;\n  }\n  if (value2[0] === '\"' && value2[value2.length - 1] === '\"' && value2.indexOf(\"\\\\\") === -1) {\n    return value2.slice(1, -1);\n  }\n  const _value = value2.trim();\n  if (_value.length <= 9) {\n    switch (_value.toLowerCase()) {\n      case \"true\": {\n        return true;\n      }\n      case \"false\": {\n        return false;\n      }\n      case \"undefined\": {\n        return void 0;\n      }\n      case \"null\": {\n        return null;\n      }\n      case \"nan\": {\n        return Number.NaN;\n      }\n      case \"infinity\": {\n        return Number.POSITIVE_INFINITY;\n      }\n      case \"-infinity\": {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n  }\n  if (!JsonSigRx.test(value2)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value2;\n  }\n  try {\n    if (suspectProtoRx.test(value2) || suspectConstructorRx.test(value2)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value2, jsonParseTransform);\n    }\n    return JSON.parse(value2);\n  } catch (error4) {\n    if (options.strict) {\n      throw error4;\n    }\n    return value2;\n  }\n}\nfunction wrapToPromise(value2) {\n  if (!value2 || typeof value2.then !== \"function\") {\n    return Promise.resolve(value2);\n  }\n  return value2;\n}\nfunction asyncCall(function_, ...arguments_) {\n  try {\n    return wrapToPromise(function_(...arguments_));\n  } catch (error4) {\n    return Promise.reject(error4);\n  }\n}\nfunction isPrimitive(value2) {\n  const type2 = typeof value2;\n  return value2 === null || type2 !== \"object\" && type2 !== \"function\";\n}\nfunction isPureObject(value2) {\n  const proto = Object.getPrototypeOf(value2);\n  return !proto || proto.isPrototypeOf(Object);\n}\nfunction stringify$1(value2) {\n  if (isPrimitive(value2)) {\n    return String(value2);\n  }\n  if (isPureObject(value2) || Array.isArray(value2)) {\n    return JSON.stringify(value2);\n  }\n  if (typeof value2.toJSON === \"function\") {\n    return stringify$1(value2.toJSON());\n  }\n  throw new Error(\"[unstorage] Cannot stringify value!\");\n}\nfunction serializeRaw(value2) {\n  if (typeof value2 === \"string\") {\n    return value2;\n  }\n  return BASE64_PREFIX + base64Encode(value2);\n}\nfunction deserializeRaw(value2) {\n  if (typeof value2 !== \"string\") {\n    return value2;\n  }\n  if (!value2.startsWith(BASE64_PREFIX)) {\n    return value2;\n  }\n  return base64Decode(value2.slice(BASE64_PREFIX.length));\n}\nfunction base64Decode(input2) {\n  if (globalThis.Buffer) {\n    return Buffer.from(input2, \"base64\");\n  }\n  return Uint8Array.from(\n    globalThis.atob(input2),\n    (c) => c.codePointAt(0)\n  );\n}\nfunction base64Encode(input2) {\n  if (globalThis.Buffer) {\n    return Buffer.from(input2).toString(\"base64\");\n  }\n  return globalThis.btoa(String.fromCodePoint(...input2));\n}\nfunction normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.split(\"?\")[0]?.replace(/[/\\\\]/g, \":\").replace(/:+/g, \":\").replace(/^:|:$/g, \"\") || \"\";\n}\nfunction joinKeys(...keys2) {\n  return normalizeKey(keys2.join(\":\"));\n}\nfunction normalizeBaseKey(base) {\n  base = normalizeKey(base);\n  return base ? base + \":\" : \"\";\n}\nfunction filterKeyByDepth(key, depth) {\n  if (depth === void 0) {\n    return true;\n  }\n  let substrCount = 0;\n  let index = key.indexOf(\":\");\n  while (index > -1) {\n    substrCount++;\n    index = key.indexOf(\":\", index + 1);\n  }\n  return substrCount <= depth;\n}\nfunction filterKeyByBase(key, base) {\n  if (base) {\n    return key.startsWith(base) && key[key.length - 1] !== \"$\";\n  }\n  return key[key.length - 1] !== \"$\";\n}\nfunction defineDriver(factory) {\n  return factory;\n}\nfunction createStorage(options = {}) {\n  const context2 = {\n    mounts: { \"\": options.driver || memory() },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = /* @__PURE__ */ __name((key) => {\n    for (const base of context2.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context2.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context2.mounts[\"\"]\n    };\n  }, \"getMount\");\n  const getMounts = /* @__PURE__ */ __name((base, includeParent) => {\n    return context2.mountpoints.filter(\n      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)\n    ).map((mountpoint) => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context2.mounts[mountpoint]\n    }));\n  }, \"getMounts\");\n  const onChange = /* @__PURE__ */ __name((event, key) => {\n    if (!context2.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context2.watchListeners) {\n      listener(event, key);\n    }\n  }, \"onChange\");\n  const startWatch = /* @__PURE__ */ __name(async () => {\n    if (context2.watching) {\n      return;\n    }\n    context2.watching = true;\n    for (const mountpoint in context2.mounts) {\n      context2.unwatch[mountpoint] = await watch(\n        context2.mounts[mountpoint],\n        onChange,\n        mountpoint\n      );\n    }\n  }, \"startWatch\");\n  const stopWatch = /* @__PURE__ */ __name(async () => {\n    if (!context2.watching) {\n      return;\n    }\n    for (const mountpoint in context2.unwatch) {\n      await context2.unwatch[mountpoint]();\n    }\n    context2.unwatch = {};\n    context2.watching = false;\n  }, \"stopWatch\");\n  const runBatch = /* @__PURE__ */ __name((items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */ new Map();\n    const getBatch = /* @__PURE__ */ __name((mount) => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    }, \"getBatch\");\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value2 = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value: value2,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(\n      (r2) => r2.flat()\n    );\n  }, \"runBatch\");\n  const storage = {\n    // Item\n    hasItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value2) => destr(value2)\n      );\n    },\n    getItems(items, commonOptions = {}) {\n      return runBatch(items, commonOptions, (batch) => {\n        if (batch.driver.getItems) {\n          return asyncCall(\n            batch.driver.getItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              options: item.options\n            })),\n            commonOptions\n          ).then(\n            (r2) => r2.map((item) => ({\n              key: joinKeys(batch.base, item.key),\n              value: destr(item.value)\n            }))\n          );\n        }\n        return Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.getItem,\n              item.relativeKey,\n              item.options\n            ).then((value2) => ({\n              key: item.key,\n              value: destr(value2)\n            }));\n          })\n        );\n      });\n    },\n    getItemRaw(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value2) => deserializeRaw(value2)\n      );\n    },\n    async setItem(key, value2, opts = {}) {\n      if (value2 === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify$1(value2), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async (batch) => {\n        if (batch.driver.setItems) {\n          return asyncCall(\n            batch.driver.setItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              value: stringify$1(item.value),\n              options: item.options\n            })),\n            commonOptions\n          );\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.setItem,\n              item.relativeKey,\n              stringify$1(item.value),\n              item.options\n            );\n          })\n        );\n      });\n    },\n    async setItemRaw(key, value2, opts = {}) {\n      if (value2 === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value2, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value2), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { removeMeta: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { nativeOnly: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      const meta2 = /* @__PURE__ */ Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta2, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value2 = await asyncCall(\n          driver.getItem,\n          relativeKey + \"$\",\n          opts\n        ).then((value_) => destr(value_));\n        if (value2 && typeof value2 === \"object\") {\n          if (typeof value2.atime === \"string\") {\n            value2.atime = new Date(value2.atime);\n          }\n          if (typeof value2.mtime === \"string\") {\n            value2.mtime = new Date(value2.mtime);\n          }\n          Object.assign(meta2, value2);\n        }\n      }\n      return meta2;\n    },\n    setMeta(key, value2, opts = {}) {\n      return this.setItem(key + \"$\", value2, opts);\n    },\n    removeMeta(key, opts = {}) {\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      let allMountsSupportMaxDepth = true;\n      for (const mount of mounts) {\n        if (!mount.driver.flags?.maxDepth) {\n          allMountsSupportMaxDepth = false;\n        }\n        const rawKeys = await asyncCall(\n          mount.driver.getKeys,\n          mount.relativeBase,\n          opts\n        );\n        for (const key of rawKeys) {\n          const fullKey = mount.mountpoint + normalizeKey(key);\n          if (!maskedMounts.some((p2) => fullKey.startsWith(p2))) {\n            allKeys.push(fullKey);\n          }\n        }\n        maskedMounts = [\n          mount.mountpoint,\n          ...maskedMounts.filter((p2) => !p2.startsWith(mount.mountpoint))\n        ];\n      }\n      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;\n      return allKeys.filter(\n        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)\n      );\n    },\n    // Utils\n    async clear(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      await Promise.all(\n        getMounts(base, false).map(async (m2) => {\n          if (m2.driver.clear) {\n            return asyncCall(m2.driver.clear, m2.relativeBase, opts);\n          }\n          if (m2.driver.removeItem) {\n            const keys2 = await m2.driver.getKeys(m2.relativeBase || \"\", opts);\n            return Promise.all(\n              keys2.map((key) => m2.driver.removeItem(key, opts))\n            );\n          }\n        })\n      );\n    },\n    async dispose() {\n      await Promise.all(\n        Object.values(context2.mounts).map((driver) => dispose(driver))\n      );\n    },\n    async watch(callback) {\n      await startWatch();\n      context2.watchListeners.push(callback);\n      return async () => {\n        context2.watchListeners = context2.watchListeners.filter(\n          (listener) => listener !== callback\n        );\n        if (context2.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context2.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context2.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context2.mountpoints.push(base);\n        context2.mountpoints.sort((a2, b3) => b3.length - a2.length);\n      }\n      context2.mounts[base] = driver;\n      if (context2.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {\n          context2.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base, _dispose = true) {\n      base = normalizeBaseKey(base);\n      if (!base || !context2.mounts[base]) {\n        return;\n      }\n      if (context2.watching && base in context2.unwatch) {\n        context2.unwatch[base]?.();\n        delete context2.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context2.mounts[base]);\n      }\n      context2.mountpoints = context2.mountpoints.filter((key) => key !== base);\n      delete context2.mounts[base];\n    },\n    getMount(key = \"\") {\n      key = normalizeKey(key) + \":\";\n      const m2 = getMount(key);\n      return {\n        driver: m2.driver,\n        base: m2.base\n      };\n    },\n    getMounts(base = \"\", opts = {}) {\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map((m2) => ({\n        driver: m2.driver,\n        base: m2.mountpoint\n      }));\n    },\n    // Aliases\n    keys: /* @__PURE__ */ __name((base, opts = {}) => storage.getKeys(base, opts), \"keys\"),\n    get: /* @__PURE__ */ __name((key, opts = {}) => storage.getItem(key, opts), \"get\"),\n    set: /* @__PURE__ */ __name((key, value2, opts = {}) => storage.setItem(key, value2, opts), \"set\"),\n    has: /* @__PURE__ */ __name((key, opts = {}) => storage.hasItem(key, opts), \"has\"),\n    del: /* @__PURE__ */ __name((key, opts = {}) => storage.removeItem(key, opts), \"del\"),\n    remove: /* @__PURE__ */ __name((key, opts = {}) => storage.removeItem(key, opts), \"remove\")\n  };\n  return storage;\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {\n  };\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\nfunction resolveSessionDriverName(driver) {\n  if (!driver) {\n    return null;\n  }\n  try {\n    if (driver === \"fs\") {\n      return builtinDrivers.fsLite;\n    }\n    if (driver in builtinDrivers) {\n      return builtinDrivers[driver];\n    }\n  } catch {\n    return null;\n  }\n  return driver;\n}\nfunction sequence(...handlers) {\n  const filtered = handlers.filter((h3) => !!h3);\n  const length = filtered.length;\n  if (!length) {\n    return defineMiddleware((_context, next) => {\n      return next();\n    });\n  }\n  return defineMiddleware((context2, next) => {\n    let carriedPayload = void 0;\n    return applyHandle(0, context2);\n    function applyHandle(i, handleContext) {\n      const handle = filtered[i];\n      const result = handle(handleContext, async (payload) => {\n        if (i < length - 1) {\n          if (payload) {\n            let newRequest;\n            if (payload instanceof Request) {\n              newRequest = payload;\n            } else if (payload instanceof URL) {\n              newRequest = new Request(payload, handleContext.request);\n            } else {\n              newRequest = new Request(\n                new URL(payload, handleContext.url.origin),\n                handleContext.request\n              );\n            }\n            const oldPathname = handleContext.url.pathname;\n            const pipeline = Reflect.get(handleContext, apiContextRoutesSymbol);\n            const { routeData, pathname } = await pipeline.tryRewrite(\n              payload,\n              handleContext.request\n            );\n            if (pipeline.serverLike === true && handleContext.isPrerendered === false && routeData.prerender === true) {\n              throw new AstroError({\n                ...ForbiddenRewrite,\n                message: ForbiddenRewrite.message(\n                  handleContext.url.pathname,\n                  pathname,\n                  routeData.component\n                ),\n                hint: ForbiddenRewrite.hint(routeData.component)\n              });\n            }\n            carriedPayload = payload;\n            handleContext.request = newRequest;\n            handleContext.url = new URL(newRequest.url);\n            handleContext.cookies = new AstroCookies(newRequest);\n            handleContext.params = getParams(routeData, pathname);\n            setOriginPathname(handleContext.request, oldPathname);\n          }\n          return applyHandle(i + 1, handleContext);\n        } else {\n          return next(payload ?? carriedPayload);\n        }\n      });\n      return result;\n    }\n    __name(applyHandle, \"applyHandle\");\n  });\n}\nfunction defineMiddleware(fn2) {\n  return fn2;\n}\nvar ACTION_API_CONTEXT_SYMBOL, formContentTypes2, MANY_TRAILING_SLASHES, WITH_FILE_EXT, SERVER_ISLAND_ROUTE, SERVER_ISLAND_COMPONENT, SERVER_ISLAND_BASE_PREFIX, ROUTE404_RE, ROUTE500_RE, DELETED_EXPIRATION, DELETED_VALUE, responseSentSymbol2, identity, AstroCookie, AstroCookies, astroCookiesSymbol, VALID_PARAM_TYPES, RouteCache, Slots, suspectProtoRx, suspectConstructorRx, JsonSigRx, BASE64_PREFIX, DRIVER_NAME, memory, builtinDrivers, PERSIST_SYMBOL, DEFAULT_COOKIE_NAME, VALID_COOKIE_REGEX, unflatten2, stringify2, AstroSession, apiContextRoutesSymbol, RenderContext;\nvar init_index_Bos_IFPf = __esm({\n  \"dist/_worker.js/chunks/index_Bos_IFPf.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_astro_designed_error_pages_DuwJl2PN();\n    init_server_C8vVOH8G();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    ACTION_API_CONTEXT_SYMBOL = Symbol.for(\"astro.actionAPIContext\");\n    formContentTypes2 = [\"application/x-www-form-urlencoded\", \"multipart/form-data\"];\n    __name(hasContentType, \"hasContentType\");\n    __name(appendForwardSlash, \"appendForwardSlash\");\n    __name(prependForwardSlash, \"prependForwardSlash\");\n    MANY_TRAILING_SLASHES = /\\/{2,}$/g;\n    __name(collapseDuplicateTrailingSlashes, \"collapseDuplicateTrailingSlashes\");\n    __name(removeTrailingForwardSlash, \"removeTrailingForwardSlash\");\n    __name(removeLeadingForwardSlash, \"removeLeadingForwardSlash\");\n    __name(trimSlashes, \"trimSlashes\");\n    __name(isString, \"isString\");\n    __name(joinPaths, \"joinPaths\");\n    __name(slash, \"slash\");\n    __name(fileExtension, \"fileExtension\");\n    WITH_FILE_EXT = /\\/[^/]+\\.\\w+$/;\n    __name(hasFileExtension, \"hasFileExtension\");\n    __name(hasActionPayload, \"hasActionPayload\");\n    __name(createGetActionResult, \"createGetActionResult\");\n    __name(createCallAction, \"createCallAction\");\n    __name(shouldAppendForwardSlash, \"shouldAppendForwardSlash\");\n    __name(redirectIsExternal, \"redirectIsExternal\");\n    __name(renderRedirect, \"renderRedirect\");\n    __name(redirectRouteGenerate, \"redirectRouteGenerate\");\n    SERVER_ISLAND_ROUTE = \"/_server-islands/[name]\";\n    SERVER_ISLAND_COMPONENT = \"_server-islands.astro\";\n    SERVER_ISLAND_BASE_PREFIX = \"_server-islands\";\n    __name(badRequest, \"badRequest\");\n    __name(getRequestData, \"getRequestData\");\n    __name(createEndpoint, \"createEndpoint\");\n    __name(matchRoute, \"matchRoute\");\n    ROUTE404_RE = /^\\/404\\/?$/;\n    ROUTE500_RE = /^\\/500\\/?$/;\n    __name(isRoute404, \"isRoute404\");\n    __name(isRoute500, \"isRoute500\");\n    __name(isRoute404or500, \"isRoute404or500\");\n    __name(isRouteServerIsland, \"isRouteServerIsland\");\n    __name(isRequestServerIsland, \"isRequestServerIsland\");\n    __name(requestIs404Or500, \"requestIs404Or500\");\n    __name(isRouteExternalRedirect, \"isRouteExternalRedirect\");\n    __name(requestHasLocale, \"requestHasLocale\");\n    __name(pathHasLocale, \"pathHasLocale\");\n    __name(getPathByLocale, \"getPathByLocale\");\n    __name(normalizeTheLocale, \"normalizeTheLocale\");\n    __name(getAllCodes, \"getAllCodes\");\n    __name(redirectToDefaultLocale, \"redirectToDefaultLocale\");\n    __name(notFound, \"notFound\");\n    __name(redirectToFallback, \"redirectToFallback\");\n    __name(parseLocale, \"parseLocale\");\n    __name(sortAndFilterLocales, \"sortAndFilterLocales\");\n    __name(computePreferredLocale, \"computePreferredLocale\");\n    __name(computePreferredLocaleList, \"computePreferredLocaleList\");\n    __name(computeCurrentLocale, \"computeCurrentLocale\");\n    DELETED_EXPIRATION = /* @__PURE__ */ new Date(0);\n    DELETED_VALUE = \"deleted\";\n    responseSentSymbol2 = Symbol.for(\"astro.responseSent\");\n    identity = /* @__PURE__ */ __name((value2) => value2, \"identity\");\n    AstroCookie = class {\n      static {\n        __name(this, \"AstroCookie\");\n      }\n      constructor(value2) {\n        this.value = value2;\n      }\n      json() {\n        if (this.value === void 0) {\n          throw new Error(`Cannot convert undefined to an object.`);\n        }\n        return JSON.parse(this.value);\n      }\n      number() {\n        return Number(this.value);\n      }\n      boolean() {\n        if (this.value === \"false\") return false;\n        if (this.value === \"0\") return false;\n        return Boolean(this.value);\n      }\n    };\n    AstroCookies = class {\n      static {\n        __name(this, \"AstroCookies\");\n      }\n      #request;\n      #requestValues;\n      #outgoing;\n      #consumed;\n      constructor(request) {\n        this.#request = request;\n        this.#requestValues = null;\n        this.#outgoing = null;\n        this.#consumed = false;\n      }\n      /**\n       * Astro.cookies.delete(key) is used to delete a cookie. Using this method will result\n       * in a Set-Cookie header added to the response.\n       * @param key The cookie to delete\n       * @param options Options related to this deletion, such as the path of the cookie.\n       */\n      delete(key, options) {\n        const {\n          // @ts-expect-error\n          maxAge: _ignoredMaxAge,\n          // @ts-expect-error\n          expires: _ignoredExpires,\n          ...sanitizedOptions\n        } = options || {};\n        const serializeOptions = {\n          expires: DELETED_EXPIRATION,\n          ...sanitizedOptions\n        };\n        this.#ensureOutgoingMap().set(key, [\n          DELETED_VALUE,\n          distExports.serialize(key, DELETED_VALUE, serializeOptions),\n          false\n        ]);\n      }\n      /**\n       * Astro.cookies.get(key) is used to get a cookie value. The cookie value is read from the\n       * request. If you have set a cookie via Astro.cookies.set(key, value), the value will be taken\n       * from that set call, overriding any values already part of the request.\n       * @param key The cookie to get.\n       * @returns An object containing the cookie value as well as convenience methods for converting its value.\n       */\n      get(key, options = void 0) {\n        if (this.#outgoing?.has(key)) {\n          let [serializedValue, , isSetValue] = this.#outgoing.get(key);\n          if (isSetValue) {\n            return new AstroCookie(serializedValue);\n          } else {\n            return void 0;\n          }\n        }\n        const decode2 = options?.decode ?? decodeURIComponent;\n        const values = this.#ensureParsed();\n        if (key in values) {\n          const value2 = values[key];\n          if (value2) {\n            return new AstroCookie(decode2(value2));\n          }\n        }\n      }\n      /**\n       * Astro.cookies.has(key) returns a boolean indicating whether this cookie is either\n       * part of the initial request or set via Astro.cookies.set(key)\n       * @param key The cookie to check for.\n       * @param _options This parameter is no longer used.\n       * @returns\n       */\n      has(key, _options) {\n        if (this.#outgoing?.has(key)) {\n          let [, , isSetValue] = this.#outgoing.get(key);\n          return isSetValue;\n        }\n        const values = this.#ensureParsed();\n        return values[key] !== void 0;\n      }\n      /**\n       * Astro.cookies.set(key, value) is used to set a cookie's value. If provided\n       * an object it will be stringified via JSON.stringify(value). Additionally you\n       * can provide options customizing how this cookie will be set, such as setting httpOnly\n       * in order to prevent the cookie from being read in client-side JavaScript.\n       * @param key The name of the cookie to set.\n       * @param value A value, either a string or other primitive or an object.\n       * @param options Options for the cookie, such as the path and security settings.\n       */\n      set(key, value2, options) {\n        if (this.#consumed) {\n          const warning = new Error(\n            \"Astro.cookies.set() was called after the cookies had already been sent to the browser.\\nThis may have happened if this method was called in an imported component.\\nPlease make sure that Astro.cookies.set() is only called in the frontmatter of the main page.\"\n          );\n          warning.name = \"Warning\";\n          console.warn(warning);\n        }\n        let serializedValue;\n        if (typeof value2 === \"string\") {\n          serializedValue = value2;\n        } else {\n          let toStringValue = value2.toString();\n          if (toStringValue === Object.prototype.toString.call(value2)) {\n            serializedValue = JSON.stringify(value2);\n          } else {\n            serializedValue = toStringValue;\n          }\n        }\n        const serializeOptions = {};\n        if (options) {\n          Object.assign(serializeOptions, options);\n        }\n        this.#ensureOutgoingMap().set(key, [\n          serializedValue,\n          distExports.serialize(key, serializedValue, serializeOptions),\n          true\n        ]);\n        if (this.#request[responseSentSymbol2]) {\n          throw new AstroError({\n            ...ResponseSentError\n          });\n        }\n      }\n      /**\n       * Merges a new AstroCookies instance into the current instance. Any new cookies\n       * will be added to the current instance, overwriting any existing cookies with the same name.\n       */\n      merge(cookies) {\n        const outgoing = cookies.#outgoing;\n        if (outgoing) {\n          for (const [key, value2] of outgoing) {\n            this.#ensureOutgoingMap().set(key, value2);\n          }\n        }\n      }\n      /**\n       * Astro.cookies.header() returns an iterator for the cookies that have previously\n       * been set by either Astro.cookies.set() or Astro.cookies.delete().\n       * This method is primarily used by adapters to set the header on outgoing responses.\n       * @returns\n       */\n      *headers() {\n        if (this.#outgoing == null) return;\n        for (const [, value2] of this.#outgoing) {\n          yield value2[1];\n        }\n      }\n      /**\n       * Behaves the same as AstroCookies.prototype.headers(),\n       * but allows a warning when cookies are set after the instance is consumed.\n       */\n      static consume(cookies) {\n        cookies.#consumed = true;\n        return cookies.headers();\n      }\n      #ensureParsed() {\n        if (!this.#requestValues) {\n          this.#parse();\n        }\n        if (!this.#requestValues) {\n          this.#requestValues = {};\n        }\n        return this.#requestValues;\n      }\n      #ensureOutgoingMap() {\n        if (!this.#outgoing) {\n          this.#outgoing = /* @__PURE__ */ new Map();\n        }\n        return this.#outgoing;\n      }\n      #parse() {\n        const raw2 = this.#request.headers.get(\"cookie\");\n        if (!raw2) {\n          return;\n        }\n        this.#requestValues = distExports.parse(raw2, { decode: identity });\n      }\n    };\n    astroCookiesSymbol = Symbol.for(\"astro.cookies\");\n    __name(attachCookiesToResponse, \"attachCookiesToResponse\");\n    __name(getCookiesFromResponse, \"getCookiesFromResponse\");\n    __name(getSetCookiesFromResponse, \"getSetCookiesFromResponse\");\n    __name(createRequest, \"createRequest\");\n    __name(findRouteToRewrite, \"findRouteToRewrite\");\n    __name(copyRequest, \"copyRequest\");\n    __name(setOriginPathname, \"setOriginPathname\");\n    __name(getOriginPathname, \"getOriginPathname\");\n    __name(getActionContext, \"getActionContext\");\n    __name(getCallerInfo, \"getCallerInfo\");\n    __name(parseRequestBody, \"parseRequestBody\");\n    __name(callMiddleware, \"callMiddleware\");\n    VALID_PARAM_TYPES = [\"string\", \"number\", \"undefined\"];\n    __name(validateGetStaticPathsParameter, \"validateGetStaticPathsParameter\");\n    __name(validateDynamicRouteModule, \"validateDynamicRouteModule\");\n    __name(validateGetStaticPathsResult, \"validateGetStaticPathsResult\");\n    __name(stringifyParams, \"stringifyParams\");\n    __name(generatePaginateFunction, \"generatePaginateFunction\");\n    __name(addRouteBase, \"addRouteBase\");\n    __name(callGetStaticPaths, \"callGetStaticPaths\");\n    RouteCache = class {\n      static {\n        __name(this, \"RouteCache\");\n      }\n      logger;\n      cache = {};\n      runtimeMode;\n      constructor(logger, runtimeMode = \"production\") {\n        this.logger = logger;\n        this.runtimeMode = runtimeMode;\n      }\n      /** Clear the cache. */\n      clearAll() {\n        this.cache = {};\n      }\n      set(route, entry) {\n        const key = this.key(route);\n        if (this.runtimeMode === \"production\" && this.cache[key]?.staticPaths) {\n          this.logger.warn(null, `Internal Warning: route cache overwritten. (${key})`);\n        }\n        this.cache[key] = entry;\n      }\n      get(route) {\n        return this.cache[this.key(route)];\n      }\n      key(route) {\n        return `${route.route}_${route.component}`;\n      }\n    };\n    __name(findPathItemByKey, \"findPathItemByKey\");\n    __name(routeIsRedirect, \"routeIsRedirect\");\n    __name(routeIsFallback, \"routeIsFallback\");\n    __name(getProps, \"getProps\");\n    __name(getParams, \"getParams\");\n    __name(validatePrerenderEndpointCollision, \"validatePrerenderEndpointCollision\");\n    __name(getFunctionExpression, \"getFunctionExpression\");\n    Slots = class {\n      static {\n        __name(this, \"Slots\");\n      }\n      #result;\n      #slots;\n      #logger;\n      constructor(result, slots, logger) {\n        this.#result = result;\n        this.#slots = slots;\n        this.#logger = logger;\n        if (slots) {\n          for (const key of Object.keys(slots)) {\n            if (this[key] !== void 0) {\n              throw new AstroError({\n                ...ReservedSlotName,\n                message: ReservedSlotName.message(key)\n              });\n            }\n            Object.defineProperty(this, key, {\n              get() {\n                return true;\n              },\n              enumerable: true\n            });\n          }\n        }\n      }\n      has(name) {\n        if (!this.#slots) return false;\n        return Boolean(this.#slots[name]);\n      }\n      async render(name, args = []) {\n        if (!this.#slots || !this.has(name)) return;\n        const result = this.#result;\n        if (!Array.isArray(args)) {\n          this.#logger.warn(\n            null,\n            `Expected second parameter to be an array, received a ${typeof args}. If you're trying to pass an array as a single argument and getting unexpected results, make sure you're passing your array as a item of an array. Ex: Astro.slots.render('default', [[\"Hello\", \"World\"]])`\n          );\n        } else if (args.length > 0) {\n          const slotValue = this.#slots[name];\n          const component = typeof slotValue === \"function\" ? await slotValue(result) : await slotValue;\n          const expression = getFunctionExpression(component);\n          if (expression) {\n            const slot = /* @__PURE__ */ __name(async () => typeof expression === \"function\" ? expression(...args) : expression, \"slot\");\n            return await renderSlotToString(result, slot).then((res) => {\n              return res;\n            });\n          }\n          if (typeof component === \"function\") {\n            return await renderJSX(result, component(...args)).then(\n              (res) => res != null ? String(res) : res\n            );\n          }\n        }\n        const content = await renderSlotToString(result, this.#slots[name]);\n        const outHTML = chunkToString(result, content);\n        return outHTML;\n      }\n    };\n    suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\n    suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\n    JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\n    __name(jsonParseTransform, \"jsonParseTransform\");\n    __name(warnKeyDropped, \"warnKeyDropped\");\n    __name(destr, \"destr\");\n    __name(wrapToPromise, \"wrapToPromise\");\n    __name(asyncCall, \"asyncCall\");\n    __name(isPrimitive, \"isPrimitive\");\n    __name(isPureObject, \"isPureObject\");\n    __name(stringify$1, \"stringify$1\");\n    BASE64_PREFIX = \"base64:\";\n    __name(serializeRaw, \"serializeRaw\");\n    __name(deserializeRaw, \"deserializeRaw\");\n    __name(base64Decode, \"base64Decode\");\n    __name(base64Encode, \"base64Encode\");\n    __name(normalizeKey, \"normalizeKey\");\n    __name(joinKeys, \"joinKeys\");\n    __name(normalizeBaseKey, \"normalizeBaseKey\");\n    __name(filterKeyByDepth, \"filterKeyByDepth\");\n    __name(filterKeyByBase, \"filterKeyByBase\");\n    __name(defineDriver, \"defineDriver\");\n    DRIVER_NAME = \"memory\";\n    memory = defineDriver(() => {\n      const data = /* @__PURE__ */ new Map();\n      return {\n        name: DRIVER_NAME,\n        getInstance: /* @__PURE__ */ __name(() => data, \"getInstance\"),\n        hasItem(key) {\n          return data.has(key);\n        },\n        getItem(key) {\n          return data.get(key) ?? null;\n        },\n        getItemRaw(key) {\n          return data.get(key) ?? null;\n        },\n        setItem(key, value2) {\n          data.set(key, value2);\n        },\n        setItemRaw(key, value2) {\n          data.set(key, value2);\n        },\n        removeItem(key) {\n          data.delete(key);\n        },\n        getKeys() {\n          return [...data.keys()];\n        },\n        clear() {\n          data.clear();\n        },\n        dispose() {\n          data.clear();\n        }\n      };\n    });\n    __name(createStorage, \"createStorage\");\n    __name(watch, \"watch\");\n    __name(dispose, \"dispose\");\n    builtinDrivers = {\n      \"azure-app-configuration\": \"unstorage/drivers/azure-app-configuration\",\n      \"azureAppConfiguration\": \"unstorage/drivers/azure-app-configuration\",\n      \"azure-cosmos\": \"unstorage/drivers/azure-cosmos\",\n      \"azureCosmos\": \"unstorage/drivers/azure-cosmos\",\n      \"azure-key-vault\": \"unstorage/drivers/azure-key-vault\",\n      \"azureKeyVault\": \"unstorage/drivers/azure-key-vault\",\n      \"azure-storage-blob\": \"unstorage/drivers/azure-storage-blob\",\n      \"azureStorageBlob\": \"unstorage/drivers/azure-storage-blob\",\n      \"azure-storage-table\": \"unstorage/drivers/azure-storage-table\",\n      \"azureStorageTable\": \"unstorage/drivers/azure-storage-table\",\n      \"capacitor-preferences\": \"unstorage/drivers/capacitor-preferences\",\n      \"capacitorPreferences\": \"unstorage/drivers/capacitor-preferences\",\n      \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n      \"cloudflareKVBinding\": \"unstorage/drivers/cloudflare-kv-binding\",\n      \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\",\n      \"cloudflareKVHttp\": \"unstorage/drivers/cloudflare-kv-http\",\n      \"cloudflare-r2-binding\": \"unstorage/drivers/cloudflare-r2-binding\",\n      \"cloudflareR2Binding\": \"unstorage/drivers/cloudflare-r2-binding\",\n      \"db0\": \"unstorage/drivers/db0\",\n      \"deno-kv-node\": \"unstorage/drivers/deno-kv-node\",\n      \"denoKVNode\": \"unstorage/drivers/deno-kv-node\",\n      \"deno-kv\": \"unstorage/drivers/deno-kv\",\n      \"denoKV\": \"unstorage/drivers/deno-kv\",\n      \"fs-lite\": \"unstorage/drivers/fs-lite\",\n      \"fsLite\": \"unstorage/drivers/fs-lite\",\n      \"fs\": \"unstorage/drivers/fs\",\n      \"github\": \"unstorage/drivers/github\",\n      \"http\": \"unstorage/drivers/http\",\n      \"indexedb\": \"unstorage/drivers/indexedb\",\n      \"localstorage\": \"unstorage/drivers/localstorage\",\n      \"lru-cache\": \"unstorage/drivers/lru-cache\",\n      \"lruCache\": \"unstorage/drivers/lru-cache\",\n      \"memory\": \"unstorage/drivers/memory\",\n      \"mongodb\": \"unstorage/drivers/mongodb\",\n      \"netlify-blobs\": \"unstorage/drivers/netlify-blobs\",\n      \"netlifyBlobs\": \"unstorage/drivers/netlify-blobs\",\n      \"null\": \"unstorage/drivers/null\",\n      \"overlay\": \"unstorage/drivers/overlay\",\n      \"planetscale\": \"unstorage/drivers/planetscale\",\n      \"redis\": \"unstorage/drivers/redis\",\n      \"s3\": \"unstorage/drivers/s3\",\n      \"session-storage\": \"unstorage/drivers/session-storage\",\n      \"sessionStorage\": \"unstorage/drivers/session-storage\",\n      \"uploadthing\": \"unstorage/drivers/uploadthing\",\n      \"upstash\": \"unstorage/drivers/upstash\",\n      \"vercel-blob\": \"unstorage/drivers/vercel-blob\",\n      \"vercelBlob\": \"unstorage/drivers/vercel-blob\",\n      \"vercel-kv\": \"unstorage/drivers/vercel-kv\",\n      \"vercelKV\": \"unstorage/drivers/vercel-kv\"\n    };\n    PERSIST_SYMBOL = Symbol();\n    DEFAULT_COOKIE_NAME = \"astro-session\";\n    VALID_COOKIE_REGEX = /^[\\w-]+$/;\n    unflatten2 = /* @__PURE__ */ __name((parsed, _3) => {\n      return unflatten(parsed, {\n        URL: /* @__PURE__ */ __name((href) => new URL(href), \"URL\")\n      });\n    }, \"unflatten\");\n    stringify2 = /* @__PURE__ */ __name((data, _3) => {\n      return stringify(data, {\n        // Support URL objects\n        URL: /* @__PURE__ */ __name((val) => val instanceof URL && val.href, \"URL\")\n      });\n    }, \"stringify\");\n    AstroSession = class _AstroSession {\n      static {\n        __name(this, \"AstroSession\");\n      }\n      // The cookies object.\n      #cookies;\n      // The session configuration.\n      #config;\n      // The cookie config\n      #cookieConfig;\n      // The cookie name\n      #cookieName;\n      // The unstorage object for the session driver.\n      #storage;\n      #data;\n      // The session ID. A v4 UUID.\n      #sessionID;\n      // Sessions to destroy. Needed because we won't have the old session ID after it's destroyed locally.\n      #toDestroy = /* @__PURE__ */ new Set();\n      // Session keys to delete. Used for partial data sets to avoid overwriting the deleted value.\n      #toDelete = /* @__PURE__ */ new Set();\n      // Whether the session is dirty and needs to be saved.\n      #dirty = false;\n      // Whether the session cookie has been set.\n      #cookieSet = false;\n      // The local data is \"partial\" if it has not been loaded from storage yet and only\n      // contains values that have been set or deleted in-memory locally.\n      // We do this to avoid the need to block on loading data when it is only being set.\n      // When we load the data from storage, we need to merge it with the local partial data,\n      // preserving in-memory changes and deletions.\n      #partial = true;\n      static #sharedStorage = /* @__PURE__ */ new Map();\n      constructor(cookies, {\n        cookie: cookieConfig = DEFAULT_COOKIE_NAME,\n        ...config3\n      }, runtimeMode) {\n        this.#cookies = cookies;\n        let cookieConfigObject;\n        if (typeof cookieConfig === \"object\") {\n          const { name = DEFAULT_COOKIE_NAME, ...rest } = cookieConfig;\n          this.#cookieName = name;\n          cookieConfigObject = rest;\n        } else {\n          this.#cookieName = cookieConfig || DEFAULT_COOKIE_NAME;\n        }\n        this.#cookieConfig = {\n          sameSite: \"lax\",\n          secure: runtimeMode === \"production\",\n          path: \"/\",\n          ...cookieConfigObject,\n          httpOnly: true\n        };\n        this.#config = config3;\n      }\n      /**\n       * Gets a session value. Returns `undefined` if the session or value does not exist.\n       */\n      async get(key) {\n        return (await this.#ensureData()).get(key)?.data;\n      }\n      /**\n       * Checks if a session value exists.\n       */\n      async has(key) {\n        return (await this.#ensureData()).has(key);\n      }\n      /**\n       * Gets all session values.\n       */\n      async keys() {\n        return (await this.#ensureData()).keys();\n      }\n      /**\n       * Gets all session values.\n       */\n      async values() {\n        return [...(await this.#ensureData()).values()].map((entry) => entry.data);\n      }\n      /**\n       * Gets all session entries.\n       */\n      async entries() {\n        return [...(await this.#ensureData()).entries()].map(([key, entry]) => [key, entry.data]);\n      }\n      /**\n       * Deletes a session value.\n       */\n      delete(key) {\n        this.#data?.delete(key);\n        if (this.#partial) {\n          this.#toDelete.add(key);\n        }\n        this.#dirty = true;\n      }\n      /**\n       * Sets a session value. The session is created if it does not exist.\n       */\n      set(key, value2, { ttl } = {}) {\n        if (!key) {\n          throw new AstroError({\n            ...SessionStorageSaveError,\n            message: \"The session key was not provided.\"\n          });\n        }\n        let cloned;\n        try {\n          cloned = unflatten2(JSON.parse(stringify2(value2)));\n        } catch (err) {\n          throw new AstroError(\n            {\n              ...SessionStorageSaveError,\n              message: `The session data for ${key} could not be serialized.`,\n              hint: \"See the devalue library for all supported types: https://github.com/rich-harris/devalue\"\n            },\n            { cause: err }\n          );\n        }\n        if (!this.#cookieSet) {\n          this.#setCookie();\n          this.#cookieSet = true;\n        }\n        this.#data ??= /* @__PURE__ */ new Map();\n        const lifetime = ttl ?? this.#config.ttl;\n        const expires = typeof lifetime === \"number\" ? Date.now() + lifetime * 1e3 : lifetime;\n        this.#data.set(key, {\n          data: cloned,\n          expires\n        });\n        this.#dirty = true;\n      }\n      /**\n       * Destroys the session, clearing the cookie and storage if it exists.\n       */\n      destroy() {\n        this.#destroySafe();\n      }\n      /**\n       * Regenerates the session, creating a new session ID. The existing session data is preserved.\n       */\n      async regenerate() {\n        let data = /* @__PURE__ */ new Map();\n        try {\n          data = await this.#ensureData();\n        } catch (err) {\n          console.error(\"Failed to load session data during regeneration:\", err);\n        }\n        const oldSessionId = this.#sessionID;\n        this.#sessionID = crypto.randomUUID();\n        this.#data = data;\n        await this.#setCookie();\n        if (oldSessionId && this.#storage) {\n          this.#storage.removeItem(oldSessionId).catch((err) => {\n            console.error(\"Failed to remove old session data:\", err);\n          });\n        }\n      }\n      // Persists the session data to storage.\n      // This is called automatically at the end of the request.\n      // Uses a symbol to prevent users from calling it directly.\n      async [PERSIST_SYMBOL]() {\n        if (!this.#dirty && !this.#toDestroy.size) {\n          return;\n        }\n        const storage = await this.#ensureStorage();\n        if (this.#dirty && this.#data) {\n          const data = await this.#ensureData();\n          this.#toDelete.forEach((key2) => data.delete(key2));\n          const key = this.#ensureSessionID();\n          let serialized;\n          try {\n            serialized = stringify2(data);\n          } catch (err) {\n            throw new AstroError(\n              {\n                ...SessionStorageSaveError,\n                message: SessionStorageSaveError.message(\n                  \"The session data could not be serialized.\",\n                  this.#config.driver\n                )\n              },\n              { cause: err }\n            );\n          }\n          await storage.setItem(key, serialized);\n          this.#dirty = false;\n        }\n        if (this.#toDestroy.size > 0) {\n          const cleanupPromises = [...this.#toDestroy].map(\n            (sessionId) => storage.removeItem(sessionId).catch((err) => {\n              console.error(`Failed to clean up session ${sessionId}:`, err);\n            })\n          );\n          await Promise.all(cleanupPromises);\n          this.#toDestroy.clear();\n        }\n      }\n      get sessionID() {\n        return this.#sessionID;\n      }\n      /**\n       * Loads a session from storage with the given ID, and replaces the current session.\n       * Any changes made to the current session will be lost.\n       * This is not normally needed, as the session is automatically loaded using the cookie.\n       * However it can be used to restore a session where the ID has been recorded somewhere\n       * else (e.g. in a database).\n       */\n      async load(sessionID) {\n        this.#sessionID = sessionID;\n        this.#data = void 0;\n        await this.#setCookie();\n        await this.#ensureData();\n      }\n      /**\n       * Sets the session cookie.\n       */\n      async #setCookie() {\n        if (!VALID_COOKIE_REGEX.test(this.#cookieName)) {\n          throw new AstroError({\n            ...SessionStorageSaveError,\n            message: \"Invalid cookie name. Cookie names can only contain letters, numbers, and dashes.\"\n          });\n        }\n        const value2 = this.#ensureSessionID();\n        this.#cookies.set(this.#cookieName, value2, this.#cookieConfig);\n      }\n      /**\n       * Attempts to load the session data from storage, or creates a new data object if none exists.\n       * If there is existing partial data, it will be merged into the new data object.\n       */\n      async #ensureData() {\n        const storage = await this.#ensureStorage();\n        if (this.#data && !this.#partial) {\n          return this.#data;\n        }\n        this.#data ??= /* @__PURE__ */ new Map();\n        const raw2 = await storage.get(this.#ensureSessionID());\n        if (!raw2) {\n          return this.#data;\n        }\n        try {\n          const storedMap = unflatten2(raw2);\n          if (!(storedMap instanceof Map)) {\n            await this.#destroySafe();\n            throw new AstroError({\n              ...SessionStorageInitError,\n              message: SessionStorageInitError.message(\n                \"The session data was an invalid type.\",\n                this.#config.driver\n              )\n            });\n          }\n          const now = Date.now();\n          for (const [key, value2] of storedMap) {\n            const expired = typeof value2.expires === \"number\" && value2.expires < now;\n            if (!this.#data.has(key) && !this.#toDelete.has(key) && !expired) {\n              this.#data.set(key, value2);\n            }\n          }\n          this.#partial = false;\n          return this.#data;\n        } catch (err) {\n          await this.#destroySafe();\n          if (err instanceof AstroError) {\n            throw err;\n          }\n          throw new AstroError(\n            {\n              ...SessionStorageInitError,\n              message: SessionStorageInitError.message(\n                \"The session data could not be parsed.\",\n                this.#config.driver\n              )\n            },\n            { cause: err }\n          );\n        }\n      }\n      /**\n       * Safely destroys the session, clearing the cookie and storage if it exists.\n       */\n      #destroySafe() {\n        if (this.#sessionID) {\n          this.#toDestroy.add(this.#sessionID);\n        }\n        if (this.#cookieName) {\n          this.#cookies.delete(this.#cookieName, this.#cookieConfig);\n        }\n        this.#sessionID = void 0;\n        this.#data = void 0;\n        this.#dirty = true;\n      }\n      /**\n       * Returns the session ID, generating a new one if it does not exist.\n       */\n      #ensureSessionID() {\n        this.#sessionID ??= this.#cookies.get(this.#cookieName)?.value ?? crypto.randomUUID();\n        return this.#sessionID;\n      }\n      /**\n       * Ensures the storage is initialized.\n       * This is called automatically when a storage operation is needed.\n       */\n      async #ensureStorage() {\n        if (this.#storage) {\n          return this.#storage;\n        }\n        if (_AstroSession.#sharedStorage.has(this.#config.driver)) {\n          this.#storage = _AstroSession.#sharedStorage.get(this.#config.driver);\n          return this.#storage;\n        }\n        if (this.#config.driver === \"test\") {\n          this.#storage = this.#config.options.mockStorage;\n          return this.#storage;\n        }\n        if (this.#config.driver === \"fs\" || this.#config.driver === \"fsLite\" || this.#config.driver === \"fs-lite\") {\n          this.#config.options ??= {};\n          this.#config.driver = \"fs-lite\";\n          this.#config.options.base ??= \".astro/session\";\n        }\n        if (!this.#config?.driver) {\n          throw new AstroError({\n            ...SessionStorageInitError,\n            message: SessionStorageInitError.message(\n              \"No driver was defined in the session configuration and the adapter did not provide a default driver.\"\n            )\n          });\n        }\n        let driver = null;\n        try {\n          if (this.#config.driverModule) {\n            driver = (await this.#config.driverModule()).default;\n          } else if (this.#config.driver) {\n            const driverName = resolveSessionDriverName(this.#config.driver);\n            if (driverName) {\n              driver = (await import(driverName)).default;\n            }\n          }\n        } catch (err) {\n          if (err.code === \"ERR_MODULE_NOT_FOUND\") {\n            throw new AstroError(\n              {\n                ...SessionStorageInitError,\n                message: SessionStorageInitError.message(\n                  err.message.includes(`Cannot find package`) ? \"The driver module could not be found.\" : err.message,\n                  this.#config.driver\n                )\n              },\n              { cause: err }\n            );\n          }\n          throw err;\n        }\n        if (!driver) {\n          throw new AstroError({\n            ...SessionStorageInitError,\n            message: SessionStorageInitError.message(\n              \"The module did not export a driver.\",\n              this.#config.driver\n            )\n          });\n        }\n        try {\n          this.#storage = createStorage({\n            driver: driver(this.#config.options)\n          });\n          _AstroSession.#sharedStorage.set(this.#config.driver, this.#storage);\n          return this.#storage;\n        } catch (err) {\n          throw new AstroError(\n            {\n              ...SessionStorageInitError,\n              message: SessionStorageInitError.message(\"Unknown error\", this.#config.driver)\n            },\n            { cause: err }\n          );\n        }\n      }\n    };\n    __name(resolveSessionDriverName, \"resolveSessionDriverName\");\n    apiContextRoutesSymbol = Symbol.for(\"context.routes\");\n    RenderContext = class _RenderContext {\n      static {\n        __name(this, \"RenderContext\");\n      }\n      constructor(pipeline, locals, middleware2, actions2, pathname, request, routeData, status, clientAddress, cookies = new AstroCookies(request), params = getParams(routeData, pathname), url = new URL(request.url), props = {}, partial = void 0, session = pipeline.manifest.sessionConfig ? new AstroSession(cookies, pipeline.manifest.sessionConfig, pipeline.runtimeMode) : void 0) {\n        this.pipeline = pipeline;\n        this.locals = locals;\n        this.middleware = middleware2;\n        this.actions = actions2;\n        this.pathname = pathname;\n        this.request = request;\n        this.routeData = routeData;\n        this.status = status;\n        this.clientAddress = clientAddress;\n        this.cookies = cookies;\n        this.params = params;\n        this.url = url;\n        this.props = props;\n        this.partial = partial;\n        this.session = session;\n      }\n      /**\n       * A flag that tells the render content if the rewriting was triggered\n       */\n      isRewriting = false;\n      /**\n       * A safety net in case of loops\n       */\n      counter = 0;\n      static async create({\n        locals = {},\n        middleware: middleware2,\n        pathname,\n        pipeline,\n        request,\n        routeData,\n        clientAddress,\n        status = 200,\n        props,\n        partial = void 0,\n        actions: actions2\n      }) {\n        const pipelineMiddleware = await pipeline.getMiddleware();\n        const pipelineActions = actions2 ?? await pipeline.getActions();\n        setOriginPathname(request, pathname);\n        return new _RenderContext(\n          pipeline,\n          locals,\n          sequence(...pipeline.internalMiddleware, middleware2 ?? pipelineMiddleware),\n          pipelineActions,\n          pathname,\n          request,\n          routeData,\n          status,\n          clientAddress,\n          void 0,\n          void 0,\n          void 0,\n          props,\n          partial\n        );\n      }\n      /**\n       * The main function of the RenderContext.\n       *\n       * Use this function to render any route known to Astro.\n       * It attempts to render a route. A route can be a:\n       *\n       * - page\n       * - redirect\n       * - endpoint\n       * - fallback\n       */\n      async render(componentInstance, slots = {}) {\n        const { cookies, middleware: middleware2, pipeline } = this;\n        const { logger, serverLike, streaming, manifest: manifest2 } = pipeline;\n        const props = Object.keys(this.props).length > 0 ? this.props : await getProps({\n          mod: componentInstance,\n          routeData: this.routeData,\n          routeCache: this.pipeline.routeCache,\n          pathname: this.pathname,\n          logger,\n          serverLike,\n          base: manifest2.base\n        });\n        const actionApiContext = this.createActionAPIContext();\n        const apiContext = this.createAPIContext(props, actionApiContext);\n        this.counter++;\n        if (this.counter === 4) {\n          return new Response(\"Loop Detected\", {\n            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508\n            status: 508,\n            statusText: \"Astro detected a loop where you tried to call the rewriting logic more than four times.\"\n          });\n        }\n        const lastNext = /* @__PURE__ */ __name(async (ctx, payload) => {\n          if (payload) {\n            const oldPathname = this.pathname;\n            pipeline.logger.debug(\"router\", \"Called rewriting to:\", payload);\n            const {\n              routeData,\n              componentInstance: newComponent,\n              pathname,\n              newUrl\n            } = await pipeline.tryRewrite(payload, this.request);\n            if (this.pipeline.serverLike === true && this.routeData.prerender === false && routeData.prerender === true) {\n              throw new AstroError({\n                ...ForbiddenRewrite,\n                message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),\n                hint: ForbiddenRewrite.hint(routeData.component)\n              });\n            }\n            this.routeData = routeData;\n            componentInstance = newComponent;\n            if (payload instanceof Request) {\n              this.request = payload;\n            } else {\n              this.request = copyRequest(\n                newUrl,\n                this.request,\n                // need to send the flag of the previous routeData\n                routeData.prerender,\n                this.pipeline.logger,\n                this.routeData.route\n              );\n            }\n            this.isRewriting = true;\n            this.url = new URL(this.request.url);\n            this.params = getParams(routeData, pathname);\n            this.pathname = pathname;\n            this.status = 200;\n            setOriginPathname(this.request, oldPathname);\n          }\n          let response2;\n          if (!ctx.isPrerendered) {\n            const { action, setActionResult, serializeActionResult: serializeActionResult2 } = getActionContext(ctx);\n            if (action?.calledFrom === \"form\") {\n              const actionResult = await action.handler();\n              setActionResult(action.name, serializeActionResult2(actionResult));\n            }\n          }\n          switch (this.routeData.type) {\n            case \"endpoint\": {\n              response2 = await renderEndpoint(\n                componentInstance,\n                ctx,\n                this.routeData.prerender,\n                logger\n              );\n              break;\n            }\n            case \"redirect\":\n              return renderRedirect(this);\n            case \"page\": {\n              const result = await this.createResult(componentInstance, actionApiContext);\n              try {\n                response2 = await renderPage(\n                  result,\n                  componentInstance?.default,\n                  props,\n                  slots,\n                  streaming,\n                  this.routeData\n                );\n              } catch (e) {\n                result.cancelled = true;\n                throw e;\n              }\n              response2.headers.set(ROUTE_TYPE_HEADER, \"page\");\n              if (this.routeData.route === \"/404\" || this.routeData.route === \"/500\") {\n                response2.headers.set(REROUTE_DIRECTIVE_HEADER, \"no\");\n              }\n              if (this.isRewriting) {\n                response2.headers.set(REWRITE_DIRECTIVE_HEADER_KEY, REWRITE_DIRECTIVE_HEADER_VALUE);\n              }\n              break;\n            }\n            case \"fallback\": {\n              return new Response(null, { status: 500, headers: { [ROUTE_TYPE_HEADER]: \"fallback\" } });\n            }\n          }\n          const responseCookies = getCookiesFromResponse(response2);\n          if (responseCookies) {\n            cookies.merge(responseCookies);\n          }\n          return response2;\n        }, \"lastNext\");\n        if (isRouteExternalRedirect(this.routeData)) {\n          return renderRedirect(this);\n        }\n        const response = await callMiddleware(middleware2, apiContext, lastNext);\n        if (response.headers.get(ROUTE_TYPE_HEADER)) {\n          response.headers.delete(ROUTE_TYPE_HEADER);\n        }\n        attachCookiesToResponse(response, cookies);\n        return response;\n      }\n      createAPIContext(props, context2) {\n        const redirect = /* @__PURE__ */ __name((path, status = 302) => new Response(null, { status, headers: { Location: path } }), \"redirect\");\n        Reflect.set(context2, apiContextRoutesSymbol, this.pipeline);\n        return Object.assign(context2, {\n          props,\n          redirect,\n          getActionResult: createGetActionResult(context2.locals),\n          callAction: createCallAction(context2)\n        });\n      }\n      async #executeRewrite(reroutePayload) {\n        this.pipeline.logger.debug(\"router\", \"Calling rewrite: \", reroutePayload);\n        const oldPathname = this.pathname;\n        const { routeData, componentInstance, newUrl, pathname } = await this.pipeline.tryRewrite(\n          reroutePayload,\n          this.request\n        );\n        if (this.pipeline.serverLike && !this.routeData.prerender && routeData.prerender) {\n          throw new AstroError({\n            ...ForbiddenRewrite,\n            message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),\n            hint: ForbiddenRewrite.hint(routeData.component)\n          });\n        }\n        this.routeData = routeData;\n        if (reroutePayload instanceof Request) {\n          this.request = reroutePayload;\n        } else {\n          this.request = copyRequest(\n            newUrl,\n            this.request,\n            // need to send the flag of the previous routeData\n            routeData.prerender,\n            this.pipeline.logger,\n            this.routeData.route\n          );\n        }\n        this.url = new URL(this.request.url);\n        this.cookies = new AstroCookies(this.request);\n        this.params = getParams(routeData, pathname);\n        this.pathname = pathname;\n        this.isRewriting = true;\n        this.status = 200;\n        setOriginPathname(this.request, oldPathname);\n        return await this.render(componentInstance);\n      }\n      createActionAPIContext() {\n        const renderContext = this;\n        const { cookies, params, pipeline, url } = this;\n        const generator = `Astro v${ASTRO_VERSION}`;\n        const rewrite = /* @__PURE__ */ __name(async (reroutePayload) => {\n          return await this.#executeRewrite(reroutePayload);\n        }, \"rewrite\");\n        return {\n          cookies,\n          routePattern: this.routeData.route,\n          isPrerendered: this.routeData.prerender,\n          get clientAddress() {\n            return renderContext.getClientAddress();\n          },\n          get currentLocale() {\n            return renderContext.computeCurrentLocale();\n          },\n          generator,\n          get locals() {\n            return renderContext.locals;\n          },\n          set locals(_3) {\n            throw new AstroError(LocalsReassigned);\n          },\n          params,\n          get preferredLocale() {\n            return renderContext.computePreferredLocale();\n          },\n          get preferredLocaleList() {\n            return renderContext.computePreferredLocaleList();\n          },\n          rewrite,\n          request: this.request,\n          site: pipeline.site,\n          url,\n          get originPathname() {\n            return getOriginPathname(renderContext.request);\n          },\n          get session() {\n            if (this.isPrerendered) {\n              pipeline.logger.warn(\n                \"session\",\n                `context.session was used when rendering the route ${green(this.routePattern)}, but it is not available on prerendered routes. If you need access to sessions, make sure that the route is server-rendered using \\`export const prerender = false;\\` or by setting \\`output\\` to \\`\"server\"\\` in your Astro config to make all your routes server-rendered by default. For more information, see https://docs.astro.build/en/guides/sessions/`\n              );\n              return void 0;\n            }\n            if (!renderContext.session) {\n              pipeline.logger.warn(\n                \"session\",\n                `context.session was used when rendering the route ${green(this.routePattern)}, but no storage configuration was provided. Either configure the storage manually or use an adapter that provides session storage. For more information, see https://docs.astro.build/en/guides/sessions/`\n              );\n              return void 0;\n            }\n            return renderContext.session;\n          }\n        };\n      }\n      async createResult(mod, ctx) {\n        const { cookies, pathname, pipeline, routeData, status } = this;\n        const { clientDirectives, inlinedScripts, compressHTML, manifest: manifest2, renderers: renderers2, resolve } = pipeline;\n        const { links, scripts, styles } = await pipeline.headElements(routeData);\n        const componentMetadata = await pipeline.componentMetadata(routeData) ?? manifest2.componentMetadata;\n        const headers = new Headers({ \"Content-Type\": \"text/html\" });\n        const partial = typeof this.partial === \"boolean\" ? this.partial : Boolean(mod.partial);\n        const actionResult = hasActionPayload(this.locals) ? deserializeActionResult(this.locals._actionPayload.actionResult) : void 0;\n        const response = {\n          status: actionResult?.error ? actionResult?.error.status : status,\n          statusText: actionResult?.error ? actionResult?.error.type : \"OK\",\n          get headers() {\n            return headers;\n          },\n          // Disallow `Astro.response.headers = new Headers`\n          set headers(_3) {\n            throw new AstroError(AstroResponseHeadersReassigned);\n          }\n        };\n        const result = {\n          base: manifest2.base,\n          userAssetsBase: manifest2.userAssetsBase,\n          cancelled: false,\n          clientDirectives,\n          inlinedScripts,\n          componentMetadata,\n          compressHTML,\n          cookies,\n          /** This function returns the `Astro` faux-global */\n          createAstro: /* @__PURE__ */ __name((astroGlobal, props, slots) => this.createAstro(result, astroGlobal, props, slots, ctx), \"createAstro\"),\n          links,\n          params: this.params,\n          partial,\n          pathname,\n          renderers: renderers2,\n          resolve,\n          response,\n          request: this.request,\n          scripts,\n          styles,\n          actionResult,\n          serverIslandNameMap: manifest2.serverIslandNameMap ?? /* @__PURE__ */ new Map(),\n          key: manifest2.key,\n          trailingSlash: manifest2.trailingSlash,\n          _metadata: {\n            hasHydrationScript: false,\n            rendererSpecificHydrationScripts: /* @__PURE__ */ new Set(),\n            hasRenderedHead: false,\n            renderedScripts: /* @__PURE__ */ new Set(),\n            hasDirectives: /* @__PURE__ */ new Set(),\n            hasRenderedServerIslandRuntime: false,\n            headInTree: false,\n            extraHead: [],\n            propagators: /* @__PURE__ */ new Set()\n          }\n        };\n        return result;\n      }\n      #astroPagePartial;\n      /**\n       * The Astro global is sourced in 3 different phases:\n       * - **Static**: `.generator` and `.glob` is printed by the compiler, instantiated once per process per astro file\n       * - **Page-level**: `.request`, `.cookies`, `.locals` etc. These remain the same for the duration of the request.\n       * - **Component-level**: `.props`, `.slots`, and `.self` are unique to each _use_ of each component.\n       *\n       * The page level partial is used as the prototype of the user-visible `Astro` global object, which is instantiated once per use of a component.\n       */\n      createAstro(result, astroStaticPartial, props, slotValues, apiContext) {\n        let astroPagePartial;\n        if (this.isRewriting) {\n          astroPagePartial = this.#astroPagePartial = this.createAstroPagePartial(\n            result,\n            astroStaticPartial,\n            apiContext\n          );\n        } else {\n          astroPagePartial = this.#astroPagePartial ??= this.createAstroPagePartial(\n            result,\n            astroStaticPartial,\n            apiContext\n          );\n        }\n        const astroComponentPartial = { props, self: null };\n        const Astro = Object.assign(\n          Object.create(astroPagePartial),\n          astroComponentPartial\n        );\n        let _slots;\n        Object.defineProperty(Astro, \"slots\", {\n          get: /* @__PURE__ */ __name(() => {\n            if (!_slots) {\n              _slots = new Slots(\n                result,\n                slotValues,\n                this.pipeline.logger\n              );\n            }\n            return _slots;\n          }, \"get\")\n        });\n        return Astro;\n      }\n      createAstroPagePartial(result, astroStaticPartial, apiContext) {\n        const renderContext = this;\n        const { cookies, locals, params, pipeline, url } = this;\n        const { response } = result;\n        const redirect = /* @__PURE__ */ __name((path, status = 302) => {\n          if (this.request[responseSentSymbol]) {\n            throw new AstroError({\n              ...ResponseSentError\n            });\n          }\n          return new Response(null, { status, headers: { Location: path } });\n        }, \"redirect\");\n        const rewrite = /* @__PURE__ */ __name(async (reroutePayload) => {\n          return await this.#executeRewrite(reroutePayload);\n        }, \"rewrite\");\n        const callAction = createCallAction(apiContext);\n        return {\n          generator: astroStaticPartial.generator,\n          glob: astroStaticPartial.glob,\n          routePattern: this.routeData.route,\n          isPrerendered: this.routeData.prerender,\n          cookies,\n          get session() {\n            if (this.isPrerendered) {\n              pipeline.logger.warn(\n                \"session\",\n                `Astro.session was used when rendering the route ${green(this.routePattern)}, but it is not available on prerendered pages. If you need access to sessions, make sure that the page is server-rendered using \\`export const prerender = false;\\` or by setting \\`output\\` to \\`\"server\"\\` in your Astro config to make all your pages server-rendered by default. For more information, see https://docs.astro.build/en/guides/sessions/`\n              );\n              return void 0;\n            }\n            if (!renderContext.session) {\n              pipeline.logger.warn(\n                \"session\",\n                `Astro.session was used when rendering the route ${green(this.routePattern)}, but no storage configuration was provided. Either configure the storage manually or use an adapter that provides session storage. For more information, see https://docs.astro.build/en/guides/sessions/`\n              );\n              return void 0;\n            }\n            return renderContext.session;\n          },\n          get clientAddress() {\n            return renderContext.getClientAddress();\n          },\n          get currentLocale() {\n            return renderContext.computeCurrentLocale();\n          },\n          params,\n          get preferredLocale() {\n            return renderContext.computePreferredLocale();\n          },\n          get preferredLocaleList() {\n            return renderContext.computePreferredLocaleList();\n          },\n          locals,\n          redirect,\n          rewrite,\n          request: this.request,\n          response,\n          site: pipeline.site,\n          getActionResult: createGetActionResult(locals),\n          get callAction() {\n            return callAction;\n          },\n          url,\n          get originPathname() {\n            return getOriginPathname(renderContext.request);\n          }\n        };\n      }\n      getClientAddress() {\n        const { pipeline, request, routeData, clientAddress } = this;\n        if (routeData.prerender) {\n          throw new AstroError({\n            ...PrerenderClientAddressNotAvailable,\n            message: PrerenderClientAddressNotAvailable.message(routeData.component)\n          });\n        }\n        if (clientAddress) {\n          return clientAddress;\n        }\n        if (clientAddressSymbol in request) {\n          return Reflect.get(request, clientAddressSymbol);\n        }\n        if (pipeline.adapterName) {\n          throw new AstroError({\n            ...ClientAddressNotAvailable,\n            message: ClientAddressNotAvailable.message(pipeline.adapterName)\n          });\n        }\n        throw new AstroError(StaticClientAddressNotAvailable);\n      }\n      /**\n       * API Context may be created multiple times per request, i18n data needs to be computed only once.\n       * So, it is computed and saved here on creation of the first APIContext and reused for later ones.\n       */\n      #currentLocale;\n      computeCurrentLocale() {\n        const {\n          url,\n          pipeline: { i18n },\n          routeData\n        } = this;\n        if (!i18n) return;\n        const { defaultLocale, locales, strategy } = i18n;\n        const fallbackTo = strategy === \"pathname-prefix-other-locales\" || strategy === \"domains-prefix-other-locales\" ? defaultLocale : void 0;\n        if (this.#currentLocale) {\n          return this.#currentLocale;\n        }\n        let computedLocale;\n        if (isRouteServerIsland(routeData)) {\n          let referer = this.request.headers.get(\"referer\");\n          if (referer) {\n            if (URL.canParse(referer)) {\n              referer = new URL(referer).pathname;\n            }\n            computedLocale = computeCurrentLocale(referer, locales, defaultLocale);\n          }\n        } else {\n          let pathname = routeData.pathname;\n          if (!routeData.pattern.test(url.pathname)) {\n            for (const fallbackRoute of routeData.fallbackRoutes) {\n              if (fallbackRoute.pattern.test(url.pathname)) {\n                pathname = fallbackRoute.pathname;\n                break;\n              }\n            }\n          }\n          pathname = pathname && !isRoute404or500(routeData) ? pathname : url.pathname;\n          computedLocale = computeCurrentLocale(pathname, locales, defaultLocale);\n        }\n        this.#currentLocale = computedLocale ?? fallbackTo;\n        return this.#currentLocale;\n      }\n      #preferredLocale;\n      computePreferredLocale() {\n        const {\n          pipeline: { i18n },\n          request\n        } = this;\n        if (!i18n) return;\n        return this.#preferredLocale ??= computePreferredLocale(request, i18n.locales);\n      }\n      #preferredLocaleList;\n      computePreferredLocaleList() {\n        const {\n          pipeline: { i18n },\n          request\n        } = this;\n        if (!i18n) return;\n        return this.#preferredLocaleList ??= computePreferredLocaleList(request, i18n.locales);\n      }\n    };\n    __name(sequence, \"sequence\");\n    __name(defineMiddleware, \"defineMiddleware\");\n  }\n});\n\n// dist/_worker.js/chunks/cloudflare-kv-binding_DMly_2Gl.mjs\nvar cloudflare_kv_binding_DMly_2Gl_exports = {};\n__export(cloudflare_kv_binding_DMly_2Gl_exports, {\n  default: () => cloudflareKvBinding\n});\nfunction defineDriver2(factory) {\n  return factory;\n}\nfunction normalizeKey2(key, sep = \":\") {\n  if (!key) {\n    return \"\";\n  }\n  return key.replace(/[:/\\\\]/g, sep).replace(/^[:/\\\\]|[:/\\\\]$/g, \"\");\n}\nfunction joinKeys2(...keys2) {\n  return keys2.map((key) => normalizeKey2(key)).filter(Boolean).join(\":\");\n}\nfunction createError(driver, message, opts) {\n  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(err, createError);\n  }\n  return err;\n}\nfunction getBinding(binding2) {\n  let bindingName = \"[binding]\";\n  if (typeof binding2 === \"string\") {\n    bindingName = binding2;\n    binding2 = globalThis[bindingName] || globalThis.__env__?.[bindingName];\n  }\n  if (!binding2) {\n    throw createError(\n      \"cloudflare\",\n      `Invalid binding \\`${bindingName}\\`: \\`${binding2}\\``\n    );\n  }\n  for (const key of [\"get\", \"put\", \"delete\"]) {\n    if (!(key in binding2)) {\n      throw createError(\n        \"cloudflare\",\n        `Invalid binding \\`${bindingName}\\`: \\`${key}\\` key is missing`\n      );\n    }\n  }\n  return binding2;\n}\nfunction getKVBinding(binding2 = \"STORAGE\") {\n  return getBinding(binding2);\n}\nvar DRIVER_NAME2, cloudflareKvBinding;\nvar init_cloudflare_kv_binding_DMly_2Gl = __esm({\n  \"dist/_worker.js/chunks/cloudflare-kv-binding_DMly_2Gl.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    __name(defineDriver2, \"defineDriver\");\n    __name(normalizeKey2, \"normalizeKey\");\n    __name(joinKeys2, \"joinKeys\");\n    __name(createError, \"createError\");\n    __name(getBinding, \"getBinding\");\n    __name(getKVBinding, \"getKVBinding\");\n    DRIVER_NAME2 = \"cloudflare-kv-binding\";\n    cloudflareKvBinding = defineDriver2((opts) => {\n      const r2 = /* @__PURE__ */ __name((key = \"\") => opts.base ? joinKeys2(opts.base, key) : key, \"r\");\n      async function getKeys(base = \"\") {\n        base = r2(base);\n        const binding2 = getKVBinding(opts.binding);\n        const keys2 = [];\n        let cursor = void 0;\n        do {\n          const kvList = await binding2.list({ prefix: base || void 0, cursor });\n          keys2.push(...kvList.keys);\n          cursor = kvList.list_complete ? void 0 : kvList.cursor;\n        } while (cursor);\n        return keys2.map((key) => key.name);\n      }\n      __name(getKeys, \"getKeys\");\n      return {\n        name: DRIVER_NAME2,\n        options: opts,\n        getInstance: /* @__PURE__ */ __name(() => getKVBinding(opts.binding), \"getInstance\"),\n        async hasItem(key) {\n          key = r2(key);\n          const binding2 = getKVBinding(opts.binding);\n          return await binding2.get(key) !== null;\n        },\n        getItem(key) {\n          key = r2(key);\n          const binding2 = getKVBinding(opts.binding);\n          return binding2.get(key);\n        },\n        setItem(key, value2, topts) {\n          key = r2(key);\n          const binding2 = getKVBinding(opts.binding);\n          return binding2.put(\n            key,\n            value2,\n            topts ? {\n              expirationTtl: topts?.ttl ? Math.max(topts.ttl, opts.minTTL ?? 60) : void 0,\n              ...topts\n            } : void 0\n          );\n        },\n        removeItem(key) {\n          key = r2(key);\n          const binding2 = getKVBinding(opts.binding);\n          return binding2.delete(key);\n        },\n        getKeys(base) {\n          return getKeys(base).then(\n            (keys2) => keys2.map((key) => opts.base ? key.slice(opts.base.length) : key)\n          );\n        },\n        async clear(base) {\n          const binding2 = getKVBinding(opts.binding);\n          const keys2 = await getKeys(base);\n          await Promise.all(keys2.map((key) => binding2.delete(key)));\n        }\n      };\n    });\n  }\n});\n\n// dist/_worker.js/pages/_image.astro.mjs\nvar image_astro_exports = {};\n__export(image_astro_exports, {\n  page: () => page,\n  renderers: () => renderers\n});\nvar prerender, GET, _page, page;\nvar init_image_astro = __esm({\n  \"dist/_worker.js/pages/_image.astro.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_renderers();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    prerender = false;\n    GET = /* @__PURE__ */ __name((ctx) => {\n      const href = ctx.url.searchParams.get(\"href\");\n      if (!href) {\n        return new Response(\"Missing 'href' query parameter\", {\n          status: 400,\n          statusText: \"Missing 'href' query parameter\"\n        });\n      }\n      return fetch(new URL(href, ctx.url.origin));\n    }, \"GET\");\n    _page = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      GET,\n      prerender\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    page = /* @__PURE__ */ __name(() => _page, \"page\");\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs\nvar readdir, stat, unlink, writeFile, readFile;\nvar init_promises = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_utils();\n    readdir = /* @__PURE__ */ notImplemented(\"fs.readdir\");\n    stat = /* @__PURE__ */ notImplemented(\"fs.stat\");\n    unlink = /* @__PURE__ */ notImplemented(\"fs.unlink\");\n    writeFile = /* @__PURE__ */ notImplemented(\"fs.writeFile\");\n    readFile = /* @__PURE__ */ notImplemented(\"fs.readFile\");\n  }\n});\n\n// node_modules/alchemy/node_modules/unenv/dist/runtime/node/fs/promises.mjs\nvar init_promises2 = __esm({\n  \"node_modules/alchemy/node_modules/unenv/dist/runtime/node/fs/promises.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_promises();\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs\nvar subtle;\nvar init_web = __esm({\n  \"node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    subtle = globalThis.crypto?.subtle;\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs\nvar webcrypto, createCipher, createDecipher, pseudoRandomBytes, Cipher, Decipher;\nvar init_node = __esm({\n  \"node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_utils2();\n    webcrypto = new Proxy(globalThis.crypto, { get(_3, key) {\n      if (key === \"CryptoKey\") {\n        return globalThis.CryptoKey;\n      }\n      if (typeof globalThis.crypto[key] === \"function\") {\n        return globalThis.crypto[key].bind(globalThis.crypto);\n      }\n      return globalThis.crypto[key];\n    } });\n    createCipher = /* @__PURE__ */ notImplemented2(\"crypto.createCipher\");\n    createDecipher = /* @__PURE__ */ notImplemented2(\"crypto.createDecipher\");\n    pseudoRandomBytes = /* @__PURE__ */ notImplemented2(\"crypto.pseudoRandomBytes\");\n    Cipher = /* @__PURE__ */ notImplementedClass(\"crypto.Cipher\");\n    Decipher = /* @__PURE__ */ notImplementedClass(\"crypto.Decipher\");\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs\nvar SSL_OP_ALL, SSL_OP_ALLOW_NO_DHE_KEX, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_NO_COMPRESSION, SSL_OP_NO_ENCRYPT_THEN_MAC, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_RENEGOTIATION, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_NO_TLSv1_3, SSL_OP_PRIORITIZE_CHACHA, SSL_OP_TLS_ROLLBACK_BUG, ENGINE_METHOD_RSA, ENGINE_METHOD_DSA, ENGINE_METHOD_DH, ENGINE_METHOD_RAND, ENGINE_METHOD_EC, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_ALL, ENGINE_METHOD_NONE, DH_CHECK_P_NOT_SAFE_PRIME, DH_CHECK_P_NOT_PRIME, DH_UNABLE_TO_CHECK_GENERATOR, DH_NOT_SUITABLE_GENERATOR, RSA_PKCS1_PADDING, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_X931_PADDING, RSA_PKCS1_PSS_PADDING, RSA_PSS_SALTLEN_DIGEST, RSA_PSS_SALTLEN_MAX_SIGN, RSA_PSS_SALTLEN_AUTO, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_UNCOMPRESSED, POINT_CONVERSION_HYBRID, defaultCoreCipherList, defaultCipherList, OPENSSL_VERSION_NUMBER, TLS1_VERSION, TLS1_1_VERSION, TLS1_2_VERSION, TLS1_3_VERSION;\nvar init_constants = __esm({\n  \"node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    SSL_OP_ALL = 2147485776;\n    SSL_OP_ALLOW_NO_DHE_KEX = 1024;\n    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;\n    SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;\n    SSL_OP_CISCO_ANYCONNECT = 32768;\n    SSL_OP_COOKIE_EXCHANGE = 8192;\n    SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;\n    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;\n    SSL_OP_LEGACY_SERVER_CONNECT = 4;\n    SSL_OP_NO_COMPRESSION = 131072;\n    SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;\n    SSL_OP_NO_QUERY_MTU = 4096;\n    SSL_OP_NO_RENEGOTIATION = 1073741824;\n    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;\n    SSL_OP_NO_SSLv2 = 0;\n    SSL_OP_NO_SSLv3 = 33554432;\n    SSL_OP_NO_TICKET = 16384;\n    SSL_OP_NO_TLSv1 = 67108864;\n    SSL_OP_NO_TLSv1_1 = 268435456;\n    SSL_OP_NO_TLSv1_2 = 134217728;\n    SSL_OP_NO_TLSv1_3 = 536870912;\n    SSL_OP_PRIORITIZE_CHACHA = 2097152;\n    SSL_OP_TLS_ROLLBACK_BUG = 8388608;\n    ENGINE_METHOD_RSA = 1;\n    ENGINE_METHOD_DSA = 2;\n    ENGINE_METHOD_DH = 4;\n    ENGINE_METHOD_RAND = 8;\n    ENGINE_METHOD_EC = 2048;\n    ENGINE_METHOD_CIPHERS = 64;\n    ENGINE_METHOD_DIGESTS = 128;\n    ENGINE_METHOD_PKEY_METHS = 512;\n    ENGINE_METHOD_PKEY_ASN1_METHS = 1024;\n    ENGINE_METHOD_ALL = 65535;\n    ENGINE_METHOD_NONE = 0;\n    DH_CHECK_P_NOT_SAFE_PRIME = 2;\n    DH_CHECK_P_NOT_PRIME = 1;\n    DH_UNABLE_TO_CHECK_GENERATOR = 4;\n    DH_NOT_SUITABLE_GENERATOR = 8;\n    RSA_PKCS1_PADDING = 1;\n    RSA_NO_PADDING = 3;\n    RSA_PKCS1_OAEP_PADDING = 4;\n    RSA_X931_PADDING = 5;\n    RSA_PKCS1_PSS_PADDING = 6;\n    RSA_PSS_SALTLEN_DIGEST = -1;\n    RSA_PSS_SALTLEN_MAX_SIGN = -2;\n    RSA_PSS_SALTLEN_AUTO = -2;\n    POINT_CONVERSION_COMPRESSED = 2;\n    POINT_CONVERSION_UNCOMPRESSED = 4;\n    POINT_CONVERSION_HYBRID = 6;\n    defaultCoreCipherList = \"\";\n    defaultCipherList = \"\";\n    OPENSSL_VERSION_NUMBER = 0;\n    TLS1_VERSION = 0;\n    TLS1_1_VERSION = 0;\n    TLS1_2_VERSION = 0;\n    TLS1_3_VERSION = 0;\n  }\n});\n\n// node_modules/unenv/dist/runtime/node/crypto.mjs\nvar constants;\nvar init_crypto = __esm({\n  \"node_modules/unenv/dist/runtime/node/crypto.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_constants();\n    init_web();\n    init_node();\n    constants = {\n      OPENSSL_VERSION_NUMBER,\n      SSL_OP_ALL,\n      SSL_OP_ALLOW_NO_DHE_KEX,\n      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,\n      SSL_OP_CIPHER_SERVER_PREFERENCE,\n      SSL_OP_CISCO_ANYCONNECT,\n      SSL_OP_COOKIE_EXCHANGE,\n      SSL_OP_CRYPTOPRO_TLSEXT_BUG,\n      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,\n      SSL_OP_LEGACY_SERVER_CONNECT,\n      SSL_OP_NO_COMPRESSION,\n      SSL_OP_NO_ENCRYPT_THEN_MAC,\n      SSL_OP_NO_QUERY_MTU,\n      SSL_OP_NO_RENEGOTIATION,\n      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,\n      SSL_OP_NO_SSLv2,\n      SSL_OP_NO_SSLv3,\n      SSL_OP_NO_TICKET,\n      SSL_OP_NO_TLSv1,\n      SSL_OP_NO_TLSv1_1,\n      SSL_OP_NO_TLSv1_2,\n      SSL_OP_NO_TLSv1_3,\n      SSL_OP_PRIORITIZE_CHACHA,\n      SSL_OP_TLS_ROLLBACK_BUG,\n      ENGINE_METHOD_RSA,\n      ENGINE_METHOD_DSA,\n      ENGINE_METHOD_DH,\n      ENGINE_METHOD_RAND,\n      ENGINE_METHOD_EC,\n      ENGINE_METHOD_CIPHERS,\n      ENGINE_METHOD_DIGESTS,\n      ENGINE_METHOD_PKEY_METHS,\n      ENGINE_METHOD_PKEY_ASN1_METHS,\n      ENGINE_METHOD_ALL,\n      ENGINE_METHOD_NONE,\n      DH_CHECK_P_NOT_SAFE_PRIME,\n      DH_CHECK_P_NOT_PRIME,\n      DH_UNABLE_TO_CHECK_GENERATOR,\n      DH_NOT_SUITABLE_GENERATOR,\n      RSA_PKCS1_PADDING,\n      RSA_NO_PADDING,\n      RSA_PKCS1_OAEP_PADDING,\n      RSA_X931_PADDING,\n      RSA_PKCS1_PSS_PADDING,\n      RSA_PSS_SALTLEN_DIGEST,\n      RSA_PSS_SALTLEN_MAX_SIGN,\n      RSA_PSS_SALTLEN_AUTO,\n      defaultCoreCipherList,\n      TLS1_VERSION,\n      TLS1_1_VERSION,\n      TLS1_2_VERSION,\n      TLS1_3_VERSION,\n      POINT_CONVERSION_COMPRESSED,\n      POINT_CONVERSION_UNCOMPRESSED,\n      POINT_CONVERSION_HYBRID,\n      defaultCipherList\n    };\n  }\n});\n\n// node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs\nvar workerdCrypto, Certificate, checkPrime, checkPrimeSync, Cipheriv, createCipheriv, createDecipheriv, createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createHmac, createPrivateKey, createPublicKey, createSecretKey, createSign, createVerify, Decipheriv, diffieHellman, DiffieHellman, DiffieHellmanGroup, ECDH, fips, generateKey, generateKeyPair, generateKeyPairSync, generateKeySync, generatePrime, generatePrimeSync, getCipherInfo, getCiphers, getCurves, getDiffieHellman, getFips, getHashes, getRandomValues, hash, Hash, hkdf, hkdfSync, Hmac, KeyObject, pbkdf2, pbkdf2Sync, privateDecrypt, privateEncrypt, publicDecrypt, publicEncrypt, randomBytes, randomFill, randomFillSync, randomInt, randomUUID, scrypt, scryptSync, secureHeapUsed, setEngine, setFips, sign, Sign, subtle2, timingSafeEqual, verify, Verify, X509Certificate, webcrypto2, crypto_default;\nvar init_crypto2 = __esm({\n  \"node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs\"() {\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_crypto();\n    workerdCrypto = process.getBuiltinModule(\"node:crypto\");\n    ({\n      Certificate,\n      checkPrime,\n      checkPrimeSync,\n      Cipheriv: (\n        // @ts-expect-error\n        Cipheriv\n      ),\n      createCipheriv,\n      createDecipheriv,\n      createDiffieHellman,\n      createDiffieHellmanGroup,\n      createECDH,\n      createHash,\n      createHmac,\n      createPrivateKey,\n      createPublicKey,\n      createSecretKey,\n      createSign,\n      createVerify,\n      Decipheriv: (\n        // @ts-expect-error\n        Decipheriv\n      ),\n      diffieHellman,\n      DiffieHellman,\n      DiffieHellmanGroup,\n      ECDH,\n      fips,\n      generateKey,\n      generateKeyPair,\n      generateKeyPairSync,\n      generateKeySync,\n      generatePrime,\n      generatePrimeSync,\n      getCipherInfo,\n      getCiphers,\n      getCurves,\n      getDiffieHellman,\n      getFips,\n      getHashes,\n      getRandomValues,\n      hash,\n      Hash,\n      hkdf,\n      hkdfSync,\n      Hmac,\n      KeyObject,\n      pbkdf2,\n      pbkdf2Sync,\n      privateDecrypt,\n      privateEncrypt,\n      publicDecrypt,\n      publicEncrypt,\n      randomBytes,\n      randomFill,\n      randomFillSync,\n      randomInt,\n      randomUUID,\n      scrypt,\n      scryptSync,\n      secureHeapUsed,\n      setEngine,\n      setFips,\n      sign,\n      Sign,\n      subtle: subtle2,\n      timingSafeEqual,\n      verify,\n      Verify,\n      X509Certificate\n    } = workerdCrypto);\n    webcrypto2 = {\n      // @ts-expect-error\n      CryptoKey: webcrypto.CryptoKey,\n      getRandomValues,\n      randomUUID,\n      subtle: subtle2\n    };\n    crypto_default = {\n      /**\n       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable\n       */\n      Certificate,\n      Cipher,\n      Cipheriv,\n      Decipher,\n      Decipheriv,\n      ECDH,\n      Sign,\n      Verify,\n      X509Certificate,\n      // @ts-expect-error @types/node is out of date - this is a bug in typings\n      constants,\n      createCipheriv,\n      createDecipheriv,\n      createECDH,\n      createSign,\n      createVerify,\n      diffieHellman,\n      getCipherInfo,\n      hash,\n      privateDecrypt,\n      privateEncrypt,\n      publicDecrypt,\n      publicEncrypt,\n      scrypt,\n      scryptSync,\n      sign,\n      verify,\n      // default-only export from unenv\n      // @ts-expect-error unenv has unknown type\n      createCipher,\n      // @ts-expect-error unenv has unknown type\n      createDecipher,\n      // @ts-expect-error unenv has unknown type\n      pseudoRandomBytes,\n      /**\n       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable\n       */\n      DiffieHellman,\n      DiffieHellmanGroup,\n      Hash,\n      Hmac,\n      KeyObject,\n      checkPrime,\n      checkPrimeSync,\n      createDiffieHellman,\n      createDiffieHellmanGroup,\n      createHash,\n      createHmac,\n      createPrivateKey,\n      createPublicKey,\n      createSecretKey,\n      generateKey,\n      generateKeyPair,\n      generateKeyPairSync,\n      generateKeySync,\n      generatePrime,\n      generatePrimeSync,\n      getCiphers,\n      getCurves,\n      getDiffieHellman,\n      getFips,\n      getHashes,\n      getRandomValues,\n      hkdf,\n      hkdfSync,\n      pbkdf2,\n      pbkdf2Sync,\n      randomBytes,\n      randomFill,\n      randomFillSync,\n      randomInt,\n      randomUUID,\n      secureHeapUsed,\n      setEngine,\n      setFips,\n      subtle: subtle2,\n      timingSafeEqual,\n      // default-only export from workerd\n      fips,\n      // special-cased deep merged symbols\n      webcrypto: webcrypto2\n    };\n  }\n});\n\n// dist/_worker.js/chunks/bknd.config_m27Qk-4t.mjs\nimport { Readable } from \"stream\";\nfunction IsAsyncIterator$3(value2) {\n  return IsObject$3(value2) && globalThis.Symbol.asyncIterator in value2;\n}\nfunction IsIterator$3(value2) {\n  return IsObject$3(value2) && globalThis.Symbol.iterator in value2;\n}\nfunction IsPromise$2(value2) {\n  return value2 instanceof globalThis.Promise;\n}\nfunction IsDate$3(value2) {\n  return value2 instanceof Date && globalThis.Number.isFinite(value2.getTime());\n}\nfunction IsMap(value2) {\n  return value2 instanceof globalThis.Map;\n}\nfunction IsSet(value2) {\n  return value2 instanceof globalThis.Set;\n}\nfunction IsTypedArray(value2) {\n  return globalThis.ArrayBuffer.isView(value2);\n}\nfunction IsUint8Array$3(value2) {\n  return value2 instanceof globalThis.Uint8Array;\n}\nfunction HasPropertyKey$1(value2, key) {\n  return key in value2;\n}\nfunction IsObject$3(value2) {\n  return value2 !== null && typeof value2 === \"object\";\n}\nfunction IsArray$3(value2) {\n  return globalThis.Array.isArray(value2) && !globalThis.ArrayBuffer.isView(value2);\n}\nfunction IsUndefined$3(value2) {\n  return value2 === void 0;\n}\nfunction IsNull$3(value2) {\n  return value2 === null;\n}\nfunction IsBoolean$3(value2) {\n  return typeof value2 === \"boolean\";\n}\nfunction IsNumber$3(value2) {\n  return typeof value2 === \"number\";\n}\nfunction IsInteger$2(value2) {\n  return globalThis.Number.isInteger(value2);\n}\nfunction IsBigInt$3(value2) {\n  return typeof value2 === \"bigint\";\n}\nfunction IsString$3(value2) {\n  return typeof value2 === \"string\";\n}\nfunction IsFunction$3(value2) {\n  return typeof value2 === \"function\";\n}\nfunction IsSymbol$3(value2) {\n  return typeof value2 === \"symbol\";\n}\nfunction IsValueType(value2) {\n  return IsBigInt$3(value2) || IsBoolean$3(value2) || IsNull$3(value2) || IsNumber$3(value2) || IsString$3(value2) || IsSymbol$3(value2) || IsUndefined$3(value2);\n}\nfunction Entries$1() {\n  return new Map(map$1);\n}\nfunction Clear$1() {\n  return map$1.clear();\n}\nfunction Delete$1(format2) {\n  return map$1.delete(format2);\n}\nfunction Has$1(format2) {\n  return map$1.has(format2);\n}\nfunction Set$3(format2, func) {\n  map$1.set(format2, func);\n}\nfunction Get$1(format2) {\n  return map$1.get(format2);\n}\nfunction Entries() {\n  return new Map(map);\n}\nfunction Clear() {\n  return map.clear();\n}\nfunction Delete(kind2) {\n  return map.delete(kind2);\n}\nfunction Has(kind2) {\n  return map.has(kind2);\n}\nfunction Set$2(kind2, func) {\n  map.set(kind2, func);\n}\nfunction Get(kind2) {\n  return map.get(kind2);\n}\nfunction HasPropertyKey(value2, key) {\n  return key in value2;\n}\nfunction IsAsyncIterator$2(value2) {\n  return IsObject$2(value2) && !IsArray$2(value2) && !IsUint8Array$2(value2) && Symbol.asyncIterator in value2;\n}\nfunction IsArray$2(value2) {\n  return Array.isArray(value2);\n}\nfunction IsBigInt$2(value2) {\n  return typeof value2 === \"bigint\";\n}\nfunction IsBoolean$2(value2) {\n  return typeof value2 === \"boolean\";\n}\nfunction IsDate$2(value2) {\n  return value2 instanceof globalThis.Date;\n}\nfunction IsFunction$2(value2) {\n  return typeof value2 === \"function\";\n}\nfunction IsIterator$2(value2) {\n  return IsObject$2(value2) && !IsArray$2(value2) && !IsUint8Array$2(value2) && Symbol.iterator in value2;\n}\nfunction IsNull$2(value2) {\n  return value2 === null;\n}\nfunction IsNumber$2(value2) {\n  return typeof value2 === \"number\";\n}\nfunction IsObject$2(value2) {\n  return typeof value2 === \"object\" && value2 !== null;\n}\nfunction IsRegExp$2(value2) {\n  return value2 instanceof globalThis.RegExp;\n}\nfunction IsString$2(value2) {\n  return typeof value2 === \"string\";\n}\nfunction IsSymbol$2(value2) {\n  return typeof value2 === \"symbol\";\n}\nfunction IsUint8Array$2(value2) {\n  return value2 instanceof globalThis.Uint8Array;\n}\nfunction IsUndefined$2(value2) {\n  return value2 === void 0;\n}\nfunction ImmutableArray(value2) {\n  return globalThis.Object.freeze(value2).map((value3) => Immutable(value3));\n}\nfunction ImmutableDate(value2) {\n  return value2;\n}\nfunction ImmutableUint8Array(value2) {\n  return value2;\n}\nfunction ImmutableRegExp(value2) {\n  return value2;\n}\nfunction ImmutableObject(value2) {\n  const result = {};\n  for (const key of Object.getOwnPropertyNames(value2)) {\n    result[key] = Immutable(value2[key]);\n  }\n  for (const key of Object.getOwnPropertySymbols(value2)) {\n    result[key] = Immutable(value2[key]);\n  }\n  return globalThis.Object.freeze(result);\n}\nfunction Immutable(value$1) {\n  return IsArray$2(value$1) ? ImmutableArray(value$1) : IsDate$2(value$1) ? ImmutableDate(value$1) : IsUint8Array$2(value$1) ? ImmutableUint8Array(value$1) : IsRegExp$2(value$1) ? ImmutableRegExp(value$1) : IsObject$2(value$1) ? ImmutableObject(value$1) : value$1;\n}\nfunction ArrayType$1(value2) {\n  return value2.map((value3) => Visit$8(value3));\n}\nfunction DateType$1(value2) {\n  return new Date(value2.getTime());\n}\nfunction Uint8ArrayType$1(value2) {\n  return new Uint8Array(value2);\n}\nfunction RegExpType(value2) {\n  return new RegExp(value2.source, value2.flags);\n}\nfunction ObjectType$1(value2) {\n  const result = {};\n  for (const key of Object.getOwnPropertyNames(value2)) {\n    result[key] = Visit$8(value2[key]);\n  }\n  for (const key of Object.getOwnPropertySymbols(value2)) {\n    result[key] = Visit$8(value2[key]);\n  }\n  return result;\n}\nfunction Visit$8(value$1) {\n  return IsArray$2(value$1) ? ArrayType$1(value$1) : IsDate$2(value$1) ? DateType$1(value$1) : IsUint8Array$2(value$1) ? Uint8ArrayType$1(value$1) : IsRegExp$2(value$1) ? RegExpType(value$1) : IsObject$2(value$1) ? ObjectType$1(value$1) : value$1;\n}\nfunction Clone$1(value2) {\n  return Visit$8(value2);\n}\nfunction CreateType(schema2, options) {\n  const result = options !== void 0 ? { ...options, ...schema2 } : schema2;\n  switch (TypeSystemPolicy.InstanceMode) {\n    case \"freeze\":\n      return Immutable(result);\n    case \"clone\":\n      return Clone$1(result);\n    default:\n      return result;\n  }\n}\nfunction Unsafe(options = {}) {\n  return CreateType({ [Kind]: options[Kind] ?? \"Unsafe\" }, options);\n}\nfunction MappedKey(T2) {\n  return CreateType({\n    [Kind]: \"MappedKey\",\n    keys: T2\n  });\n}\nfunction MappedResult(properties) {\n  return CreateType({\n    [Kind]: \"MappedResult\",\n    properties\n  });\n}\nfunction DiscardKey(value2, key) {\n  const { [key]: _3, ...rest } = value2;\n  return rest;\n}\nfunction Discard(value2, keys2) {\n  return keys2.reduce((acc, key) => DiscardKey(acc, key), value2);\n}\nfunction Array$1(items, options) {\n  return CreateType({ [Kind]: \"Array\", type: \"array\", items }, options);\n}\nfunction AsyncIterator(items, options) {\n  return CreateType({ [Kind]: \"AsyncIterator\", type: \"AsyncIterator\", items }, options);\n}\nfunction Constructor(parameters, returns, options) {\n  return CreateType({ [Kind]: \"Constructor\", type: \"Constructor\", parameters, returns }, options);\n}\nfunction Function$1(parameters, returns, options) {\n  return CreateType({ [Kind]: \"Function\", type: \"Function\", parameters, returns }, options);\n}\nfunction Computed(target, parameters, options) {\n  return CreateType({ [Kind]: \"Computed\", target, parameters }, options);\n}\nfunction Never(options) {\n  return CreateType({ [Kind]: \"Never\", not: {} }, options);\n}\nfunction IsReadonly$1(value$1) {\n  return IsObject$2(value$1) && value$1[ReadonlyKind] === \"Readonly\";\n}\nfunction IsOptional$1(value$1) {\n  return IsObject$2(value$1) && value$1[OptionalKind] === \"Optional\";\n}\nfunction IsAny$1(value2) {\n  return IsKindOf$1(value2, \"Any\");\n}\nfunction IsArgument$1(value2) {\n  return IsKindOf$1(value2, \"Argument\");\n}\nfunction IsArray$1(value2) {\n  return IsKindOf$1(value2, \"Array\");\n}\nfunction IsAsyncIterator$1(value2) {\n  return IsKindOf$1(value2, \"AsyncIterator\");\n}\nfunction IsBigInt$1(value2) {\n  return IsKindOf$1(value2, \"BigInt\");\n}\nfunction IsBoolean$1(value2) {\n  return IsKindOf$1(value2, \"Boolean\");\n}\nfunction IsComputed$1(value2) {\n  return IsKindOf$1(value2, \"Computed\");\n}\nfunction IsConstructor$1(value2) {\n  return IsKindOf$1(value2, \"Constructor\");\n}\nfunction IsDate$1(value2) {\n  return IsKindOf$1(value2, \"Date\");\n}\nfunction IsFunction$1(value2) {\n  return IsKindOf$1(value2, \"Function\");\n}\nfunction IsImport$1(value2) {\n  return IsKindOf$1(value2, \"Import\");\n}\nfunction IsInteger$1(value2) {\n  return IsKindOf$1(value2, \"Integer\");\n}\nfunction IsProperties$1(value$1) {\n  return IsObject$2(value$1);\n}\nfunction IsIntersect$1(value2) {\n  return IsKindOf$1(value2, \"Intersect\");\n}\nfunction IsIterator$1(value2) {\n  return IsKindOf$1(value2, \"Iterator\");\n}\nfunction IsKindOf$1(value$1, kind2) {\n  return IsObject$2(value$1) && Kind in value$1 && value$1[Kind] === kind2;\n}\nfunction IsLiteralString$1(value$1) {\n  return IsLiteral$1(value$1) && IsString$2(value$1.const);\n}\nfunction IsLiteralNumber$1(value$1) {\n  return IsLiteral$1(value$1) && IsNumber$2(value$1.const);\n}\nfunction IsLiteralBoolean$1(value$1) {\n  return IsLiteral$1(value$1) && IsBoolean$2(value$1.const);\n}\nfunction IsLiteralValue$1(value$1) {\n  return IsBoolean$2(value$1) || IsNumber$2(value$1) || IsString$2(value$1);\n}\nfunction IsLiteral$1(value2) {\n  return IsKindOf$1(value2, \"Literal\");\n}\nfunction IsMappedKey$1(value2) {\n  return IsKindOf$1(value2, \"MappedKey\");\n}\nfunction IsMappedResult$1(value2) {\n  return IsKindOf$1(value2, \"MappedResult\");\n}\nfunction IsNever$1(value2) {\n  return IsKindOf$1(value2, \"Never\");\n}\nfunction IsNot$1(value2) {\n  return IsKindOf$1(value2, \"Not\");\n}\nfunction IsNull$1(value2) {\n  return IsKindOf$1(value2, \"Null\");\n}\nfunction IsNumber$1(value2) {\n  return IsKindOf$1(value2, \"Number\");\n}\nfunction IsObject$1(value2) {\n  return IsKindOf$1(value2, \"Object\");\n}\nfunction IsPromise$1(value2) {\n  return IsKindOf$1(value2, \"Promise\");\n}\nfunction IsRecord$1(value2) {\n  return IsKindOf$1(value2, \"Record\");\n}\nfunction IsRecursive$1(value$1) {\n  return IsObject$2(value$1) && Hint in value$1 && value$1[Hint] === \"Recursive\";\n}\nfunction IsRef$1(value2) {\n  return IsKindOf$1(value2, \"Ref\");\n}\nfunction IsRegExp$1(value2) {\n  return IsKindOf$1(value2, \"RegExp\");\n}\nfunction IsString$1(value2) {\n  return IsKindOf$1(value2, \"String\");\n}\nfunction IsSymbol$1(value2) {\n  return IsKindOf$1(value2, \"Symbol\");\n}\nfunction IsTemplateLiteral$1(value2) {\n  return IsKindOf$1(value2, \"TemplateLiteral\");\n}\nfunction IsThis$1(value2) {\n  return IsKindOf$1(value2, \"This\");\n}\nfunction IsTransform$1(value$1) {\n  return IsObject$2(value$1) && TransformKind in value$1;\n}\nfunction IsTuple$1(value2) {\n  return IsKindOf$1(value2, \"Tuple\");\n}\nfunction IsUndefined$1(value2) {\n  return IsKindOf$1(value2, \"Undefined\");\n}\nfunction IsUnion$1(value2) {\n  return IsKindOf$1(value2, \"Union\");\n}\nfunction IsUint8Array$1(value2) {\n  return IsKindOf$1(value2, \"Uint8Array\");\n}\nfunction IsUnknown$1(value2) {\n  return IsKindOf$1(value2, \"Unknown\");\n}\nfunction IsUnsafe$1(value2) {\n  return IsKindOf$1(value2, \"Unsafe\");\n}\nfunction IsVoid$1(value2) {\n  return IsKindOf$1(value2, \"Void\");\n}\nfunction IsKind$1(value$1) {\n  return IsObject$2(value$1) && Kind in value$1 && IsString$2(value$1[Kind]);\n}\nfunction IsSchema$1(value2) {\n  return IsAny$1(value2) || IsArgument$1(value2) || IsArray$1(value2) || IsBoolean$1(value2) || IsBigInt$1(value2) || IsAsyncIterator$1(value2) || IsComputed$1(value2) || IsConstructor$1(value2) || IsDate$1(value2) || IsFunction$1(value2) || IsInteger$1(value2) || IsIntersect$1(value2) || IsIterator$1(value2) || IsLiteral$1(value2) || IsMappedKey$1(value2) || IsMappedResult$1(value2) || IsNever$1(value2) || IsNot$1(value2) || IsNull$1(value2) || IsNumber$1(value2) || IsObject$1(value2) || IsPromise$1(value2) || IsRecord$1(value2) || IsRef$1(value2) || IsRegExp$1(value2) || IsString$1(value2) || IsSymbol$1(value2) || IsTemplateLiteral$1(value2) || IsThis$1(value2) || IsTuple$1(value2) || IsUndefined$1(value2) || IsUnion$1(value2) || IsUint8Array$1(value2) || IsUnknown$1(value2) || IsUnsafe$1(value2) || IsVoid$1(value2) || IsKind$1(value2);\n}\nfunction RemoveOptional(schema2) {\n  return CreateType(Discard(schema2, [OptionalKind]));\n}\nfunction AddOptional(schema2) {\n  return CreateType({ ...schema2, [OptionalKind]: \"Optional\" });\n}\nfunction OptionalWithFlag(schema2, F2) {\n  return F2 === false ? RemoveOptional(schema2) : AddOptional(schema2);\n}\nfunction Optional(schema2, enable) {\n  const F2 = enable ?? true;\n  return IsMappedResult$1(schema2) ? OptionalFromMappedResult(schema2, F2) : OptionalWithFlag(schema2, F2);\n}\nfunction FromProperties$i(P3, F2) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))\n    Acc[K2] = Optional(P3[K2], F2);\n  return Acc;\n}\nfunction FromMappedResult$b(R4, F2) {\n  return FromProperties$i(R4.properties, F2);\n}\nfunction OptionalFromMappedResult(R4, F2) {\n  const P3 = FromMappedResult$b(R4, F2);\n  return MappedResult(P3);\n}\nfunction IntersectCreate(T2, options = {}) {\n  const allObjects = T2.every((schema2) => IsObject$1(schema2));\n  const clonedUnevaluatedProperties = IsSchema$1(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};\n  return CreateType(options.unevaluatedProperties === false || IsSchema$1(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: \"Intersect\", type: \"object\", allOf: T2 } : { ...clonedUnevaluatedProperties, [Kind]: \"Intersect\", allOf: T2 }, options);\n}\nfunction IsIntersectOptional(types) {\n  return types.every((left) => IsOptional$1(left));\n}\nfunction RemoveOptionalFromType$1(type2) {\n  return Discard(type2, [OptionalKind]);\n}\nfunction RemoveOptionalFromRest$1(types) {\n  return types.map((left) => IsOptional$1(left) ? RemoveOptionalFromType$1(left) : left);\n}\nfunction ResolveIntersect(types, options) {\n  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest$1(types), options)) : IntersectCreate(RemoveOptionalFromRest$1(types), options);\n}\nfunction IntersectEvaluated(types, options = {}) {\n  if (types.length === 1)\n    return CreateType(types[0], options);\n  if (types.length === 0)\n    return Never(options);\n  if (types.some((schema2) => IsTransform$1(schema2)))\n    throw new Error(\"Cannot intersect transform types\");\n  return ResolveIntersect(types, options);\n}\nfunction Intersect$1(types, options) {\n  if (types.length === 1)\n    return CreateType(types[0], options);\n  if (types.length === 0)\n    return Never(options);\n  if (types.some((schema2) => IsTransform$1(schema2)))\n    throw new Error(\"Cannot intersect transform types\");\n  return IntersectCreate(types, options);\n}\nfunction UnionCreate(T2, options) {\n  return CreateType({ [Kind]: \"Union\", anyOf: T2 }, options);\n}\nfunction IsUnionOptional(types) {\n  return types.some((type2) => IsOptional$1(type2));\n}\nfunction RemoveOptionalFromRest(types) {\n  return types.map((left) => IsOptional$1(left) ? RemoveOptionalFromType(left) : left);\n}\nfunction RemoveOptionalFromType(T2) {\n  return Discard(T2, [OptionalKind]);\n}\nfunction ResolveUnion(types, options) {\n  const isOptional = IsUnionOptional(types);\n  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);\n}\nfunction UnionEvaluated(T2, options) {\n  return T2.length === 1 ? CreateType(T2[0], options) : T2.length === 0 ? Never(options) : ResolveUnion(T2, options);\n}\nfunction Union$1(types, options) {\n  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);\n}\nfunction Unescape(pattern) {\n  return pattern.replace(/\\\\\\$/g, \"$\").replace(/\\\\\\*/g, \"*\").replace(/\\\\\\^/g, \"^\").replace(/\\\\\\|/g, \"|\").replace(/\\\\\\(/g, \"(\").replace(/\\\\\\)/g, \")\");\n}\nfunction IsNonEscaped(pattern, index, char) {\n  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n}\nfunction IsOpenParen(pattern, index) {\n  return IsNonEscaped(pattern, index, \"(\");\n}\nfunction IsCloseParen(pattern, index) {\n  return IsNonEscaped(pattern, index, \")\");\n}\nfunction IsSeparator(pattern, index) {\n  return IsNonEscaped(pattern, index, \"|\");\n}\nfunction IsGroup(pattern) {\n  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n    return false;\n  let count3 = 0;\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index))\n      count3 += 1;\n    if (IsCloseParen(pattern, index))\n      count3 -= 1;\n    if (count3 === 0 && index !== pattern.length - 1)\n      return false;\n  }\n  return true;\n}\nfunction InGroup(pattern) {\n  return pattern.slice(1, pattern.length - 1);\n}\nfunction IsPrecedenceOr(pattern) {\n  let count3 = 0;\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index))\n      count3 += 1;\n    if (IsCloseParen(pattern, index))\n      count3 -= 1;\n    if (IsSeparator(pattern, index) && count3 === 0)\n      return true;\n  }\n  return false;\n}\nfunction IsPrecedenceAnd(pattern) {\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index))\n      return true;\n  }\n  return false;\n}\nfunction Or$2(pattern) {\n  let [count3, start] = [0, 0];\n  const expressions = [];\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index))\n      count3 += 1;\n    if (IsCloseParen(pattern, index))\n      count3 -= 1;\n    if (IsSeparator(pattern, index) && count3 === 0) {\n      const range2 = pattern.slice(start, index);\n      if (range2.length > 0)\n        expressions.push(TemplateLiteralParse(range2));\n      start = index + 1;\n    }\n  }\n  const range = pattern.slice(start);\n  if (range.length > 0)\n    expressions.push(TemplateLiteralParse(range));\n  if (expressions.length === 0)\n    return { type: \"const\", const: \"\" };\n  if (expressions.length === 1)\n    return expressions[0];\n  return { type: \"or\", expr: expressions };\n}\nfunction And(pattern) {\n  function Group(value2, index) {\n    if (!IsOpenParen(value2, index))\n      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n    let count3 = 0;\n    for (let scan = index; scan < value2.length; scan++) {\n      if (IsOpenParen(value2, scan))\n        count3 += 1;\n      if (IsCloseParen(value2, scan))\n        count3 -= 1;\n      if (count3 === 0)\n        return [index, scan];\n    }\n    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n  }\n  __name(Group, \"Group\");\n  function Range(pattern2, index) {\n    for (let scan = index; scan < pattern2.length; scan++) {\n      if (IsOpenParen(pattern2, scan))\n        return [index, scan];\n    }\n    return [index, pattern2.length];\n  }\n  __name(Range, \"Range\");\n  const expressions = [];\n  for (let index = 0; index < pattern.length; index++) {\n    if (IsOpenParen(pattern, index)) {\n      const [start, end] = Group(pattern, index);\n      const range = pattern.slice(start, end + 1);\n      expressions.push(TemplateLiteralParse(range));\n      index = end;\n    } else {\n      const [start, end] = Range(pattern, index);\n      const range = pattern.slice(start, end);\n      if (range.length > 0)\n        expressions.push(TemplateLiteralParse(range));\n      index = end - 1;\n    }\n  }\n  return expressions.length === 0 ? { type: \"const\", const: \"\" } : expressions.length === 1 ? expressions[0] : { type: \"and\", expr: expressions };\n}\nfunction TemplateLiteralParse(pattern) {\n  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or$2(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: \"const\", const: Unescape(pattern) };\n}\nfunction TemplateLiteralParseExact(pattern) {\n  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));\n}\nfunction IsNumberExpression(expression) {\n  return expression.type === \"or\" && expression.expr.length === 2 && expression.expr[0].type === \"const\" && expression.expr[0].const === \"0\" && expression.expr[1].type === \"const\" && expression.expr[1].const === \"[1-9][0-9]*\";\n}\nfunction IsBooleanExpression(expression) {\n  return expression.type === \"or\" && expression.expr.length === 2 && expression.expr[0].type === \"const\" && expression.expr[0].const === \"true\" && expression.expr[1].type === \"const\" && expression.expr[1].const === \"false\";\n}\nfunction IsStringExpression(expression) {\n  return expression.type === \"const\" && expression.const === \".*\";\n}\nfunction IsTemplateLiteralExpressionFinite(expression) {\n  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === \"and\" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === \"or\" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === \"const\" ? true : (() => {\n    throw new TemplateLiteralFiniteError(`Unknown expression type`);\n  })();\n}\nfunction IsTemplateLiteralFinite(schema2) {\n  const expression = TemplateLiteralParseExact(schema2.pattern);\n  return IsTemplateLiteralExpressionFinite(expression);\n}\nfunction* GenerateReduce(buffer) {\n  if (buffer.length === 1)\n    return yield* buffer[0];\n  for (const left of buffer[0]) {\n    for (const right of GenerateReduce(buffer.slice(1))) {\n      yield `${left}${right}`;\n    }\n  }\n}\nfunction* GenerateAnd(expression) {\n  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));\n}\nfunction* GenerateOr(expression) {\n  for (const expr of expression.expr)\n    yield* TemplateLiteralExpressionGenerate(expr);\n}\nfunction* GenerateConst(expression) {\n  return yield expression.const;\n}\nfunction* TemplateLiteralExpressionGenerate(expression) {\n  return expression.type === \"and\" ? yield* GenerateAnd(expression) : expression.type === \"or\" ? yield* GenerateOr(expression) : expression.type === \"const\" ? yield* GenerateConst(expression) : (() => {\n    throw new TemplateLiteralGenerateError(\"Unknown expression\");\n  })();\n}\nfunction TemplateLiteralGenerate(schema2) {\n  const expression = TemplateLiteralParseExact(schema2.pattern);\n  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];\n}\nfunction Literal(value2, options) {\n  return CreateType({\n    [Kind]: \"Literal\",\n    const: value2,\n    type: typeof value2\n  }, options);\n}\nfunction Boolean$1(options) {\n  return CreateType({ [Kind]: \"Boolean\", type: \"boolean\" }, options);\n}\nfunction BigInt$1(options) {\n  return CreateType({ [Kind]: \"BigInt\", type: \"bigint\" }, options);\n}\nfunction Number$1(options) {\n  return CreateType({ [Kind]: \"Number\", type: \"number\" }, options);\n}\nfunction String$1(options) {\n  return CreateType({ [Kind]: \"String\", type: \"string\" }, options);\n}\nfunction* FromUnion$e(syntax) {\n  const trim2 = syntax.trim().replace(/\"|'/g, \"\");\n  return trim2 === \"boolean\" ? yield Boolean$1() : trim2 === \"number\" ? yield Number$1() : trim2 === \"bigint\" ? yield BigInt$1() : trim2 === \"string\" ? yield String$1() : yield (() => {\n    const literals = trim2.split(\"|\").map((literal) => Literal(literal.trim()));\n    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);\n  })();\n}\nfunction* FromTerminal(syntax) {\n  if (syntax[1] !== \"{\") {\n    const L2 = Literal(\"$\");\n    const R4 = FromSyntax(syntax.slice(1));\n    return yield* [L2, ...R4];\n  }\n  for (let i = 2; i < syntax.length; i++) {\n    if (syntax[i] === \"}\") {\n      const L2 = FromUnion$e(syntax.slice(2, i));\n      const R4 = FromSyntax(syntax.slice(i + 1));\n      return yield* [...L2, ...R4];\n    }\n  }\n  yield Literal(syntax);\n}\nfunction* FromSyntax(syntax) {\n  for (let i = 0; i < syntax.length; i++) {\n    if (syntax[i] === \"$\") {\n      const L2 = Literal(syntax.slice(0, i));\n      const R4 = FromTerminal(syntax.slice(i));\n      return yield* [L2, ...R4];\n    }\n  }\n  yield Literal(syntax);\n}\nfunction TemplateLiteralSyntax(syntax) {\n  return [...FromSyntax(syntax)];\n}\nfunction Escape(value2) {\n  return value2.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction Visit$7(schema2, acc) {\n  return IsTemplateLiteral$1(schema2) ? schema2.pattern.slice(1, schema2.pattern.length - 1) : IsUnion$1(schema2) ? `(${schema2.anyOf.map((schema3) => Visit$7(schema3, acc)).join(\"|\")})` : IsNumber$1(schema2) ? `${acc}${PatternNumber}` : IsInteger$1(schema2) ? `${acc}${PatternNumber}` : IsBigInt$1(schema2) ? `${acc}${PatternNumber}` : IsString$1(schema2) ? `${acc}${PatternString}` : IsLiteral$1(schema2) ? `${acc}${Escape(schema2.const.toString())}` : IsBoolean$1(schema2) ? `${acc}${PatternBoolean}` : (() => {\n    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema2[Kind]}'`);\n  })();\n}\nfunction TemplateLiteralPattern(kinds) {\n  return `^${kinds.map((schema2) => Visit$7(schema2, \"\")).join(\"\")}$`;\n}\nfunction TemplateLiteralToUnion(schema2) {\n  const R4 = TemplateLiteralGenerate(schema2);\n  const L2 = R4.map((S2) => Literal(S2));\n  return UnionEvaluated(L2);\n}\nfunction TemplateLiteral(unresolved, options) {\n  const pattern = IsString$2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);\n  return CreateType({ [Kind]: \"TemplateLiteral\", type: \"string\", pattern }, options);\n}\nfunction FromTemplateLiteral$4(templateLiteral) {\n  const keys2 = TemplateLiteralGenerate(templateLiteral);\n  return keys2.map((key) => key.toString());\n}\nfunction FromUnion$d(types) {\n  const result = [];\n  for (const type2 of types)\n    result.push(...IndexPropertyKeys(type2));\n  return result;\n}\nfunction FromLiteral$3(literalValue) {\n  return [literalValue.toString()];\n}\nfunction IndexPropertyKeys(type2) {\n  return [...new Set(IsTemplateLiteral$1(type2) ? FromTemplateLiteral$4(type2) : IsUnion$1(type2) ? FromUnion$d(type2.anyOf) : IsLiteral$1(type2) ? FromLiteral$3(type2.const) : IsNumber$1(type2) ? [\"[number]\"] : IsInteger$1(type2) ? [\"[number]\"] : [])];\n}\nfunction FromProperties$h(type2, properties, options) {\n  const result = {};\n  for (const K2 of Object.getOwnPropertyNames(properties)) {\n    result[K2] = Index(type2, IndexPropertyKeys(properties[K2]), options);\n  }\n  return result;\n}\nfunction FromMappedResult$a(type2, mappedResult, options) {\n  return FromProperties$h(type2, mappedResult.properties, options);\n}\nfunction IndexFromMappedResult(type2, mappedResult, options) {\n  const properties = FromMappedResult$a(type2, mappedResult, options);\n  return MappedResult(properties);\n}\nfunction FromRest$6(types, key) {\n  return types.map((type2) => IndexFromPropertyKey(type2, key));\n}\nfunction FromIntersectRest(types) {\n  return types.filter((type2) => !IsNever$1(type2));\n}\nfunction FromIntersect$c(types, key) {\n  return IntersectEvaluated(FromIntersectRest(FromRest$6(types, key)));\n}\nfunction FromUnionRest(types) {\n  return types.some((L2) => IsNever$1(L2)) ? [] : types;\n}\nfunction FromUnion$c(types, key) {\n  return UnionEvaluated(FromUnionRest(FromRest$6(types, key)));\n}\nfunction FromTuple$9(types, key) {\n  return key in types ? types[key] : key === \"[number]\" ? UnionEvaluated(types) : Never();\n}\nfunction FromArray$b(type2, key) {\n  return key === \"[number]\" ? type2 : Never();\n}\nfunction FromProperty$2(properties, propertyKey) {\n  return propertyKey in properties ? properties[propertyKey] : Never();\n}\nfunction IndexFromPropertyKey(type2, propertyKey) {\n  return IsIntersect$1(type2) ? FromIntersect$c(type2.allOf, propertyKey) : IsUnion$1(type2) ? FromUnion$c(type2.anyOf, propertyKey) : IsTuple$1(type2) ? FromTuple$9(type2.items ?? [], propertyKey) : IsArray$1(type2) ? FromArray$b(type2.items, propertyKey) : IsObject$1(type2) ? FromProperty$2(type2.properties, propertyKey) : Never();\n}\nfunction IndexFromPropertyKeys(type2, propertyKeys) {\n  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type2, propertyKey));\n}\nfunction FromSchema(type2, propertyKeys) {\n  return UnionEvaluated(IndexFromPropertyKeys(type2, propertyKeys));\n}\nfunction IndexFromComputed(type2, key) {\n  return Computed(\"Index\", [type2, key]);\n}\nfunction Index(type2, key, options) {\n  if (IsRef$1(type2) || IsRef$1(key)) {\n    const error4 = `Index types using Ref parameters require both Type and Key to be of TSchema`;\n    if (!IsSchema$1(type2) || !IsSchema$1(key))\n      throw new TypeBoxError(error4);\n    return Computed(\"Index\", [type2, key]);\n  }\n  if (IsMappedResult$1(key))\n    return IndexFromMappedResult(type2, key, options);\n  if (IsMappedKey$1(key))\n    return IndexFromMappedKey(type2, key, options);\n  return CreateType(IsSchema$1(key) ? FromSchema(type2, IndexPropertyKeys(key)) : FromSchema(type2, key), options);\n}\nfunction MappedIndexPropertyKey(type2, key, options) {\n  return { [key]: Index(type2, [key], Clone$1(options)) };\n}\nfunction MappedIndexPropertyKeys(type2, propertyKeys, options) {\n  return propertyKeys.reduce((result, left) => {\n    return { ...result, ...MappedIndexPropertyKey(type2, left, options) };\n  }, {});\n}\nfunction MappedIndexProperties(type2, mappedKey, options) {\n  return MappedIndexPropertyKeys(type2, mappedKey.keys, options);\n}\nfunction IndexFromMappedKey(type2, mappedKey, options) {\n  const properties = MappedIndexProperties(type2, mappedKey, options);\n  return MappedResult(properties);\n}\nfunction Iterator(items, options) {\n  return CreateType({ [Kind]: \"Iterator\", type: \"Iterator\", items }, options);\n}\nfunction RequiredKeys(properties) {\n  const keys2 = [];\n  for (let key in properties) {\n    if (!IsOptional$1(properties[key]))\n      keys2.push(key);\n  }\n  return keys2;\n}\nfunction _Object(properties, options) {\n  const required = RequiredKeys(properties);\n  const schematic = required.length > 0 ? { [Kind]: \"Object\", type: \"object\", properties, required } : { [Kind]: \"Object\", type: \"object\", properties };\n  return CreateType(schematic, options);\n}\nfunction Promise$2(item, options) {\n  return CreateType({ [Kind]: \"Promise\", type: \"Promise\", item }, options);\n}\nfunction RemoveReadonly(schema2) {\n  return CreateType(Discard(schema2, [ReadonlyKind]));\n}\nfunction AddReadonly(schema2) {\n  return CreateType({ ...schema2, [ReadonlyKind]: \"Readonly\" });\n}\nfunction ReadonlyWithFlag(schema2, F2) {\n  return F2 === false ? RemoveReadonly(schema2) : AddReadonly(schema2);\n}\nfunction Readonly(schema2, enable) {\n  const F2 = enable ?? true;\n  return IsMappedResult$1(schema2) ? ReadonlyFromMappedResult(schema2, F2) : ReadonlyWithFlag(schema2, F2);\n}\nfunction FromProperties$g(K2, F2) {\n  const Acc = {};\n  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))\n    Acc[K22] = Readonly(K2[K22], F2);\n  return Acc;\n}\nfunction FromMappedResult$9(R4, F2) {\n  return FromProperties$g(R4.properties, F2);\n}\nfunction ReadonlyFromMappedResult(R4, F2) {\n  const P3 = FromMappedResult$9(R4, F2);\n  return MappedResult(P3);\n}\nfunction Tuple(types, options) {\n  return CreateType(types.length > 0 ? { [Kind]: \"Tuple\", type: \"array\", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: \"Tuple\", type: \"array\", minItems: types.length, maxItems: types.length }, options);\n}\nfunction SetIncludes(T2, S2) {\n  return T2.includes(S2);\n}\nfunction SetIsSubset(T2, S2) {\n  return T2.every((L2) => SetIncludes(S2, L2));\n}\nfunction SetDistinct(T2) {\n  return [...new Set(T2)];\n}\nfunction SetIntersect(T2, S2) {\n  return T2.filter((L2) => S2.includes(L2));\n}\nfunction SetUnion(T2, S2) {\n  return [...T2, ...S2];\n}\nfunction SetComplement(T2, S2) {\n  return T2.filter((L2) => !S2.includes(L2));\n}\nfunction SetIntersectManyResolve(T2, Init) {\n  return T2.reduce((Acc, L2) => {\n    return SetIntersect(Acc, L2);\n  }, Init);\n}\nfunction SetIntersectMany(T2) {\n  return T2.length === 1 ? T2[0] : T2.length > 1 ? SetIntersectManyResolve(T2.slice(1), T2[0]) : [];\n}\nfunction SetUnionMany(T2) {\n  const Acc = [];\n  for (const L2 of T2)\n    Acc.push(...L2);\n  return Acc;\n}\nfunction FromMappedResult$8(K2, P3) {\n  return K2 in P3 ? FromSchemaType(K2, P3[K2]) : MappedResult(P3);\n}\nfunction MappedKeyToKnownMappedResultProperties(K2) {\n  return { [K2]: Literal(K2) };\n}\nfunction MappedKeyToUnknownMappedResultProperties(P3) {\n  const Acc = {};\n  for (const L2 of P3)\n    Acc[L2] = Literal(L2);\n  return Acc;\n}\nfunction MappedKeyToMappedResultProperties(K2, P3) {\n  return SetIncludes(P3, K2) ? MappedKeyToKnownMappedResultProperties(K2) : MappedKeyToUnknownMappedResultProperties(P3);\n}\nfunction FromMappedKey$3(K2, P3) {\n  const R4 = MappedKeyToMappedResultProperties(K2, P3);\n  return FromMappedResult$8(K2, R4);\n}\nfunction FromRest$5(K2, T2) {\n  return T2.map((L2) => FromSchemaType(K2, L2));\n}\nfunction FromProperties$f(K2, T2) {\n  const Acc = {};\n  for (const K22 of globalThis.Object.getOwnPropertyNames(T2))\n    Acc[K22] = FromSchemaType(K2, T2[K22]);\n  return Acc;\n}\nfunction FromSchemaType(K2, T2) {\n  const options = { ...T2 };\n  return (\n    // unevaluated modifier types\n    IsOptional$1(T2) ? Optional(FromSchemaType(K2, Discard(T2, [OptionalKind]))) : IsReadonly$1(T2) ? Readonly(FromSchemaType(K2, Discard(T2, [ReadonlyKind]))) : (\n      // unevaluated mapped types\n      IsMappedResult$1(T2) ? FromMappedResult$8(K2, T2.properties) : IsMappedKey$1(T2) ? FromMappedKey$3(K2, T2.keys) : (\n        // unevaluated types\n        IsConstructor$1(T2) ? Constructor(FromRest$5(K2, T2.parameters), FromSchemaType(K2, T2.returns), options) : IsFunction$1(T2) ? Function$1(FromRest$5(K2, T2.parameters), FromSchemaType(K2, T2.returns), options) : IsAsyncIterator$1(T2) ? AsyncIterator(FromSchemaType(K2, T2.items), options) : IsIterator$1(T2) ? Iterator(FromSchemaType(K2, T2.items), options) : IsIntersect$1(T2) ? Intersect$1(FromRest$5(K2, T2.allOf), options) : IsUnion$1(T2) ? Union$1(FromRest$5(K2, T2.anyOf), options) : IsTuple$1(T2) ? Tuple(FromRest$5(K2, T2.items ?? []), options) : IsObject$1(T2) ? Object$1(FromProperties$f(K2, T2.properties), options) : IsArray$1(T2) ? Array$1(FromSchemaType(K2, T2.items), options) : IsPromise$1(T2) ? Promise$2(FromSchemaType(K2, T2.item), options) : T2\n      )\n    )\n  );\n}\nfunction MappedFunctionReturnType(K2, T2) {\n  const Acc = {};\n  for (const L2 of K2)\n    Acc[L2] = FromSchemaType(L2, T2);\n  return Acc;\n}\nfunction Mapped(key, map2, options) {\n  const K2 = IsSchema$1(key) ? IndexPropertyKeys(key) : key;\n  const RT = map2({ [Kind]: \"MappedKey\", keys: K2 });\n  const R4 = MappedFunctionReturnType(K2, RT);\n  return Object$1(R4, options);\n}\nfunction Ref(...args) {\n  const [$ref, options] = typeof args[0] === \"string\" ? [args[0], args[1]] : [args[0].$id, args[1]];\n  if (typeof $ref !== \"string\")\n    throw new TypeBoxError(\"Ref: $ref must be a string\");\n  return CreateType({ [Kind]: \"Ref\", $ref }, options);\n}\nfunction FromRest$4(types) {\n  const result = [];\n  for (const L2 of types)\n    result.push(KeyOfPropertyKeys(L2));\n  return result;\n}\nfunction FromIntersect$b(types) {\n  const propertyKeysArray = FromRest$4(types);\n  const propertyKeys = SetUnionMany(propertyKeysArray);\n  return propertyKeys;\n}\nfunction FromUnion$b(types) {\n  const propertyKeysArray = FromRest$4(types);\n  const propertyKeys = SetIntersectMany(propertyKeysArray);\n  return propertyKeys;\n}\nfunction FromTuple$8(types) {\n  return types.map((_3, indexer) => indexer.toString());\n}\nfunction FromArray$a(_3) {\n  return [\"[number]\"];\n}\nfunction FromProperties$e(T2) {\n  return globalThis.Object.getOwnPropertyNames(T2);\n}\nfunction FromPatternProperties(patternProperties) {\n  if (!includePatternProperties)\n    return [];\n  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);\n  return patternPropertyKeys.map((key) => {\n    return key[0] === \"^\" && key[key.length - 1] === \"$\" ? key.slice(1, key.length - 1) : key;\n  });\n}\nfunction KeyOfPropertyKeys(type2) {\n  return IsIntersect$1(type2) ? FromIntersect$b(type2.allOf) : IsUnion$1(type2) ? FromUnion$b(type2.anyOf) : IsTuple$1(type2) ? FromTuple$8(type2.items ?? []) : IsArray$1(type2) ? FromArray$a(type2.items) : IsObject$1(type2) ? FromProperties$e(type2.properties) : IsRecord$1(type2) ? FromPatternProperties(type2.patternProperties) : [];\n}\nfunction KeyOfPattern(schema2) {\n  includePatternProperties = true;\n  const keys2 = KeyOfPropertyKeys(schema2);\n  includePatternProperties = false;\n  const pattern = keys2.map((key) => `(${key})`);\n  return `^(${pattern.join(\"|\")})$`;\n}\nfunction FromComputed$4(target, parameters) {\n  return Computed(\"KeyOf\", [Computed(target, parameters)]);\n}\nfunction FromRef$8($ref) {\n  return Computed(\"KeyOf\", [Ref($ref)]);\n}\nfunction KeyOfFromType(type2, options) {\n  const propertyKeys = KeyOfPropertyKeys(type2);\n  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);\n  const result = UnionEvaluated(propertyKeyTypes);\n  return CreateType(result, options);\n}\nfunction KeyOfPropertyKeysToRest(propertyKeys) {\n  return propertyKeys.map((L2) => L2 === \"[number]\" ? Number$1() : Literal(L2));\n}\nfunction KeyOf(type2, options) {\n  return IsComputed$1(type2) ? FromComputed$4(type2.target, type2.parameters) : IsRef$1(type2) ? FromRef$8(type2.$ref) : IsMappedResult$1(type2) ? KeyOfFromMappedResult(type2, options) : KeyOfFromType(type2, options);\n}\nfunction FromProperties$d(properties, options) {\n  const result = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n    result[K2] = KeyOf(properties[K2], Clone$1(options));\n  return result;\n}\nfunction FromMappedResult$7(mappedResult, options) {\n  return FromProperties$d(mappedResult.properties, options);\n}\nfunction KeyOfFromMappedResult(mappedResult, options) {\n  const properties = FromMappedResult$7(mappedResult, options);\n  return MappedResult(properties);\n}\nfunction KeyOfPropertyEntries(schema2) {\n  const keys2 = KeyOfPropertyKeys(schema2);\n  const schemas = IndexFromPropertyKeys(schema2, keys2);\n  return keys2.map((_3, index) => [keys2[index], schemas[index]]);\n}\nfunction Intersect(schema2) {\n  return schema2.allOf.every((schema3) => ExtendsUndefinedCheck(schema3));\n}\nfunction Union(schema2) {\n  return schema2.anyOf.some((schema3) => ExtendsUndefinedCheck(schema3));\n}\nfunction Not$1(schema2) {\n  return !ExtendsUndefinedCheck(schema2.not);\n}\nfunction ExtendsUndefinedCheck(schema2) {\n  return schema2[Kind] === \"Intersect\" ? Intersect(schema2) : schema2[Kind] === \"Union\" ? Union(schema2) : schema2[Kind] === \"Not\" ? Not$1(schema2) : schema2[Kind] === \"Undefined\" ? true : false;\n}\nfunction DefaultErrorFunction(error4) {\n  switch (error4.errorType) {\n    case ValueErrorType.ArrayContains:\n      return \"Expected array to contain at least one matching value\";\n    case ValueErrorType.ArrayMaxContains:\n      return `Expected array to contain no more than ${error4.schema.maxContains} matching values`;\n    case ValueErrorType.ArrayMinContains:\n      return `Expected array to contain at least ${error4.schema.minContains} matching values`;\n    case ValueErrorType.ArrayMaxItems:\n      return `Expected array length to be less or equal to ${error4.schema.maxItems}`;\n    case ValueErrorType.ArrayMinItems:\n      return `Expected array length to be greater or equal to ${error4.schema.minItems}`;\n    case ValueErrorType.ArrayUniqueItems:\n      return \"Expected array elements to be unique\";\n    case ValueErrorType.Array:\n      return \"Expected array\";\n    case ValueErrorType.AsyncIterator:\n      return \"Expected AsyncIterator\";\n    case ValueErrorType.BigIntExclusiveMaximum:\n      return `Expected bigint to be less than ${error4.schema.exclusiveMaximum}`;\n    case ValueErrorType.BigIntExclusiveMinimum:\n      return `Expected bigint to be greater than ${error4.schema.exclusiveMinimum}`;\n    case ValueErrorType.BigIntMaximum:\n      return `Expected bigint to be less or equal to ${error4.schema.maximum}`;\n    case ValueErrorType.BigIntMinimum:\n      return `Expected bigint to be greater or equal to ${error4.schema.minimum}`;\n    case ValueErrorType.BigIntMultipleOf:\n      return `Expected bigint to be a multiple of ${error4.schema.multipleOf}`;\n    case ValueErrorType.BigInt:\n      return \"Expected bigint\";\n    case ValueErrorType.Boolean:\n      return \"Expected boolean\";\n    case ValueErrorType.DateExclusiveMinimumTimestamp:\n      return `Expected Date timestamp to be greater than ${error4.schema.exclusiveMinimumTimestamp}`;\n    case ValueErrorType.DateExclusiveMaximumTimestamp:\n      return `Expected Date timestamp to be less than ${error4.schema.exclusiveMaximumTimestamp}`;\n    case ValueErrorType.DateMinimumTimestamp:\n      return `Expected Date timestamp to be greater or equal to ${error4.schema.minimumTimestamp}`;\n    case ValueErrorType.DateMaximumTimestamp:\n      return `Expected Date timestamp to be less or equal to ${error4.schema.maximumTimestamp}`;\n    case ValueErrorType.DateMultipleOfTimestamp:\n      return `Expected Date timestamp to be a multiple of ${error4.schema.multipleOfTimestamp}`;\n    case ValueErrorType.Date:\n      return \"Expected Date\";\n    case ValueErrorType.Function:\n      return \"Expected function\";\n    case ValueErrorType.IntegerExclusiveMaximum:\n      return `Expected integer to be less than ${error4.schema.exclusiveMaximum}`;\n    case ValueErrorType.IntegerExclusiveMinimum:\n      return `Expected integer to be greater than ${error4.schema.exclusiveMinimum}`;\n    case ValueErrorType.IntegerMaximum:\n      return `Expected integer to be less or equal to ${error4.schema.maximum}`;\n    case ValueErrorType.IntegerMinimum:\n      return `Expected integer to be greater or equal to ${error4.schema.minimum}`;\n    case ValueErrorType.IntegerMultipleOf:\n      return `Expected integer to be a multiple of ${error4.schema.multipleOf}`;\n    case ValueErrorType.Integer:\n      return \"Expected integer\";\n    case ValueErrorType.IntersectUnevaluatedProperties:\n      return \"Unexpected property\";\n    case ValueErrorType.Intersect:\n      return \"Expected all values to match\";\n    case ValueErrorType.Iterator:\n      return \"Expected Iterator\";\n    case ValueErrorType.Literal:\n      return `Expected ${typeof error4.schema.const === \"string\" ? `'${error4.schema.const}'` : error4.schema.const}`;\n    case ValueErrorType.Never:\n      return \"Never\";\n    case ValueErrorType.Not:\n      return \"Value should not match\";\n    case ValueErrorType.Null:\n      return \"Expected null\";\n    case ValueErrorType.NumberExclusiveMaximum:\n      return `Expected number to be less than ${error4.schema.exclusiveMaximum}`;\n    case ValueErrorType.NumberExclusiveMinimum:\n      return `Expected number to be greater than ${error4.schema.exclusiveMinimum}`;\n    case ValueErrorType.NumberMaximum:\n      return `Expected number to be less or equal to ${error4.schema.maximum}`;\n    case ValueErrorType.NumberMinimum:\n      return `Expected number to be greater or equal to ${error4.schema.minimum}`;\n    case ValueErrorType.NumberMultipleOf:\n      return `Expected number to be a multiple of ${error4.schema.multipleOf}`;\n    case ValueErrorType.Number:\n      return \"Expected number\";\n    case ValueErrorType.Object:\n      return \"Expected object\";\n    case ValueErrorType.ObjectAdditionalProperties:\n      return \"Unexpected property\";\n    case ValueErrorType.ObjectMaxProperties:\n      return `Expected object to have no more than ${error4.schema.maxProperties} properties`;\n    case ValueErrorType.ObjectMinProperties:\n      return `Expected object to have at least ${error4.schema.minProperties} properties`;\n    case ValueErrorType.ObjectRequiredProperty:\n      return \"Expected required property\";\n    case ValueErrorType.Promise:\n      return \"Expected Promise\";\n    case ValueErrorType.RegExp:\n      return \"Expected string to match regular expression\";\n    case ValueErrorType.StringFormatUnknown:\n      return `Unknown format '${error4.schema.format}'`;\n    case ValueErrorType.StringFormat:\n      return `Expected string to match '${error4.schema.format}' format`;\n    case ValueErrorType.StringMaxLength:\n      return `Expected string length less or equal to ${error4.schema.maxLength}`;\n    case ValueErrorType.StringMinLength:\n      return `Expected string length greater or equal to ${error4.schema.minLength}`;\n    case ValueErrorType.StringPattern:\n      return `Expected string to match '${error4.schema.pattern}'`;\n    case ValueErrorType.String:\n      return \"Expected string\";\n    case ValueErrorType.Symbol:\n      return \"Expected symbol\";\n    case ValueErrorType.TupleLength:\n      return `Expected tuple to have ${error4.schema.maxItems || 0} elements`;\n    case ValueErrorType.Tuple:\n      return \"Expected tuple\";\n    case ValueErrorType.Uint8ArrayMaxByteLength:\n      return `Expected byte length less or equal to ${error4.schema.maxByteLength}`;\n    case ValueErrorType.Uint8ArrayMinByteLength:\n      return `Expected byte length greater or equal to ${error4.schema.minByteLength}`;\n    case ValueErrorType.Uint8Array:\n      return \"Expected Uint8Array\";\n    case ValueErrorType.Undefined:\n      return \"Expected undefined\";\n    case ValueErrorType.Union:\n      return \"Expected union value\";\n    case ValueErrorType.Void:\n      return \"Expected void\";\n    case ValueErrorType.Kind:\n      return `Expected kind '${error4.schema[Kind]}'`;\n    default:\n      return \"Unknown error type\";\n  }\n}\nfunction SetErrorFunction(callback) {\n  errorFunction = callback;\n}\nfunction GetErrorFunction() {\n  return errorFunction;\n}\nfunction Resolve(schema2, references) {\n  const target = references.find((target2) => target2.$id === schema2.$ref);\n  if (target === void 0)\n    throw new TypeDereferenceError(schema2);\n  return Deref(target, references);\n}\nfunction Pushref(schema2, references) {\n  if (!IsString$3(schema2.$id) || references.some((target) => target.$id === schema2.$id))\n    return references;\n  references.push(schema2);\n  return references;\n}\nfunction Deref(schema2, references) {\n  return schema2[Kind] === \"This\" || schema2[Kind] === \"Ref\" ? Resolve(schema2, references) : schema2;\n}\nfunction* NumberToBytes(value2) {\n  const byteCount = value2 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value2) + 1) / 8);\n  for (let i = 0; i < byteCount; i++) {\n    yield value2 >> 8 * (byteCount - 1 - i) & 255;\n  }\n}\nfunction ArrayType(value2) {\n  FNV1A64(ByteMarker.Array);\n  for (const item of value2) {\n    Visit$6(item);\n  }\n}\nfunction BooleanType(value2) {\n  FNV1A64(ByteMarker.Boolean);\n  FNV1A64(value2 ? 1 : 0);\n}\nfunction BigIntType(value2) {\n  FNV1A64(ByteMarker.BigInt);\n  F64In.setBigInt64(0, value2);\n  for (const byte of F64Out) {\n    FNV1A64(byte);\n  }\n}\nfunction DateType(value2) {\n  FNV1A64(ByteMarker.Date);\n  Visit$6(value2.getTime());\n}\nfunction NullType(value2) {\n  FNV1A64(ByteMarker.Null);\n}\nfunction NumberType(value2) {\n  FNV1A64(ByteMarker.Number);\n  F64In.setFloat64(0, value2);\n  for (const byte of F64Out) {\n    FNV1A64(byte);\n  }\n}\nfunction ObjectType(value2) {\n  FNV1A64(ByteMarker.Object);\n  for (const key of globalThis.Object.getOwnPropertyNames(value2).sort()) {\n    Visit$6(key);\n    Visit$6(value2[key]);\n  }\n}\nfunction StringType(value2) {\n  FNV1A64(ByteMarker.String);\n  for (let i = 0; i < value2.length; i++) {\n    for (const byte of NumberToBytes(value2.charCodeAt(i))) {\n      FNV1A64(byte);\n    }\n  }\n}\nfunction SymbolType(value2) {\n  FNV1A64(ByteMarker.Symbol);\n  Visit$6(value2.description);\n}\nfunction Uint8ArrayType(value2) {\n  FNV1A64(ByteMarker.Uint8Array);\n  for (let i = 0; i < value2.length; i++) {\n    FNV1A64(value2[i]);\n  }\n}\nfunction UndefinedType(value2) {\n  return FNV1A64(ByteMarker.Undefined);\n}\nfunction Visit$6(value2) {\n  if (IsArray$3(value2))\n    return ArrayType(value2);\n  if (IsBoolean$3(value2))\n    return BooleanType(value2);\n  if (IsBigInt$3(value2))\n    return BigIntType(value2);\n  if (IsDate$3(value2))\n    return DateType(value2);\n  if (IsNull$3(value2))\n    return NullType();\n  if (IsNumber$3(value2))\n    return NumberType(value2);\n  if (IsObject$3(value2))\n    return ObjectType(value2);\n  if (IsString$3(value2))\n    return StringType(value2);\n  if (IsSymbol$3(value2))\n    return SymbolType(value2);\n  if (IsUint8Array$3(value2))\n    return Uint8ArrayType(value2);\n  if (IsUndefined$3(value2))\n    return UndefinedType();\n  throw new ValueHashError(value2);\n}\nfunction FNV1A64(byte) {\n  Accumulator = Accumulator ^ Bytes[byte];\n  Accumulator = Accumulator * Prime % Size;\n}\nfunction Hash$1(value2) {\n  Accumulator = BigInt(\"14695981039346656037\");\n  Visit$6(value2);\n  return Accumulator;\n}\nfunction Any(options) {\n  return CreateType({ [Kind]: \"Any\" }, options);\n}\nfunction Unknown(options) {\n  return CreateType({ [Kind]: \"Unknown\" }, options);\n}\nfunction IsPattern(value2) {\n  try {\n    new RegExp(value2);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction IsControlCharacterFree(value$1) {\n  if (!IsString$2(value$1))\n    return false;\n  for (let i = 0; i < value$1.length; i++) {\n    const code = value$1.charCodeAt(i);\n    if (code >= 7 && code <= 13 || code === 27 || code === 127) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction IsAdditionalProperties(value2) {\n  return IsOptionalBoolean(value2) || IsSchema(value2);\n}\nfunction IsOptionalBigInt(value$1) {\n  return IsUndefined$2(value$1) || IsBigInt$2(value$1);\n}\nfunction IsOptionalNumber(value$1) {\n  return IsUndefined$2(value$1) || IsNumber$2(value$1);\n}\nfunction IsOptionalBoolean(value$1) {\n  return IsUndefined$2(value$1) || IsBoolean$2(value$1);\n}\nfunction IsOptionalString(value$1) {\n  return IsUndefined$2(value$1) || IsString$2(value$1);\n}\nfunction IsOptionalPattern(value$1) {\n  return IsUndefined$2(value$1) || IsString$2(value$1) && IsControlCharacterFree(value$1) && IsPattern(value$1);\n}\nfunction IsOptionalFormat(value$1) {\n  return IsUndefined$2(value$1) || IsString$2(value$1) && IsControlCharacterFree(value$1);\n}\nfunction IsOptionalSchema(value$1) {\n  return IsUndefined$2(value$1) || IsSchema(value$1);\n}\nfunction IsReadonly(value$1) {\n  return IsObject$2(value$1) && value$1[ReadonlyKind] === \"Readonly\";\n}\nfunction IsOptional(value$1) {\n  return IsObject$2(value$1) && value$1[OptionalKind] === \"Optional\";\n}\nfunction IsAny(value2) {\n  return IsKindOf(value2, \"Any\") && IsOptionalString(value2.$id);\n}\nfunction IsArgument(value$1) {\n  return IsKindOf(value$1, \"Argument\") && IsNumber$2(value$1.index);\n}\nfunction IsArray(value2) {\n  return IsKindOf(value2, \"Array\") && value2.type === \"array\" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);\n}\nfunction IsAsyncIterator(value2) {\n  return IsKindOf(value2, \"AsyncIterator\") && value2.type === \"AsyncIterator\" && IsOptionalString(value2.$id) && IsSchema(value2.items);\n}\nfunction IsBigInt(value2) {\n  return IsKindOf(value2, \"BigInt\") && value2.type === \"bigint\" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);\n}\nfunction IsBoolean(value2) {\n  return IsKindOf(value2, \"Boolean\") && value2.type === \"boolean\" && IsOptionalString(value2.$id);\n}\nfunction IsComputed(value$1) {\n  return IsKindOf(value$1, \"Computed\") && IsString$2(value$1.target) && IsArray$2(value$1.parameters) && value$1.parameters.every((schema2) => IsSchema(schema2));\n}\nfunction IsConstructor(value$1) {\n  return IsKindOf(value$1, \"Constructor\") && value$1.type === \"Constructor\" && IsOptionalString(value$1.$id) && IsArray$2(value$1.parameters) && value$1.parameters.every((schema2) => IsSchema(schema2)) && IsSchema(value$1.returns);\n}\nfunction IsDate(value2) {\n  return IsKindOf(value2, \"Date\") && value2.type === \"Date\" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);\n}\nfunction IsFunction(value$1) {\n  return IsKindOf(value$1, \"Function\") && value$1.type === \"Function\" && IsOptionalString(value$1.$id) && IsArray$2(value$1.parameters) && value$1.parameters.every((schema2) => IsSchema(schema2)) && IsSchema(value$1.returns);\n}\nfunction IsImport(value$1) {\n  return IsKindOf(value$1, \"Import\") && HasPropertyKey(value$1, \"$defs\") && IsObject$2(value$1.$defs) && IsProperties(value$1.$defs) && HasPropertyKey(value$1, \"$ref\") && IsString$2(value$1.$ref) && value$1.$ref in value$1.$defs;\n}\nfunction IsInteger(value2) {\n  return IsKindOf(value2, \"Integer\") && value2.type === \"integer\" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);\n}\nfunction IsProperties(value$1) {\n  return IsObject$2(value$1) && Object.entries(value$1).every(([key, schema2]) => IsControlCharacterFree(key) && IsSchema(schema2));\n}\nfunction IsIntersect(value$1) {\n  return IsKindOf(value$1, \"Intersect\") && (IsString$2(value$1.type) && value$1.type !== \"object\" ? false : true) && IsArray$2(value$1.allOf) && value$1.allOf.every((schema2) => IsSchema(schema2) && !IsTransform(schema2)) && IsOptionalString(value$1.type) && (IsOptionalBoolean(value$1.unevaluatedProperties) || IsOptionalSchema(value$1.unevaluatedProperties)) && IsOptionalString(value$1.$id);\n}\nfunction IsIterator(value2) {\n  return IsKindOf(value2, \"Iterator\") && value2.type === \"Iterator\" && IsOptionalString(value2.$id) && IsSchema(value2.items);\n}\nfunction IsKindOf(value$1, kind2) {\n  return IsObject$2(value$1) && Kind in value$1 && value$1[Kind] === kind2;\n}\nfunction IsLiteralString(value$1) {\n  return IsLiteral(value$1) && IsString$2(value$1.const);\n}\nfunction IsLiteralNumber(value$1) {\n  return IsLiteral(value$1) && IsNumber$2(value$1.const);\n}\nfunction IsLiteralBoolean(value$1) {\n  return IsLiteral(value$1) && IsBoolean$2(value$1.const);\n}\nfunction IsLiteral(value2) {\n  return IsKindOf(value2, \"Literal\") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);\n}\nfunction IsLiteralValue(value$1) {\n  return IsBoolean$2(value$1) || IsNumber$2(value$1) || IsString$2(value$1);\n}\nfunction IsMappedKey(value$1) {\n  return IsKindOf(value$1, \"MappedKey\") && IsArray$2(value$1.keys) && value$1.keys.every((key) => IsNumber$2(key) || IsString$2(key));\n}\nfunction IsMappedResult(value2) {\n  return IsKindOf(value2, \"MappedResult\") && IsProperties(value2.properties);\n}\nfunction IsNever(value$1) {\n  return IsKindOf(value$1, \"Never\") && IsObject$2(value$1.not) && Object.getOwnPropertyNames(value$1.not).length === 0;\n}\nfunction IsNot(value2) {\n  return IsKindOf(value2, \"Not\") && IsSchema(value2.not);\n}\nfunction IsNull(value2) {\n  return IsKindOf(value2, \"Null\") && value2.type === \"null\" && IsOptionalString(value2.$id);\n}\nfunction IsNumber(value2) {\n  return IsKindOf(value2, \"Number\") && value2.type === \"number\" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);\n}\nfunction IsObject(value2) {\n  return IsKindOf(value2, \"Object\") && value2.type === \"object\" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);\n}\nfunction IsPromise(value2) {\n  return IsKindOf(value2, \"Promise\") && value2.type === \"Promise\" && IsOptionalString(value2.$id) && IsSchema(value2.item);\n}\nfunction IsRecord(value$1) {\n  return IsKindOf(value$1, \"Record\") && value$1.type === \"object\" && IsOptionalString(value$1.$id) && IsAdditionalProperties(value$1.additionalProperties) && IsObject$2(value$1.patternProperties) && ((schema2) => {\n    const keys2 = Object.getOwnPropertyNames(schema2.patternProperties);\n    return keys2.length === 1 && IsPattern(keys2[0]) && IsObject$2(schema2.patternProperties) && IsSchema(schema2.patternProperties[keys2[0]]);\n  })(value$1);\n}\nfunction IsRecursive(value$1) {\n  return IsObject$2(value$1) && Hint in value$1 && value$1[Hint] === \"Recursive\";\n}\nfunction IsRef(value$1) {\n  return IsKindOf(value$1, \"Ref\") && IsOptionalString(value$1.$id) && IsString$2(value$1.$ref);\n}\nfunction IsRegExp(value$1) {\n  return IsKindOf(value$1, \"RegExp\") && IsOptionalString(value$1.$id) && IsString$2(value$1.source) && IsString$2(value$1.flags) && IsOptionalNumber(value$1.maxLength) && IsOptionalNumber(value$1.minLength);\n}\nfunction IsString(value2) {\n  return IsKindOf(value2, \"String\") && value2.type === \"string\" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);\n}\nfunction IsSymbol(value2) {\n  return IsKindOf(value2, \"Symbol\") && value2.type === \"symbol\" && IsOptionalString(value2.$id);\n}\nfunction IsTemplateLiteral(value$1) {\n  return IsKindOf(value$1, \"TemplateLiteral\") && value$1.type === \"string\" && IsString$2(value$1.pattern) && value$1.pattern[0] === \"^\" && value$1.pattern[value$1.pattern.length - 1] === \"$\";\n}\nfunction IsThis(value$1) {\n  return IsKindOf(value$1, \"This\") && IsOptionalString(value$1.$id) && IsString$2(value$1.$ref);\n}\nfunction IsTransform(value$1) {\n  return IsObject$2(value$1) && TransformKind in value$1;\n}\nfunction IsTuple(value$1) {\n  return IsKindOf(value$1, \"Tuple\") && value$1.type === \"array\" && IsOptionalString(value$1.$id) && IsNumber$2(value$1.minItems) && IsNumber$2(value$1.maxItems) && value$1.minItems === value$1.maxItems && // empty\n  (IsUndefined$2(value$1.items) && IsUndefined$2(value$1.additionalItems) && value$1.minItems === 0 || IsArray$2(value$1.items) && value$1.items.every((schema2) => IsSchema(schema2)));\n}\nfunction IsUndefined(value2) {\n  return IsKindOf(value2, \"Undefined\") && value2.type === \"undefined\" && IsOptionalString(value2.$id);\n}\nfunction IsUnionLiteral(value2) {\n  return IsUnion(value2) && value2.anyOf.every((schema2) => IsLiteralString(schema2) || IsLiteralNumber(schema2));\n}\nfunction IsUnion(value$1) {\n  return IsKindOf(value$1, \"Union\") && IsOptionalString(value$1.$id) && IsObject$2(value$1) && IsArray$2(value$1.anyOf) && value$1.anyOf.every((schema2) => IsSchema(schema2));\n}\nfunction IsUint8Array(value2) {\n  return IsKindOf(value2, \"Uint8Array\") && value2.type === \"Uint8Array\" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);\n}\nfunction IsUnknown(value2) {\n  return IsKindOf(value2, \"Unknown\") && IsOptionalString(value2.$id);\n}\nfunction IsUnsafe(value2) {\n  return IsKindOf(value2, \"Unsafe\");\n}\nfunction IsVoid(value2) {\n  return IsKindOf(value2, \"Void\") && value2.type === \"void\" && IsOptionalString(value2.$id);\n}\nfunction IsKind(value$1) {\n  return IsObject$2(value$1) && Kind in value$1 && IsString$2(value$1[Kind]) && !KnownTypes.includes(value$1[Kind]);\n}\nfunction IsSchema(value$1) {\n  return IsObject$2(value$1) && (IsAny(value$1) || IsArgument(value$1) || IsArray(value$1) || IsBoolean(value$1) || IsBigInt(value$1) || IsAsyncIterator(value$1) || IsComputed(value$1) || IsConstructor(value$1) || IsDate(value$1) || IsFunction(value$1) || IsInteger(value$1) || IsIntersect(value$1) || IsIterator(value$1) || IsLiteral(value$1) || IsMappedKey(value$1) || IsMappedResult(value$1) || IsNever(value$1) || IsNot(value$1) || IsNull(value$1) || IsNumber(value$1) || IsObject(value$1) || IsPromise(value$1) || IsRecord(value$1) || IsRef(value$1) || IsRegExp(value$1) || IsString(value$1) || IsSymbol(value$1) || IsTemplateLiteral(value$1) || IsThis(value$1) || IsTuple(value$1) || IsUndefined(value$1) || IsUnion(value$1) || IsUint8Array(value$1) || IsUnknown(value$1) || IsUnsafe(value$1) || IsVoid(value$1) || IsKind(value$1));\n}\nfunction IntoBooleanResult(result) {\n  return result === ExtendsResult.False ? result : ExtendsResult.True;\n}\nfunction Throw(message) {\n  throw new ExtendsResolverError(message);\n}\nfunction IsStructuralRight(right) {\n  return IsNever(right) || IsIntersect(right) || IsUnion(right) || IsUnknown(right) || IsAny(right);\n}\nfunction StructuralRight(left, right) {\n  return IsNever(right) ? FromNeverRight() : IsIntersect(right) ? FromIntersectRight(left, right) : IsUnion(right) ? FromUnionRight(left, right) : IsUnknown(right) ? FromUnknownRight() : IsAny(right) ? FromAnyRight() : Throw(\"StructuralRight\");\n}\nfunction FromAnyRight(left, right) {\n  return ExtendsResult.True;\n}\nfunction FromAny$2(left, right) {\n  return IsIntersect(right) ? FromIntersectRight(left, right) : IsUnion(right) && right.anyOf.some((schema2) => IsAny(schema2) || IsUnknown(schema2)) ? ExtendsResult.True : IsUnion(right) ? ExtendsResult.Union : IsUnknown(right) ? ExtendsResult.True : IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;\n}\nfunction FromArrayRight(left, right) {\n  return IsUnknown(left) ? ExtendsResult.False : IsAny(left) ? ExtendsResult.Union : IsNever(left) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromArray$9(left, right) {\n  return IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit$5(left.items, right.items));\n}\nfunction FromAsyncIterator$5(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : !IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit$5(left.items, right.items));\n}\nfunction FromBigInt$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromBooleanRight(left, right) {\n  return IsLiteralBoolean(left) ? ExtendsResult.True : IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromBoolean$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromConstructor$5(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : !IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema2, index) => IntoBooleanResult(Visit$5(right.parameters[index], schema2)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit$5(left.returns, right.returns));\n}\nfunction FromDate$4(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsDate(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromFunction$5(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : !IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema2, index) => IntoBooleanResult(Visit$5(right.parameters[index], schema2)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit$5(left.returns, right.returns));\n}\nfunction FromIntegerRight(left, right) {\n  return IsLiteral(left) && IsNumber$2(left.const) ? ExtendsResult.True : IsNumber(left) || IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromInteger$2(left, right) {\n  return IsInteger(right) || IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;\n}\nfunction FromIntersectRight(left, right) {\n  return right.allOf.every((schema2) => Visit$5(left, schema2) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromIntersect$a(left, right) {\n  return left.allOf.some((schema2) => Visit$5(schema2, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromIterator$5(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : !IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit$5(left.items, right.items));\n}\nfunction FromLiteral$2(left, right) {\n  return IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsString(right) ? FromStringRight(left) : IsNumber(right) ? FromNumberRight(left) : IsInteger(right) ? FromIntegerRight(left) : IsBoolean(right) ? FromBooleanRight(left) : ExtendsResult.False;\n}\nfunction FromNeverRight(left, right) {\n  return ExtendsResult.False;\n}\nfunction FromNever$2(left, right) {\n  return ExtendsResult.True;\n}\nfunction UnwrapTNot(schema2) {\n  let [current, depth] = [schema2, 0];\n  while (true) {\n    if (!IsNot(current))\n      break;\n    current = current.not;\n    depth += 1;\n  }\n  return depth % 2 === 0 ? current : Unknown();\n}\nfunction FromNot$4(left, right) {\n  return IsNot(left) ? Visit$5(UnwrapTNot(left), right) : IsNot(right) ? Visit$5(left, UnwrapTNot(right)) : Throw(\"Invalid fallthrough for Not\");\n}\nfunction FromNull$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsNull(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromNumberRight(left, right) {\n  return IsLiteralNumber(left) ? ExtendsResult.True : IsNumber(left) || IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromNumber$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsInteger(right) || IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction IsObjectPropertyCount(schema2, count3) {\n  return Object.getOwnPropertyNames(schema2.properties).length === count3;\n}\nfunction IsObjectStringLike(schema2) {\n  return IsObjectArrayLike(schema2);\n}\nfunction IsObjectSymbolLike(schema2) {\n  return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && \"description\" in schema2.properties && IsUnion(schema2.properties.description) && schema2.properties.description.anyOf.length === 2 && (IsString(schema2.properties.description.anyOf[0]) && IsUndefined(schema2.properties.description.anyOf[1]) || IsString(schema2.properties.description.anyOf[1]) && IsUndefined(schema2.properties.description.anyOf[0]));\n}\nfunction IsObjectNumberLike(schema2) {\n  return IsObjectPropertyCount(schema2, 0);\n}\nfunction IsObjectBooleanLike(schema2) {\n  return IsObjectPropertyCount(schema2, 0);\n}\nfunction IsObjectBigIntLike(schema2) {\n  return IsObjectPropertyCount(schema2, 0);\n}\nfunction IsObjectDateLike(schema2) {\n  return IsObjectPropertyCount(schema2, 0);\n}\nfunction IsObjectUint8ArrayLike(schema2) {\n  return IsObjectArrayLike(schema2);\n}\nfunction IsObjectFunctionLike(schema2) {\n  const length = Number$1();\n  return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && \"length\" in schema2.properties && IntoBooleanResult(Visit$5(schema2.properties[\"length\"], length)) === ExtendsResult.True;\n}\nfunction IsObjectConstructorLike(schema2) {\n  return IsObjectPropertyCount(schema2, 0);\n}\nfunction IsObjectArrayLike(schema2) {\n  const length = Number$1();\n  return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && \"length\" in schema2.properties && IntoBooleanResult(Visit$5(schema2.properties[\"length\"], length)) === ExtendsResult.True;\n}\nfunction IsObjectPromiseLike(schema2) {\n  const then = Function$1([Any()], Any());\n  return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && \"then\" in schema2.properties && IntoBooleanResult(Visit$5(schema2.properties[\"then\"], then)) === ExtendsResult.True;\n}\nfunction Property(left, right) {\n  return Visit$5(left, right) === ExtendsResult.False ? ExtendsResult.False : IsOptional(left) && !IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;\n}\nfunction FromObjectRight(left, right) {\n  return IsUnknown(left) ? ExtendsResult.False : IsAny(left) ? ExtendsResult.Union : IsNever(left) || IsLiteralString(left) && IsObjectStringLike(right) || IsLiteralNumber(left) && IsObjectNumberLike(right) || IsLiteralBoolean(left) && IsObjectBooleanLike(right) || IsSymbol(left) && IsObjectSymbolLike(right) || IsBigInt(left) && IsObjectBigIntLike(right) || IsString(left) && IsObjectStringLike(right) || IsSymbol(left) && IsObjectSymbolLike(right) || IsNumber(left) && IsObjectNumberLike(right) || IsInteger(left) && IsObjectNumberLike(right) || IsBoolean(left) && IsObjectBooleanLike(right) || IsUint8Array(left) && IsObjectUint8ArrayLike(right) || IsDate(left) && IsObjectDateLike(right) || IsConstructor(left) && IsObjectConstructorLike(right) || IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : IsRecord(left) && IsString(RecordKey$1(left)) ? (() => {\n    return right[Hint] === \"Record\" ? ExtendsResult.True : ExtendsResult.False;\n  })() : IsRecord(left) && IsNumber(RecordKey$1(left)) ? (() => {\n    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;\n  })() : ExtendsResult.False;\n}\nfunction FromObject$c(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : !IsObject(right) ? ExtendsResult.False : (() => {\n    for (const key of Object.getOwnPropertyNames(right.properties)) {\n      if (!(key in left.properties) && !IsOptional(right.properties[key])) {\n        return ExtendsResult.False;\n      }\n      if (IsOptional(right.properties[key])) {\n        return ExtendsResult.True;\n      }\n      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {\n        return ExtendsResult.False;\n      }\n    }\n    return ExtendsResult.True;\n  })();\n}\nfunction FromPromise$5(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit$5(left.item, right.item));\n}\nfunction RecordKey$1(schema2) {\n  return PatternNumberExact in schema2.patternProperties ? Number$1() : PatternStringExact in schema2.patternProperties ? String$1() : Throw(\"Unknown record key pattern\");\n}\nfunction RecordValue$1(schema2) {\n  return PatternNumberExact in schema2.patternProperties ? schema2.patternProperties[PatternNumberExact] : PatternStringExact in schema2.patternProperties ? schema2.patternProperties[PatternStringExact] : Throw(\"Unable to get record value schema\");\n}\nfunction FromRecordRight(left, right) {\n  const [Key, Value2] = [RecordKey$1(right), RecordValue$1(right)];\n  return IsLiteralString(left) && IsNumber(Key) && IntoBooleanResult(Visit$5(left, Value2)) === ExtendsResult.True ? ExtendsResult.True : IsUint8Array(left) && IsNumber(Key) ? Visit$5(left, Value2) : IsString(left) && IsNumber(Key) ? Visit$5(left, Value2) : IsArray(left) && IsNumber(Key) ? Visit$5(left, Value2) : IsObject(left) ? (() => {\n    for (const key of Object.getOwnPropertyNames(left.properties)) {\n      if (Property(Value2, left.properties[key]) === ExtendsResult.False) {\n        return ExtendsResult.False;\n      }\n    }\n    return ExtendsResult.True;\n  })() : ExtendsResult.False;\n}\nfunction FromRecord$7(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : !IsRecord(right) ? ExtendsResult.False : Visit$5(RecordValue$1(left), RecordValue$1(right));\n}\nfunction FromRegExp$2(left, right) {\n  const L2 = IsRegExp(left) ? String$1() : left;\n  const R4 = IsRegExp(right) ? String$1() : right;\n  return Visit$5(L2, R4);\n}\nfunction FromStringRight(left, right) {\n  return IsLiteral(left) && IsString$2(left.const) ? ExtendsResult.True : IsString(left) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromString$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsString(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromSymbol$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromTemplateLiteral$3(left, right) {\n  return IsTemplateLiteral(left) ? Visit$5(TemplateLiteralToUnion(left), right) : IsTemplateLiteral(right) ? Visit$5(left, TemplateLiteralToUnion(right)) : Throw(\"Invalid fallthrough for TemplateLiteral\");\n}\nfunction IsArrayOfTuple(left, right) {\n  return IsArray(right) && left.items !== void 0 && left.items.every((schema2) => Visit$5(schema2, right.items) === ExtendsResult.True);\n}\nfunction FromTupleRight(left, right) {\n  return IsNever(left) ? ExtendsResult.True : IsUnknown(left) ? ExtendsResult.False : IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;\n}\nfunction FromTuple$7(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !IsTuple(right) ? ExtendsResult.False : IsUndefined$2(left.items) && !IsUndefined$2(right.items) || !IsUndefined$2(left.items) && IsUndefined$2(right.items) ? ExtendsResult.False : IsUndefined$2(left.items) && !IsUndefined$2(right.items) ? ExtendsResult.True : left.items.every((schema2, index) => Visit$5(schema2, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromUint8Array$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromUndefined$2(left, right) {\n  return IsStructuralRight(right) ? StructuralRight(left, right) : IsObject(right) ? FromObjectRight(left, right) : IsRecord(right) ? FromRecordRight(left, right) : IsVoid(right) ? FromVoidRight(left) : IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromUnionRight(left, right) {\n  return right.anyOf.some((schema2) => Visit$5(left, schema2) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromUnion$a(left, right) {\n  return left.anyOf.every((schema2) => Visit$5(schema2, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromUnknownRight(left, right) {\n  return ExtendsResult.True;\n}\nfunction FromUnknown$2(left, right) {\n  return IsNever(right) ? FromNeverRight() : IsIntersect(right) ? FromIntersectRight(left, right) : IsUnion(right) ? FromUnionRight(left, right) : IsAny(right) ? FromAnyRight() : IsString(right) ? FromStringRight(left) : IsNumber(right) ? FromNumberRight(left) : IsInteger(right) ? FromIntegerRight(left) : IsBoolean(right) ? FromBooleanRight(left) : IsArray(right) ? FromArrayRight(left) : IsTuple(right) ? FromTupleRight(left) : IsObject(right) ? FromObjectRight(left, right) : IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromVoidRight(left, right) {\n  return IsUndefined(left) ? ExtendsResult.True : IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction FromVoid$2(left, right) {\n  return IsIntersect(right) ? FromIntersectRight(left, right) : IsUnion(right) ? FromUnionRight(left, right) : IsUnknown(right) ? FromUnknownRight() : IsAny(right) ? FromAnyRight() : IsObject(right) ? FromObjectRight(left, right) : IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;\n}\nfunction Visit$5(left, right) {\n  return (\n    // resolvable\n    IsTemplateLiteral(left) || IsTemplateLiteral(right) ? FromTemplateLiteral$3(left, right) : IsRegExp(left) || IsRegExp(right) ? FromRegExp$2(left, right) : IsNot(left) || IsNot(right) ? FromNot$4(left, right) : (\n      // standard\n      IsAny(left) ? FromAny$2(left, right) : IsArray(left) ? FromArray$9(left, right) : IsBigInt(left) ? FromBigInt$2(left, right) : IsBoolean(left) ? FromBoolean$2(left, right) : IsAsyncIterator(left) ? FromAsyncIterator$5(left, right) : IsConstructor(left) ? FromConstructor$5(left, right) : IsDate(left) ? FromDate$4(left, right) : IsFunction(left) ? FromFunction$5(left, right) : IsInteger(left) ? FromInteger$2(left, right) : IsIntersect(left) ? FromIntersect$a(left, right) : IsIterator(left) ? FromIterator$5(left, right) : IsLiteral(left) ? FromLiteral$2(left, right) : IsNever(left) ? FromNever$2() : IsNull(left) ? FromNull$2(left, right) : IsNumber(left) ? FromNumber$2(left, right) : IsObject(left) ? FromObject$c(left, right) : IsRecord(left) ? FromRecord$7(left, right) : IsString(left) ? FromString$2(left, right) : IsSymbol(left) ? FromSymbol$2(left, right) : IsTuple(left) ? FromTuple$7(left, right) : IsPromise(left) ? FromPromise$5(left, right) : IsUint8Array(left) ? FromUint8Array$2(left, right) : IsUndefined(left) ? FromUndefined$2(left, right) : IsUnion(left) ? FromUnion$a(left, right) : IsUnknown(left) ? FromUnknown$2(left, right) : IsVoid(left) ? FromVoid$2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`)\n    )\n  );\n}\nfunction ExtendsCheck(left, right) {\n  return Visit$5(left, right);\n}\nfunction FromProperties$c(P3, Right, True, False, options) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))\n    Acc[K2] = Extends(P3[K2], Right, True, False, Clone$1(options));\n  return Acc;\n}\nfunction FromMappedResult$6(Left, Right, True, False, options) {\n  return FromProperties$c(Left.properties, Right, True, False, options);\n}\nfunction ExtendsFromMappedResult(Left, Right, True, False, options) {\n  const P3 = FromMappedResult$6(Left, Right, True, False, options);\n  return MappedResult(P3);\n}\nfunction ExtendsResolve(left, right, trueType, falseType) {\n  const R4 = ExtendsCheck(left, right);\n  return R4 === ExtendsResult.Union ? Union$1([trueType, falseType]) : R4 === ExtendsResult.True ? trueType : falseType;\n}\nfunction Extends(L2, R4, T2, F2, options) {\n  return IsMappedResult$1(L2) ? ExtendsFromMappedResult(L2, R4, T2, F2, options) : IsMappedKey$1(L2) ? CreateType(ExtendsFromMappedKey(L2, R4, T2, F2, options)) : CreateType(ExtendsResolve(L2, R4, T2, F2), options);\n}\nfunction FromPropertyKey$2(K2, U2, L2, R4, options) {\n  return {\n    [K2]: Extends(Literal(K2), U2, L2, R4, Clone$1(options))\n  };\n}\nfunction FromPropertyKeys$2(K2, U2, L2, R4, options) {\n  return K2.reduce((Acc, LK) => {\n    return { ...Acc, ...FromPropertyKey$2(LK, U2, L2, R4, options) };\n  }, {});\n}\nfunction FromMappedKey$2(K2, U2, L2, R4, options) {\n  return FromPropertyKeys$2(K2.keys, U2, L2, R4, options);\n}\nfunction ExtendsFromMappedKey(T2, U2, L2, R4, options) {\n  const P3 = FromMappedKey$2(T2, U2, L2, R4, options);\n  return MappedResult(P3);\n}\nfunction IsAnyOrUnknown(schema2) {\n  return schema2[Kind] === \"Any\" || schema2[Kind] === \"Unknown\";\n}\nfunction IsDefined$1(value2) {\n  return value2 !== void 0;\n}\nfunction FromAny$1(schema2, references, value2) {\n  return true;\n}\nfunction FromArgument$2(schema2, references, value2) {\n  return true;\n}\nfunction FromArray$8(schema2, references, value2) {\n  if (!IsArray$3(value2))\n    return false;\n  if (IsDefined$1(schema2.minItems) && !(value2.length >= schema2.minItems)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maxItems) && !(value2.length <= schema2.maxItems)) {\n    return false;\n  }\n  if (!value2.every((value3) => Visit$4(schema2.items, references, value3))) {\n    return false;\n  }\n  if (schema2.uniqueItems === true && !function() {\n    const set2 = /* @__PURE__ */ new Set();\n    for (const element of value2) {\n      const hashed = Hash$1(element);\n      if (set2.has(hashed)) {\n        return false;\n      } else {\n        set2.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    return false;\n  }\n  if (!(IsDefined$1(schema2.contains) || IsNumber$3(schema2.minContains) || IsNumber$3(schema2.maxContains))) {\n    return true;\n  }\n  const containsSchema = IsDefined$1(schema2.contains) ? schema2.contains : Never();\n  const containsCount = value2.reduce((acc, value3) => Visit$4(containsSchema, references, value3) ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    return false;\n  }\n  if (IsNumber$3(schema2.minContains) && containsCount < schema2.minContains) {\n    return false;\n  }\n  if (IsNumber$3(schema2.maxContains) && containsCount > schema2.maxContains) {\n    return false;\n  }\n  return true;\n}\nfunction FromAsyncIterator$4(schema2, references, value2) {\n  return IsAsyncIterator$3(value2);\n}\nfunction FromBigInt$1(schema2, references, value2) {\n  if (!IsBigInt$3(value2))\n    return false;\n  if (IsDefined$1(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maximum) && !(value2 <= schema2.maximum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minimum) && !(value2 >= schema2.minimum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.multipleOf) && !(value2 % schema2.multipleOf === BigInt(0))) {\n    return false;\n  }\n  return true;\n}\nfunction FromBoolean$1(schema2, references, value2) {\n  return IsBoolean$3(value2);\n}\nfunction FromConstructor$4(schema2, references, value2) {\n  return Visit$4(schema2.returns, references, value2.prototype);\n}\nfunction FromDate$3(schema2, references, value2) {\n  if (!IsDate$3(value2))\n    return false;\n  if (IsDefined$1(schema2.exclusiveMaximumTimestamp) && !(value2.getTime() < schema2.exclusiveMaximumTimestamp)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.exclusiveMinimumTimestamp) && !(value2.getTime() > schema2.exclusiveMinimumTimestamp)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maximumTimestamp) && !(value2.getTime() <= schema2.maximumTimestamp)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minimumTimestamp) && !(value2.getTime() >= schema2.minimumTimestamp)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.multipleOfTimestamp) && !(value2.getTime() % schema2.multipleOfTimestamp === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromFunction$4(schema2, references, value2) {\n  return IsFunction$3(value2);\n}\nfunction FromImport$4(schema2, references, value2) {\n  const definitions = globalThis.Object.values(schema2.$defs);\n  const target = schema2.$defs[schema2.$ref];\n  return Visit$4(target, [...references, ...definitions], value2);\n}\nfunction FromInteger$1(schema2, references, value2) {\n  if (!IsInteger$2(value2)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maximum) && !(value2 <= schema2.maximum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minimum) && !(value2 >= schema2.minimum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromIntersect$9(schema2, references, value2) {\n  const check1 = schema2.allOf.every((schema3) => Visit$4(schema3, references, value2));\n  if (schema2.unevaluatedProperties === false) {\n    const keyPattern = new RegExp(KeyOfPattern(schema2));\n    const check2 = Object.getOwnPropertyNames(value2).every((key) => keyPattern.test(key));\n    return check1 && check2;\n  } else if (IsSchema$1(schema2.unevaluatedProperties)) {\n    const keyCheck = new RegExp(KeyOfPattern(schema2));\n    const check2 = Object.getOwnPropertyNames(value2).every((key) => keyCheck.test(key) || Visit$4(schema2.unevaluatedProperties, references, value2[key]));\n    return check1 && check2;\n  } else {\n    return check1;\n  }\n}\nfunction FromIterator$4(schema2, references, value2) {\n  return IsIterator$3(value2);\n}\nfunction FromLiteral$1(schema2, references, value2) {\n  return value2 === schema2.const;\n}\nfunction FromNever$1(schema2, references, value2) {\n  return false;\n}\nfunction FromNot$3(schema2, references, value2) {\n  return !Visit$4(schema2.not, references, value2);\n}\nfunction FromNull$1(schema2, references, value2) {\n  return IsNull$3(value2);\n}\nfunction FromNumber$1(schema2, references, value2) {\n  if (!TypeSystemPolicy.IsNumberLike(value2))\n    return false;\n  if (IsDefined$1(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minimum) && !(value2 >= schema2.minimum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maximum) && !(value2 <= schema2.maximum)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {\n    return false;\n  }\n  return true;\n}\nfunction FromObject$b(schema2, references, value2) {\n  if (!TypeSystemPolicy.IsObjectLike(value2))\n    return false;\n  if (IsDefined$1(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {\n    return false;\n  }\n  const knownKeys = Object.getOwnPropertyNames(schema2.properties);\n  for (const knownKey of knownKeys) {\n    const property2 = schema2.properties[knownKey];\n    if (schema2.required && schema2.required.includes(knownKey)) {\n      if (!Visit$4(property2, references, value2[knownKey])) {\n        return false;\n      }\n      if ((ExtendsUndefinedCheck(property2) || IsAnyOrUnknown(property2)) && !(knownKey in value2)) {\n        return false;\n      }\n    } else {\n      if (TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey) && !Visit$4(property2, references, value2[knownKey])) {\n        return false;\n      }\n    }\n  }\n  if (schema2.additionalProperties === false) {\n    const valueKeys = Object.getOwnPropertyNames(value2);\n    if (schema2.required && schema2.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n      return true;\n    } else {\n      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));\n    }\n  } else if (typeof schema2.additionalProperties === \"object\") {\n    const valueKeys = Object.getOwnPropertyNames(value2);\n    return valueKeys.every((key) => knownKeys.includes(key) || Visit$4(schema2.additionalProperties, references, value2[key]));\n  } else {\n    return true;\n  }\n}\nfunction FromPromise$4(schema2, references, value2) {\n  return IsPromise$2(value2);\n}\nfunction FromRecord$6(schema2, references, value2) {\n  if (!TypeSystemPolicy.IsRecordLike(value2)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {\n    return false;\n  }\n  const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];\n  const regex2 = new RegExp(patternKey);\n  const check1 = Object.entries(value2).every(([key, value3]) => {\n    return regex2.test(key) ? Visit$4(patternSchema, references, value3) : true;\n  });\n  const check2 = typeof schema2.additionalProperties === \"object\" ? Object.entries(value2).every(([key, value3]) => {\n    return !regex2.test(key) ? Visit$4(schema2.additionalProperties, references, value3) : true;\n  }) : true;\n  const check3 = schema2.additionalProperties === false ? Object.getOwnPropertyNames(value2).every((key) => {\n    return regex2.test(key);\n  }) : true;\n  return check1 && check2 && check3;\n}\nfunction FromRef$7(schema2, references, value2) {\n  return Visit$4(Deref(schema2, references), references, value2);\n}\nfunction FromRegExp$1(schema2, references, value2) {\n  const regex2 = new RegExp(schema2.source, schema2.flags);\n  if (IsDefined$1(schema2.minLength)) {\n    if (!(value2.length >= schema2.minLength))\n      return false;\n  }\n  if (IsDefined$1(schema2.maxLength)) {\n    if (!(value2.length <= schema2.maxLength))\n      return false;\n  }\n  return regex2.test(value2);\n}\nfunction FromString$1(schema2, references, value2) {\n  if (!IsString$3(value2)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minLength)) {\n    if (!(value2.length >= schema2.minLength))\n      return false;\n  }\n  if (IsDefined$1(schema2.maxLength)) {\n    if (!(value2.length <= schema2.maxLength))\n      return false;\n  }\n  if (IsDefined$1(schema2.pattern)) {\n    const regex2 = new RegExp(schema2.pattern);\n    if (!regex2.test(value2))\n      return false;\n  }\n  if (IsDefined$1(schema2.format)) {\n    if (!Has$1(schema2.format))\n      return false;\n    const func = Get$1(schema2.format);\n    return func(value2);\n  }\n  return true;\n}\nfunction FromSymbol$1(schema2, references, value2) {\n  return IsSymbol$3(value2);\n}\nfunction FromTemplateLiteral$2(schema2, references, value2) {\n  return IsString$3(value2) && new RegExp(schema2.pattern).test(value2);\n}\nfunction FromThis$4(schema2, references, value2) {\n  return Visit$4(Deref(schema2, references), references, value2);\n}\nfunction FromTuple$6(schema2, references, value2) {\n  if (!IsArray$3(value2)) {\n    return false;\n  }\n  if (schema2.items === void 0 && !(value2.length === 0)) {\n    return false;\n  }\n  if (!(value2.length === schema2.maxItems)) {\n    return false;\n  }\n  if (!schema2.items) {\n    return true;\n  }\n  for (let i = 0; i < schema2.items.length; i++) {\n    if (!Visit$4(schema2.items[i], references, value2[i]))\n      return false;\n  }\n  return true;\n}\nfunction FromUndefined$1(schema2, references, value2) {\n  return IsUndefined$3(value2);\n}\nfunction FromUnion$9(schema2, references, value2) {\n  return schema2.anyOf.some((inner) => Visit$4(inner, references, value2));\n}\nfunction FromUint8Array$1(schema2, references, value2) {\n  if (!IsUint8Array$3(value2)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.maxByteLength) && !(value2.length <= schema2.maxByteLength)) {\n    return false;\n  }\n  if (IsDefined$1(schema2.minByteLength) && !(value2.length >= schema2.minByteLength)) {\n    return false;\n  }\n  return true;\n}\nfunction FromUnknown$1(schema2, references, value2) {\n  return true;\n}\nfunction FromVoid$1(schema2, references, value2) {\n  return TypeSystemPolicy.IsVoidLike(value2);\n}\nfunction FromKind$1(schema2, references, value2) {\n  if (!Has(schema2[Kind]))\n    return false;\n  const func = Get(schema2[Kind]);\n  return func(schema2, value2);\n}\nfunction Visit$4(schema2, references, value2) {\n  const references_ = IsDefined$1(schema2.$id) ? Pushref(schema2, references) : references;\n  const schema_ = schema2;\n  switch (schema_[Kind]) {\n    case \"Any\":\n      return FromAny$1();\n    case \"Argument\":\n      return FromArgument$2();\n    case \"Array\":\n      return FromArray$8(schema_, references_, value2);\n    case \"AsyncIterator\":\n      return FromAsyncIterator$4(schema_, references_, value2);\n    case \"BigInt\":\n      return FromBigInt$1(schema_, references_, value2);\n    case \"Boolean\":\n      return FromBoolean$1(schema_, references_, value2);\n    case \"Constructor\":\n      return FromConstructor$4(schema_, references_, value2);\n    case \"Date\":\n      return FromDate$3(schema_, references_, value2);\n    case \"Function\":\n      return FromFunction$4(schema_, references_, value2);\n    case \"Import\":\n      return FromImport$4(schema_, references_, value2);\n    case \"Integer\":\n      return FromInteger$1(schema_, references_, value2);\n    case \"Intersect\":\n      return FromIntersect$9(schema_, references_, value2);\n    case \"Iterator\":\n      return FromIterator$4(schema_, references_, value2);\n    case \"Literal\":\n      return FromLiteral$1(schema_, references_, value2);\n    case \"Never\":\n      return FromNever$1();\n    case \"Not\":\n      return FromNot$3(schema_, references_, value2);\n    case \"Null\":\n      return FromNull$1(schema_, references_, value2);\n    case \"Number\":\n      return FromNumber$1(schema_, references_, value2);\n    case \"Object\":\n      return FromObject$b(schema_, references_, value2);\n    case \"Promise\":\n      return FromPromise$4(schema_, references_, value2);\n    case \"Record\":\n      return FromRecord$6(schema_, references_, value2);\n    case \"Ref\":\n      return FromRef$7(schema_, references_, value2);\n    case \"RegExp\":\n      return FromRegExp$1(schema_, references_, value2);\n    case \"String\":\n      return FromString$1(schema_, references_, value2);\n    case \"Symbol\":\n      return FromSymbol$1(schema_, references_, value2);\n    case \"TemplateLiteral\":\n      return FromTemplateLiteral$2(schema_, references_, value2);\n    case \"This\":\n      return FromThis$4(schema_, references_, value2);\n    case \"Tuple\":\n      return FromTuple$6(schema_, references_, value2);\n    case \"Undefined\":\n      return FromUndefined$1(schema_, references_, value2);\n    case \"Union\":\n      return FromUnion$9(schema_, references_, value2);\n    case \"Uint8Array\":\n      return FromUint8Array$1(schema_, references_, value2);\n    case \"Unknown\":\n      return FromUnknown$1();\n    case \"Void\":\n      return FromVoid$1(schema_, references_, value2);\n    default:\n      if (!Has(schema_[Kind]))\n        throw new ValueCheckUnknownTypeError(schema_);\n      return FromKind$1(schema_, references_, value2);\n  }\n}\nfunction Check(...args) {\n  return args.length === 3 ? Visit$4(args[0], args[1], args[2]) : Visit$4(args[0], [], args[1]);\n}\nfunction EscapeKey(key) {\n  return key.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nfunction IsDefined(value2) {\n  return value2 !== void 0;\n}\nfunction Create(errorType, schema2, path, value2, errors = []) {\n  return {\n    type: errorType,\n    schema: schema2,\n    path,\n    value: value2,\n    message: GetErrorFunction()({ errorType, path, schema: schema2, value: value2, errors }),\n    errors\n  };\n}\nfunction* FromAny(schema2, references, path, value2) {\n}\nfunction* FromArgument$1(schema2, references, path, value2) {\n}\nfunction* FromArray$7(schema2, references, path, value2) {\n  if (!IsArray$3(value2)) {\n    return yield Create(ValueErrorType.Array, schema2, path, value2);\n  }\n  if (IsDefined(schema2.minItems) && !(value2.length >= schema2.minItems)) {\n    yield Create(ValueErrorType.ArrayMinItems, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maxItems) && !(value2.length <= schema2.maxItems)) {\n    yield Create(ValueErrorType.ArrayMaxItems, schema2, path, value2);\n  }\n  for (let i = 0; i < value2.length; i++) {\n    yield* Visit$3(schema2.items, references, `${path}/${i}`, value2[i]);\n  }\n  if (schema2.uniqueItems === true && !function() {\n    const set2 = /* @__PURE__ */ new Set();\n    for (const element of value2) {\n      const hashed = Hash$1(element);\n      if (set2.has(hashed)) {\n        return false;\n      } else {\n        set2.add(hashed);\n      }\n    }\n    return true;\n  }()) {\n    yield Create(ValueErrorType.ArrayUniqueItems, schema2, path, value2);\n  }\n  if (!(IsDefined(schema2.contains) || IsDefined(schema2.minContains) || IsDefined(schema2.maxContains))) {\n    return;\n  }\n  const containsSchema = IsDefined(schema2.contains) ? schema2.contains : Never();\n  const containsCount = value2.reduce((acc, value3, index) => Visit$3(containsSchema, references, `${path}${index}`, value3).next().done === true ? acc + 1 : acc, 0);\n  if (containsCount === 0) {\n    yield Create(ValueErrorType.ArrayContains, schema2, path, value2);\n  }\n  if (IsNumber$3(schema2.minContains) && containsCount < schema2.minContains) {\n    yield Create(ValueErrorType.ArrayMinContains, schema2, path, value2);\n  }\n  if (IsNumber$3(schema2.maxContains) && containsCount > schema2.maxContains) {\n    yield Create(ValueErrorType.ArrayMaxContains, schema2, path, value2);\n  }\n}\nfunction* FromAsyncIterator$3(schema2, references, path, value2) {\n  if (!IsAsyncIterator$3(value2))\n    yield Create(ValueErrorType.AsyncIterator, schema2, path, value2);\n}\nfunction* FromBigInt(schema2, references, path, value2) {\n  if (!IsBigInt$3(value2))\n    return yield Create(ValueErrorType.BigInt, schema2, path, value2);\n  if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {\n    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {\n    yield Create(ValueErrorType.BigIntMaximum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {\n    yield Create(ValueErrorType.BigIntMinimum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === BigInt(0))) {\n    yield Create(ValueErrorType.BigIntMultipleOf, schema2, path, value2);\n  }\n}\nfunction* FromBoolean(schema2, references, path, value2) {\n  if (!IsBoolean$3(value2))\n    yield Create(ValueErrorType.Boolean, schema2, path, value2);\n}\nfunction* FromConstructor$3(schema2, references, path, value2) {\n  yield* Visit$3(schema2.returns, references, path, value2.prototype);\n}\nfunction* FromDate$2(schema2, references, path, value2) {\n  if (!IsDate$3(value2))\n    return yield Create(ValueErrorType.Date, schema2, path, value2);\n  if (IsDefined(schema2.exclusiveMaximumTimestamp) && !(value2.getTime() < schema2.exclusiveMaximumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema2, path, value2);\n  }\n  if (IsDefined(schema2.exclusiveMinimumTimestamp) && !(value2.getTime() > schema2.exclusiveMinimumTimestamp)) {\n    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maximumTimestamp) && !(value2.getTime() <= schema2.maximumTimestamp)) {\n    yield Create(ValueErrorType.DateMaximumTimestamp, schema2, path, value2);\n  }\n  if (IsDefined(schema2.minimumTimestamp) && !(value2.getTime() >= schema2.minimumTimestamp)) {\n    yield Create(ValueErrorType.DateMinimumTimestamp, schema2, path, value2);\n  }\n  if (IsDefined(schema2.multipleOfTimestamp) && !(value2.getTime() % schema2.multipleOfTimestamp === 0)) {\n    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema2, path, value2);\n  }\n}\nfunction* FromFunction$3(schema2, references, path, value2) {\n  if (!IsFunction$3(value2))\n    yield Create(ValueErrorType.Function, schema2, path, value2);\n}\nfunction* FromImport$3(schema2, references, path, value2) {\n  const definitions = globalThis.Object.values(schema2.$defs);\n  const target = schema2.$defs[schema2.$ref];\n  yield* Visit$3(target, [...references, ...definitions], path, value2);\n}\nfunction* FromInteger(schema2, references, path, value2) {\n  if (!IsInteger$2(value2))\n    return yield Create(ValueErrorType.Integer, schema2, path, value2);\n  if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {\n    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {\n    yield Create(ValueErrorType.IntegerMaximum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {\n    yield Create(ValueErrorType.IntegerMinimum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {\n    yield Create(ValueErrorType.IntegerMultipleOf, schema2, path, value2);\n  }\n}\nfunction* FromIntersect$8(schema2, references, path, value2) {\n  let hasError = false;\n  for (const inner of schema2.allOf) {\n    for (const error4 of Visit$3(inner, references, path, value2)) {\n      hasError = true;\n      yield error4;\n    }\n  }\n  if (hasError) {\n    return yield Create(ValueErrorType.Intersect, schema2, path, value2);\n  }\n  if (schema2.unevaluatedProperties === false) {\n    const keyCheck = new RegExp(KeyOfPattern(schema2));\n    for (const valueKey of Object.getOwnPropertyNames(value2)) {\n      if (!keyCheck.test(valueKey)) {\n        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema2, `${path}/${valueKey}`, value2);\n      }\n    }\n  }\n  if (typeof schema2.unevaluatedProperties === \"object\") {\n    const keyCheck = new RegExp(KeyOfPattern(schema2));\n    for (const valueKey of Object.getOwnPropertyNames(value2)) {\n      if (!keyCheck.test(valueKey)) {\n        const next = Visit$3(schema2.unevaluatedProperties, references, `${path}/${valueKey}`, value2[valueKey]).next();\n        if (!next.done)\n          yield next.value;\n      }\n    }\n  }\n}\nfunction* FromIterator$3(schema2, references, path, value2) {\n  if (!IsIterator$3(value2))\n    yield Create(ValueErrorType.Iterator, schema2, path, value2);\n}\nfunction* FromLiteral(schema2, references, path, value2) {\n  if (!(value2 === schema2.const))\n    yield Create(ValueErrorType.Literal, schema2, path, value2);\n}\nfunction* FromNever(schema2, references, path, value2) {\n  yield Create(ValueErrorType.Never, schema2, path, value2);\n}\nfunction* FromNot$2(schema2, references, path, value2) {\n  if (Visit$3(schema2.not, references, path, value2).next().done === true)\n    yield Create(ValueErrorType.Not, schema2, path, value2);\n}\nfunction* FromNull(schema2, references, path, value2) {\n  if (!IsNull$3(value2))\n    yield Create(ValueErrorType.Null, schema2, path, value2);\n}\nfunction* FromNumber(schema2, references, path, value2) {\n  if (!TypeSystemPolicy.IsNumberLike(value2))\n    return yield Create(ValueErrorType.Number, schema2, path, value2);\n  if (IsDefined(schema2.exclusiveMaximum) && !(value2 < schema2.exclusiveMaximum)) {\n    yield Create(ValueErrorType.NumberExclusiveMaximum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.exclusiveMinimum) && !(value2 > schema2.exclusiveMinimum)) {\n    yield Create(ValueErrorType.NumberExclusiveMinimum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maximum) && !(value2 <= schema2.maximum)) {\n    yield Create(ValueErrorType.NumberMaximum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.minimum) && !(value2 >= schema2.minimum)) {\n    yield Create(ValueErrorType.NumberMinimum, schema2, path, value2);\n  }\n  if (IsDefined(schema2.multipleOf) && !(value2 % schema2.multipleOf === 0)) {\n    yield Create(ValueErrorType.NumberMultipleOf, schema2, path, value2);\n  }\n}\nfunction* FromObject$a(schema2, references, path, value2) {\n  if (!TypeSystemPolicy.IsObjectLike(value2))\n    return yield Create(ValueErrorType.Object, schema2, path, value2);\n  if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema2, path, value2);\n  }\n  const requiredKeys = Array.isArray(schema2.required) ? schema2.required : [];\n  const knownKeys = Object.getOwnPropertyNames(schema2.properties);\n  const unknownKeys = Object.getOwnPropertyNames(value2);\n  for (const requiredKey of requiredKeys) {\n    if (unknownKeys.includes(requiredKey))\n      continue;\n    yield Create(ValueErrorType.ObjectRequiredProperty, schema2.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);\n  }\n  if (schema2.additionalProperties === false) {\n    for (const valueKey of unknownKeys) {\n      if (!knownKeys.includes(valueKey)) {\n        yield Create(ValueErrorType.ObjectAdditionalProperties, schema2, `${path}/${EscapeKey(valueKey)}`, value2[valueKey]);\n      }\n    }\n  }\n  if (typeof schema2.additionalProperties === \"object\") {\n    for (const valueKey of unknownKeys) {\n      if (knownKeys.includes(valueKey))\n        continue;\n      yield* Visit$3(schema2.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value2[valueKey]);\n    }\n  }\n  for (const knownKey of knownKeys) {\n    const property2 = schema2.properties[knownKey];\n    if (schema2.required && schema2.required.includes(knownKey)) {\n      yield* Visit$3(property2, references, `${path}/${EscapeKey(knownKey)}`, value2[knownKey]);\n      if (ExtendsUndefinedCheck(schema2) && !(knownKey in value2)) {\n        yield Create(ValueErrorType.ObjectRequiredProperty, property2, `${path}/${EscapeKey(knownKey)}`, void 0);\n      }\n    } else {\n      if (TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey)) {\n        yield* Visit$3(property2, references, `${path}/${EscapeKey(knownKey)}`, value2[knownKey]);\n      }\n    }\n  }\n}\nfunction* FromPromise$3(schema2, references, path, value2) {\n  if (!IsPromise$2(value2))\n    yield Create(ValueErrorType.Promise, schema2, path, value2);\n}\nfunction* FromRecord$5(schema2, references, path, value2) {\n  if (!TypeSystemPolicy.IsRecordLike(value2))\n    return yield Create(ValueErrorType.Object, schema2, path, value2);\n  if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema2.minProperties)) {\n    yield Create(ValueErrorType.ObjectMinProperties, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema2.maxProperties)) {\n    yield Create(ValueErrorType.ObjectMaxProperties, schema2, path, value2);\n  }\n  const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];\n  const regex2 = new RegExp(patternKey);\n  for (const [propertyKey, propertyValue] of Object.entries(value2)) {\n    if (regex2.test(propertyKey))\n      yield* Visit$3(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n  }\n  if (typeof schema2.additionalProperties === \"object\") {\n    for (const [propertyKey, propertyValue] of Object.entries(value2)) {\n      if (!regex2.test(propertyKey))\n        yield* Visit$3(schema2.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n  if (schema2.additionalProperties === false) {\n    for (const [propertyKey, propertyValue] of Object.entries(value2)) {\n      if (regex2.test(propertyKey))\n        continue;\n      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema2, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n  }\n}\nfunction* FromRef$6(schema2, references, path, value2) {\n  yield* Visit$3(Deref(schema2, references), references, path, value2);\n}\nfunction* FromRegExp(schema2, references, path, value2) {\n  if (!IsString$3(value2))\n    return yield Create(ValueErrorType.String, schema2, path, value2);\n  if (IsDefined(schema2.minLength) && !(value2.length >= schema2.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maxLength) && !(value2.length <= schema2.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema2, path, value2);\n  }\n  const regex2 = new RegExp(schema2.source, schema2.flags);\n  if (!regex2.test(value2)) {\n    return yield Create(ValueErrorType.RegExp, schema2, path, value2);\n  }\n}\nfunction* FromString(schema2, references, path, value2) {\n  if (!IsString$3(value2))\n    return yield Create(ValueErrorType.String, schema2, path, value2);\n  if (IsDefined(schema2.minLength) && !(value2.length >= schema2.minLength)) {\n    yield Create(ValueErrorType.StringMinLength, schema2, path, value2);\n  }\n  if (IsDefined(schema2.maxLength) && !(value2.length <= schema2.maxLength)) {\n    yield Create(ValueErrorType.StringMaxLength, schema2, path, value2);\n  }\n  if (IsString$3(schema2.pattern)) {\n    const regex2 = new RegExp(schema2.pattern);\n    if (!regex2.test(value2)) {\n      yield Create(ValueErrorType.StringPattern, schema2, path, value2);\n    }\n  }\n  if (IsString$3(schema2.format)) {\n    if (!Has$1(schema2.format)) {\n      yield Create(ValueErrorType.StringFormatUnknown, schema2, path, value2);\n    } else {\n      const format2 = Get$1(schema2.format);\n      if (!format2(value2)) {\n        yield Create(ValueErrorType.StringFormat, schema2, path, value2);\n      }\n    }\n  }\n}\nfunction* FromSymbol(schema2, references, path, value2) {\n  if (!IsSymbol$3(value2))\n    yield Create(ValueErrorType.Symbol, schema2, path, value2);\n}\nfunction* FromTemplateLiteral$1(schema2, references, path, value2) {\n  if (!IsString$3(value2))\n    return yield Create(ValueErrorType.String, schema2, path, value2);\n  const regex2 = new RegExp(schema2.pattern);\n  if (!regex2.test(value2)) {\n    yield Create(ValueErrorType.StringPattern, schema2, path, value2);\n  }\n}\nfunction* FromThis$3(schema2, references, path, value2) {\n  yield* Visit$3(Deref(schema2, references), references, path, value2);\n}\nfunction* FromTuple$5(schema2, references, path, value2) {\n  if (!IsArray$3(value2))\n    return yield Create(ValueErrorType.Tuple, schema2, path, value2);\n  if (schema2.items === void 0 && !(value2.length === 0)) {\n    return yield Create(ValueErrorType.TupleLength, schema2, path, value2);\n  }\n  if (!(value2.length === schema2.maxItems)) {\n    return yield Create(ValueErrorType.TupleLength, schema2, path, value2);\n  }\n  if (!schema2.items) {\n    return;\n  }\n  for (let i = 0; i < schema2.items.length; i++) {\n    yield* Visit$3(schema2.items[i], references, `${path}/${i}`, value2[i]);\n  }\n}\nfunction* FromUndefined(schema2, references, path, value2) {\n  if (!IsUndefined$3(value2))\n    yield Create(ValueErrorType.Undefined, schema2, path, value2);\n}\nfunction* FromUnion$8(schema2, references, path, value2) {\n  if (Check(schema2, references, value2))\n    return;\n  const errors = schema2.anyOf.map((variant) => new ValueErrorIterator(Visit$3(variant, references, path, value2)));\n  yield Create(ValueErrorType.Union, schema2, path, value2, errors);\n}\nfunction* FromUint8Array(schema2, references, path, value2) {\n  if (!IsUint8Array$3(value2))\n    return yield Create(ValueErrorType.Uint8Array, schema2, path, value2);\n  if (IsDefined(schema2.maxByteLength) && !(value2.length <= schema2.maxByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema2, path, value2);\n  }\n  if (IsDefined(schema2.minByteLength) && !(value2.length >= schema2.minByteLength)) {\n    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema2, path, value2);\n  }\n}\nfunction* FromUnknown(schema2, references, path, value2) {\n}\nfunction* FromVoid(schema2, references, path, value2) {\n  if (!TypeSystemPolicy.IsVoidLike(value2))\n    yield Create(ValueErrorType.Void, schema2, path, value2);\n}\nfunction* FromKind(schema2, references, path, value2) {\n  const check2 = Get(schema2[Kind]);\n  if (!check2(schema2, value2))\n    yield Create(ValueErrorType.Kind, schema2, path, value2);\n}\nfunction* Visit$3(schema2, references, path, value2) {\n  const references_ = IsDefined(schema2.$id) ? [...references, schema2] : references;\n  const schema_ = schema2;\n  switch (schema_[Kind]) {\n    case \"Any\":\n      return yield* FromAny();\n    case \"Argument\":\n      return yield* FromArgument$1();\n    case \"Array\":\n      return yield* FromArray$7(schema_, references_, path, value2);\n    case \"AsyncIterator\":\n      return yield* FromAsyncIterator$3(schema_, references_, path, value2);\n    case \"BigInt\":\n      return yield* FromBigInt(schema_, references_, path, value2);\n    case \"Boolean\":\n      return yield* FromBoolean(schema_, references_, path, value2);\n    case \"Constructor\":\n      return yield* FromConstructor$3(schema_, references_, path, value2);\n    case \"Date\":\n      return yield* FromDate$2(schema_, references_, path, value2);\n    case \"Function\":\n      return yield* FromFunction$3(schema_, references_, path, value2);\n    case \"Import\":\n      return yield* FromImport$3(schema_, references_, path, value2);\n    case \"Integer\":\n      return yield* FromInteger(schema_, references_, path, value2);\n    case \"Intersect\":\n      return yield* FromIntersect$8(schema_, references_, path, value2);\n    case \"Iterator\":\n      return yield* FromIterator$3(schema_, references_, path, value2);\n    case \"Literal\":\n      return yield* FromLiteral(schema_, references_, path, value2);\n    case \"Never\":\n      return yield* FromNever(schema_, references_, path, value2);\n    case \"Not\":\n      return yield* FromNot$2(schema_, references_, path, value2);\n    case \"Null\":\n      return yield* FromNull(schema_, references_, path, value2);\n    case \"Number\":\n      return yield* FromNumber(schema_, references_, path, value2);\n    case \"Object\":\n      return yield* FromObject$a(schema_, references_, path, value2);\n    case \"Promise\":\n      return yield* FromPromise$3(schema_, references_, path, value2);\n    case \"Record\":\n      return yield* FromRecord$5(schema_, references_, path, value2);\n    case \"Ref\":\n      return yield* FromRef$6(schema_, references_, path, value2);\n    case \"RegExp\":\n      return yield* FromRegExp(schema_, references_, path, value2);\n    case \"String\":\n      return yield* FromString(schema_, references_, path, value2);\n    case \"Symbol\":\n      return yield* FromSymbol(schema_, references_, path, value2);\n    case \"TemplateLiteral\":\n      return yield* FromTemplateLiteral$1(schema_, references_, path, value2);\n    case \"This\":\n      return yield* FromThis$3(schema_, references_, path, value2);\n    case \"Tuple\":\n      return yield* FromTuple$5(schema_, references_, path, value2);\n    case \"Undefined\":\n      return yield* FromUndefined(schema_, references_, path, value2);\n    case \"Union\":\n      return yield* FromUnion$8(schema_, references_, path, value2);\n    case \"Uint8Array\":\n      return yield* FromUint8Array(schema_, references_, path, value2);\n    case \"Unknown\":\n      return yield* FromUnknown();\n    case \"Void\":\n      return yield* FromVoid(schema_, references_, path, value2);\n    default:\n      if (!Has(schema_[Kind]))\n        throw new ValueErrorsUnknownTypeError(schema2);\n      return yield* FromKind(schema_, references_, path, value2);\n  }\n}\nfunction Errors(...args) {\n  const iterator = args.length === 3 ? Visit$3(args[0], args[1], \"\", args[2]) : Visit$3(args[0], [], \"\", args[1]);\n  return new ValueErrorIterator(iterator);\n}\nfunction FromObject$9(value2) {\n  const Acc = {};\n  for (const key of Object.getOwnPropertyNames(value2)) {\n    Acc[key] = Clone(value2[key]);\n  }\n  for (const key of Object.getOwnPropertySymbols(value2)) {\n    Acc[key] = Clone(value2[key]);\n  }\n  return Acc;\n}\nfunction FromArray$6(value2) {\n  return value2.map((element) => Clone(element));\n}\nfunction FromTypedArray(value2) {\n  return value2.slice();\n}\nfunction FromMap(value2) {\n  return new Map(Clone([...value2.entries()]));\n}\nfunction FromSet(value2) {\n  return new Set(Clone([...value2.entries()]));\n}\nfunction FromDate$1(value2) {\n  return new Date(value2.toISOString());\n}\nfunction FromValue$1(value2) {\n  return value2;\n}\nfunction Clone(value2) {\n  if (IsArray$3(value2))\n    return FromArray$6(value2);\n  if (IsDate$3(value2))\n    return FromDate$1(value2);\n  if (IsTypedArray(value2))\n    return FromTypedArray(value2);\n  if (IsMap(value2))\n    return FromMap(value2);\n  if (IsSet(value2))\n    return FromSet(value2);\n  if (IsObject$3(value2))\n    return FromObject$9(value2);\n  if (IsValueType(value2))\n    return FromValue$1(value2);\n  throw new Error(\"ValueClone: Unable to clone value\");\n}\nfunction Default$1(schema2, path, value2) {\n  try {\n    return IsTransform$1(schema2) ? schema2[TransformKind].Decode(value2) : value2;\n  } catch (error4) {\n    throw new TransformDecodeError(schema2, path, value2, error4);\n  }\n}\nfunction FromArray$5(schema2, references, path, value2) {\n  return IsArray$3(value2) ? Default$1(schema2, path, value2.map((value3, index) => Visit$2(schema2.items, references, `${path}/${index}`, value3))) : Default$1(schema2, path, value2);\n}\nfunction FromIntersect$7(schema2, references, path, value2) {\n  if (!IsObject$3(value2) || IsValueType(value2))\n    return Default$1(schema2, path, value2);\n  const knownEntries = KeyOfPropertyEntries(schema2);\n  const knownKeys = knownEntries.map((entry) => entry[0]);\n  const knownProperties = { ...value2 };\n  for (const [knownKey, knownSchema] of knownEntries)\n    if (knownKey in knownProperties) {\n      knownProperties[knownKey] = Visit$2(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);\n    }\n  if (!IsTransform$1(schema2.unevaluatedProperties)) {\n    return Default$1(schema2, path, knownProperties);\n  }\n  const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n  const unevaluatedProperties = schema2.unevaluatedProperties;\n  const unknownProperties = { ...knownProperties };\n  for (const key of unknownKeys)\n    if (!knownKeys.includes(key)) {\n      unknownProperties[key] = Default$1(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);\n    }\n  return Default$1(schema2, path, unknownProperties);\n}\nfunction FromImport$2(schema2, references, path, value2) {\n  const additional = globalThis.Object.values(schema2.$defs);\n  const target = schema2.$defs[schema2.$ref];\n  const result = Visit$2(target, [...references, ...additional], path, value2);\n  return Default$1(schema2, path, result);\n}\nfunction FromNot$1(schema2, references, path, value2) {\n  return Default$1(schema2, path, Visit$2(schema2.not, references, path, value2));\n}\nfunction FromObject$8(schema2, references, path, value2) {\n  if (!IsObject$3(value2))\n    return Default$1(schema2, path, value2);\n  const knownKeys = KeyOfPropertyKeys(schema2);\n  const knownProperties = { ...value2 };\n  for (const key of knownKeys) {\n    if (!HasPropertyKey$1(knownProperties, key))\n      continue;\n    if (IsUndefined$3(knownProperties[key]) && (!IsUndefined$1(schema2.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))\n      continue;\n    knownProperties[key] = Visit$2(schema2.properties[key], references, `${path}/${key}`, knownProperties[key]);\n  }\n  if (!IsSchema$1(schema2.additionalProperties)) {\n    return Default$1(schema2, path, knownProperties);\n  }\n  const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n  const additionalProperties = schema2.additionalProperties;\n  const unknownProperties = { ...knownProperties };\n  for (const key of unknownKeys)\n    if (!knownKeys.includes(key)) {\n      unknownProperties[key] = Default$1(additionalProperties, `${path}/${key}`, unknownProperties[key]);\n    }\n  return Default$1(schema2, path, unknownProperties);\n}\nfunction FromRecord$4(schema2, references, path, value2) {\n  if (!IsObject$3(value2))\n    return Default$1(schema2, path, value2);\n  const pattern = Object.getOwnPropertyNames(schema2.patternProperties)[0];\n  const knownKeys = new RegExp(pattern);\n  const knownProperties = { ...value2 };\n  for (const key of Object.getOwnPropertyNames(value2))\n    if (knownKeys.test(key)) {\n      knownProperties[key] = Visit$2(schema2.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);\n    }\n  if (!IsSchema$1(schema2.additionalProperties)) {\n    return Default$1(schema2, path, knownProperties);\n  }\n  const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n  const additionalProperties = schema2.additionalProperties;\n  const unknownProperties = { ...knownProperties };\n  for (const key of unknownKeys)\n    if (!knownKeys.test(key)) {\n      unknownProperties[key] = Default$1(additionalProperties, `${path}/${key}`, unknownProperties[key]);\n    }\n  return Default$1(schema2, path, unknownProperties);\n}\nfunction FromRef$5(schema2, references, path, value2) {\n  const target = Deref(schema2, references);\n  return Default$1(schema2, path, Visit$2(target, references, path, value2));\n}\nfunction FromThis$2(schema2, references, path, value2) {\n  const target = Deref(schema2, references);\n  return Default$1(schema2, path, Visit$2(target, references, path, value2));\n}\nfunction FromTuple$4(schema2, references, path, value2) {\n  return IsArray$3(value2) && IsArray$3(schema2.items) ? Default$1(schema2, path, schema2.items.map((schema3, index) => Visit$2(schema3, references, `${path}/${index}`, value2[index]))) : Default$1(schema2, path, value2);\n}\nfunction FromUnion$7(schema2, references, path, value2) {\n  for (const subschema of schema2.anyOf) {\n    if (!Check(subschema, references, value2))\n      continue;\n    const decoded = Visit$2(subschema, references, path, value2);\n    return Default$1(schema2, path, decoded);\n  }\n  return Default$1(schema2, path, value2);\n}\nfunction Visit$2(schema2, references, path, value2) {\n  const references_ = Pushref(schema2, references);\n  const schema_ = schema2;\n  switch (schema2[Kind]) {\n    case \"Array\":\n      return FromArray$5(schema_, references_, path, value2);\n    case \"Import\":\n      return FromImport$2(schema_, references_, path, value2);\n    case \"Intersect\":\n      return FromIntersect$7(schema_, references_, path, value2);\n    case \"Not\":\n      return FromNot$1(schema_, references_, path, value2);\n    case \"Object\":\n      return FromObject$8(schema_, references_, path, value2);\n    case \"Record\":\n      return FromRecord$4(schema_, references_, path, value2);\n    case \"Ref\":\n      return FromRef$5(schema_, references_, path, value2);\n    case \"Symbol\":\n      return Default$1(schema_, path, value2);\n    case \"This\":\n      return FromThis$2(schema_, references_, path, value2);\n    case \"Tuple\":\n      return FromTuple$4(schema_, references_, path, value2);\n    case \"Union\":\n      return FromUnion$7(schema_, references_, path, value2);\n    default:\n      return Default$1(schema_, path, value2);\n  }\n}\nfunction TransformDecode(schema2, references, value2) {\n  return Visit$2(schema2, references, \"\", value2);\n}\nfunction FromArray$4(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.items, references);\n}\nfunction FromAsyncIterator$2(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.items, references);\n}\nfunction FromConstructor$2(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.returns, references) || schema2.parameters.some((schema3) => Visit$1(schema3, references));\n}\nfunction FromFunction$2(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.returns, references) || schema2.parameters.some((schema3) => Visit$1(schema3, references));\n}\nfunction FromIntersect$6(schema2, references) {\n  return IsTransform$1(schema2) || IsTransform$1(schema2.unevaluatedProperties) || schema2.allOf.some((schema3) => Visit$1(schema3, references));\n}\nfunction FromImport$1(schema2, references) {\n  const additional = globalThis.Object.getOwnPropertyNames(schema2.$defs).reduce((result, key) => [...result, schema2.$defs[key]], []);\n  const target = schema2.$defs[schema2.$ref];\n  return IsTransform$1(schema2) || Visit$1(target, [...additional, ...references]);\n}\nfunction FromIterator$2(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.items, references);\n}\nfunction FromNot(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.not, references);\n}\nfunction FromObject$7(schema2, references) {\n  return IsTransform$1(schema2) || Object.values(schema2.properties).some((schema3) => Visit$1(schema3, references)) || IsSchema$1(schema2.additionalProperties) && Visit$1(schema2.additionalProperties, references);\n}\nfunction FromPromise$2(schema2, references) {\n  return IsTransform$1(schema2) || Visit$1(schema2.item, references);\n}\nfunction FromRecord$3(schema2, references) {\n  const pattern = Object.getOwnPropertyNames(schema2.patternProperties)[0];\n  const property2 = schema2.patternProperties[pattern];\n  return IsTransform$1(schema2) || Visit$1(property2, references) || IsSchema$1(schema2.additionalProperties) && IsTransform$1(schema2.additionalProperties);\n}\nfunction FromRef$4(schema2, references) {\n  if (IsTransform$1(schema2))\n    return true;\n  return Visit$1(Deref(schema2, references), references);\n}\nfunction FromThis$1(schema2, references) {\n  if (IsTransform$1(schema2))\n    return true;\n  return Visit$1(Deref(schema2, references), references);\n}\nfunction FromTuple$3(schema2, references) {\n  return IsTransform$1(schema2) || !IsUndefined$3(schema2.items) && schema2.items.some((schema3) => Visit$1(schema3, references));\n}\nfunction FromUnion$6(schema2, references) {\n  return IsTransform$1(schema2) || schema2.anyOf.some((schema3) => Visit$1(schema3, references));\n}\nfunction Visit$1(schema2, references) {\n  const references_ = Pushref(schema2, references);\n  const schema_ = schema2;\n  if (schema2.$id && visited.has(schema2.$id))\n    return false;\n  if (schema2.$id)\n    visited.add(schema2.$id);\n  switch (schema2[Kind]) {\n    case \"Array\":\n      return FromArray$4(schema_, references_);\n    case \"AsyncIterator\":\n      return FromAsyncIterator$2(schema_, references_);\n    case \"Constructor\":\n      return FromConstructor$2(schema_, references_);\n    case \"Function\":\n      return FromFunction$2(schema_, references_);\n    case \"Import\":\n      return FromImport$1(schema_, references_);\n    case \"Intersect\":\n      return FromIntersect$6(schema_, references_);\n    case \"Iterator\":\n      return FromIterator$2(schema_, references_);\n    case \"Not\":\n      return FromNot(schema_, references_);\n    case \"Object\":\n      return FromObject$7(schema_, references_);\n    case \"Promise\":\n      return FromPromise$2(schema_, references_);\n    case \"Record\":\n      return FromRecord$3(schema_, references_);\n    case \"Ref\":\n      return FromRef$4(schema_, references_);\n    case \"This\":\n      return FromThis$1(schema_, references_);\n    case \"Tuple\":\n      return FromTuple$3(schema_, references_);\n    case \"Union\":\n      return FromUnion$6(schema_, references_);\n    default:\n      return IsTransform$1(schema2);\n  }\n}\nfunction HasTransform(schema2, references) {\n  visited.clear();\n  return Visit$1(schema2, references);\n}\nfunction Decode(...args) {\n  const [schema2, references, value2] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n  if (!Check(schema2, references, value2))\n    throw new TransformDecodeCheckError(schema2, value2, Errors(schema2, references, value2).First());\n  return HasTransform(schema2, references) ? TransformDecode(schema2, references, value2) : value2;\n}\nfunction ValueOrDefault(schema2, value2) {\n  const defaultValue = HasPropertyKey$1(schema2, \"default\") ? schema2.default : void 0;\n  const clone = IsFunction$3(defaultValue) ? defaultValue() : Clone(defaultValue);\n  return IsUndefined$3(value2) ? clone : IsObject$3(value2) && IsObject$3(clone) ? Object.assign(clone, value2) : value2;\n}\nfunction HasDefaultProperty(schema2) {\n  return IsKind$1(schema2) && \"default\" in schema2;\n}\nfunction FromArray$3(schema2, references, value2) {\n  if (IsArray$3(value2)) {\n    for (let i = 0; i < value2.length; i++) {\n      value2[i] = Visit(schema2.items, references, value2[i]);\n    }\n    return value2;\n  }\n  const defaulted = ValueOrDefault(schema2, value2);\n  if (!IsArray$3(defaulted))\n    return defaulted;\n  for (let i = 0; i < defaulted.length; i++) {\n    defaulted[i] = Visit(schema2.items, references, defaulted[i]);\n  }\n  return defaulted;\n}\nfunction FromDate(schema2, references, value2) {\n  return IsDate$3(value2) ? value2 : ValueOrDefault(schema2, value2);\n}\nfunction FromImport(schema2, references, value2) {\n  const definitions = globalThis.Object.values(schema2.$defs);\n  const target = schema2.$defs[schema2.$ref];\n  return Visit(target, [...references, ...definitions], value2);\n}\nfunction FromIntersect$5(schema2, references, value2) {\n  const defaulted = ValueOrDefault(schema2, value2);\n  return schema2.allOf.reduce((acc, schema3) => {\n    const next = Visit(schema3, references, defaulted);\n    return IsObject$3(next) ? { ...acc, ...next } : next;\n  }, {});\n}\nfunction FromObject$6(schema2, references, value2) {\n  const defaulted = ValueOrDefault(schema2, value2);\n  if (!IsObject$3(defaulted))\n    return defaulted;\n  const knownPropertyKeys = Object.getOwnPropertyNames(schema2.properties);\n  for (const key of knownPropertyKeys) {\n    const propertyValue = Visit(schema2.properties[key], references, defaulted[key]);\n    if (IsUndefined$3(propertyValue))\n      continue;\n    defaulted[key] = Visit(schema2.properties[key], references, defaulted[key]);\n  }\n  if (!HasDefaultProperty(schema2.additionalProperties))\n    return defaulted;\n  for (const key of Object.getOwnPropertyNames(defaulted)) {\n    if (knownPropertyKeys.includes(key))\n      continue;\n    defaulted[key] = Visit(schema2.additionalProperties, references, defaulted[key]);\n  }\n  return defaulted;\n}\nfunction FromRecord$2(schema2, references, value2) {\n  const defaulted = ValueOrDefault(schema2, value2);\n  if (!IsObject$3(defaulted))\n    return defaulted;\n  const additionalPropertiesSchema = schema2.additionalProperties;\n  const [propertyKeyPattern, propertySchema] = Object.entries(schema2.patternProperties)[0];\n  const knownPropertyKey = new RegExp(propertyKeyPattern);\n  for (const key of Object.getOwnPropertyNames(defaulted)) {\n    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))\n      continue;\n    defaulted[key] = Visit(propertySchema, references, defaulted[key]);\n  }\n  if (!HasDefaultProperty(additionalPropertiesSchema))\n    return defaulted;\n  for (const key of Object.getOwnPropertyNames(defaulted)) {\n    if (knownPropertyKey.test(key))\n      continue;\n    defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);\n  }\n  return defaulted;\n}\nfunction FromRef$3(schema2, references, value2) {\n  return Visit(Deref(schema2, references), references, ValueOrDefault(schema2, value2));\n}\nfunction FromThis(schema2, references, value2) {\n  return Visit(Deref(schema2, references), references, value2);\n}\nfunction FromTuple$2(schema2, references, value2) {\n  const defaulted = ValueOrDefault(schema2, value2);\n  if (!IsArray$3(defaulted) || IsUndefined$3(schema2.items))\n    return defaulted;\n  const [items, max] = [schema2.items, Math.max(schema2.items.length, defaulted.length)];\n  for (let i = 0; i < max; i++) {\n    if (i < items.length)\n      defaulted[i] = Visit(items[i], references, defaulted[i]);\n  }\n  return defaulted;\n}\nfunction FromUnion$5(schema2, references, value2) {\n  const defaulted = ValueOrDefault(schema2, value2);\n  for (const inner of schema2.anyOf) {\n    const result = Visit(inner, references, Clone(defaulted));\n    if (Check(inner, references, result)) {\n      return result;\n    }\n  }\n  return defaulted;\n}\nfunction Visit(schema2, references, value2) {\n  const references_ = Pushref(schema2, references);\n  const schema_ = schema2;\n  switch (schema_[Kind]) {\n    case \"Array\":\n      return FromArray$3(schema_, references_, value2);\n    case \"Date\":\n      return FromDate(schema_, references_, value2);\n    case \"Import\":\n      return FromImport(schema_, references_, value2);\n    case \"Intersect\":\n      return FromIntersect$5(schema_, references_, value2);\n    case \"Object\":\n      return FromObject$6(schema_, references_, value2);\n    case \"Record\":\n      return FromRecord$2(schema_, references_, value2);\n    case \"Ref\":\n      return FromRef$3(schema_, references_, value2);\n    case \"This\":\n      return FromThis(schema_, references_, value2);\n    case \"Tuple\":\n      return FromTuple$2(schema_, references_, value2);\n    case \"Union\":\n      return FromUnion$5(schema_, references_, value2);\n    default:\n      return ValueOrDefault(schema_, value2);\n  }\n}\nfunction Default(...args) {\n  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\nasync function hmac(key, string2) {\n  const cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    typeof key === \"string\" ? encoder$12.encode(key) : key,\n    { name: \"HMAC\", hash: { name: \"SHA-256\" } },\n    false,\n    [\"sign\"]\n  );\n  return crypto.subtle.sign(\"HMAC\", cryptoKey, encoder$12.encode(string2));\n}\nasync function hash$1(content) {\n  return crypto.subtle.digest(\"SHA-256\", typeof content === \"string\" ? encoder$12.encode(content) : content);\n}\nfunction buf2hex(arrayBuffer) {\n  const buffer = new Uint8Array(arrayBuffer);\n  let out = \"\";\n  for (let idx = 0; idx < buffer.length; idx++) {\n    const n27 = buffer[idx];\n    out += HEX_CHARS[n27 >>> 4 & 15];\n    out += HEX_CHARS[n27 & 15];\n  }\n  return out;\n}\nfunction encodeRfc3986(urlEncodedStr) {\n  return urlEncodedStr.replace(/[!'()*]/g, (c) => \"%\" + c.charCodeAt(0).toString(16).toUpperCase());\n}\nfunction guessServiceRegion(url, headers) {\n  const { hostname, pathname } = url;\n  if (hostname.endsWith(\".on.aws\")) {\n    const match2 = hostname.match(/^[^.]{1,63}\\.lambda-url\\.([^.]{1,63})\\.on\\.aws$/);\n    return match2 != null ? [\"lambda\", match2[1] || \"\"] : [\"\", \"\"];\n  }\n  if (hostname.endsWith(\".r2.cloudflarestorage.com\")) {\n    return [\"s3\", \"auto\"];\n  }\n  if (hostname.endsWith(\".backblazeb2.com\")) {\n    const match2 = hostname.match(/^(?:[^.]{1,63}\\.)?s3\\.([^.]{1,63})\\.backblazeb2\\.com$/);\n    return match2 != null ? [\"s3\", match2[1] || \"\"] : [\"\", \"\"];\n  }\n  const match = hostname.replace(\"dualstack.\", \"\").match(/([^.]{1,63})\\.(?:([^.]{0,63})\\.)?amazonaws\\.com(?:\\.cn)?$/);\n  let service = match && match[1] || \"\";\n  let region = match && match[2];\n  if (region === \"us-gov\") {\n    region = \"us-gov-west-1\";\n  } else if (region === \"s3\" || region === \"s3-accelerate\") {\n    region = \"us-east-1\";\n    service = \"s3\";\n  } else if (service === \"iot\") {\n    if (hostname.startsWith(\"iot.\")) {\n      service = \"execute-api\";\n    } else if (hostname.startsWith(\"data.jobs.iot.\")) {\n      service = \"iot-jobs-data\";\n    } else {\n      service = pathname === \"/mqtt\" ? \"iotdevicegateway\" : \"iotdata\";\n    }\n  } else if (service === \"autoscaling\") {\n    const targetPrefix = (headers.get(\"X-Amz-Target\") || \"\").split(\".\")[0];\n    if (targetPrefix === \"AnyScaleFrontendService\") {\n      service = \"application-autoscaling\";\n    } else if (targetPrefix === \"AnyScaleScalingPlannerFrontendService\") {\n      service = \"autoscaling-plans\";\n    }\n  } else if (region == null && service.startsWith(\"s3-\")) {\n    region = service.slice(3).replace(/^fips-|^external-1/, \"\");\n    service = \"s3\";\n  } else if (service.endsWith(\"-fips\")) {\n    service = service.slice(0, -5);\n  } else if (region && /-\\d$/.test(service) && !/-\\d$/.test(region)) {\n    [service, region] = [region, service];\n  }\n  return [HOST_SERVICES[service] || service, region || \"\"];\n}\nfunction getAllMatches(string2, regex2) {\n  const matches = [];\n  let match = regex2.exec(string2);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex2.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex2.exec(string2);\n  }\n  return matches;\n}\nfunction isExist(v3) {\n  return typeof v3 !== \"undefined\";\n}\nfunction validate$1(xmlData, options) {\n  options = Object.assign({}, defaultOptions$1, options);\n  const tags = [];\n  let tagFound = false;\n  let reachedRoot = false;\n  if (xmlData[0] === \"\\uFEFF\") {\n    xmlData = xmlData.substr(1);\n  }\n  for (let i = 0; i < xmlData.length; i++) {\n    if (xmlData[i] === \"<\" && xmlData[i + 1] === \"?\") {\n      i += 2;\n      i = readPI(xmlData, i);\n      if (i.err) return i;\n    } else if (xmlData[i] === \"<\") {\n      let tagStartPos = i;\n      i++;\n      if (xmlData[i] === \"!\") {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === \"/\") {\n          closingTag = true;\n          i++;\n        }\n        let tagName = \"\";\n        for (; i < xmlData.length && xmlData[i] !== \">\" && xmlData[i] !== \" \" && xmlData[i] !== \"\t\" && xmlData[i] !== \"\\n\" && xmlData[i] !== \"\\r\"; i++) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        if (tagName[tagName.length - 1] === \"/\") {\n          tagName = tagName.substring(0, tagName.length - 1);\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n          }\n          return getErrorObject(\"InvalidTag\", msg, getLineNumberForPosition(xmlData, i));\n        }\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject(\"InvalidAttr\", \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n        if (attrStr[attrStr.length - 1] === \"/\") {\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid2 = validateAttributeString(attrStr, options);\n          if (isValid2 === true) {\n            tagFound = true;\n          } else {\n            return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject(\n                \"InvalidTag\",\n                \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos)\n              );\n            }\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid2 = validateAttributeString(attrStr, options);\n          if (isValid2 !== true) {\n            return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid2.err.line));\n          }\n          if (reachedRoot === true) {\n            return getErrorObject(\"InvalidXml\", \"Multiple possible root nodes found.\", getLineNumberForPosition(xmlData, i));\n          } else if (options.unpairedTags.indexOf(tagName) !== -1) ;\n          else {\n            tags.push({ tagName, tagStartPos });\n          }\n          tagFound = true;\n        }\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === \"<\") {\n            if (xmlData[i + 1] === \"!\") {\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i + 1] === \"?\") {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else {\n              break;\n            }\n          } else if (xmlData[i] === \"&\") {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject(\"InvalidChar\", \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          } else {\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject(\"InvalidXml\", \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        }\n        if (xmlData[i] === \"<\") {\n          i--;\n        }\n      }\n    } else {\n      if (isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject(\"InvalidChar\", \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n  if (!tagFound) {\n    return getErrorObject(\"InvalidXml\", \"Start tag expected.\", 1);\n  } else if (tags.length == 1) {\n    return getErrorObject(\"InvalidTag\", \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  } else if (tags.length > 0) {\n    return getErrorObject(\"InvalidXml\", \"Invalid '\" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\\r?\\n/g, \"\") + \"' found.\", { line: 1, col: 1 });\n  }\n  return true;\n}\nfunction isWhiteSpace(char) {\n  return char === \" \" || char === \"\t\" || char === \"\\n\" || char === \"\\r\";\n}\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == \"?\" || xmlData[i] == \" \") {\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === \"xml\") {\n        return getErrorObject(\"InvalidXml\", \"XML declaration allowed only at the start of the document.\", getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n        i += 2;\n        break;\n      }\n    }\n  } else if (xmlData.length > i + 8 && xmlData[i + 1] === \"D\" && xmlData[i + 2] === \"O\" && xmlData[i + 3] === \"C\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"Y\" && xmlData[i + 6] === \"P\" && xmlData[i + 7] === \"E\") {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === \"<\") {\n        angleBracketsCount++;\n      } else if (xmlData[i] === \">\") {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (xmlData.length > i + 9 && xmlData[i + 1] === \"[\" && xmlData[i + 2] === \"C\" && xmlData[i + 3] === \"D\" && xmlData[i + 4] === \"A\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"A\" && xmlData[i + 7] === \"[\") {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n        i += 2;\n        break;\n      }\n    }\n  }\n  return i;\n}\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = \"\";\n  let startChar = \"\";\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === \"\") {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) ;\n      else {\n        startChar = \"\";\n      }\n    } else if (xmlData[i] === \">\") {\n      if (startChar === \"\") {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== \"\") {\n    return false;\n  }\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed\n  };\n}\nfunction validateAttributeString(attrStr, options) {\n  const matches = getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {\n      return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {\n      return getErrorObject(\"InvalidAttr\", \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n  return true;\n}\nfunction validateNumberAmpersand(xmlData, i) {\n  let re2 = /\\d/;\n  if (xmlData[i] === \"x\") {\n    i++;\n    re2 = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === \";\")\n      return i;\n    if (!xmlData[i].match(re2))\n      break;\n  }\n  return -1;\n}\nfunction validateAmpersand(xmlData, i) {\n  i++;\n  if (xmlData[i] === \";\")\n    return -1;\n  if (xmlData[i] === \"#\") {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count3 = 0;\n  for (; i < xmlData.length; i++, count3++) {\n    if (xmlData[i].match(/\\w/) && count3 < 20)\n      continue;\n    if (xmlData[i] === \";\")\n      break;\n    return -1;\n  }\n  return i;\n}\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col\n    }\n  };\n}\nfunction validateAttrName(attrName) {\n  return isName(attrName);\n}\nfunction validateTagName(tagname) {\n  return isName(tagname);\n}\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\nfunction readDocType(xmlData, i) {\n  const entities = {};\n  if (xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"C\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"Y\" && xmlData[i + 7] === \"P\" && xmlData[i + 8] === \"E\") {\n    i = i + 9;\n    let angleBracketsCount = 1;\n    let hasBody = false, comment = false;\n    let exp = \"\";\n    for (; i < xmlData.length; i++) {\n      if (xmlData[i] === \"<\" && !comment) {\n        if (hasBody && hasSeq(xmlData, \"!ENTITY\", i)) {\n          i += 7;\n          let entityName, val;\n          [entityName, val, i] = readEntityExp(xmlData, i + 1);\n          if (val.indexOf(\"&\") === -1)\n            entities[entityName] = {\n              regx: RegExp(`&${entityName};`, \"g\"),\n              val\n            };\n        } else if (hasBody && hasSeq(xmlData, \"!ELEMENT\", i)) {\n          i += 8;\n          const { index } = readElementExp(xmlData, i + 1);\n          i = index;\n        } else if (hasBody && hasSeq(xmlData, \"!ATTLIST\", i)) {\n          i += 8;\n        } else if (hasBody && hasSeq(xmlData, \"!NOTATION\", i)) {\n          i += 9;\n          const { index } = readNotationExp(xmlData, i + 1);\n          i = index;\n        } else if (hasSeq(xmlData, \"!--\", i)) comment = true;\n        else throw new Error(\"Invalid DOCTYPE\");\n        angleBracketsCount++;\n        exp = \"\";\n      } else if (xmlData[i] === \">\") {\n        if (comment) {\n          if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n            comment = false;\n            angleBracketsCount--;\n          }\n        } else {\n          angleBracketsCount--;\n        }\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      } else if (xmlData[i] === \"[\") {\n        hasBody = true;\n      } else {\n        exp += xmlData[i];\n      }\n    }\n    if (angleBracketsCount !== 0) {\n      throw new Error(`Unclosed DOCTYPE`);\n    }\n  } else {\n    throw new Error(`Invalid Tag instead of DOCTYPE`);\n  }\n  return { entities, i };\n}\nfunction readEntityExp(xmlData, i) {\n  i = skipWhitespace(xmlData, i);\n  let entityName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n    entityName += xmlData[i];\n    i++;\n  }\n  validateEntityName(entityName);\n  i = skipWhitespace(xmlData, i);\n  if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n    throw new Error(\"External entities are not supported\");\n  } else if (xmlData[i] === \"%\") {\n    throw new Error(\"Parameter entities are not supported\");\n  }\n  let entityValue = \"\";\n  [i, entityValue] = readIdentifierVal(xmlData, i, \"entity\");\n  i--;\n  return [entityName, entityValue, i];\n}\nfunction readNotationExp(xmlData, i) {\n  i = skipWhitespace(xmlData, i);\n  let notationName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n    notationName += xmlData[i];\n    i++;\n  }\n  validateEntityName(notationName);\n  i = skipWhitespace(xmlData, i);\n  const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n  if (identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n    throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n  }\n  i += identifierType.length;\n  i = skipWhitespace(xmlData, i);\n  let publicIdentifier = null;\n  let systemIdentifier = null;\n  if (identifierType === \"PUBLIC\") {\n    [i, publicIdentifier] = readIdentifierVal(xmlData, i, \"publicIdentifier\");\n    i = skipWhitespace(xmlData, i);\n    if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n      [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n    }\n  } else if (identifierType === \"SYSTEM\") {\n    [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n    if (!systemIdentifier) {\n      throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n    }\n  }\n  return { notationName, publicIdentifier, systemIdentifier, index: --i };\n}\nfunction readIdentifierVal(xmlData, i, type2) {\n  let identifierVal = \"\";\n  const startChar = xmlData[i];\n  if (startChar !== '\"' && startChar !== \"'\") {\n    throw new Error(`Expected quoted string, found \"${startChar}\"`);\n  }\n  i++;\n  while (i < xmlData.length && xmlData[i] !== startChar) {\n    identifierVal += xmlData[i];\n    i++;\n  }\n  if (xmlData[i] !== startChar) {\n    throw new Error(`Unterminated ${type2} value`);\n  }\n  i++;\n  return [i, identifierVal];\n}\nfunction readElementExp(xmlData, i) {\n  i = skipWhitespace(xmlData, i);\n  let elementName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n    elementName += xmlData[i];\n    i++;\n  }\n  if (!validateEntityName(elementName)) {\n    throw new Error(`Invalid element name: \"${elementName}\"`);\n  }\n  i = skipWhitespace(xmlData, i);\n  let contentModel = \"\";\n  if (xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\", i)) i += 6;\n  else if (xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\", i)) i += 4;\n  else if (xmlData[i] === \"(\") {\n    i++;\n    while (i < xmlData.length && xmlData[i] !== \")\") {\n      contentModel += xmlData[i];\n      i++;\n    }\n    if (xmlData[i] !== \")\") {\n      throw new Error(\"Unterminated content model\");\n    }\n  } else {\n    throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n  }\n  return {\n    elementName,\n    contentModel: contentModel.trim(),\n    index: i\n  };\n}\nfunction hasSeq(data, seq, i) {\n  for (let j3 = 0; j3 < seq.length; j3++) {\n    if (seq[j3] !== data[i + j3 + 1]) return false;\n  }\n  return true;\n}\nfunction validateEntityName(name) {\n  if (isName(name))\n    return name;\n  else\n    throw new Error(`Invalid entity name ${name}`);\n}\nfunction toNumber(str, options = {}) {\n  options = Object.assign({}, consider, options);\n  if (!str || typeof str !== \"string\") return str;\n  let trimmedStr = str.trim();\n  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;\n  else if (str === \"0\") return 0;\n  else if (options.hex && hexRegex.test(trimmedStr)) {\n    return parse_int(trimmedStr, 16);\n  } else if (trimmedStr.search(/.+[eE].+/) !== -1) {\n    return resolveEnotation(str, trimmedStr, options);\n  } else {\n    const match = numRegex.exec(trimmedStr);\n    if (match) {\n      const sign3 = match[1] || \"\";\n      const leadingZeros = match[2];\n      let numTrimmedByZeros = trimZeros(match[3]);\n      const decimalAdjacentToLeadingZeros = sign3 ? (\n        // 0., -00., 000.\n        str[leadingZeros.length + 1] === \".\"\n      ) : str[leadingZeros.length] === \".\";\n      if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {\n        return str;\n      } else {\n        const num = Number(trimmedStr);\n        const parsedStr = String(num);\n        if (num === 0) return num;\n        if (parsedStr.search(/[eE]/) !== -1) {\n          if (options.eNotation) return num;\n          else return str;\n        } else if (trimmedStr.indexOf(\".\") !== -1) {\n          if (parsedStr === \"0\") return num;\n          else if (parsedStr === numTrimmedByZeros) return num;\n          else if (parsedStr === `${sign3}${numTrimmedByZeros}`) return num;\n          else return str;\n        }\n        let n27 = leadingZeros ? numTrimmedByZeros : trimmedStr;\n        if (leadingZeros) {\n          return n27 === parsedStr || sign3 + n27 === parsedStr ? num : str;\n        } else {\n          return n27 === parsedStr || n27 === sign3 + parsedStr ? num : str;\n        }\n      }\n    } else {\n      return str;\n    }\n  }\n}\nfunction resolveEnotation(str, trimmedStr, options) {\n  if (!options.eNotation) return str;\n  const notation = trimmedStr.match(eNotationRegx);\n  if (notation) {\n    let sign3 = notation[1] || \"\";\n    const eChar = notation[3].indexOf(\"e\") === -1 ? \"E\" : \"e\";\n    const leadingZeros = notation[2];\n    const eAdjacentToLeadingZeros = sign3 ? (\n      // 0E.\n      str[leadingZeros.length + 1] === eChar\n    ) : str[leadingZeros.length] === eChar;\n    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;\n    else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {\n      return Number(trimmedStr);\n    } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {\n      trimmedStr = (notation[1] || \"\") + notation[3];\n      return Number(trimmedStr);\n    } else return str;\n  } else {\n    return str;\n  }\n}\nfunction trimZeros(numStr) {\n  if (numStr && numStr.indexOf(\".\") !== -1) {\n    numStr = numStr.replace(/0+$/, \"\");\n    if (numStr === \".\") numStr = \"0\";\n    else if (numStr[0] === \".\") numStr = \"0\" + numStr;\n    else if (numStr[numStr.length - 1] === \".\") numStr = numStr.substring(0, numStr.length - 1);\n    return numStr;\n  }\n  return numStr;\n}\nfunction parse_int(numStr, base) {\n  if (parseInt) return parseInt(numStr, base);\n  else if (Number.parseInt) return Number.parseInt(numStr, base);\n  else if (window && window.parseInt) return window.parseInt(numStr, base);\n  else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\");\n}\nfunction getIgnoreAttributesFn(ignoreAttributes) {\n  if (typeof ignoreAttributes === \"function\") {\n    return ignoreAttributes;\n  }\n  if (Array.isArray(ignoreAttributes)) {\n    return (attrName) => {\n      for (const pattern of ignoreAttributes) {\n        if (typeof pattern === \"string\" && attrName === pattern) {\n          return true;\n        }\n        if (pattern instanceof RegExp && pattern.test(attrName)) {\n          return true;\n        }\n      }\n    };\n  }\n  return () => false;\n}\nfunction addExternalEntities(externalEntities) {\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n      regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n      val: externalEntities[ent]\n    };\n  }\n}\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== void 0) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if (val.length > 0) {\n      if (!escapeEntities) val = this.replaceEntitiesValue(val);\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if (newval === null || newval === void 0) {\n        return val;\n      } else if (typeof newval !== typeof val || newval !== val) {\n        return newval;\n      } else if (this.options.trimValues) {\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      } else {\n        const trimmedVal = val.trim();\n        if (trimmedVal === val) {\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        } else {\n          return val;\n        }\n      }\n    }\n  }\n}\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(\":\");\n    const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n    if (tags[0] === \"xmlns\") {\n      return \"\";\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === \"string\") {\n    const matches = getAllMatches(attrStr, attrsRegx);\n    const len = matches.length;\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue;\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if (aName === \"__proto__\") aName = \"#__proto__\";\n        if (oldVal !== void 0) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if (newVal === null || newVal === void 0) {\n            attrs[aName] = oldVal;\n          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n            attrs[aName] = newVal;\n          } else {\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\nfunction addChild(currentNode, childNode, jPath, startIndex) {\n  if (!this.options.captureMetaData) startIndex = void 0;\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n  if (result === false) ;\n  else if (typeof result === \"string\") {\n    childNode.tagname = result;\n    currentNode.addChild(childNode, startIndex);\n  } else {\n    currentNode.addChild(childNode, startIndex);\n  }\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) {\n    if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;\n    textData = this.parseTextData(\n      textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode\n    );\n    if (textData !== void 0 && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\nfunction isItStopNode(stopNodes, jPath, currentTagName) {\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n  }\n  return false;\n}\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\";\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if (closingChar[1]) {\n        if (xmlData[index + 1] === closingChar[1]) {\n          return {\n            data: tagExp,\n            index\n          };\n        }\n      } else {\n        return {\n          data: tagExp,\n          index\n        };\n      }\n    } else if (ch === \"\t\") {\n      ch = \" \";\n    }\n    tagExp += ch;\n  }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n  if (!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if (separatorIndex !== -1) {\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n  const rawTagName = tagName;\n  if (removeNSPrefix) {\n    const colonIndex = tagName.indexOf(\":\");\n    if (colonIndex !== -1) {\n      tagName = tagName.substr(colonIndex + 1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n  return {\n    tagName,\n    tagExp,\n    closeIndex,\n    attrExpPresent,\n    rawTagName\n  };\n}\nfunction readStopNodeData(xmlData, tagName, i) {\n  const startIndex = i;\n  let openTagCount = 1;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === \"<\") {\n      if (xmlData[i + 1] === \"/\") {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (closeTagName === tagName) {\n          openTagCount--;\n          if (openTagCount === 0) {\n            return {\n              tagContent: xmlData.substring(startIndex, i),\n              i: closeIndex\n            };\n          }\n        }\n        i = closeIndex;\n      } else if (xmlData[i + 1] === \"?\") {\n        const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n        const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 2) === \"![\") {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n        i = closeIndex;\n      } else {\n        const tagData = readTagExp(xmlData, i, \">\");\n        if (tagData) {\n          const openTagName = tagData && tagData.tagName;\n          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n            openTagCount++;\n          }\n          i = tagData.closeIndex;\n        }\n      }\n    }\n  }\n}\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === \"string\") {\n    const newval = val.trim();\n    if (newval === \"true\") return true;\n    else if (newval === \"false\") return false;\n    else return toNumber(val, options);\n  } else {\n    if (isExist(val)) {\n      return val;\n    } else {\n      return \"\";\n    }\n  }\n}\nfunction prettify(node, options) {\n  return compress(node, options);\n}\nfunction compress(arr, options, jPath) {\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property2 = propName(tagObj);\n    let newJpath = \"\";\n    if (jPath === void 0) newJpath = property2;\n    else newJpath = jPath + \".\" + property2;\n    if (property2 === options.textNodeName) {\n      if (text === void 0) text = tagObj[property2];\n      else text += \"\" + tagObj[property2];\n    } else if (property2 === void 0) {\n      continue;\n    } else if (tagObj[property2]) {\n      let val = compress(tagObj[property2], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n      if (tagObj[METADATA_SYMBOL] !== void 0) {\n        val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL];\n      }\n      if (tagObj[\":@\"]) {\n        assignAttributes(val, tagObj[\":@\"], newJpath, options);\n      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {\n        val = val[options.textNodeName];\n      } else if (Object.keys(val).length === 0) {\n        if (options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n      if (compressedObj[property2] !== void 0 && compressedObj.hasOwnProperty(property2)) {\n        if (!Array.isArray(compressedObj[property2])) {\n          compressedObj[property2] = [compressedObj[property2]];\n        }\n        compressedObj[property2].push(val);\n      } else {\n        if (options.isArray(property2, newJpath, isLeaf)) {\n          compressedObj[property2] = [val];\n        } else {\n          compressedObj[property2] = val;\n        }\n      }\n    }\n  }\n  if (typeof text === \"string\") {\n    if (text.length > 0) compressedObj[options.textNodeName] = text;\n  } else if (text !== void 0) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\nfunction propName(obj) {\n  const keys2 = Object.keys(obj);\n  for (let i = 0; i < keys2.length; i++) {\n    const key = keys2[i];\n    if (key !== \":@\") return key;\n  }\n}\nfunction assignAttributes(obj, attrMap, jpath, options) {\n  if (attrMap) {\n    const keys2 = Object.keys(attrMap);\n    const len = keys2.length;\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys2[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [attrMap[atrrName]];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\nfunction isLeafTag(obj, options) {\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  if (propCount === 0) {\n    return true;\n  }\n  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)) {\n    return true;\n  }\n  return false;\n}\nfunction getRawTag(value2) {\n  var isOwn = hasOwnProperty$d.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];\n  try {\n    value2[symToStringTag$1] = void 0;\n    var unmasked = true;\n  } catch (e) {\n  }\n  var result = nativeObjectToString$1.call(value2);\n  if (unmasked) {\n    if (isOwn) {\n      value2[symToStringTag$1] = tag;\n    } else {\n      delete value2[symToStringTag$1];\n    }\n  }\n  return result;\n}\nfunction objectToString(value2) {\n  return nativeObjectToString.call(value2);\n}\nfunction baseGetTag(value2) {\n  if (value2 == null) {\n    return value2 === void 0 ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);\n}\nfunction isObjectLike(value2) {\n  return value2 != null && typeof value2 == \"object\";\n}\nfunction isSymbol(value2) {\n  return typeof value2 == \"symbol\" || isObjectLike(value2) && baseGetTag(value2) == symbolTag$3;\n}\nfunction arrayMap(array2, iteratee) {\n  var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);\n  while (++index < length) {\n    result[index] = iteratee(array2[index], index, array2);\n  }\n  return result;\n}\nfunction baseToString(value2) {\n  if (typeof value2 == \"string\") {\n    return value2;\n  }\n  if (isArray(value2)) {\n    return arrayMap(value2, baseToString) + \"\";\n  }\n  if (isSymbol(value2)) {\n    return symbolToString ? symbolToString.call(value2) : \"\";\n  }\n  var result = value2 + \"\";\n  return result == \"0\" && 1 / value2 == -Infinity ? \"-0\" : result;\n}\nfunction isObject$1(value2) {\n  var type2 = typeof value2;\n  return value2 != null && (type2 == \"object\" || type2 == \"function\");\n}\nfunction identity2(value2) {\n  return value2;\n}\nfunction isFunction$1(value2) {\n  if (!isObject$1(value2)) {\n    return false;\n  }\n  var tag = baseGetTag(value2);\n  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;\n}\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString$2.call(func);\n    } catch (e) {\n    }\n    try {\n      return func + \"\";\n    } catch (e) {\n    }\n  }\n  return \"\";\n}\nfunction baseIsNative(value2) {\n  if (!isObject$1(value2) || isMasked(value2)) {\n    return false;\n  }\n  var pattern = isFunction$1(value2) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value2));\n}\nfunction getValue(object2, key) {\n  return object2 == null ? void 0 : object2[key];\n}\nfunction getNative(object2, key) {\n  var value2 = getValue(object2, key);\n  return baseIsNative(value2) ? value2 : void 0;\n}\nfunction apply$1(func, thisArg, args) {\n  switch (args.length) {\n    case 0:\n      return func.call(thisArg);\n    case 1:\n      return func.call(thisArg, args[0]);\n    case 2:\n      return func.call(thisArg, args[0], args[1]);\n    case 3:\n      return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\nfunction copyArray(source, array2) {\n  var index = -1, length = source.length;\n  array2 || (array2 = Array(length));\n  while (++index < length) {\n    array2[index] = source[index];\n  }\n  return array2;\n}\nfunction shortOut(func) {\n  var count3 = 0, lastCalled = 0;\n  return function() {\n    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count3 >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count3 = 0;\n    }\n    return func.apply(void 0, arguments);\n  };\n}\nfunction constant(value2) {\n  return function() {\n    return value2;\n  };\n}\nfunction arrayEach(array2, iteratee) {\n  var index = -1, length = array2 == null ? 0 : array2.length;\n  while (++index < length) {\n    if (iteratee(array2[index], index, array2) === false) {\n      break;\n    }\n  }\n  return array2;\n}\nfunction isIndex(value2, length) {\n  var type2 = typeof value2;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n  return !!length && (type2 == \"number\" || type2 != \"symbol\" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);\n}\nfunction baseAssignValue(object2, key, value2) {\n  if (key == \"__proto__\" && defineProperty) {\n    defineProperty(object2, key, {\n      \"configurable\": true,\n      \"enumerable\": true,\n      \"value\": value2,\n      \"writable\": true\n    });\n  } else {\n    object2[key] = value2;\n  }\n}\nfunction eq(value2, other) {\n  return value2 === other || value2 !== value2 && other !== other;\n}\nfunction assignValue(object2, key, value2) {\n  var objValue = object2[key];\n  if (!(hasOwnProperty$b.call(object2, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object2)) {\n    baseAssignValue(object2, key, value2);\n  }\n}\nfunction copyObject(source, props, object2, customizer) {\n  var isNew = !object2;\n  object2 || (object2 = {});\n  var index = -1, length = props.length;\n  while (++index < length) {\n    var key = props[index];\n    var newValue = void 0;\n    if (newValue === void 0) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object2, key, newValue);\n    } else {\n      assignValue(object2, key, newValue);\n    }\n  }\n  return object2;\n}\nfunction overRest(func, start, transform2) {\n  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);\n  return function() {\n    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);\n    while (++index < length) {\n      array2[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform2(array2);\n    return apply$1(func, this, otherArgs);\n  };\n}\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity2), func + \"\");\n}\nfunction isLength(value2) {\n  return typeof value2 == \"number\" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;\n}\nfunction isArrayLike(value2) {\n  return value2 != null && isLength(value2.length) && !isFunction$1(value2);\n}\nfunction isIterateeCall(value2, index, object2) {\n  if (!isObject$1(object2)) {\n    return false;\n  }\n  var type2 = typeof index;\n  if (type2 == \"number\" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == \"string\" && index in object2) {\n    return eq(object2[index], value2);\n  }\n  return false;\n}\nfunction createAssigner(assigner) {\n  return baseRest(function(object2, sources) {\n    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;\n    customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : void 0;\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? void 0 : customizer;\n      length = 1;\n    }\n    object2 = Object(object2);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object2, source, index, customizer);\n      }\n    }\n    return object2;\n  });\n}\nfunction isPrototype(value2) {\n  var Ctor = value2 && value2.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$c;\n  return value2 === proto;\n}\nfunction baseTimes(n27, iteratee) {\n  var index = -1, result = Array(n27);\n  while (++index < n27) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\nfunction baseIsArguments(value2) {\n  return isObjectLike(value2) && baseGetTag(value2) == argsTag$3;\n}\nfunction stubFalse() {\n  return false;\n}\nfunction baseIsTypedArray(value2) {\n  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];\n}\nfunction baseUnary(func) {\n  return function(value2) {\n    return func(value2);\n  };\n}\nfunction arrayLikeKeys(value2, inherited) {\n  var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;\n  for (var key in value2) {\n    if ((inherited || hasOwnProperty$9.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n    isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nfunction overArg(func, transform2) {\n  return function(arg) {\n    return func(transform2(arg));\n  };\n}\nfunction baseKeys(object2) {\n  if (!isPrototype(object2)) {\n    return nativeKeys(object2);\n  }\n  var result = [];\n  for (var key in Object(object2)) {\n    if (hasOwnProperty$8.call(object2, key) && key != \"constructor\") {\n      result.push(key);\n    }\n  }\n  return result;\n}\nfunction keys(object2) {\n  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);\n}\nfunction nativeKeysIn(object2) {\n  var result = [];\n  if (object2 != null) {\n    for (var key in Object(object2)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nfunction baseKeysIn(object2) {\n  if (!isObject$1(object2)) {\n    return nativeKeysIn(object2);\n  }\n  var isProto = isPrototype(object2), result = [];\n  for (var key in object2) {\n    if (!(key == \"constructor\" && (isProto || !hasOwnProperty$7.call(object2, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\nfunction keysIn(object2) {\n  return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);\n}\nfunction isKey(value2, object2) {\n  if (isArray(value2)) {\n    return false;\n  }\n  var type2 = typeof value2;\n  if (type2 == \"number\" || type2 == \"symbol\" || type2 == \"boolean\" || value2 == null || isSymbol(value2)) {\n    return true;\n  }\n  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);\n}\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED$2 ? void 0 : result;\n  }\n  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;\n}\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);\n}\nfunction hashSet(key, value2) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;\n  return this;\n}\nfunction Hash2(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\nfunction assocIndexOf(array2, key) {\n  var length = array2.length;\n  while (length--) {\n    if (eq(array2[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nfunction listCacheDelete(key) {\n  var data = this.__data__, index = assocIndexOf(data, key);\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\nfunction listCacheGet(key) {\n  var data = this.__data__, index = assocIndexOf(data, key);\n  return index < 0 ? void 0 : data[index][1];\n}\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\nfunction listCacheSet(key, value2) {\n  var data = this.__data__, index = assocIndexOf(data, key);\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value2]);\n  } else {\n    data[index][1] = value2;\n  }\n  return this;\n}\nfunction ListCache(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    \"hash\": new Hash2(),\n    \"map\": new (Map$1 || ListCache)(),\n    \"string\": new Hash2()\n  };\n}\nfunction isKeyable(value2) {\n  var type2 = typeof value2;\n  return type2 == \"string\" || type2 == \"number\" || type2 == \"symbol\" || type2 == \"boolean\" ? value2 !== \"__proto__\" : value2 === null;\n}\nfunction getMapData(map2, key) {\n  var data = map2.__data__;\n  return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\nfunction mapCacheSet(key, value2) {\n  var data = getMapData(this, key), size = data.size;\n  data.set(key, value2);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nfunction MapCache(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nfunction memoize(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = /* @__PURE__ */ __name(function() {\n    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  }, \"memoized\");\n  memoized.cache = new (memoize.Cache || MapCache)();\n  return memoized;\n}\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n  var cache = result.cache;\n  return result;\n}\nfunction toString$1(value2) {\n  return value2 == null ? \"\" : baseToString(value2);\n}\nfunction castPath(value2, object2) {\n  if (isArray(value2)) {\n    return value2;\n  }\n  return isKey(value2, object2) ? [value2] : stringToPath(toString$1(value2));\n}\nfunction toKey(value2) {\n  if (typeof value2 == \"string\" || isSymbol(value2)) {\n    return value2;\n  }\n  var result = value2 + \"\";\n  return result == \"0\" && 1 / value2 == -Infinity ? \"-0\" : result;\n}\nfunction baseGet(object2, path) {\n  path = castPath(path, object2);\n  var index = 0, length = path.length;\n  while (object2 != null && index < length) {\n    object2 = object2[toKey(path[index++])];\n  }\n  return index && index == length ? object2 : void 0;\n}\nfunction get(object2, path, defaultValue) {\n  var result = object2 == null ? void 0 : baseGet(object2, path);\n  return result === void 0 ? defaultValue : result;\n}\nfunction arrayPush(array2, values) {\n  var index = -1, length = values.length, offset = array2.length;\n  while (++index < length) {\n    array2[offset + index] = values[index];\n  }\n  return array2;\n}\nfunction isFlattenable(value2) {\n  return isArray(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);\n}\nfunction baseFlatten(array2, depth, predicate, isStrict, result) {\n  var index = -1, length = array2.length;\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n  while (++index < length) {\n    var value2 = array2[index];\n    if (predicate(value2)) {\n      {\n        arrayPush(result, value2);\n      }\n    } else {\n      result[result.length] = value2;\n    }\n  }\n  return result;\n}\nfunction flatten(array2) {\n  var length = array2 == null ? 0 : array2.length;\n  return length ? baseFlatten(array2) : [];\n}\nfunction flatRest(func) {\n  return setToString(overRest(func, void 0, flatten), func + \"\");\n}\nfunction isPlainObject$1(value2) {\n  if (!isObjectLike(value2) || baseGetTag(value2) != objectTag$3) {\n    return false;\n  }\n  var proto = getPrototype(value2);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty$4.call(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\nfunction baseSlice(array2, start, end) {\n  var index = -1, length = array2.length;\n  if (start < 0) {\n    start = -start > length ? 0 : length + start;\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array2[index + start];\n  }\n  return result;\n}\nfunction stackClear() {\n  this.__data__ = new ListCache();\n  this.size = 0;\n}\nfunction stackDelete(key) {\n  var data = this.__data__, result = data[\"delete\"](key);\n  this.size = data.size;\n  return result;\n}\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\nfunction stackSet(key, value2) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n      pairs.push([key, value2]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value2);\n  this.size = data.size;\n  return this;\n}\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n  buffer.copy(result);\n  return result;\n}\nfunction arrayFilter(array2, predicate) {\n  var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];\n  while (++index < length) {\n    var value2 = array2[index];\n    if (predicate(value2, index, array2)) {\n      result[resIndex++] = value2;\n    }\n  }\n  return result;\n}\nfunction stubArray() {\n  return [];\n}\nfunction baseGetAllKeys(object2, keysFunc, symbolsFunc) {\n  var result = keysFunc(object2);\n  return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));\n}\nfunction getAllKeys(object2) {\n  return baseGetAllKeys(object2, keys, getSymbols);\n}\nfunction getAllKeysIn(object2) {\n  return baseGetAllKeys(object2, keysIn, getSymbolsIn);\n}\nfunction initCloneArray(array2) {\n  var length = array2.length, result = new array2.constructor(length);\n  if (length && typeof array2[0] == \"string\" && hasOwnProperty$3.call(array2, \"index\")) {\n    result.index = array2.index;\n    result.input = array2.input;\n  }\n  return result;\n}\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));\n  return result;\n}\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = cloneArrayBuffer(dataView.buffer);\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\nfunction cloneSymbol(symbol) {\n  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};\n}\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nfunction initCloneByTag(object2, tag, isDeep) {\n  var Ctor = object2.constructor;\n  switch (tag) {\n    case arrayBufferTag$2:\n      return cloneArrayBuffer(object2);\n    case boolTag$2:\n    case dateTag$2:\n      return new Ctor(+object2);\n    case dataViewTag$2:\n      return cloneDataView(object2);\n    case float32Tag$1:\n    case float64Tag$1:\n    case int8Tag$1:\n    case int16Tag$1:\n    case int32Tag$1:\n    case uint8Tag$1:\n    case uint8ClampedTag$1:\n    case uint16Tag$1:\n    case uint32Tag$1:\n      return cloneTypedArray(object2, isDeep);\n    case mapTag$3:\n      return new Ctor();\n    case numberTag$2:\n    case stringTag$2:\n      return new Ctor(object2);\n    case regexpTag$2:\n      return cloneRegExp(object2);\n    case setTag$3:\n      return new Ctor();\n    case symbolTag$2:\n      return cloneSymbol(object2);\n  }\n}\nfunction initCloneObject(object2) {\n  return typeof object2.constructor == \"function\" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};\n}\nfunction baseIsMap(value2) {\n  return isObjectLike(value2) && getTag$1(value2) == mapTag$2;\n}\nfunction baseIsSet(value2) {\n  return isObjectLike(value2) && getTag$1(value2) == setTag$2;\n}\nfunction baseClone(value2, bitmask, customizer, key, object2, stack) {\n  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1;\n  if (customizer) {\n    result = object2 ? customizer(value2, key, object2, stack) : customizer(value2);\n  }\n  if (result !== void 0) {\n    return result;\n  }\n  if (!isObject$1(value2)) {\n    return value2;\n  }\n  var isArr = isArray(value2);\n  if (isArr) {\n    result = initCloneArray(value2);\n  } else {\n    var tag = getTag$1(value2), isFunc = tag == funcTag || tag == genTag;\n    if (isBuffer(value2)) {\n      return cloneBuffer(value2, isDeep);\n    }\n    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {\n      result = {};\n    } else {\n      if (!cloneableTags[tag]) {\n        return object2 ? value2 : {};\n      }\n      result = initCloneByTag(value2, tag, isDeep);\n    }\n  }\n  stack || (stack = new Stack());\n  var stacked = stack.get(value2);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value2, result);\n  if (isSet(value2)) {\n    value2.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));\n    });\n  } else if (isMap(value2)) {\n    value2.forEach(function(subValue, key2) {\n      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));\n    });\n  }\n  var keysFunc = getAllKeysIn;\n  var props = isArr ? void 0 : keysFunc(value2);\n  arrayEach(props || value2, function(subValue, key2) {\n    if (props) {\n      key2 = subValue;\n      subValue = value2[key2];\n    }\n    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));\n  });\n  return result;\n}\nfunction setCacheAdd(value2) {\n  this.__data__.set(value2, HASH_UNDEFINED);\n  return this;\n}\nfunction setCacheHas(value2) {\n  return this.__data__.has(value2);\n}\nfunction SetCache(values) {\n  var index = -1, length = values == null ? 0 : values.length;\n  this.__data__ = new MapCache();\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\nfunction arraySome(array2, predicate) {\n  var index = -1, length = array2 == null ? 0 : array2.length;\n  while (++index < length) {\n    if (predicate(array2[index], index, array2)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\nfunction equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  var arrStacked = stack.get(array2);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array2;\n  }\n  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;\n  stack.set(array2, other);\n  stack.set(other, array2);\n  while (++index < arrLength) {\n    var arrValue = array2[index], othValue = other[index];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);\n    }\n    if (compared !== void 0) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    if (seen) {\n      if (!arraySome(other, function(othValue2, othIndex) {\n        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n          return seen.push(othIndex);\n        }\n      })) {\n        result = false;\n        break;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n      result = false;\n      break;\n    }\n  }\n  stack[\"delete\"](array2);\n  stack[\"delete\"](other);\n  return result;\n}\nfunction mapToArray(map2) {\n  var index = -1, result = Array(map2.size);\n  map2.forEach(function(value2, key) {\n    result[++index] = [key, value2];\n  });\n  return result;\n}\nfunction setToArray(set2) {\n  var index = -1, result = Array(set2.size);\n  set2.forEach(function(value2) {\n    result[++index] = value2;\n  });\n  return result;\n}\nfunction equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {\n        return false;\n      }\n      object2 = object2.buffer;\n      other = other.buffer;\n    case arrayBufferTag:\n      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {\n        return false;\n      }\n      return true;\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      return eq(+object2, +other);\n    case errorTag:\n      return object2.name == other.name && object2.message == other.message;\n    case regexpTag:\n    case stringTag:\n      return object2 == other + \"\";\n    case mapTag:\n      var convert = mapToArray;\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n      convert || (convert = setToArray);\n      if (object2.size != other.size && !isPartial) {\n        return false;\n      }\n      var stacked = stack.get(object2);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG$2;\n      stack.set(object2, other);\n      var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);\n      stack[\"delete\"](object2);\n      return result;\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object2) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\nfunction equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {\n      return false;\n    }\n  }\n  var objStacked = stack.get(object2);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object2;\n  }\n  var result = true;\n  stack.set(object2, other);\n  stack.set(other, object2);\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object2[key], othValue = other[key];\n    if (customizer) {\n      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);\n    }\n    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == \"constructor\");\n  }\n  if (result && !skipCtor) {\n    var objCtor = object2.constructor, othCtor = other.constructor;\n    if (objCtor != othCtor && (\"constructor\" in object2 && \"constructor\" in other) && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack[\"delete\"](object2);\n  stack[\"delete\"](other);\n  return result;\n}\nfunction baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n  if (isSameTag && isBuffer(object2)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack());\n    return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object2, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, \"__wrapped__\");\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;\n      stack || (stack = new Stack());\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack());\n  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);\n}\nfunction baseIsEqual(value2, other, bitmask, customizer, stack) {\n  if (value2 === other) {\n    return true;\n  }\n  if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {\n    return value2 !== value2 && other !== other;\n  }\n  return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);\n}\nfunction baseIsMatch(object2, source, matchData, customizer) {\n  var index = matchData.length, length = index;\n  if (object2 == null) {\n    return !length;\n  }\n  object2 = Object(object2);\n  while (index--) {\n    var data = matchData[index];\n    if (data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0], objValue = object2[key], srcValue = data[1];\n    if (data[2]) {\n      if (objValue === void 0 && !(key in object2)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack();\n      var result;\n      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction isStrictComparable(value2) {\n  return value2 === value2 && !isObject$1(value2);\n}\nfunction getMatchData(object2) {\n  var result = keys(object2), length = result.length;\n  while (length--) {\n    var key = result[length], value2 = object2[key];\n    result[length] = [key, value2, isStrictComparable(value2)];\n  }\n  return result;\n}\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object2) {\n    if (object2 == null) {\n      return false;\n    }\n    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));\n  };\n}\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object2) {\n    return object2 === source || baseIsMatch(object2, source, matchData);\n  };\n}\nfunction baseHasIn(object2, key) {\n  return object2 != null && key in Object(object2);\n}\nfunction hasPath(object2, path, hasFunc) {\n  path = castPath(path, object2);\n  var index = -1, length = path.length, result = false;\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object2 != null && hasFunc(object2, key))) {\n      break;\n    }\n    object2 = object2[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object2 == null ? 0 : object2.length;\n  return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));\n}\nfunction hasIn(object2, path) {\n  return object2 != null && hasPath(object2, path, baseHasIn);\n}\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object2) {\n    var objValue = get(object2, path);\n    return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\nfunction baseProperty(key) {\n  return function(object2) {\n    return object2 == null ? void 0 : object2[key];\n  };\n}\nfunction basePropertyDeep(path) {\n  return function(object2) {\n    return baseGet(object2, path);\n  };\n}\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\nfunction baseIteratee(value2) {\n  if (typeof value2 == \"function\") {\n    return value2;\n  }\n  if (value2 == null) {\n    return identity2;\n  }\n  if (typeof value2 == \"object\") {\n    return isArray(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);\n  }\n  return property(value2);\n}\nfunction createBaseFor(fromRight) {\n  return function(object2, iteratee, keysFunc) {\n    var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;\n    while (length--) {\n      var key = props[++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object2;\n  };\n}\nfunction baseForOwn(object2, iteratee) {\n  return object2 && baseFor(object2, iteratee, keys);\n}\nfunction assignMergeValue(object2, key, value2) {\n  if (value2 !== void 0 && !eq(object2[key], value2) || value2 === void 0 && !(key in object2)) {\n    baseAssignValue(object2, key, value2);\n  }\n}\nfunction isArrayLikeObject(value2) {\n  return isObjectLike(value2) && isArrayLike(value2);\n}\nfunction safeGet(object2, key) {\n  if (key === \"constructor\" && typeof object2[key] === \"function\") {\n    return;\n  }\n  if (key == \"__proto__\") {\n    return;\n  }\n  return object2[key];\n}\nfunction toPlainObject(value2) {\n  return copyObject(value2, keysIn(value2));\n}\nfunction baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);\n  if (stacked) {\n    assignMergeValue(object2, key, stacked);\n    return;\n  }\n  var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object2, source, stack) : void 0;\n  var isCommon = newValue === void 0;\n  if (isCommon) {\n    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      } else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      } else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      } else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      } else {\n        newValue = [];\n      }\n    } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      } else if (!isObject$1(objValue) || isFunction$1(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    } else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack[\"delete\"](srcValue);\n  }\n  assignMergeValue(object2, key, newValue);\n}\nfunction baseMerge(object2, source, srcIndex, customizer, stack) {\n  if (object2 === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack());\n    if (isObject$1(srcValue)) {\n      baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);\n    } else {\n      var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + \"\", object2, source, stack) : void 0;\n      if (newValue === void 0) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object2, key, newValue);\n    }\n  }, keysIn);\n}\nfunction last(array2) {\n  var length = array2 == null ? 0 : array2.length;\n  return length ? array2[length - 1] : void 0;\n}\nfunction baseHas(object2, key) {\n  return object2 != null && hasOwnProperty.call(object2, key);\n}\nfunction has(object2, path) {\n  return object2 != null && hasPath(object2, path, baseHas);\n}\nfunction parent(object2, path) {\n  return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));\n}\nfunction isEqual(value2, other) {\n  return baseIsEqual(value2, other);\n}\nfunction baseUnset(object2, path) {\n  path = castPath(path, object2);\n  object2 = parent(object2, path);\n  return object2 == null || delete object2[toKey(last(path))];\n}\nfunction customOmitClone(value2) {\n  return isPlainObject$1(value2) ? void 0 : value2;\n}\nfunction baseSet(object2, path, value2, customizer) {\n  if (!isObject$1(object2)) {\n    return object2;\n  }\n  path = castPath(path, object2);\n  var index = -1, length = path.length, lastIndex = length - 1, nested = object2;\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]), newValue = value2;\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      return object2;\n    }\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = void 0;\n      if (newValue === void 0) {\n        newValue = isObject$1(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object2;\n}\nfunction basePickBy(object2, paths, predicate) {\n  var index = -1, length = paths.length, result = {};\n  while (++index < length) {\n    var path = paths[index], value2 = baseGet(object2, path);\n    if (predicate(value2, path)) {\n      baseSet(result, castPath(path, object2), value2);\n    }\n  }\n  return result;\n}\nfunction basePick(object2, paths) {\n  return basePickBy(object2, paths, function(value2, path) {\n    return hasIn(object2, path);\n  });\n}\nfunction set(object2, path, value2) {\n  return object2 == null ? object2 : baseSet(object2, path, value2);\n}\nfunction transform(object2, iteratee, accumulator) {\n  var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);\n  iteratee = baseIteratee(iteratee);\n  if (accumulator == null) {\n    var Ctor = object2 && object2.constructor;\n    if (isArrLike) {\n      accumulator = isArr ? new Ctor() : [];\n    } else if (isObject$1(object2)) {\n      accumulator = isFunction$1(Ctor) ? baseCreate(getPrototype(object2)) : {};\n    } else {\n      accumulator = {};\n    }\n  }\n  (isArrLike ? arrayEach : baseForOwn)(object2, function(value2, index, object3) {\n    return iteratee(accumulator, value2, index, object3);\n  });\n  return accumulator;\n}\nfunction CloneRest(schemas) {\n  return schemas.map((schema2) => CloneType(schema2));\n}\nfunction CloneType(schema2, options) {\n  return options === void 0 ? Clone$1(schema2) : Clone$1({ ...options, ...schema2 });\n}\nfunction Increment(T2) {\n  return (parseInt(T2) + 1).toString();\n}\nfunction Argument(index) {\n  return CreateType({ [Kind]: \"Argument\", index });\n}\nfunction FromComputed$3(target, parameters) {\n  return Computed(\"Awaited\", [Computed(target, parameters)]);\n}\nfunction FromRef$2($ref) {\n  return Computed(\"Awaited\", [Ref($ref)]);\n}\nfunction FromIntersect$4(types) {\n  return Intersect$1(FromRest$3(types));\n}\nfunction FromUnion$4(types) {\n  return Union$1(FromRest$3(types));\n}\nfunction FromPromise$1(type2) {\n  return Awaited(type2);\n}\nfunction FromRest$3(types) {\n  return types.map((type2) => Awaited(type2));\n}\nfunction Awaited(type2, options) {\n  return CreateType(IsComputed$1(type2) ? FromComputed$3(type2.target, type2.parameters) : IsIntersect$1(type2) ? FromIntersect$4(type2.allOf) : IsUnion$1(type2) ? FromUnion$4(type2.anyOf) : IsPromise$1(type2) ? FromPromise$1(type2.item) : IsRef$1(type2) ? FromRef$2(type2.$ref) : type2, options);\n}\nfunction CompositeKeys(T2) {\n  const Acc = [];\n  for (const L2 of T2)\n    Acc.push(...KeyOfPropertyKeys(L2));\n  return SetDistinct(Acc);\n}\nfunction FilterNever(T2) {\n  return T2.filter((L2) => !IsNever$1(L2));\n}\nfunction CompositeProperty(T2, K2) {\n  const Acc = [];\n  for (const L2 of T2)\n    Acc.push(...IndexFromPropertyKeys(L2, [K2]));\n  return FilterNever(Acc);\n}\nfunction CompositeProperties(T2, K2) {\n  const Acc = {};\n  for (const L2 of K2) {\n    Acc[L2] = IntersectEvaluated(CompositeProperty(T2, L2));\n  }\n  return Acc;\n}\nfunction Composite(T2, options) {\n  const K2 = CompositeKeys(T2);\n  const P3 = CompositeProperties(T2, K2);\n  const R4 = Object$1(P3, options);\n  return R4;\n}\nfunction Date$1(options) {\n  return CreateType({ [Kind]: \"Date\", type: \"Date\" }, options);\n}\nfunction Null(options) {\n  return CreateType({ [Kind]: \"Null\", type: \"null\" }, options);\n}\nfunction Symbol$1(options) {\n  return CreateType({ [Kind]: \"Symbol\", type: \"symbol\" }, options);\n}\nfunction Undefined(options) {\n  return CreateType({ [Kind]: \"Undefined\", type: \"undefined\" }, options);\n}\nfunction Uint8Array$1(options) {\n  return CreateType({ [Kind]: \"Uint8Array\", type: \"Uint8Array\" }, options);\n}\nfunction FromArray$2(T2) {\n  return T2.map((L2) => FromValue(L2, false));\n}\nfunction FromProperties$b(value2) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(value2))\n    Acc[K2] = Readonly(FromValue(value2[K2], false));\n  return Acc;\n}\nfunction ConditionalReadonly(T2, root2) {\n  return root2 === true ? T2 : Readonly(T2);\n}\nfunction FromValue(value2, root2) {\n  return IsAsyncIterator$2(value2) ? ConditionalReadonly(Any(), root2) : IsIterator$2(value2) ? ConditionalReadonly(Any(), root2) : IsArray$2(value2) ? Readonly(Tuple(FromArray$2(value2))) : IsUint8Array$2(value2) ? Uint8Array$1() : IsDate$2(value2) ? Date$1() : IsObject$2(value2) ? ConditionalReadonly(Object$1(FromProperties$b(value2)), root2) : IsFunction$2(value2) ? ConditionalReadonly(Function$1([], Unknown()), root2) : IsUndefined$2(value2) ? Undefined() : IsNull$2(value2) ? Null() : IsSymbol$2(value2) ? Symbol$1() : IsBigInt$2(value2) ? BigInt$1() : IsNumber$2(value2) ? Literal(value2) : IsBoolean$2(value2) ? Literal(value2) : IsString$2(value2) ? Literal(value2) : Object$1({});\n}\nfunction Const(T2, options) {\n  return CreateType(FromValue(T2, true), options);\n}\nfunction ConstructorParameters(schema2, options) {\n  return IsConstructor$1(schema2) ? Tuple(schema2.parameters, options) : Never(options);\n}\nfunction Enum(item, options) {\n  if (IsUndefined$2(item))\n    throw new Error(\"Enum undefined or empty\");\n  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);\n  const values2 = [...new Set(values1)];\n  const anyOf = values2.map((value2) => Literal(value2));\n  return Union$1(anyOf, { ...options, [Hint]: \"Enum\" });\n}\nfunction ExcludeFromTemplateLiteral(L2, R4) {\n  return Exclude(TemplateLiteralToUnion(L2), R4);\n}\nfunction ExcludeRest(L2, R4) {\n  const excluded = L2.filter((inner) => ExtendsCheck(inner, R4) === ExtendsResult.False);\n  return excluded.length === 1 ? excluded[0] : Union$1(excluded);\n}\nfunction Exclude(L2, R4, options = {}) {\n  if (IsTemplateLiteral$1(L2))\n    return CreateType(ExcludeFromTemplateLiteral(L2, R4), options);\n  if (IsMappedResult$1(L2))\n    return CreateType(ExcludeFromMappedResult(L2, R4), options);\n  return CreateType(IsUnion$1(L2) ? ExcludeRest(L2.anyOf, R4) : ExtendsCheck(L2, R4) !== ExtendsResult.False ? Never() : L2, options);\n}\nfunction FromProperties$a(P3, U2) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))\n    Acc[K2] = Exclude(P3[K2], U2);\n  return Acc;\n}\nfunction FromMappedResult$5(R4, T2) {\n  return FromProperties$a(R4.properties, T2);\n}\nfunction ExcludeFromMappedResult(R4, T2) {\n  const P3 = FromMappedResult$5(R4, T2);\n  return MappedResult(P3);\n}\nfunction ExtractFromTemplateLiteral(L2, R4) {\n  return Extract(TemplateLiteralToUnion(L2), R4);\n}\nfunction ExtractRest(L2, R4) {\n  const extracted = L2.filter((inner) => ExtendsCheck(inner, R4) !== ExtendsResult.False);\n  return extracted.length === 1 ? extracted[0] : Union$1(extracted);\n}\nfunction Extract(L2, R4, options) {\n  if (IsTemplateLiteral$1(L2))\n    return CreateType(ExtractFromTemplateLiteral(L2, R4), options);\n  if (IsMappedResult$1(L2))\n    return CreateType(ExtractFromMappedResult(L2, R4), options);\n  return CreateType(IsUnion$1(L2) ? ExtractRest(L2.anyOf, R4) : ExtendsCheck(L2, R4) !== ExtendsResult.False ? L2 : Never(), options);\n}\nfunction FromProperties$9(P3, T2) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))\n    Acc[K2] = Extract(P3[K2], T2);\n  return Acc;\n}\nfunction FromMappedResult$4(R4, T2) {\n  return FromProperties$9(R4.properties, T2);\n}\nfunction ExtractFromMappedResult(R4, T2) {\n  const P3 = FromMappedResult$4(R4, T2);\n  return MappedResult(P3);\n}\nfunction InstanceType(schema2, options) {\n  return IsConstructor$1(schema2) ? CreateType(schema2.returns, options) : Never(options);\n}\nfunction ReadonlyOptional(schema2) {\n  return Readonly(Optional(schema2));\n}\nfunction RecordCreateFromPattern(pattern, T2, options) {\n  return CreateType({ [Kind]: \"Record\", type: \"object\", patternProperties: { [pattern]: T2 } }, options);\n}\nfunction RecordCreateFromKeys(K2, T2, options) {\n  const result = {};\n  for (const K22 of K2)\n    result[K22] = T2;\n  return Object$1(result, { ...options, [Hint]: \"Record\" });\n}\nfunction FromTemplateLiteralKey(K2, T2, options) {\n  return IsTemplateLiteralFinite(K2) ? RecordCreateFromKeys(IndexPropertyKeys(K2), T2, options) : RecordCreateFromPattern(K2.pattern, T2, options);\n}\nfunction FromUnionKey(key, type2, options) {\n  return RecordCreateFromKeys(IndexPropertyKeys(Union$1(key)), type2, options);\n}\nfunction FromLiteralKey(key, type2, options) {\n  return RecordCreateFromKeys([key.toString()], type2, options);\n}\nfunction FromRegExpKey(key, type2, options) {\n  return RecordCreateFromPattern(key.source, type2, options);\n}\nfunction FromStringKey(key, type2, options) {\n  const pattern = IsUndefined$2(key.pattern) ? PatternStringExact : key.pattern;\n  return RecordCreateFromPattern(pattern, type2, options);\n}\nfunction FromAnyKey(_3, type2, options) {\n  return RecordCreateFromPattern(PatternStringExact, type2, options);\n}\nfunction FromNeverKey(_key2, type2, options) {\n  return RecordCreateFromPattern(PatternNeverExact, type2, options);\n}\nfunction FromBooleanKey(_key2, type2, options) {\n  return Object$1({ true: type2, false: type2 }, options);\n}\nfunction FromIntegerKey(_key2, type2, options) {\n  return RecordCreateFromPattern(PatternNumberExact, type2, options);\n}\nfunction FromNumberKey(_3, type2, options) {\n  return RecordCreateFromPattern(PatternNumberExact, type2, options);\n}\nfunction Record(key, type2, options = {}) {\n  return IsUnion$1(key) ? FromUnionKey(key.anyOf, type2, options) : IsTemplateLiteral$1(key) ? FromTemplateLiteralKey(key, type2, options) : IsLiteral$1(key) ? FromLiteralKey(key.const, type2, options) : IsBoolean$1(key) ? FromBooleanKey(key, type2, options) : IsInteger$1(key) ? FromIntegerKey(key, type2, options) : IsNumber$1(key) ? FromNumberKey(key, type2, options) : IsRegExp$1(key) ? FromRegExpKey(key, type2, options) : IsString$1(key) ? FromStringKey(key, type2, options) : IsAny$1(key) ? FromAnyKey(key, type2, options) : IsNever$1(key) ? FromNeverKey(key, type2, options) : Never(options);\n}\nfunction RecordPattern(record) {\n  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];\n}\nfunction RecordKey(type2) {\n  const pattern = RecordPattern(type2);\n  return pattern === PatternStringExact ? String$1() : pattern === PatternNumberExact ? Number$1() : String$1({ pattern });\n}\nfunction RecordValue(type2) {\n  return type2.patternProperties[RecordPattern(type2)];\n}\nfunction FromConstructor$1(args, type2) {\n  type2.parameters = FromTypes$1(args, type2.parameters);\n  type2.returns = FromType$1(args, type2.returns);\n  return type2;\n}\nfunction FromFunction$1(args, type2) {\n  type2.parameters = FromTypes$1(args, type2.parameters);\n  type2.returns = FromType$1(args, type2.returns);\n  return type2;\n}\nfunction FromIntersect$3(args, type2) {\n  type2.allOf = FromTypes$1(args, type2.allOf);\n  return type2;\n}\nfunction FromUnion$3(args, type2) {\n  type2.anyOf = FromTypes$1(args, type2.anyOf);\n  return type2;\n}\nfunction FromTuple$1(args, type2) {\n  if (IsUndefined$2(type2.items))\n    return type2;\n  type2.items = FromTypes$1(args, type2.items);\n  return type2;\n}\nfunction FromArray$1(args, type2) {\n  type2.items = FromType$1(args, type2.items);\n  return type2;\n}\nfunction FromAsyncIterator$1(args, type2) {\n  type2.items = FromType$1(args, type2.items);\n  return type2;\n}\nfunction FromIterator$1(args, type2) {\n  type2.items = FromType$1(args, type2.items);\n  return type2;\n}\nfunction FromPromise(args, type2) {\n  type2.item = FromType$1(args, type2.item);\n  return type2;\n}\nfunction FromObject$5(args, type2) {\n  const mappedProperties = FromProperties$8(args, type2.properties);\n  return { ...type2, ...Object$1(mappedProperties) };\n}\nfunction FromRecord$1(args, type2) {\n  const mappedKey = FromType$1(args, RecordKey(type2));\n  const mappedValue = FromType$1(args, RecordValue(type2));\n  const result = Record(mappedKey, mappedValue);\n  return { ...type2, ...result };\n}\nfunction FromArgument(args, argument) {\n  return argument.index in args ? args[argument.index] : Unknown();\n}\nfunction FromProperty$1(args, type2) {\n  const isReadonly = IsReadonly$1(type2);\n  const isOptional = IsOptional$1(type2);\n  const mapped = FromType$1(args, type2);\n  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;\n}\nfunction FromProperties$8(args, properties) {\n  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {\n    return { ...result, [key]: FromProperty$1(args, properties[key]) };\n  }, {});\n}\nfunction FromTypes$1(args, types) {\n  return types.map((type2) => FromType$1(args, type2));\n}\nfunction FromType$1(args, type2) {\n  return IsConstructor$1(type2) ? FromConstructor$1(args, type2) : IsFunction$1(type2) ? FromFunction$1(args, type2) : IsIntersect$1(type2) ? FromIntersect$3(args, type2) : IsUnion$1(type2) ? FromUnion$3(args, type2) : IsTuple$1(type2) ? FromTuple$1(args, type2) : IsArray$1(type2) ? FromArray$1(args, type2) : IsAsyncIterator$1(type2) ? FromAsyncIterator$1(args, type2) : IsIterator$1(type2) ? FromIterator$1(args, type2) : IsPromise$1(type2) ? FromPromise(args, type2) : IsObject$1(type2) ? FromObject$5(args, type2) : IsRecord$1(type2) ? FromRecord$1(args, type2) : IsArgument$1(type2) ? FromArgument(args, type2) : type2;\n}\nfunction Instantiate(type2, args) {\n  return FromType$1(args, CloneType(type2));\n}\nfunction Integer(options) {\n  return CreateType({ [Kind]: \"Integer\", type: \"integer\" }, options);\n}\nfunction MappedIntrinsicPropertyKey(K2, M3, options) {\n  return {\n    [K2]: Intrinsic(Literal(K2), M3, Clone$1(options))\n  };\n}\nfunction MappedIntrinsicPropertyKeys(K2, M3, options) {\n  const result = K2.reduce((Acc, L2) => {\n    return { ...Acc, ...MappedIntrinsicPropertyKey(L2, M3, options) };\n  }, {});\n  return result;\n}\nfunction MappedIntrinsicProperties(T2, M3, options) {\n  return MappedIntrinsicPropertyKeys(T2[\"keys\"], M3, options);\n}\nfunction IntrinsicFromMappedKey(T2, M3, options) {\n  const P3 = MappedIntrinsicProperties(T2, M3, options);\n  return MappedResult(P3);\n}\nfunction ApplyUncapitalize(value2) {\n  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];\n  return [first.toLowerCase(), rest].join(\"\");\n}\nfunction ApplyCapitalize(value2) {\n  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];\n  return [first.toUpperCase(), rest].join(\"\");\n}\nfunction ApplyUppercase(value2) {\n  return value2.toUpperCase();\n}\nfunction ApplyLowercase(value2) {\n  return value2.toLowerCase();\n}\nfunction FromTemplateLiteral(schema2, mode, options) {\n  const expression = TemplateLiteralParseExact(schema2.pattern);\n  const finite = IsTemplateLiteralExpressionFinite(expression);\n  if (!finite)\n    return { ...schema2, pattern: FromLiteralValue(schema2.pattern, mode) };\n  const strings = [...TemplateLiteralExpressionGenerate(expression)];\n  const literals = strings.map((value2) => Literal(value2));\n  const mapped = FromRest$2(literals, mode);\n  const union = Union$1(mapped);\n  return TemplateLiteral([union], options);\n}\nfunction FromLiteralValue(value2, mode) {\n  return typeof value2 === \"string\" ? mode === \"Uncapitalize\" ? ApplyUncapitalize(value2) : mode === \"Capitalize\" ? ApplyCapitalize(value2) : mode === \"Uppercase\" ? ApplyUppercase(value2) : mode === \"Lowercase\" ? ApplyLowercase(value2) : value2 : value2.toString();\n}\nfunction FromRest$2(T2, M3) {\n  return T2.map((L2) => Intrinsic(L2, M3));\n}\nfunction Intrinsic(schema2, mode, options = {}) {\n  return (\n    // Intrinsic-Mapped-Inference\n    IsMappedKey$1(schema2) ? IntrinsicFromMappedKey(schema2, mode, options) : (\n      // Standard-Inference\n      IsTemplateLiteral$1(schema2) ? FromTemplateLiteral(schema2, mode, options) : IsUnion$1(schema2) ? Union$1(FromRest$2(schema2.anyOf, mode), options) : IsLiteral$1(schema2) ? Literal(FromLiteralValue(schema2.const, mode), options) : (\n        // Default Type\n        CreateType(schema2, options)\n      )\n    )\n  );\n}\nfunction Capitalize(T2, options = {}) {\n  return Intrinsic(T2, \"Capitalize\", options);\n}\nfunction Lowercase(T2, options = {}) {\n  return Intrinsic(T2, \"Lowercase\", options);\n}\nfunction Uncapitalize(T2, options = {}) {\n  return Intrinsic(T2, \"Uncapitalize\", options);\n}\nfunction Uppercase(T2, options = {}) {\n  return Intrinsic(T2, \"Uppercase\", options);\n}\nfunction FromProperties$7(properties, propertyKeys, options) {\n  const result = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n    result[K2] = Omit(properties[K2], propertyKeys, Clone$1(options));\n  return result;\n}\nfunction FromMappedResult$3(mappedResult, propertyKeys, options) {\n  return FromProperties$7(mappedResult.properties, propertyKeys, options);\n}\nfunction OmitFromMappedResult(mappedResult, propertyKeys, options) {\n  const properties = FromMappedResult$3(mappedResult, propertyKeys, options);\n  return MappedResult(properties);\n}\nfunction FromIntersect$2(types, propertyKeys) {\n  return types.map((type2) => OmitResolve(type2, propertyKeys));\n}\nfunction FromUnion$2(types, propertyKeys) {\n  return types.map((type2) => OmitResolve(type2, propertyKeys));\n}\nfunction FromProperty(properties, key) {\n  const { [key]: _3, ...R4 } = properties;\n  return R4;\n}\nfunction FromProperties$6(properties, propertyKeys) {\n  return propertyKeys.reduce((T2, K2) => FromProperty(T2, K2), properties);\n}\nfunction FromObject$4(properties, propertyKeys) {\n  const options = Discard(properties, [TransformKind, \"$id\", \"required\", \"properties\"]);\n  const omittedProperties = FromProperties$6(properties[\"properties\"], propertyKeys);\n  return Object$1(omittedProperties, options);\n}\nfunction UnionFromPropertyKeys$1(propertyKeys) {\n  const result = propertyKeys.reduce((result2, key) => IsLiteralValue$1(key) ? [...result2, Literal(key)] : result2, []);\n  return Union$1(result);\n}\nfunction OmitResolve(properties, propertyKeys) {\n  return IsIntersect$1(properties) ? Intersect$1(FromIntersect$2(properties.allOf, propertyKeys)) : IsUnion$1(properties) ? Union$1(FromUnion$2(properties.anyOf, propertyKeys)) : IsObject$1(properties) ? FromObject$4(properties, propertyKeys) : Object$1({});\n}\nfunction Omit(type2, key, options) {\n  const typeKey = IsArray$2(key) ? UnionFromPropertyKeys$1(key) : key;\n  const propertyKeys = IsSchema$1(key) ? IndexPropertyKeys(key) : key;\n  const isTypeRef = IsRef$1(type2);\n  const isKeyRef = IsRef$1(key);\n  return IsMappedResult$1(type2) ? OmitFromMappedResult(type2, propertyKeys, options) : IsMappedKey$1(key) ? OmitFromMappedKey(type2, key, options) : isTypeRef && isKeyRef ? Computed(\"Omit\", [type2, typeKey], options) : !isTypeRef && isKeyRef ? Computed(\"Omit\", [type2, typeKey], options) : isTypeRef && !isKeyRef ? Computed(\"Omit\", [type2, typeKey], options) : CreateType({ ...OmitResolve(type2, propertyKeys), ...options });\n}\nfunction FromPropertyKey$1(type2, key, options) {\n  return { [key]: Omit(type2, [key], Clone$1(options)) };\n}\nfunction FromPropertyKeys$1(type2, propertyKeys, options) {\n  return propertyKeys.reduce((Acc, LK) => {\n    return { ...Acc, ...FromPropertyKey$1(type2, LK, options) };\n  }, {});\n}\nfunction FromMappedKey$1(type2, mappedKey, options) {\n  return FromPropertyKeys$1(type2, mappedKey.keys, options);\n}\nfunction OmitFromMappedKey(type2, mappedKey, options) {\n  const properties = FromMappedKey$1(type2, mappedKey, options);\n  return MappedResult(properties);\n}\nfunction FromProperties$5(properties, propertyKeys, options) {\n  const result = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n    result[K2] = Pick(properties[K2], propertyKeys, Clone$1(options));\n  return result;\n}\nfunction FromMappedResult$2(mappedResult, propertyKeys, options) {\n  return FromProperties$5(mappedResult.properties, propertyKeys, options);\n}\nfunction PickFromMappedResult(mappedResult, propertyKeys, options) {\n  const properties = FromMappedResult$2(mappedResult, propertyKeys, options);\n  return MappedResult(properties);\n}\nfunction FromIntersect$1(types, propertyKeys) {\n  return types.map((type2) => PickResolve(type2, propertyKeys));\n}\nfunction FromUnion$1(types, propertyKeys) {\n  return types.map((type2) => PickResolve(type2, propertyKeys));\n}\nfunction FromProperties$4(properties, propertyKeys) {\n  const result = {};\n  for (const K2 of propertyKeys)\n    if (K2 in properties)\n      result[K2] = properties[K2];\n  return result;\n}\nfunction FromObject$3(T2, K2) {\n  const options = Discard(T2, [TransformKind, \"$id\", \"required\", \"properties\"]);\n  const properties = FromProperties$4(T2[\"properties\"], K2);\n  return Object$1(properties, options);\n}\nfunction UnionFromPropertyKeys(propertyKeys) {\n  const result = propertyKeys.reduce((result2, key) => IsLiteralValue$1(key) ? [...result2, Literal(key)] : result2, []);\n  return Union$1(result);\n}\nfunction PickResolve(properties, propertyKeys) {\n  return IsIntersect$1(properties) ? Intersect$1(FromIntersect$1(properties.allOf, propertyKeys)) : IsUnion$1(properties) ? Union$1(FromUnion$1(properties.anyOf, propertyKeys)) : IsObject$1(properties) ? FromObject$3(properties, propertyKeys) : Object$1({});\n}\nfunction Pick(type2, key, options) {\n  const typeKey = IsArray$2(key) ? UnionFromPropertyKeys(key) : key;\n  const propertyKeys = IsSchema$1(key) ? IndexPropertyKeys(key) : key;\n  const isTypeRef = IsRef$1(type2);\n  const isKeyRef = IsRef$1(key);\n  return IsMappedResult$1(type2) ? PickFromMappedResult(type2, propertyKeys, options) : IsMappedKey$1(key) ? PickFromMappedKey(type2, key, options) : isTypeRef && isKeyRef ? Computed(\"Pick\", [type2, typeKey], options) : !isTypeRef && isKeyRef ? Computed(\"Pick\", [type2, typeKey], options) : isTypeRef && !isKeyRef ? Computed(\"Pick\", [type2, typeKey], options) : CreateType({ ...PickResolve(type2, propertyKeys), ...options });\n}\nfunction FromPropertyKey(type2, key, options) {\n  return {\n    [key]: Pick(type2, [key], Clone$1(options))\n  };\n}\nfunction FromPropertyKeys(type2, propertyKeys, options) {\n  return propertyKeys.reduce((result, leftKey) => {\n    return { ...result, ...FromPropertyKey(type2, leftKey, options) };\n  }, {});\n}\nfunction FromMappedKey(type2, mappedKey, options) {\n  return FromPropertyKeys(type2, mappedKey.keys, options);\n}\nfunction PickFromMappedKey(type2, mappedKey, options) {\n  const properties = FromMappedKey(type2, mappedKey, options);\n  return MappedResult(properties);\n}\nfunction FromComputed$2(target, parameters) {\n  return Computed(\"Partial\", [Computed(target, parameters)]);\n}\nfunction FromRef$1($ref) {\n  return Computed(\"Partial\", [Ref($ref)]);\n}\nfunction FromProperties$3(properties) {\n  const partialProperties = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n    partialProperties[K2] = Optional(properties[K2]);\n  return partialProperties;\n}\nfunction FromObject$2(type2) {\n  const options = Discard(type2, [TransformKind, \"$id\", \"required\", \"properties\"]);\n  const properties = FromProperties$3(type2[\"properties\"]);\n  return Object$1(properties, options);\n}\nfunction FromRest$1(types) {\n  return types.map((type2) => PartialResolve(type2));\n}\nfunction PartialResolve(type2) {\n  return (\n    // Mappable\n    IsComputed$1(type2) ? FromComputed$2(type2.target, type2.parameters) : IsRef$1(type2) ? FromRef$1(type2.$ref) : IsIntersect$1(type2) ? Intersect$1(FromRest$1(type2.allOf)) : IsUnion$1(type2) ? Union$1(FromRest$1(type2.anyOf)) : IsObject$1(type2) ? FromObject$2(type2) : (\n      // Intrinsic\n      IsBigInt$1(type2) ? type2 : IsBoolean$1(type2) ? type2 : IsInteger$1(type2) ? type2 : IsLiteral$1(type2) ? type2 : IsNull$1(type2) ? type2 : IsNumber$1(type2) ? type2 : IsString$1(type2) ? type2 : IsSymbol$1(type2) ? type2 : IsUndefined$1(type2) ? type2 : (\n        // Passthrough\n        Object$1({})\n      )\n    )\n  );\n}\nfunction Partial(type2, options) {\n  if (IsMappedResult$1(type2)) {\n    return PartialFromMappedResult(type2, options);\n  } else {\n    return CreateType({ ...PartialResolve(type2), ...options });\n  }\n}\nfunction FromProperties$2(K2, options) {\n  const Acc = {};\n  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))\n    Acc[K22] = Partial(K2[K22], Clone$1(options));\n  return Acc;\n}\nfunction FromMappedResult$1(R4, options) {\n  return FromProperties$2(R4.properties, options);\n}\nfunction PartialFromMappedResult(R4, options) {\n  const P3 = FromMappedResult$1(R4, options);\n  return MappedResult(P3);\n}\nfunction FromComputed$1(target, parameters) {\n  return Computed(\"Required\", [Computed(target, parameters)]);\n}\nfunction FromRef($ref) {\n  return Computed(\"Required\", [Ref($ref)]);\n}\nfunction FromProperties$1(properties) {\n  const requiredProperties = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n    requiredProperties[K2] = Discard(properties[K2], [OptionalKind]);\n  return requiredProperties;\n}\nfunction FromObject$1(type2) {\n  const options = Discard(type2, [TransformKind, \"$id\", \"required\", \"properties\"]);\n  const properties = FromProperties$1(type2[\"properties\"]);\n  return Object$1(properties, options);\n}\nfunction FromRest(types) {\n  return types.map((type2) => RequiredResolve(type2));\n}\nfunction RequiredResolve(type2) {\n  return (\n    // Mappable\n    IsComputed$1(type2) ? FromComputed$1(type2.target, type2.parameters) : IsRef$1(type2) ? FromRef(type2.$ref) : IsIntersect$1(type2) ? Intersect$1(FromRest(type2.allOf)) : IsUnion$1(type2) ? Union$1(FromRest(type2.anyOf)) : IsObject$1(type2) ? FromObject$1(type2) : (\n      // Intrinsic\n      IsBigInt$1(type2) ? type2 : IsBoolean$1(type2) ? type2 : IsInteger$1(type2) ? type2 : IsLiteral$1(type2) ? type2 : IsNull$1(type2) ? type2 : IsNumber$1(type2) ? type2 : IsString$1(type2) ? type2 : IsSymbol$1(type2) ? type2 : IsUndefined$1(type2) ? type2 : (\n        // Passthrough\n        Object$1({})\n      )\n    )\n  );\n}\nfunction Required(type2, options) {\n  if (IsMappedResult$1(type2)) {\n    return RequiredFromMappedResult(type2, options);\n  } else {\n    return CreateType({ ...RequiredResolve(type2), ...options });\n  }\n}\nfunction FromProperties(P3, options) {\n  const Acc = {};\n  for (const K2 of globalThis.Object.getOwnPropertyNames(P3))\n    Acc[K2] = Required(P3[K2], options);\n  return Acc;\n}\nfunction FromMappedResult(R4, options) {\n  return FromProperties(R4.properties, options);\n}\nfunction RequiredFromMappedResult(R4, options) {\n  const P3 = FromMappedResult(R4, options);\n  return MappedResult(P3);\n}\nfunction DereferenceParameters(moduleProperties, types) {\n  return types.map((type2) => {\n    return IsRef$1(type2) ? Dereference(moduleProperties, type2.$ref) : FromType(moduleProperties, type2);\n  });\n}\nfunction Dereference(moduleProperties, ref) {\n  return ref in moduleProperties ? IsRef$1(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType(moduleProperties, moduleProperties[ref]) : Never();\n}\nfunction FromAwaited(parameters) {\n  return Awaited(parameters[0]);\n}\nfunction FromIndex(parameters) {\n  return Index(parameters[0], parameters[1]);\n}\nfunction FromKeyOf(parameters) {\n  return KeyOf(parameters[0]);\n}\nfunction FromPartial(parameters) {\n  return Partial(parameters[0]);\n}\nfunction FromOmit(parameters) {\n  return Omit(parameters[0], parameters[1]);\n}\nfunction FromPick(parameters) {\n  return Pick(parameters[0], parameters[1]);\n}\nfunction FromRequired(parameters) {\n  return Required(parameters[0]);\n}\nfunction FromComputed(moduleProperties, target, parameters) {\n  const dereferenced = DereferenceParameters(moduleProperties, parameters);\n  return target === \"Awaited\" ? FromAwaited(dereferenced) : target === \"Index\" ? FromIndex(dereferenced) : target === \"KeyOf\" ? FromKeyOf(dereferenced) : target === \"Partial\" ? FromPartial(dereferenced) : target === \"Omit\" ? FromOmit(dereferenced) : target === \"Pick\" ? FromPick(dereferenced) : target === \"Required\" ? FromRequired(dereferenced) : Never();\n}\nfunction FromArray(moduleProperties, type2) {\n  return Array$1(FromType(moduleProperties, type2));\n}\nfunction FromAsyncIterator(moduleProperties, type2) {\n  return AsyncIterator(FromType(moduleProperties, type2));\n}\nfunction FromConstructor(moduleProperties, parameters, instanceType) {\n  return Constructor(FromTypes(moduleProperties, parameters), FromType(moduleProperties, instanceType));\n}\nfunction FromFunction(moduleProperties, parameters, returnType) {\n  return Function$1(FromTypes(moduleProperties, parameters), FromType(moduleProperties, returnType));\n}\nfunction FromIntersect(moduleProperties, types) {\n  return Intersect$1(FromTypes(moduleProperties, types));\n}\nfunction FromIterator(moduleProperties, type2) {\n  return Iterator(FromType(moduleProperties, type2));\n}\nfunction FromObject(moduleProperties, properties) {\n  return Object$1(globalThis.Object.keys(properties).reduce((result, key) => {\n    return { ...result, [key]: FromType(moduleProperties, properties[key]) };\n  }, {}));\n}\nfunction FromRecord(moduleProperties, type2) {\n  const [value2, pattern] = [FromType(moduleProperties, RecordValue(type2)), RecordPattern(type2)];\n  const result = CloneType(type2);\n  result.patternProperties[pattern] = value2;\n  return result;\n}\nfunction FromTransform(moduleProperties, transform2) {\n  return IsRef$1(transform2) ? { ...Dereference(moduleProperties, transform2.$ref), [TransformKind]: transform2[TransformKind] } : transform2;\n}\nfunction FromTuple(moduleProperties, types) {\n  return Tuple(FromTypes(moduleProperties, types));\n}\nfunction FromUnion(moduleProperties, types) {\n  return Union$1(FromTypes(moduleProperties, types));\n}\nfunction FromTypes(moduleProperties, types) {\n  return types.map((type2) => FromType(moduleProperties, type2));\n}\nfunction FromType(moduleProperties, type2) {\n  return (\n    // Modifiers\n    IsOptional$1(type2) ? CreateType(FromType(moduleProperties, Discard(type2, [OptionalKind])), type2) : IsReadonly$1(type2) ? CreateType(FromType(moduleProperties, Discard(type2, [ReadonlyKind])), type2) : (\n      // Transform\n      IsTransform$1(type2) ? CreateType(FromTransform(moduleProperties, type2), type2) : (\n        // Types\n        IsArray$1(type2) ? CreateType(FromArray(moduleProperties, type2.items), type2) : IsAsyncIterator$1(type2) ? CreateType(FromAsyncIterator(moduleProperties, type2.items), type2) : IsComputed$1(type2) ? CreateType(FromComputed(moduleProperties, type2.target, type2.parameters)) : IsConstructor$1(type2) ? CreateType(FromConstructor(moduleProperties, type2.parameters, type2.returns), type2) : IsFunction$1(type2) ? CreateType(FromFunction(moduleProperties, type2.parameters, type2.returns), type2) : IsIntersect$1(type2) ? CreateType(FromIntersect(moduleProperties, type2.allOf), type2) : IsIterator$1(type2) ? CreateType(FromIterator(moduleProperties, type2.items), type2) : IsObject$1(type2) ? CreateType(FromObject(moduleProperties, type2.properties), type2) : IsRecord$1(type2) ? CreateType(FromRecord(moduleProperties, type2)) : IsTuple$1(type2) ? CreateType(FromTuple(moduleProperties, type2.items || []), type2) : IsUnion$1(type2) ? CreateType(FromUnion(moduleProperties, type2.anyOf), type2) : type2\n      )\n    )\n  );\n}\nfunction ComputeType(moduleProperties, key) {\n  return key in moduleProperties ? FromType(moduleProperties, moduleProperties[key]) : Never();\n}\nfunction ComputeModuleProperties(moduleProperties) {\n  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {\n    return { ...result, [key]: ComputeType(moduleProperties, key) };\n  }, {});\n}\nfunction Module(properties) {\n  return new TModule(properties);\n}\nfunction Not(type2, options) {\n  return CreateType({ [Kind]: \"Not\", not: type2 }, options);\n}\nfunction Parameters(schema2, options) {\n  return IsFunction$1(schema2) ? Tuple(schema2.parameters, options) : Never();\n}\nfunction Recursive(callback, options = {}) {\n  if (IsUndefined$2(options.$id))\n    options.$id = `T${Ordinal++}`;\n  const thisType = CloneType(callback({ [Kind]: \"This\", $ref: `${options.$id}` }));\n  thisType.$id = options.$id;\n  return CreateType({ [Hint]: \"Recursive\", ...thisType }, options);\n}\nfunction RegExp$1(unresolved, options) {\n  const expr = IsString$2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;\n  return CreateType({ [Kind]: \"RegExp\", type: \"RegExp\", source: expr.source, flags: expr.flags }, options);\n}\nfunction RestResolve(T2) {\n  return IsIntersect$1(T2) ? T2.allOf : IsUnion$1(T2) ? T2.anyOf : IsTuple$1(T2) ? T2.items ?? [] : [];\n}\nfunction Rest(T2) {\n  return RestResolve(T2);\n}\nfunction ReturnType(schema2, options) {\n  return IsFunction$1(schema2) ? CreateType(schema2.returns, options) : Never(options);\n}\nfunction Transform(schema2) {\n  return new TransformDecodeBuilder(schema2);\n}\nfunction Void(options) {\n  return CreateType({ [Kind]: \"Void\", type: \"void\" }, options);\n}\nfunction requireDayjs_min() {\n  if (hasRequiredDayjs_min) return dayjs_min$1.exports;\n  hasRequiredDayjs_min = 1;\n  (function(module2, exports2) {\n    !function(t, e) {\n      module2.exports = e();\n    }(dayjs_min, function() {\n      var t = 1e3, e = 6e4, n27 = 36e5, r2 = \"millisecond\", i = \"second\", s2 = \"minute\", u3 = \"hour\", a2 = \"day\", o = \"week\", c = \"month\", f2 = \"quarter\", h3 = \"year\", d2 = \"date\", l2 = \"Invalid Date\", $3 = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/, y3 = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: \"en\", weekdays: \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"), months: \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"), ordinal: /* @__PURE__ */ __name(function(t2) {\n        var e2 = [\"th\", \"st\", \"nd\", \"rd\"], n28 = t2 % 100;\n        return \"[\" + t2 + (e2[(n28 - 20) % 10] || e2[n28] || e2[0]) + \"]\";\n      }, \"ordinal\") }, m2 = /* @__PURE__ */ __name(function(t2, e2, n28) {\n        var r3 = String(t2);\n        return !r3 || r3.length >= e2 ? t2 : \"\" + Array(e2 + 1 - r3.length).join(n28) + t2;\n      }, \"m\"), v3 = { s: m2, z: /* @__PURE__ */ __name(function(t2) {\n        var e2 = -t2.utcOffset(), n28 = Math.abs(e2), r3 = Math.floor(n28 / 60), i2 = n28 % 60;\n        return (e2 <= 0 ? \"+\" : \"-\") + m2(r3, 2, \"0\") + \":\" + m2(i2, 2, \"0\");\n      }, \"z\"), m: /* @__PURE__ */ __name(function t2(e2, n28) {\n        if (e2.date() < n28.date()) return -t2(n28, e2);\n        var r3 = 12 * (n28.year() - e2.year()) + (n28.month() - e2.month()), i2 = e2.clone().add(r3, c), s3 = n28 - i2 < 0, u4 = e2.clone().add(r3 + (s3 ? -1 : 1), c);\n        return +(-(r3 + (n28 - i2) / (s3 ? i2 - u4 : u4 - i2)) || 0);\n      }, \"t\"), a: /* @__PURE__ */ __name(function(t2) {\n        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);\n      }, \"a\"), p: /* @__PURE__ */ __name(function(t2) {\n        return { M: c, y: h3, w: o, d: a2, D: d2, h: u3, m: s2, s: i, ms: r2, Q: f2 }[t2] || String(t2 || \"\").toLowerCase().replace(/s$/, \"\");\n      }, \"p\"), u: /* @__PURE__ */ __name(function(t2) {\n        return void 0 === t2;\n      }, \"u\") }, g2 = \"en\", D2 = {};\n      D2[g2] = M3;\n      var p2 = \"$isDayjsObject\", S2 = /* @__PURE__ */ __name(function(t2) {\n        return t2 instanceof _3 || !(!t2 || !t2[p2]);\n      }, \"S\"), w3 = /* @__PURE__ */ __name(function t2(e2, n28, r3) {\n        var i2;\n        if (!e2) return g2;\n        if (\"string\" == typeof e2) {\n          var s3 = e2.toLowerCase();\n          D2[s3] && (i2 = s3), n28 && (D2[s3] = n28, i2 = s3);\n          var u4 = e2.split(\"-\");\n          if (!i2 && u4.length > 1) return t2(u4[0]);\n        } else {\n          var a3 = e2.name;\n          D2[a3] = e2, i2 = a3;\n        }\n        return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;\n      }, \"t\"), O3 = /* @__PURE__ */ __name(function(t2, e2) {\n        if (S2(t2)) return t2.clone();\n        var n28 = \"object\" == typeof e2 ? e2 : {};\n        return n28.date = t2, n28.args = arguments, new _3(n28);\n      }, \"O\"), b3 = v3;\n      b3.l = w3, b3.i = S2, b3.w = function(t2, e2) {\n        return O3(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });\n      };\n      var _3 = function() {\n        function M4(t2) {\n          this.$L = w3(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;\n        }\n        __name(M4, \"M\");\n        var m3 = M4.prototype;\n        return m3.parse = function(t2) {\n          this.$d = function(t3) {\n            var e2 = t3.date, n28 = t3.utc;\n            if (null === e2) return /* @__PURE__ */ new Date(NaN);\n            if (b3.u(e2)) return /* @__PURE__ */ new Date();\n            if (e2 instanceof Date) return new Date(e2);\n            if (\"string\" == typeof e2 && !/Z$/i.test(e2)) {\n              var r3 = e2.match($3);\n              if (r3) {\n                var i2 = r3[2] - 1 || 0, s3 = (r3[7] || \"0\").substring(0, 3);\n                return n28 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);\n              }\n            }\n            return new Date(e2);\n          }(t2), this.init();\n        }, m3.init = function() {\n          var t2 = this.$d;\n          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();\n        }, m3.$utils = function() {\n          return b3;\n        }, m3.isValid = function() {\n          return !(this.$d.toString() === l2);\n        }, m3.isSame = function(t2, e2) {\n          var n28 = O3(t2);\n          return this.startOf(e2) <= n28 && n28 <= this.endOf(e2);\n        }, m3.isAfter = function(t2, e2) {\n          return O3(t2) < this.startOf(e2);\n        }, m3.isBefore = function(t2, e2) {\n          return this.endOf(e2) < O3(t2);\n        }, m3.$g = function(t2, e2, n28) {\n          return b3.u(t2) ? this[e2] : this.set(n28, t2);\n        }, m3.unix = function() {\n          return Math.floor(this.valueOf() / 1e3);\n        }, m3.valueOf = function() {\n          return this.$d.getTime();\n        }, m3.startOf = function(t2, e2) {\n          var n28 = this, r3 = !!b3.u(e2) || e2, f3 = b3.p(t2), l3 = /* @__PURE__ */ __name(function(t3, e3) {\n            var i2 = b3.w(n28.$u ? Date.UTC(n28.$y, e3, t3) : new Date(n28.$y, e3, t3), n28);\n            return r3 ? i2 : i2.endOf(a2);\n          }, \"l\"), $4 = /* @__PURE__ */ __name(function(t3, e3) {\n            return b3.w(n28.toDate()[t3].apply(n28.toDate(\"s\"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n28);\n          }, \"$\"), y4 = this.$W, M5 = this.$M, m4 = this.$D, v5 = \"set\" + (this.$u ? \"UTC\" : \"\");\n          switch (f3) {\n            case h3:\n              return r3 ? l3(1, 0) : l3(31, 11);\n            case c:\n              return r3 ? l3(1, M5) : l3(0, M5 + 1);\n            case o:\n              var g3 = this.$locale().weekStart || 0, D3 = (y4 < g3 ? y4 + 7 : y4) - g3;\n              return l3(r3 ? m4 - D3 : m4 + (6 - D3), M5);\n            case a2:\n            case d2:\n              return $4(v5 + \"Hours\", 0);\n            case u3:\n              return $4(v5 + \"Minutes\", 1);\n            case s2:\n              return $4(v5 + \"Seconds\", 2);\n            case i:\n              return $4(v5 + \"Milliseconds\", 3);\n            default:\n              return this.clone();\n          }\n        }, m3.endOf = function(t2) {\n          return this.startOf(t2, false);\n        }, m3.$set = function(t2, e2) {\n          var n28, o2 = b3.p(t2), f3 = \"set\" + (this.$u ? \"UTC\" : \"\"), l3 = (n28 = {}, n28[a2] = f3 + \"Date\", n28[d2] = f3 + \"Date\", n28[c] = f3 + \"Month\", n28[h3] = f3 + \"FullYear\", n28[u3] = f3 + \"Hours\", n28[s2] = f3 + \"Minutes\", n28[i] = f3 + \"Seconds\", n28[r2] = f3 + \"Milliseconds\", n28)[o2], $4 = o2 === a2 ? this.$D + (e2 - this.$W) : e2;\n          if (o2 === c || o2 === h3) {\n            var y4 = this.clone().set(d2, 1);\n            y4.$d[l3]($4), y4.init(), this.$d = y4.set(d2, Math.min(this.$D, y4.daysInMonth())).$d;\n          } else l3 && this.$d[l3]($4);\n          return this.init(), this;\n        }, m3.set = function(t2, e2) {\n          return this.clone().$set(t2, e2);\n        }, m3.get = function(t2) {\n          return this[b3.p(t2)]();\n        }, m3.add = function(r3, f3) {\n          var d3, l3 = this;\n          r3 = Number(r3);\n          var $4 = b3.p(f3), y4 = /* @__PURE__ */ __name(function(t2) {\n            var e2 = O3(l3);\n            return b3.w(e2.date(e2.date() + Math.round(t2 * r3)), l3);\n          }, \"y\");\n          if ($4 === c) return this.set(c, this.$M + r3);\n          if ($4 === h3) return this.set(h3, this.$y + r3);\n          if ($4 === a2) return y4(1);\n          if ($4 === o) return y4(7);\n          var M5 = (d3 = {}, d3[s2] = e, d3[u3] = n27, d3[i] = t, d3)[$4] || 1, m4 = this.$d.getTime() + r3 * M5;\n          return b3.w(m4, this);\n        }, m3.subtract = function(t2, e2) {\n          return this.add(-1 * t2, e2);\n        }, m3.format = function(t2) {\n          var e2 = this, n28 = this.$locale();\n          if (!this.isValid()) return n28.invalidDate || l2;\n          var r3 = t2 || \"YYYY-MM-DDTHH:mm:ssZ\", i2 = b3.z(this), s3 = this.$H, u4 = this.$m, a3 = this.$M, o2 = n28.weekdays, c2 = n28.months, f3 = n28.meridiem, h4 = /* @__PURE__ */ __name(function(t3, n29, i3, s4) {\n            return t3 && (t3[n29] || t3(e2, r3)) || i3[n29].slice(0, s4);\n          }, \"h\"), d3 = /* @__PURE__ */ __name(function(t3) {\n            return b3.s(s3 % 12 || 12, t3, \"0\");\n          }, \"d\"), $4 = f3 || function(t3, e3, n29) {\n            var r4 = t3 < 12 ? \"AM\" : \"PM\";\n            return n29 ? r4.toLowerCase() : r4;\n          };\n          return r3.replace(y3, function(t3, r4) {\n            return r4 || function(t4) {\n              switch (t4) {\n                case \"YY\":\n                  return String(e2.$y).slice(-2);\n                case \"YYYY\":\n                  return b3.s(e2.$y, 4, \"0\");\n                case \"M\":\n                  return a3 + 1;\n                case \"MM\":\n                  return b3.s(a3 + 1, 2, \"0\");\n                case \"MMM\":\n                  return h4(n28.monthsShort, a3, c2, 3);\n                case \"MMMM\":\n                  return h4(c2, a3);\n                case \"D\":\n                  return e2.$D;\n                case \"DD\":\n                  return b3.s(e2.$D, 2, \"0\");\n                case \"d\":\n                  return String(e2.$W);\n                case \"dd\":\n                  return h4(n28.weekdaysMin, e2.$W, o2, 2);\n                case \"ddd\":\n                  return h4(n28.weekdaysShort, e2.$W, o2, 3);\n                case \"dddd\":\n                  return o2[e2.$W];\n                case \"H\":\n                  return String(s3);\n                case \"HH\":\n                  return b3.s(s3, 2, \"0\");\n                case \"h\":\n                  return d3(1);\n                case \"hh\":\n                  return d3(2);\n                case \"a\":\n                  return $4(s3, u4, true);\n                case \"A\":\n                  return $4(s3, u4, false);\n                case \"m\":\n                  return String(u4);\n                case \"mm\":\n                  return b3.s(u4, 2, \"0\");\n                case \"s\":\n                  return String(e2.$s);\n                case \"ss\":\n                  return b3.s(e2.$s, 2, \"0\");\n                case \"SSS\":\n                  return b3.s(e2.$ms, 3, \"0\");\n                case \"Z\":\n                  return i2;\n              }\n              return null;\n            }(t3) || i2.replace(\":\", \"\");\n          });\n        }, m3.utcOffset = function() {\n          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);\n        }, m3.diff = function(r3, d3, l3) {\n          var $4, y4 = this, M5 = b3.p(d3), m4 = O3(r3), v5 = (m4.utcOffset() - this.utcOffset()) * e, g3 = this - m4, D3 = /* @__PURE__ */ __name(function() {\n            return b3.m(y4, m4);\n          }, \"D\");\n          switch (M5) {\n            case h3:\n              $4 = D3() / 12;\n              break;\n            case c:\n              $4 = D3();\n              break;\n            case f2:\n              $4 = D3() / 3;\n              break;\n            case o:\n              $4 = (g3 - v5) / 6048e5;\n              break;\n            case a2:\n              $4 = (g3 - v5) / 864e5;\n              break;\n            case u3:\n              $4 = g3 / n27;\n              break;\n            case s2:\n              $4 = g3 / e;\n              break;\n            case i:\n              $4 = g3 / t;\n              break;\n            default:\n              $4 = g3;\n          }\n          return l3 ? $4 : b3.a($4);\n        }, m3.daysInMonth = function() {\n          return this.endOf(c).$D;\n        }, m3.$locale = function() {\n          return D2[this.$L];\n        }, m3.locale = function(t2, e2) {\n          if (!t2) return this.$L;\n          var n28 = this.clone(), r3 = w3(t2, e2, true);\n          return r3 && (n28.$L = r3), n28;\n        }, m3.clone = function() {\n          return b3.w(this.$d, this);\n        }, m3.toDate = function() {\n          return new Date(this.valueOf());\n        }, m3.toJSON = function() {\n          return this.isValid() ? this.toISOString() : null;\n        }, m3.toISOString = function() {\n          return this.$d.toISOString();\n        }, m3.toString = function() {\n          return this.$d.toUTCString();\n        }, M4;\n      }(), k2 = _3.prototype;\n      return O3.prototype = k2, [[\"$ms\", r2], [\"$s\", i], [\"$m\", s2], [\"$H\", u3], [\"$W\", a2], [\"$M\", c], [\"$y\", h3], [\"$D\", d2]].forEach(function(t2) {\n        k2[t2[1]] = function(e2) {\n          return this.$g(e2, t2[0], t2[1]);\n        };\n      }), O3.extend = function(t2, e2) {\n        return t2.$i || (t2(e2, _3, O3), t2.$i = true), O3;\n      }, O3.locale = w3, O3.isDayjs = S2, O3.unix = function(t2) {\n        return O3(1e3 * t2);\n      }, O3.en = D2[g2], O3.Ls = D2, O3.p = {}, O3;\n    });\n  })(dayjs_min$1);\n  return dayjs_min$1.exports;\n}\nfunction requireWeekOfYear() {\n  if (hasRequiredWeekOfYear) return weekOfYear$1.exports;\n  hasRequiredWeekOfYear = 1;\n  (function(module2, exports2) {\n    !function(e, t) {\n      module2.exports = t();\n    }(weekOfYear, function() {\n      var e = \"week\", t = \"year\";\n      return function(i, n27, r2) {\n        var f2 = n27.prototype;\n        f2.week = function(i2) {\n          if (void 0 === i2 && (i2 = null), null !== i2) return this.add(7 * (i2 - this.week()), \"day\");\n          var n28 = this.$locale().yearStart || 1;\n          if (11 === this.month() && this.date() > 25) {\n            var f3 = r2(this).startOf(t).add(1, t).date(n28), s2 = r2(this).endOf(e);\n            if (f3.isBefore(s2)) return 1;\n          }\n          var a2 = r2(this).startOf(t).date(n28).startOf(e).subtract(1, \"millisecond\"), o = this.diff(a2, e, true);\n          return o < 0 ? r2(this).startOf(\"week\").week() : Math.ceil(o);\n        }, f2.weeks = function(e2) {\n          return void 0 === e2 && (e2 = null), this.week(e2);\n        };\n      };\n    });\n  })(weekOfYear$1);\n  return weekOfYear$1.exports;\n}\nfunction unsafeStringify(arr, offset = 0) {\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction rng() {\n  if (!getRandomValues2) {\n    if (typeof crypto === \"undefined\" || !crypto.getRandomValues) {\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    }\n    getRandomValues2 = crypto.getRandomValues.bind(crypto);\n  }\n  return getRandomValues2(rnds8);\n}\nfunction v4(options, buf2, offset) {\n  if (native.randomUUID && true && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random ?? options.rng?.() ?? rng();\n  if (rnds.length < 16) {\n    throw new Error(\"Random bytes length must be >= 16\");\n  }\n  rnds[6] = rnds[6] & 15 | 64;\n  rnds[8] = rnds[8] & 63 | 128;\n  return unsafeStringify(rnds);\n}\nfunction v7(options, buf2, offset) {\n  let bytes;\n  {\n    const now = Date.now();\n    const rnds = rng();\n    updateV7State(_state, now, rnds);\n    bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf2, offset);\n  }\n  return buf2 ?? unsafeStringify(bytes);\n}\nfunction updateV7State(state, now, rnds) {\n  state.msecs ??= -Infinity;\n  state.seq ??= 0;\n  if (now > state.msecs) {\n    state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];\n    state.msecs = now;\n  } else {\n    state.seq = state.seq + 1 | 0;\n    if (state.seq === 0) {\n      state.msecs++;\n    }\n  }\n  return state;\n}\nfunction v7Bytes(rnds, msecs, seq, buf2, offset = 0) {\n  if (rnds.length < 16) {\n    throw new Error(\"Random bytes length must be >= 16\");\n  }\n  if (!buf2) {\n    buf2 = new Uint8Array(16);\n    offset = 0;\n  } else {\n    if (offset < 0 || offset + 16 > buf2.length) {\n      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n    }\n  }\n  msecs ??= Date.now();\n  seq ??= rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];\n  buf2[offset++] = msecs / 1099511627776 & 255;\n  buf2[offset++] = msecs / 4294967296 & 255;\n  buf2[offset++] = msecs / 16777216 & 255;\n  buf2[offset++] = msecs / 65536 & 255;\n  buf2[offset++] = msecs / 256 & 255;\n  buf2[offset++] = msecs & 255;\n  buf2[offset++] = 112 | seq >>> 28 & 15;\n  buf2[offset++] = seq >>> 20 & 255;\n  buf2[offset++] = 128 | seq >>> 14 & 63;\n  buf2[offset++] = seq >>> 6 & 255;\n  buf2[offset++] = seq << 2 & 255 | rnds[10] & 3;\n  buf2[offset++] = rnds[11];\n  buf2[offset++] = rnds[12];\n  buf2[offset++] = rnds[13];\n  buf2[offset++] = rnds[14];\n  buf2[offset++] = rnds[15];\n  return buf2;\n}\nfunction deepCompareStrict(a2, b3) {\n  const typeofa = typeof a2;\n  if (typeofa !== typeof b3) {\n    return false;\n  }\n  if (Array.isArray(a2)) {\n    if (!Array.isArray(b3)) {\n      return false;\n    }\n    const length = a2.length;\n    if (length !== b3.length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      if (!deepCompareStrict(a2[i], b3[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (typeofa === \"object\") {\n    if (!a2 || !b3) {\n      return a2 === b3;\n    }\n    const aKeys = Object.keys(a2);\n    const bKeys = Object.keys(b3);\n    const length = aKeys.length;\n    if (length !== bKeys.length) {\n      return false;\n    }\n    for (const k2 of aKeys) {\n      if (!deepCompareStrict(a2[k2], b3[k2])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a2 === b3;\n}\nfunction encodePointer(p2) {\n  return encodeURI(escapePointer(p2));\n}\nfunction escapePointer(p2) {\n  return p2.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nfunction dereference(schema2, lookup = /* @__PURE__ */ Object.create(null), baseURI = initialBaseURI, basePointer = \"\") {\n  if (schema2 && typeof schema2 === \"object\" && !Array.isArray(schema2)) {\n    const id2 = schema2.$id || schema2.id;\n    if (id2) {\n      const url = new URL(id2, baseURI.href);\n      if (url.hash.length > 1) {\n        lookup[url.href] = schema2;\n      } else {\n        url.hash = \"\";\n        if (basePointer === \"\") {\n          baseURI = url;\n        } else {\n          dereference(schema2, lookup, baseURI);\n        }\n      }\n    }\n  } else if (schema2 !== true && schema2 !== false) {\n    return lookup;\n  }\n  const schemaURI = baseURI.href + (basePointer ? \"#\" + basePointer : \"\");\n  if (lookup[schemaURI] !== void 0) {\n    throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n  }\n  lookup[schemaURI] = schema2;\n  if (schema2 === true || schema2 === false) {\n    return lookup;\n  }\n  if (schema2.__absolute_uri__ === void 0) {\n    Object.defineProperty(schema2, \"__absolute_uri__\", {\n      enumerable: false,\n      value: schemaURI\n    });\n  }\n  if (schema2.$ref && schema2.__absolute_ref__ === void 0) {\n    const url = new URL(schema2.$ref, baseURI.href);\n    url.hash = url.hash;\n    Object.defineProperty(schema2, \"__absolute_ref__\", {\n      enumerable: false,\n      value: url.href\n    });\n  }\n  if (schema2.$recursiveRef && schema2.__absolute_recursive_ref__ === void 0) {\n    const url = new URL(schema2.$recursiveRef, baseURI.href);\n    url.hash = url.hash;\n    Object.defineProperty(schema2, \"__absolute_recursive_ref__\", {\n      enumerable: false,\n      value: url.href\n    });\n  }\n  if (schema2.$anchor) {\n    const url = new URL(\"#\" + schema2.$anchor, baseURI.href);\n    lookup[url.href] = schema2;\n  }\n  for (let key in schema2) {\n    if (ignoredKeyword[key]) {\n      continue;\n    }\n    const keyBase = `${basePointer}/${encodePointer(key)}`;\n    const subSchema = schema2[key];\n    if (Array.isArray(subSchema)) {\n      if (schemaArrayKeyword[key]) {\n        const length = subSchema.length;\n        for (let i = 0; i < length; i++) {\n          dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n        }\n      }\n    } else if (schemaMapKeyword[key]) {\n      for (let subKey in subSchema) {\n        dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n      }\n    } else {\n      dereference(subSchema, lookup, baseURI, keyBase);\n    }\n  }\n  return lookup;\n}\nfunction bind(r2) {\n  return r2.test.bind(r2);\n}\nfunction isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction date(str) {\n  const matches = str.match(DATE);\n  if (!matches)\n    return false;\n  const year = +matches[1];\n  const month = +matches[2];\n  const day = +matches[3];\n  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n}\nfunction time3(full, str) {\n  const matches = str.match(TIME);\n  if (!matches)\n    return false;\n  const hour = +matches[1];\n  const minute = +matches[2];\n  const second = +matches[3];\n  const timeZone = !!matches[5];\n  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);\n}\nfunction date_time(str) {\n  const dateTime = str.split(DATE_TIME_SEPARATOR);\n  return dateTime.length == 2 && date(dateTime[0]) && time3(true, dateTime[1]);\n}\nfunction uri(str) {\n  return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n}\nfunction regex(str) {\n  if (Z_ANCHOR.test(str))\n    return false;\n  try {\n    new RegExp(str, \"u\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction ucs2length(s2) {\n  let result = 0;\n  let length = s2.length;\n  let index = 0;\n  let charCode;\n  while (index < length) {\n    result++;\n    charCode = s2.charCodeAt(index++);\n    if (charCode >= 55296 && charCode <= 56319 && index < length) {\n      charCode = s2.charCodeAt(index);\n      if ((charCode & 64512) == 56320) {\n        index++;\n      }\n    }\n  }\n  return result;\n}\nfunction validate(instance, schema2, draft = \"2019-09\", lookup = dereference(schema2), shortCircuit = true, recursiveAnchor = null, instanceLocation = \"#\", schemaLocation = \"#\", evaluated = /* @__PURE__ */ Object.create(null)) {\n  if (schema2 === true) {\n    return { valid: true, errors: [] };\n  }\n  if (schema2 === false) {\n    return {\n      valid: false,\n      errors: [\n        {\n          instanceLocation,\n          keyword: \"false\",\n          keywordLocation: instanceLocation,\n          error: \"False boolean schema.\"\n        }\n      ]\n    };\n  }\n  const rawInstanceType = typeof instance;\n  let instanceType;\n  switch (rawInstanceType) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      instanceType = rawInstanceType;\n      break;\n    case \"object\":\n      if (instance === null) {\n        instanceType = \"null\";\n      } else if (Array.isArray(instance)) {\n        instanceType = \"array\";\n      } else {\n        instanceType = \"object\";\n      }\n      break;\n    default:\n      throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n  }\n  const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema2;\n  const errors = [];\n  if ($recursiveAnchor === true && recursiveAnchor === null) {\n    recursiveAnchor = schema2;\n  }\n  if ($recursiveRef === \"#\") {\n    const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;\n    const keywordLocation = `${schemaLocation}/$recursiveRef`;\n    const result = validate(instance, recursiveAnchor === null ? schema2 : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"$recursiveRef\",\n        keywordLocation,\n        error: \"A subschema had errors.\"\n      }, ...result.errors);\n    }\n  }\n  if ($ref !== void 0) {\n    const uri2 = __absolute_ref__ || $ref;\n    const refSchema = lookup[uri2];\n    if (refSchema === void 0) {\n      let message = `Unresolved $ref \"${$ref}\".`;\n      if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n        message += `  Absolute URI \"${__absolute_ref__}\".`;\n      }\n      message += `\nKnown schemas:\n- ${Object.keys(lookup).join(\"\\n- \")}`;\n      throw new Error(message);\n    }\n    const keywordLocation = `${schemaLocation}/$ref`;\n    const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"$ref\",\n        keywordLocation,\n        error: \"A subschema had errors.\"\n      }, ...result.errors);\n    }\n    if (draft === \"4\" || draft === \"7\") {\n      return { valid: errors.length === 0, errors };\n    }\n  }\n  if (Array.isArray($type)) {\n    let length = $type.length;\n    let valid = false;\n    for (let i = 0; i < length; i++) {\n      if (instanceType === $type[i] || $type[i] === \"integer\" && instanceType === \"number\" && instance % 1 === 0 && instance === instance) {\n        valid = true;\n        break;\n      }\n    }\n    if (!valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"type\",\n        keywordLocation: `${schemaLocation}/type`,\n        error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`\n      });\n    }\n  } else if ($type === \"integer\") {\n    if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n      errors.push({\n        instanceLocation,\n        keyword: \"type\",\n        keywordLocation: `${schemaLocation}/type`,\n        error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n      });\n    }\n  } else if ($type !== void 0 && instanceType !== $type) {\n    errors.push({\n      instanceLocation,\n      keyword: \"type\",\n      keywordLocation: `${schemaLocation}/type`,\n      error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n    });\n  }\n  if ($const !== void 0) {\n    if (instanceType === \"object\" || instanceType === \"array\") {\n      if (!deepCompareStrict(instance, $const)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"const\",\n          keywordLocation: `${schemaLocation}/const`,\n          error: `Instance does not match ${JSON.stringify($const)}.`\n        });\n      }\n    } else if (instance !== $const) {\n      errors.push({\n        instanceLocation,\n        keyword: \"const\",\n        keywordLocation: `${schemaLocation}/const`,\n        error: `Instance does not match ${JSON.stringify($const)}.`\n      });\n    }\n  }\n  if ($enum !== void 0) {\n    if (instanceType === \"object\" || instanceType === \"array\") {\n      if (!$enum.some((value2) => deepCompareStrict(instance, value2))) {\n        errors.push({\n          instanceLocation,\n          keyword: \"enum\",\n          keywordLocation: `${schemaLocation}/enum`,\n          error: `Instance does not match any of ${JSON.stringify($enum)}.`\n        });\n      }\n    } else if (!$enum.some((value2) => instance === value2)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"enum\",\n        keywordLocation: `${schemaLocation}/enum`,\n        error: `Instance does not match any of ${JSON.stringify($enum)}.`\n      });\n    }\n  }\n  if ($not !== void 0) {\n    const keywordLocation = `${schemaLocation}/not`;\n    const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);\n    if (result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"not\",\n        keywordLocation,\n        error: 'Instance matched \"not\" schema.'\n      });\n    }\n  }\n  let subEvaluateds = [];\n  if ($anyOf !== void 0) {\n    const keywordLocation = `${schemaLocation}/anyOf`;\n    const errorsLength = errors.length;\n    let anyValid = false;\n    for (let i = 0; i < $anyOf.length; i++) {\n      const subSchema = $anyOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      anyValid = anyValid || result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (anyValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"anyOf\",\n        keywordLocation,\n        error: \"Instance does not match any subschemas.\"\n      });\n    }\n  }\n  if ($allOf !== void 0) {\n    const keywordLocation = `${schemaLocation}/allOf`;\n    const errorsLength = errors.length;\n    let allValid = true;\n    for (let i = 0; i < $allOf.length; i++) {\n      const subSchema = $allOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      allValid = allValid && result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (allValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"allOf\",\n        keywordLocation,\n        error: `Instance does not match every subschema.`\n      });\n    }\n  }\n  if ($oneOf !== void 0) {\n    const keywordLocation = `${schemaLocation}/oneOf`;\n    const errorsLength = errors.length;\n    const matches = $oneOf.filter((subSchema, i) => {\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n      return result.valid;\n    }).length;\n    if (matches === 1) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"oneOf\",\n        keywordLocation,\n        error: `Instance does not match exactly one subschema (${matches} matches).`\n      });\n    }\n  }\n  if (instanceType === \"object\" || instanceType === \"array\") {\n    Object.assign(evaluated, ...subEvaluateds);\n  }\n  if ($if !== void 0) {\n    const keywordLocation = `${schemaLocation}/if`;\n    const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n    if (conditionResult) {\n      if ($then !== void 0) {\n        const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n        if (!thenResult.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"if\",\n            keywordLocation,\n            error: `Instance does not match \"then\" schema.`\n          }, ...thenResult.errors);\n        }\n      }\n    } else if ($else !== void 0) {\n      const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n      if (!elseResult.valid) {\n        errors.push({\n          instanceLocation,\n          keyword: \"if\",\n          keywordLocation,\n          error: `Instance does not match \"else\" schema.`\n        }, ...elseResult.errors);\n      }\n    }\n  }\n  if (instanceType === \"object\") {\n    if ($required !== void 0) {\n      for (const key of $required) {\n        if (!(key in instance)) {\n          errors.push({\n            instanceLocation,\n            keyword: \"required\",\n            keywordLocation: `${schemaLocation}/required`,\n            error: `Instance does not have required property \"${key}\".`\n          });\n        }\n      }\n    }\n    const keys2 = Object.keys(instance);\n    if ($minProperties !== void 0 && keys2.length < $minProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minProperties\",\n        keywordLocation: `${schemaLocation}/minProperties`,\n        error: `Instance does not have at least ${$minProperties} properties.`\n      });\n    }\n    if ($maxProperties !== void 0 && keys2.length > $maxProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxProperties\",\n        keywordLocation: `${schemaLocation}/maxProperties`,\n        error: `Instance does not have at least ${$maxProperties} properties.`\n      });\n    }\n    if ($propertyNames !== void 0) {\n      const keywordLocation = `${schemaLocation}/propertyNames`;\n      for (const key in instance) {\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"propertyNames\",\n            keywordLocation,\n            error: `Property name \"${key}\" does not match schema.`\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($dependentRequired !== void 0) {\n      const keywordLocation = `${schemaLocation}/dependantRequired`;\n      for (const key in $dependentRequired) {\n        if (key in instance) {\n          const required = $dependentRequired[key];\n          for (const dependantKey of required) {\n            if (!(dependantKey in instance)) {\n              errors.push({\n                instanceLocation,\n                keyword: \"dependentRequired\",\n                keywordLocation,\n                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n              });\n            }\n          }\n        }\n      }\n    }\n    if ($dependentSchemas !== void 0) {\n      for (const key in $dependentSchemas) {\n        const keywordLocation = `${schemaLocation}/dependentSchemas`;\n        if (key in instance) {\n          const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n          if (!result.valid) {\n            errors.push({\n              instanceLocation,\n              keyword: \"dependentSchemas\",\n              keywordLocation,\n              error: `Instance has \"${key}\" but does not match dependant schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($dependencies !== void 0) {\n      const keywordLocation = `${schemaLocation}/dependencies`;\n      for (const key in $dependencies) {\n        if (key in instance) {\n          const propsOrSchema = $dependencies[key];\n          if (Array.isArray(propsOrSchema)) {\n            for (const dependantKey of propsOrSchema) {\n              if (!(dependantKey in instance)) {\n                errors.push({\n                  instanceLocation,\n                  keyword: \"dependencies\",\n                  keywordLocation,\n                  error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                });\n              }\n            }\n          } else {\n            const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n            if (!result.valid) {\n              errors.push({\n                instanceLocation,\n                keyword: \"dependencies\",\n                keywordLocation,\n                error: `Instance has \"${key}\" but does not match dependant schema.`\n              }, ...result.errors);\n            }\n          }\n        }\n      }\n    }\n    const thisEvaluated = /* @__PURE__ */ Object.create(null);\n    let stop = false;\n    if ($properties !== void 0) {\n      const keywordLocation = `${schemaLocation}/properties`;\n      for (const key in $properties) {\n        if (!(key in instance)) {\n          continue;\n        }\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n        if (result.valid) {\n          evaluated[key] = thisEvaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"properties\",\n            keywordLocation,\n            error: `Property \"${key}\" does not match schema.`\n          }, ...result.errors);\n          if (stop)\n            break;\n        }\n      }\n    }\n    if (!stop && $patternProperties !== void 0) {\n      const keywordLocation = `${schemaLocation}/patternProperties`;\n      for (const pattern in $patternProperties) {\n        const regex2 = new RegExp(pattern, \"u\");\n        const subSchema = $patternProperties[pattern];\n        for (const key in instance) {\n          if (!regex2.test(key)) {\n            continue;\n          }\n          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n          const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n          if (result.valid) {\n            evaluated[key] = thisEvaluated[key] = true;\n          } else {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"patternProperties\",\n              keywordLocation,\n              error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if (!stop && $additionalProperties !== void 0) {\n      const keywordLocation = `${schemaLocation}/additionalProperties`;\n      for (const key in instance) {\n        if (thisEvaluated[key]) {\n          continue;\n        }\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (result.valid) {\n          evaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"additionalProperties\",\n            keywordLocation,\n            error: `Property \"${key}\" does not match additional properties schema.`\n          }, ...result.errors);\n        }\n      }\n    } else if (!stop && $unevaluatedProperties !== void 0) {\n      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n      for (const key in instance) {\n        if (!evaluated[key]) {\n          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n          const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n          if (result.valid) {\n            evaluated[key] = true;\n          } else {\n            errors.push({\n              instanceLocation,\n              keyword: \"unevaluatedProperties\",\n              keywordLocation,\n              error: `Property \"${key}\" does not match unevaluated properties schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n  } else if (instanceType === \"array\") {\n    if ($maxItems !== void 0 && instance.length > $maxItems) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxItems\",\n        keywordLocation: `${schemaLocation}/maxItems`,\n        error: `Array has too many items (${instance.length} > ${$maxItems}).`\n      });\n    }\n    if ($minItems !== void 0 && instance.length < $minItems) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minItems\",\n        keywordLocation: `${schemaLocation}/minItems`,\n        error: `Array has too few items (${instance.length} < ${$minItems}).`\n      });\n    }\n    const length = instance.length;\n    let i = 0;\n    let stop = false;\n    if ($prefixItems !== void 0) {\n      const keywordLocation = `${schemaLocation}/prefixItems`;\n      const length2 = Math.min($prefixItems.length, length);\n      for (; i < length2; i++) {\n        const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n        evaluated[i] = true;\n        if (!result.valid) {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"prefixItems\",\n            keywordLocation,\n            error: `Items did not match schema.`\n          }, ...result.errors);\n          if (stop)\n            break;\n        }\n      }\n    }\n    if ($items !== void 0) {\n      const keywordLocation = `${schemaLocation}/items`;\n      if (Array.isArray($items)) {\n        const length2 = Math.min($items.length, length);\n        for (; i < length2; i++) {\n          const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"items\",\n              keywordLocation,\n              error: `Items did not match schema.`\n            }, ...result.errors);\n            if (stop)\n              break;\n          }\n        }\n      } else {\n        for (; i < length; i++) {\n          const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"items\",\n              keywordLocation,\n              error: `Items did not match schema.`\n            }, ...result.errors);\n            if (stop)\n              break;\n          }\n        }\n      }\n      if (!stop && $additionalItems !== void 0) {\n        const keywordLocation2 = `${schemaLocation}/additionalItems`;\n        for (; i < length; i++) {\n          const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation2);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"additionalItems\",\n              keywordLocation: keywordLocation2,\n              error: `Items did not match additional items schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($contains !== void 0) {\n      if (length === 0 && $minContains === void 0) {\n        errors.push({\n          instanceLocation,\n          keyword: \"contains\",\n          keywordLocation: `${schemaLocation}/contains`,\n          error: `Array is empty. It must contain at least one item matching the schema.`\n        });\n      } else if ($minContains !== void 0 && length < $minContains) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minContains\",\n          keywordLocation: `${schemaLocation}/minContains`,\n          error: `Array has less items (${length}) than minContains (${$minContains}).`\n        });\n      } else {\n        const keywordLocation = `${schemaLocation}/contains`;\n        const errorsLength = errors.length;\n        let contained = 0;\n        for (let j3 = 0; j3 < length; j3++) {\n          const result = validate(instance[j3], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j3}`, keywordLocation);\n          if (result.valid) {\n            evaluated[j3] = true;\n            contained++;\n          } else {\n            errors.push(...result.errors);\n          }\n        }\n        if (contained >= ($minContains || 0)) {\n          errors.length = errorsLength;\n        }\n        if ($minContains === void 0 && $maxContains === void 0 && contained === 0) {\n          errors.splice(errorsLength, 0, {\n            instanceLocation,\n            keyword: \"contains\",\n            keywordLocation,\n            error: `Array does not contain item matching schema.`\n          });\n        } else if ($minContains !== void 0 && contained < $minContains) {\n          errors.push({\n            instanceLocation,\n            keyword: \"minContains\",\n            keywordLocation: `${schemaLocation}/minContains`,\n            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`\n          });\n        } else if ($maxContains !== void 0 && contained > $maxContains) {\n          errors.push({\n            instanceLocation,\n            keyword: \"maxContains\",\n            keywordLocation: `${schemaLocation}/maxContains`,\n            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`\n          });\n        }\n      }\n    }\n    if (!stop && $unevaluatedItems !== void 0) {\n      const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n      for (i; i < length; i++) {\n        if (evaluated[i]) {\n          continue;\n        }\n        const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n        evaluated[i] = true;\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"unevaluatedItems\",\n            keywordLocation,\n            error: `Items did not match unevaluated items schema.`\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($uniqueItems) {\n      for (let j3 = 0; j3 < length; j3++) {\n        const a2 = instance[j3];\n        const ao2 = typeof a2 === \"object\" && a2 !== null;\n        for (let k2 = 0; k2 < length; k2++) {\n          if (j3 === k2) {\n            continue;\n          }\n          const b3 = instance[k2];\n          const bo = typeof b3 === \"object\" && b3 !== null;\n          if (a2 === b3 || ao2 && bo && deepCompareStrict(a2, b3)) {\n            errors.push({\n              instanceLocation,\n              keyword: \"uniqueItems\",\n              keywordLocation: `${schemaLocation}/uniqueItems`,\n              error: `Duplicate items at indexes ${j3} and ${k2}.`\n            });\n            j3 = Number.MAX_SAFE_INTEGER;\n            k2 = Number.MAX_SAFE_INTEGER;\n          }\n        }\n      }\n    }\n  } else if (instanceType === \"number\") {\n    if (draft === \"4\") {\n      if ($minimum !== void 0 && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minimum\",\n          keywordLocation: `${schemaLocation}/minimum`,\n          error: `${instance} is less than ${$exclusiveMinimum ? \"or equal to \" : \"\"} ${$minimum}.`\n        });\n      }\n      if ($maximum !== void 0 && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"maximum\",\n          keywordLocation: `${schemaLocation}/maximum`,\n          error: `${instance} is greater than ${$exclusiveMaximum ? \"or equal to \" : \"\"} ${$maximum}.`\n        });\n      }\n    } else {\n      if ($minimum !== void 0 && instance < $minimum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minimum\",\n          keywordLocation: `${schemaLocation}/minimum`,\n          error: `${instance} is less than ${$minimum}.`\n        });\n      }\n      if ($maximum !== void 0 && instance > $maximum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"maximum\",\n          keywordLocation: `${schemaLocation}/maximum`,\n          error: `${instance} is greater than ${$maximum}.`\n        });\n      }\n      if ($exclusiveMinimum !== void 0 && instance <= $exclusiveMinimum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"exclusiveMinimum\",\n          keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n          error: `${instance} is less than ${$exclusiveMinimum}.`\n        });\n      }\n      if ($exclusiveMaximum !== void 0 && instance >= $exclusiveMaximum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"exclusiveMaximum\",\n          keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`\n        });\n      }\n    }\n    if ($multipleOf !== void 0) {\n      const remainder = instance % $multipleOf;\n      if (Math.abs(0 - remainder) >= 11920929e-14 && Math.abs($multipleOf - remainder) >= 11920929e-14) {\n        errors.push({\n          instanceLocation,\n          keyword: \"multipleOf\",\n          keywordLocation: `${schemaLocation}/multipleOf`,\n          error: `${instance} is not a multiple of ${$multipleOf}.`\n        });\n      }\n    }\n  } else if (instanceType === \"string\") {\n    const length = $minLength === void 0 && $maxLength === void 0 ? 0 : ucs2length(instance);\n    if ($minLength !== void 0 && length < $minLength) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minLength\",\n        keywordLocation: `${schemaLocation}/minLength`,\n        error: `String is too short (${length} < ${$minLength}).`\n      });\n    }\n    if ($maxLength !== void 0 && length > $maxLength) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxLength\",\n        keywordLocation: `${schemaLocation}/maxLength`,\n        error: `String is too long (${length} > ${$maxLength}).`\n      });\n    }\n    if ($pattern !== void 0 && !new RegExp($pattern, \"u\").test(instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"pattern\",\n        keywordLocation: `${schemaLocation}/pattern`,\n        error: `String does not match pattern.`\n      });\n    }\n    if ($format !== void 0 && format[$format] && !format[$format](instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"format\",\n        keywordLocation: `${schemaLocation}/format`,\n        error: `String does not match format \"${$format}\".`\n      });\n    }\n  }\n  return { valid: errors.length === 0, errors };\n}\nfunction isUndefined(obj) {\n  return typeof obj === \"undefined\" || obj === void 0;\n}\nfunction isString2(obj) {\n  return typeof obj === \"string\";\n}\nfunction isNumber(obj) {\n  return typeof obj === \"number\";\n}\nfunction isBoolean(obj) {\n  return typeof obj === \"boolean\";\n}\nfunction isNull(obj) {\n  return obj === null;\n}\nfunction isDate(obj) {\n  return obj instanceof Date;\n}\nfunction isBigInt(obj) {\n  return typeof obj === \"bigint\";\n}\nfunction isFunction(obj) {\n  return typeof obj === \"function\";\n}\nfunction isObject(obj) {\n  return typeof obj === \"object\" && obj !== null;\n}\nfunction isPlainObject(obj) {\n  if (!isObject(obj) || getTag(obj) !== \"[object Object]\") {\n    return false;\n  }\n  if (Object.getPrototypeOf(obj) === null) {\n    return true;\n  }\n  let proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(obj) === proto;\n}\nfunction freeze(obj) {\n  return Object.freeze(obj);\n}\nfunction asArray(arg) {\n  if (isReadonlyArray(arg)) {\n    return arg;\n  } else {\n    return [arg];\n  }\n}\nfunction isReadonlyArray(arg) {\n  return Array.isArray(arg);\n}\nfunction noop2(obj) {\n  return obj;\n}\nfunction getTag(value2) {\n  if (value2 == null) {\n    return value2 === void 0 ? \"[object Undefined]\" : \"[object Null]\";\n  }\n  return toString.call(value2);\n}\nfunction isOperationNodeSource(obj) {\n  return isObject(obj) && isFunction(obj.toOperationNode);\n}\nfunction isExpression(obj) {\n  return isObject(obj) && \"expressionType\" in obj && isOperationNodeSource(obj);\n}\nfunction isAliasedExpression(obj) {\n  return isObject(obj) && \"expression\" in obj && isString2(obj.alias) && isOperationNodeSource(obj);\n}\nfunction isJSONOperator(op) {\n  return isString2(op) && JSON_OPERATORS.includes(op);\n}\nfunction isDynamicReferenceBuilder(obj) {\n  return isObject(obj) && isOperationNodeSource(obj) && isString2(obj.dynamicReference);\n}\nfunction isOrderByDirection(thing) {\n  return thing === \"asc\" || thing === \"desc\";\n}\nfunction parseOrderBy(args) {\n  if (args.length === 2) {\n    return [parseOrderByItem(args[0], args[1])];\n  }\n  if (args.length === 1) {\n    const [orderBy] = args;\n    if (Array.isArray(orderBy)) {\n      return orderBy.map((item) => parseOrderByItem(item));\n    }\n    return [parseOrderByItem(orderBy)];\n  }\n  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);\n}\nfunction parseOrderByItem(ref, direction) {\n  const parsedRef = parseOrderByExpression(ref);\n  if (OrderByItemNode.is(parsedRef)) {\n    if (direction) {\n      throw new Error(\"Cannot specify direction twice!\");\n    }\n    return parsedRef;\n  }\n  return OrderByItemNode.create(parsedRef, parseOrderByDirectionExpression(direction));\n}\nfunction parseOrderByExpression(expr) {\n  if (isExpressionOrFactory(expr)) {\n    return parseExpression(expr);\n  }\n  if (isDynamicReferenceBuilder(expr)) {\n    return expr.toOperationNode();\n  }\n  const [ref, direction] = expr.split(\" \");\n  if (direction) {\n    if (!isOrderByDirection(direction)) {\n      throw new Error(`Invalid order by direction: ${direction}`);\n    }\n    return OrderByItemNode.create(parseStringReference(ref), parseOrderByDirectionExpression(direction));\n  }\n  return parseStringReference(expr);\n}\nfunction parseOrderByDirectionExpression(expr) {\n  if (!expr) {\n    return void 0;\n  }\n  if (expr === \"asc\" || expr === \"desc\") {\n    return RawNode.createWithSql(expr);\n  }\n  return expr.toOperationNode();\n}\nfunction parseSimpleReferenceExpression(exp) {\n  if (isString2(exp)) {\n    return parseStringReference(exp);\n  }\n  return exp.toOperationNode();\n}\nfunction parseReferenceExpressionOrList(arg) {\n  if (isReadonlyArray(arg)) {\n    return arg.map((it2) => parseReferenceExpression(it2));\n  } else {\n    return [parseReferenceExpression(arg)];\n  }\n}\nfunction parseReferenceExpression(exp) {\n  if (isExpressionOrFactory(exp)) {\n    return parseExpression(exp);\n  }\n  return parseSimpleReferenceExpression(exp);\n}\nfunction parseJSONReference(ref, op) {\n  const referenceNode = parseStringReference(ref);\n  if (isJSONOperator(op)) {\n    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));\n  }\n  const opWithoutLastChar = op.slice(0, -1);\n  if (isJSONOperator(opWithoutLastChar)) {\n    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));\n  }\n  throw new Error(`Invalid JSON operator: ${op}`);\n}\nfunction parseStringReference(ref) {\n  const COLUMN_SEPARATOR = \".\";\n  if (!ref.includes(COLUMN_SEPARATOR)) {\n    return ReferenceNode.create(ColumnNode.create(ref));\n  }\n  const parts = ref.split(COLUMN_SEPARATOR).map(trim$2);\n  if (parts.length === 3) {\n    return parseStringReferenceWithTableAndSchema(parts);\n  }\n  if (parts.length === 2) {\n    return parseStringReferenceWithTable(parts);\n  }\n  throw new Error(`invalid column reference ${ref}`);\n}\nfunction parseAliasedStringReference(ref) {\n  const ALIAS_SEPARATOR = \" as \";\n  if (ref.includes(ALIAS_SEPARATOR)) {\n    const [columnRef, alias2] = ref.split(ALIAS_SEPARATOR).map(trim$2);\n    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias2));\n  } else {\n    return parseStringReference(ref);\n  }\n}\nfunction parseColumnName(column) {\n  return ColumnNode.create(column);\n}\nfunction parseOrderedColumnName(column) {\n  const ORDER_SEPARATOR = \" \";\n  if (column.includes(ORDER_SEPARATOR)) {\n    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim$2);\n    if (!isOrderByDirection(order)) {\n      throw new Error(`invalid order direction \"${order}\" next to \"${columnName}\"`);\n    }\n    return parseOrderBy([columnName, order])[0];\n  } else {\n    return parseColumnName(column);\n  }\n}\nfunction parseStringReferenceWithTableAndSchema(parts) {\n  const [schema2, table3, column] = parts;\n  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema2, table3));\n}\nfunction parseStringReferenceWithTable(parts) {\n  const [table3, column] = parts;\n  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table3));\n}\nfunction trim$2(str) {\n  return str.trim();\n}\nfunction parseValueExpressionOrList(arg) {\n  if (isReadonlyArray(arg)) {\n    return parseValueExpressionList(arg);\n  }\n  return parseValueExpression(arg);\n}\nfunction parseValueExpression(exp) {\n  if (isExpressionOrFactory(exp)) {\n    return parseExpression(exp);\n  }\n  return ValueNode.create(exp);\n}\nfunction isSafeImmediateValue(value2) {\n  return isNumber(value2) || isBoolean(value2) || isNull(value2);\n}\nfunction parseSafeImmediateValue(value2) {\n  if (!isSafeImmediateValue(value2)) {\n    throw new Error(`unsafe immediate value ${JSON.stringify(value2)}`);\n  }\n  return ValueNode.createImmediate(value2);\n}\nfunction parseValueExpressionList(arg) {\n  if (arg.some(isExpressionOrFactory)) {\n    return ValueListNode.create(arg.map((it2) => parseValueExpression(it2)));\n  }\n  return PrimitiveValueListNode.create(arg);\n}\nfunction parseValueBinaryOperationOrExpression(args) {\n  if (args.length === 3) {\n    return parseValueBinaryOperation(args[0], args[1], args[2]);\n  } else if (args.length === 1) {\n    return parseValueExpression(args[0]);\n  }\n  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);\n}\nfunction parseValueBinaryOperation(left, operator, right) {\n  if (isIsOperator(operator) && needsIsOperator(right)) {\n    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));\n  }\n  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));\n}\nfunction parseReferentialBinaryOperation(left, operator, right) {\n  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));\n}\nfunction parseFilterObject(obj, combinator) {\n  return parseFilterList(Object.entries(obj).filter(([, v3]) => !isUndefined(v3)).map(([k2, v3]) => parseValueBinaryOperation(k2, needsIsOperator(v3) ? \"is\" : \"=\", v3)), combinator);\n}\nfunction parseFilterList(list, combinator, withParens = true) {\n  const combine = combinator === \"and\" ? AndNode.create : OrNode.create;\n  if (list.length === 0) {\n    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create(\"=\"), ValueNode.createImmediate(combinator === \"and\" ? 1 : 0));\n  }\n  let node = toOperationNode(list[0]);\n  for (let i = 1; i < list.length; ++i) {\n    node = combine(node, toOperationNode(list[i]));\n  }\n  if (list.length > 1 && withParens) {\n    return ParensNode.create(node);\n  }\n  return node;\n}\nfunction isIsOperator(operator) {\n  return operator === \"is\" || operator === \"is not\";\n}\nfunction needsIsOperator(value2) {\n  return isNull(value2) || isBoolean(value2);\n}\nfunction parseOperator(operator) {\n  if (isString2(operator) && OPERATORS.includes(operator)) {\n    return OperatorNode.create(operator);\n  }\n  if (isOperationNodeSource(operator)) {\n    return operator.toOperationNode();\n  }\n  throw new Error(`invalid operator ${JSON.stringify(operator)}`);\n}\nfunction toOperationNode(nodeOrSource) {\n  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;\n}\nfunction preventAwait(clazz, message) {\n  Object.defineProperties(clazz.prototype, {\n    then: {\n      enumerable: false,\n      value: /* @__PURE__ */ __name(() => {\n        throw new Error(message);\n      }, \"value\")\n    }\n  });\n}\nfunction parsePartitionBy(partitionBy) {\n  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);\n}\nfunction parseSelectArg(selection) {\n  if (isFunction(selection)) {\n    return parseSelectArg(selection(expressionBuilder()));\n  } else if (isReadonlyArray(selection)) {\n    return selection.map((it2) => parseSelectExpression(it2));\n  } else {\n    return [parseSelectExpression(selection)];\n  }\n}\nfunction parseSelectExpression(selection) {\n  if (isString2(selection)) {\n    return SelectionNode.create(parseAliasedStringReference(selection));\n  } else if (isDynamicReferenceBuilder(selection)) {\n    return SelectionNode.create(selection.toOperationNode());\n  } else {\n    return SelectionNode.create(parseAliasedExpression(selection));\n  }\n}\nfunction parseSelectAll(table3) {\n  if (!table3) {\n    return [SelectionNode.createSelectAll()];\n  } else if (Array.isArray(table3)) {\n    return table3.map(parseSelectAllArg);\n  } else {\n    return [parseSelectAllArg(table3)];\n  }\n}\nfunction parseSelectAllArg(table3) {\n  if (isString2(table3)) {\n    return SelectionNode.createSelectAllFromTable(parseTable(table3));\n  }\n  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table3)}`);\n}\nfunction parseInsertExpression(arg) {\n  const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;\n  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);\n  return parseInsertColumnsAndValues(list);\n}\nfunction parseInsertColumnsAndValues(rows) {\n  const columns = parseColumnNamesAndIndexes(rows);\n  return [\n    freeze([...columns.keys()].map(ColumnNode.create)),\n    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))\n  ];\n}\nfunction parseColumnNamesAndIndexes(rows) {\n  const columns = /* @__PURE__ */ new Map();\n  for (const row of rows) {\n    const cols = Object.keys(row);\n    for (const col of cols) {\n      if (!columns.has(col) && row[col] !== void 0) {\n        columns.set(col, columns.size);\n      }\n    }\n  }\n  return columns;\n}\nfunction parseRowValues(row, columns) {\n  const rowColumns = Object.keys(row);\n  const rowValues = Array.from({\n    length: columns.size\n  });\n  let hasUndefinedOrComplexColumns = false;\n  let indexedRowColumns = rowColumns.length;\n  for (const col of rowColumns) {\n    const columnIdx = columns.get(col);\n    if (isUndefined(columnIdx)) {\n      indexedRowColumns--;\n      continue;\n    }\n    const value2 = row[col];\n    if (isUndefined(value2) || isExpressionOrFactory(value2)) {\n      hasUndefinedOrComplexColumns = true;\n    }\n    rowValues[columnIdx] = value2;\n  }\n  const hasMissingColumns = indexedRowColumns < columns.size;\n  if (hasMissingColumns || hasUndefinedOrComplexColumns) {\n    const defaultValue = DefaultInsertValueNode.create();\n    return ValueListNode.create(rowValues.map((it2) => isUndefined(it2) ? defaultValue : parseValueExpression(it2)));\n  }\n  return PrimitiveValueListNode.create(rowValues);\n}\nfunction parseUpdate(...args) {\n  if (args.length === 2) {\n    return [\n      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))\n    ];\n  }\n  return parseUpdateObjectExpression(args[0]);\n}\nfunction parseUpdateObjectExpression(update2) {\n  const updateObj = isFunction(update2) ? update2(expressionBuilder()) : update2;\n  return Object.entries(updateObj).filter(([_3, value2]) => value2 !== void 0).map(([key, value2]) => {\n    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value2));\n  });\n}\nfunction isNoResultErrorConstructor(fn2) {\n  return Object.prototype.hasOwnProperty.call(fn2, \"prototype\");\n}\nfunction parseTop(expression, modifiers) {\n  if (!isNumber(expression) && !isBigInt(expression)) {\n    throw new Error(`Invalid top expression: ${expression}`);\n  }\n  if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {\n    throw new Error(`Invalid top modifiers: ${modifiers}`);\n  }\n  return TopNode.create(expression, modifiers);\n}\nfunction isTopModifiers(modifiers) {\n  return modifiers === \"percent\" || modifiers === \"with ties\" || modifiers === \"percent with ties\";\n}\nfunction parseCommonTableExpression(nameOrBuilderCallback, expression) {\n  const expressionNode = expression(createQueryCreator()).toOperationNode();\n  if (isFunction(nameOrBuilderCallback)) {\n    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();\n  }\n  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);\n}\nfunction cteBuilderFactory(expressionNode) {\n  return (name) => {\n    return new CTEBuilder({\n      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)\n    });\n  };\n}\nfunction parseCommonTableExpressionName(name) {\n  if (name.includes(\"(\")) {\n    const parts = name.split(/[\\(\\)]/);\n    const table3 = parts[0];\n    const columns = parts[1].split(\",\").map((it2) => it2.trim());\n    return CommonTableExpressionNameNode.create(table3, columns);\n  } else {\n    return CommonTableExpressionNameNode.create(name);\n  }\n}\nfunction randomString(length) {\n  let chars = \"\";\n  for (let i = 0; i < length; ++i) {\n    chars += randomChar();\n  }\n  return chars;\n}\nfunction randomChar() {\n  return CHARS[~~(Math.random() * CHARS.length)];\n}\nfunction createQueryId() {\n  return new LazyQueryId();\n}\nfunction requireAllProps(obj) {\n  return obj;\n}\nfunction parseMergeWhen(type2, args, refRight) {\n  return WhenNode.create(parseFilterList([\n    MatchedNode.create(!type2.isMatched, type2.bySource),\n    ...args && args.length > 0 ? [\n      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)\n    ] : []\n  ], \"and\", false));\n}\nfunction parseMergeThen(result) {\n  if (isString2(result)) {\n    return RawNode.create([result], []);\n  }\n  if (isOperationNodeSource(result)) {\n    return result.toOperationNode();\n  }\n  return result;\n}\nfunction logOnce(message) {\n  if (LOGGED_MESSAGES.has(message)) {\n    return;\n  }\n  LOGGED_MESSAGES.add(message);\n  console.log(message);\n}\nfunction warnOfOutdatedDriverOrPlugins(result, transformedResult) {\n  const { numAffectedRows } = result;\n  if (numAffectedRows === void 0 && result.numUpdatedOrDeletedRows === void 0 || numAffectedRows !== void 0 && transformedResult.numAffectedRows !== void 0) {\n    return;\n  }\n  logOnce(\"kysely:warning: outdated driver/plugin detected! QueryResult.numUpdatedOrDeletedRows is deprecated and will be removed in a future release.\");\n}\nfunction createQueryCreator() {\n  return new QueryCreator({\n    executor: NOOP_QUERY_EXECUTOR\n  });\n}\nfunction createJoinBuilder(joinType, table3) {\n  return new JoinBuilder({\n    joinNode: JoinNode.create(joinType, parseTableExpression(table3))\n  });\n}\nfunction createOverBuilder() {\n  return new OverBuilder({\n    overNode: OverNode.create()\n  });\n}\nfunction parseJoin(joinType, args) {\n  if (args.length === 3) {\n    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);\n  } else if (args.length === 2) {\n    return parseCallbackJoin(joinType, args[0], args[1]);\n  } else {\n    throw new Error(\"not implemented\");\n  }\n}\nfunction parseCallbackJoin(joinType, from, callback) {\n  return callback(createJoinBuilder(joinType, from)).toOperationNode();\n}\nfunction parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {\n  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, \"=\", rhsColumn));\n}\nfunction parseGroupBy(groupBy) {\n  groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;\n  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);\n}\nfunction parseSetOperations(operator, expression, all) {\n  if (isFunction(expression)) {\n    expression = expression(createExpressionBuilder());\n  }\n  if (!isReadonlyArray(expression)) {\n    expression = [expression];\n  }\n  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all));\n}\nfunction parseFetch(rowCount, modifier) {\n  if (!isNumber(rowCount) && !isBigInt(rowCount)) {\n    throw new Error(`Invalid fetch row count: ${rowCount}`);\n  }\n  if (!isFetchModifier(modifier)) {\n    throw new Error(`Invalid fetch modifier: ${modifier}`);\n  }\n  return FetchNode.create(rowCount, modifier);\n}\nfunction isFetchModifier(value2) {\n  return value2 === \"only\" || value2 === \"with ties\";\n}\nfunction createSelectQueryBuilder(props) {\n  return new SelectQueryBuilderImpl(props);\n}\nfunction createFunctionModule() {\n  const fn2 = /* @__PURE__ */ __name((name, args) => {\n    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));\n  }, \"fn\");\n  const agg = /* @__PURE__ */ __name((name, args) => {\n    return new AggregateFunctionBuilder({\n      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : void 0)\n    });\n  }, \"agg\");\n  return Object.assign(fn2, {\n    agg,\n    avg(column) {\n      return agg(\"avg\", [column]);\n    },\n    coalesce(...values) {\n      return fn2(\"coalesce\", values);\n    },\n    count(column) {\n      return agg(\"count\", [column]);\n    },\n    countAll(table3) {\n      return new AggregateFunctionBuilder({\n        aggregateFunctionNode: AggregateFunctionNode.create(\"count\", parseSelectAll(table3))\n      });\n    },\n    max(column) {\n      return agg(\"max\", [column]);\n    },\n    min(column) {\n      return agg(\"min\", [column]);\n    },\n    sum(column) {\n      return agg(\"sum\", [column]);\n    },\n    any(column) {\n      return fn2(\"any\", [column]);\n    },\n    jsonAgg(table3) {\n      return new AggregateFunctionBuilder({\n        aggregateFunctionNode: AggregateFunctionNode.create(\"json_agg\", [\n          isString2(table3) ? parseTable(table3) : table3.toOperationNode()\n        ])\n      });\n    },\n    toJson(table3) {\n      return new ExpressionWrapper(FunctionNode.create(\"to_json\", [\n        isString2(table3) ? parseTable(table3) : table3.toOperationNode()\n      ]));\n    }\n  });\n}\nfunction parseUnaryOperation(operator, operand) {\n  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));\n}\nfunction isColumnDataType(dataType) {\n  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {\n    return true;\n  }\n  if (COLUMN_DATA_TYPE_REGEX.some((r2) => r2.test(dataType))) {\n    return true;\n  }\n  return false;\n}\nfunction parseDataTypeExpression(dataType) {\n  if (isOperationNodeSource(dataType)) {\n    return dataType.toOperationNode();\n  }\n  if (isColumnDataType(dataType)) {\n    return DataTypeNode.create(dataType);\n  }\n  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);\n}\nfunction createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {\n  function binary2(lhs, op, rhs) {\n    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));\n  }\n  __name(binary2, \"binary\");\n  function unary(op, expr) {\n    return new ExpressionWrapper(parseUnaryOperation(op, expr));\n  }\n  __name(unary, \"unary\");\n  const eb = Object.assign(binary2, {\n    fn: void 0,\n    eb: void 0,\n    selectFrom(table3) {\n      return createSelectQueryBuilder({\n        queryId: createQueryId(),\n        executor,\n        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table3))\n      });\n    },\n    case(reference) {\n      return new CaseBuilder({\n        node: CaseNode.create(isUndefined(reference) ? void 0 : parseReferenceExpression(reference))\n      });\n    },\n    ref(reference, op) {\n      if (isUndefined(op)) {\n        return new ExpressionWrapper(parseStringReference(reference));\n      }\n      return new JSONPathBuilder(parseJSONReference(reference, op));\n    },\n    jsonPath() {\n      return new JSONPathBuilder(JSONPathNode.create());\n    },\n    table(table3) {\n      return new ExpressionWrapper(parseTable(table3));\n    },\n    val(value2) {\n      return new ExpressionWrapper(parseValueExpression(value2));\n    },\n    refTuple(...values) {\n      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));\n    },\n    tuple(...values) {\n      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));\n    },\n    lit(value2) {\n      return new ExpressionWrapper(parseSafeImmediateValue(value2));\n    },\n    unary,\n    not(expr) {\n      return unary(\"not\", expr);\n    },\n    exists(expr) {\n      return unary(\"exists\", expr);\n    },\n    neg(expr) {\n      return unary(\"-\", expr);\n    },\n    between(expr, start, end) {\n      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create(\"between\"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));\n    },\n    betweenSymmetric(expr, start, end) {\n      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create(\"between symmetric\"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));\n    },\n    and(exprs) {\n      if (isReadonlyArray(exprs)) {\n        return new ExpressionWrapper(parseFilterList(exprs, \"and\"));\n      }\n      return new ExpressionWrapper(parseFilterObject(exprs, \"and\"));\n    },\n    or(exprs) {\n      if (isReadonlyArray(exprs)) {\n        return new ExpressionWrapper(parseFilterList(exprs, \"or\"));\n      }\n      return new ExpressionWrapper(parseFilterObject(exprs, \"or\"));\n    },\n    parens(...args) {\n      const node = parseValueBinaryOperationOrExpression(args);\n      if (ParensNode.is(node)) {\n        return new ExpressionWrapper(node);\n      } else {\n        return new ExpressionWrapper(ParensNode.create(node));\n      }\n    },\n    cast(expr, dataType) {\n      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));\n    },\n    withSchema(schema2) {\n      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema2)));\n    }\n  });\n  eb.fn = createFunctionModule();\n  eb.eb = eb;\n  return eb;\n}\nfunction expressionBuilder(_3) {\n  return createExpressionBuilder();\n}\nfunction parseExpression(exp) {\n  if (isOperationNodeSource(exp)) {\n    return exp.toOperationNode();\n  } else if (isFunction(exp)) {\n    return exp(expressionBuilder()).toOperationNode();\n  }\n  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);\n}\nfunction parseAliasedExpression(exp) {\n  if (isOperationNodeSource(exp)) {\n    return exp.toOperationNode();\n  } else if (isFunction(exp)) {\n    return exp(expressionBuilder()).toOperationNode();\n  }\n  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);\n}\nfunction isExpressionOrFactory(obj) {\n  return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);\n}\nfunction parseTableExpressionOrList(table3) {\n  if (isReadonlyArray(table3)) {\n    return table3.map((it2) => parseTableExpression(it2));\n  } else {\n    return [parseTableExpression(table3)];\n  }\n}\nfunction parseTableExpression(table3) {\n  if (isString2(table3)) {\n    return parseAliasedTable(table3);\n  } else {\n    return parseAliasedExpression(table3);\n  }\n}\nfunction parseAliasedTable(from) {\n  const ALIAS_SEPARATOR = \" as \";\n  if (from.includes(ALIAS_SEPARATOR)) {\n    const [table3, alias2] = from.split(ALIAS_SEPARATOR).map(trim$1);\n    return AliasNode.create(parseTable(table3), IdentifierNode.create(alias2));\n  } else {\n    return parseTable(from);\n  }\n}\nfunction parseTable(from) {\n  const SCHEMA_SEPARATOR = \".\";\n  if (from.includes(SCHEMA_SEPARATOR)) {\n    const [schema2, table3] = from.split(SCHEMA_SEPARATOR).map(trim$1);\n    return TableNode.createWithSchema(schema2, table3);\n  } else {\n    return TableNode.create(from);\n  }\n}\nfunction trim$1(str) {\n  return str.trim();\n}\nfunction parseDefaultValueExpression(value2) {\n  return isOperationNodeSource(value2) ? value2.toOperationNode() : ValueNode.createImmediate(value2);\n}\nfunction parseOnModifyForeignAction(action) {\n  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {\n    return action;\n  }\n  throw new Error(`invalid OnModifyForeignAction ${action}`);\n}\nfunction parseOnCommitAction(action) {\n  if (ON_COMMIT_ACTIONS.includes(action)) {\n    return action;\n  }\n  throw new Error(`invalid OnCommitAction ${action}`);\n}\nfunction parseSchemableIdentifier(id2) {\n  const SCHEMA_SEPARATOR = \".\";\n  if (id2.includes(SCHEMA_SEPARATOR)) {\n    const parts = id2.split(SCHEMA_SEPARATOR).map(trim);\n    if (parts.length === 2) {\n      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);\n    } else {\n      throw new Error(`invalid schemable identifier ${id2}`);\n    }\n  } else {\n    return SchemableIdentifierNode.create(id2);\n  }\n}\nfunction trim(str) {\n  return str.trim();\n}\nfunction performanceNow() {\n  if (typeof performance !== \"undefined\" && isFunction(performance.now)) {\n    return performance.now();\n  } else {\n    return Date.now();\n  }\n}\nfunction defaultLogger(event) {\n  if (event.level === \"query\") {\n    console.log(`kysely:query: ${event.query.sql}`);\n    console.log(`kysely:query: duration: ${event.queryDurationMillis.toFixed(1)}ms`);\n  } else if (event.level === \"error\") {\n    if (event.error instanceof Error) {\n      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);\n    } else {\n      console.error(`kysely:error: ${JSON.stringify({\n        error: event.error,\n        query: event.query.sql,\n        queryDurationMillis: event.queryDurationMillis\n      })}`);\n    }\n  }\n}\nfunction isCompilable(value2) {\n  return isObject(value2) && isFunction(value2.compile);\n}\nfunction isKyselyProps(obj) {\n  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);\n}\nfunction validateTransactionSettings(settings) {\n  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {\n    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);\n  }\n}\nfunction createRawBuilder(props) {\n  return new RawBuilderImpl(props);\n}\nfunction parseParameter(param) {\n  if (isOperationNodeSource(param)) {\n    return param.toOperationNode();\n  }\n  return parseValueExpression(param);\n}\nfunction parseArray(arr, objectStrategy) {\n  const target = objectStrategy === \"create\" ? new Array(arr.length) : arr;\n  for (let i = 0; i < arr.length; ++i) {\n    target[i] = parse2(arr[i], objectStrategy);\n  }\n  return target;\n}\nfunction parse2(obj, objectStrategy) {\n  if (isString2(obj)) {\n    return parseString(obj);\n  }\n  if (Array.isArray(obj)) {\n    return parseArray(obj, objectStrategy);\n  }\n  if (isPlainObject(obj)) {\n    return parseObject(obj, objectStrategy);\n  }\n  return obj;\n}\nfunction parseString(str) {\n  if (maybeJson(str)) {\n    try {\n      return parse2(JSON.parse(str), \"in-place\");\n    } catch (err) {\n    }\n  }\n  return str;\n}\nfunction maybeJson(value2) {\n  return value2.match(/^[\\[\\{]/) != null;\n}\nfunction parseObject(obj, objectStrategy) {\n  const target = objectStrategy === \"create\" ? {} : obj;\n  for (const key in obj) {\n    target[key] = parse2(obj[key], objectStrategy);\n  }\n  return target;\n}\nfunction parseUri(text) {\n  const match = URI_RE.exec(text);\n  if (match === null) {\n    throw new LibsqlError(`The URL '${text}' is not in a valid format`, \"URL_INVALID\");\n  }\n  const groups = match.groups;\n  const scheme = groups[\"scheme\"];\n  const authority = groups[\"authority\"] !== void 0 ? parseAuthority(groups[\"authority\"]) : void 0;\n  const path = percentDecode(groups[\"path\"]);\n  const query = groups[\"query\"] !== void 0 ? parseQuery(groups[\"query\"]) : void 0;\n  const fragment = groups[\"fragment\"] !== void 0 ? percentDecode(groups[\"fragment\"]) : void 0;\n  return { scheme, authority, path, query, fragment };\n}\nfunction parseAuthority(text) {\n  const match = AUTHORITY_RE.exec(text);\n  if (match === null) {\n    throw new LibsqlError(\"The authority part of the URL is not in a valid format\", \"URL_INVALID\");\n  }\n  const groups = match.groups;\n  const host = percentDecode(groups[\"host_br\"] ?? groups[\"host\"]);\n  const port = groups[\"port\"] ? parseInt(groups[\"port\"], 10) : void 0;\n  const userinfo = groups[\"username\"] !== void 0 ? {\n    username: percentDecode(groups[\"username\"]),\n    password: groups[\"password\"] !== void 0 ? percentDecode(groups[\"password\"]) : void 0\n  } : void 0;\n  return { host, port, userinfo };\n}\nfunction parseQuery(text) {\n  const sequences = text.split(\"&\");\n  const pairs = [];\n  for (const sequence2 of sequences) {\n    if (sequence2 === \"\") {\n      continue;\n    }\n    let key;\n    let value2;\n    const splitIdx = sequence2.indexOf(\"=\");\n    if (splitIdx < 0) {\n      key = sequence2;\n      value2 = \"\";\n    } else {\n      key = sequence2.substring(0, splitIdx);\n      value2 = sequence2.substring(splitIdx + 1);\n    }\n    pairs.push({\n      key: percentDecode(key.replaceAll(\"+\", \" \")),\n      value: percentDecode(value2.replaceAll(\"+\", \" \"))\n    });\n  }\n  return { pairs };\n}\nfunction percentDecode(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new LibsqlError(`URL component has invalid percent encoding: ${e}`, \"URL_INVALID\", void 0, e);\n    }\n    throw e;\n  }\n}\nfunction encodeBaseUrl(scheme, authority, path) {\n  if (authority === void 0) {\n    throw new LibsqlError(`URL with scheme ${JSON.stringify(scheme + \":\")} requires authority (the \"//\" part)`, \"URL_INVALID\");\n  }\n  const schemeText = `${scheme}:`;\n  const hostText = encodeHost(authority.host);\n  const portText = encodePort(authority.port);\n  const userinfoText = encodeUserinfo(authority.userinfo);\n  const authorityText = `//${userinfoText}${hostText}${portText}`;\n  let pathText = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n  if (pathText !== \"\" && !pathText.startsWith(\"/\")) {\n    pathText = \"/\" + pathText;\n  }\n  return new URL(`${schemeText}${authorityText}${pathText}`);\n}\nfunction encodeHost(host) {\n  return host.includes(\":\") ? `[${encodeURI(host)}]` : encodeURI(host);\n}\nfunction encodePort(port) {\n  return port !== void 0 ? `:${port}` : \"\";\n}\nfunction encodeUserinfo(userinfo) {\n  if (userinfo === void 0) {\n    return \"\";\n  }\n  const usernameText = encodeURIComponent(userinfo.username);\n  const passwordText = userinfo.password !== void 0 ? `:${encodeURIComponent(userinfo.password)}` : \"\";\n  return `${usernameText}${passwordText}@`;\n}\nfunction transactionModeToBegin(mode) {\n  if (mode === \"write\") {\n    return \"BEGIN IMMEDIATE\";\n  } else if (mode === \"read\") {\n    return \"BEGIN TRANSACTION READONLY\";\n  } else if (mode === \"deferred\") {\n    return \"BEGIN DEFERRED\";\n  } else {\n    throw RangeError('Unknown transaction mode, supported values are \"write\", \"read\" and \"deferred\"');\n  }\n}\nfunction rowToJson(row) {\n  return Array.prototype.map.call(row, valueToJson);\n}\nfunction valueToJson(value2) {\n  if (typeof value2 === \"bigint\") {\n    return \"\" + value2;\n  } else if (value2 instanceof ArrayBuffer) {\n    return gBase64.fromUint8Array(new Uint8Array(value2));\n  } else {\n    return value2;\n  }\n}\nfunction expandConfig(config3, preferHttp) {\n  if (typeof config3 !== \"object\") {\n    throw new TypeError(`Expected client configuration as object, got ${typeof config3}`);\n  }\n  let { url, authToken, tls, intMode, concurrency } = config3;\n  concurrency = Math.max(0, concurrency || 20);\n  intMode ??= \"number\";\n  let connectionQueryParams = [];\n  if (url === inMemoryMode) {\n    url = \"file::memory:\";\n  }\n  const uri2 = parseUri(url);\n  const originalUriScheme = uri2.scheme.toLowerCase();\n  const isInMemoryMode = originalUriScheme === \"file\" && uri2.path === inMemoryMode && uri2.authority === void 0;\n  let queryParamsDef;\n  if (isInMemoryMode) {\n    queryParamsDef = {\n      cache: {\n        values: [\"shared\", \"private\"],\n        update: /* @__PURE__ */ __name((key, value2) => connectionQueryParams.push(`${key}=${value2}`), \"update\")\n      }\n    };\n  } else {\n    queryParamsDef = {\n      tls: {\n        values: [\"0\", \"1\"],\n        update: /* @__PURE__ */ __name((_3, value2) => tls = value2 === \"1\", \"update\")\n      },\n      authToken: {\n        update: /* @__PURE__ */ __name((_3, value2) => authToken = value2, \"update\")\n      }\n    };\n  }\n  for (const { key, value: value2 } of uri2.query?.pairs ?? []) {\n    if (!Object.hasOwn(queryParamsDef, key)) {\n      throw new LibsqlError(`Unsupported URL query parameter ${JSON.stringify(key)}`, \"URL_PARAM_NOT_SUPPORTED\");\n    }\n    const queryParamDef = queryParamsDef[key];\n    if (queryParamDef.values !== void 0 && !queryParamDef.values.includes(value2)) {\n      throw new LibsqlError(`Unknown value for the \"${key}\" query argument: ${JSON.stringify(value2)}. Supported values are: [${queryParamDef.values.map((x) => '\"' + x + '\"').join(\", \")}]`, \"URL_INVALID\");\n    }\n    if (queryParamDef.update !== void 0) {\n      queryParamDef?.update(key, value2);\n    }\n  }\n  const connectionQueryParamsString = connectionQueryParams.length === 0 ? \"\" : `?${connectionQueryParams.join(\"&\")}`;\n  const path = uri2.path + connectionQueryParamsString;\n  let scheme;\n  if (originalUriScheme === \"libsql\") {\n    if (tls === false) {\n      if (uri2.authority?.port === void 0) {\n        throw new LibsqlError('A \"libsql:\" URL with ?tls=0 must specify an explicit port', \"URL_INVALID\");\n      }\n      scheme = \"http\";\n    } else {\n      scheme = \"https\";\n    }\n  } else {\n    scheme = originalUriScheme;\n  }\n  if (scheme === \"http\" || scheme === \"ws\") {\n    tls ??= false;\n  } else {\n    tls ??= true;\n  }\n  if (scheme !== \"http\" && scheme !== \"ws\" && scheme !== \"https\" && scheme !== \"wss\" && scheme !== \"file\") {\n    throw new LibsqlError(`The client supports only \"libsql:\", \"wss:\", \"ws:\", \"https:\", \"http:\" and \"file:\" URLs, got ${JSON.stringify(uri2.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n  }\n  if (intMode !== \"number\" && intMode !== \"bigint\" && intMode !== \"string\") {\n    throw new TypeError(`Invalid value for intMode, expected \"number\", \"bigint\" or \"string\", got ${JSON.stringify(intMode)}`);\n  }\n  if (uri2.fragment !== void 0) {\n    throw new LibsqlError(`URL fragments are not supported: ${JSON.stringify(\"#\" + uri2.fragment)}`, \"URL_INVALID\");\n  }\n  if (isInMemoryMode) {\n    return {\n      scheme: \"file\",\n      tls: false,\n      path,\n      intMode,\n      concurrency,\n      syncUrl: config3.syncUrl,\n      syncInterval: config3.syncInterval,\n      readYourWrites: config3.readYourWrites,\n      offline: config3.offline,\n      fetch: config3.fetch,\n      authToken: void 0,\n      encryptionKey: void 0,\n      authority: void 0\n    };\n  }\n  return {\n    scheme,\n    tls,\n    authority: uri2.authority,\n    path,\n    authToken,\n    intMode,\n    concurrency,\n    encryptionKey: config3.encryptionKey,\n    syncUrl: config3.syncUrl,\n    syncInterval: config3.syncInterval,\n    readYourWrites: config3.readYourWrites,\n    offline: config3.offline,\n    fetch: config3.fetch\n  };\n}\nfunction string(value2) {\n  if (typeof value2 === \"string\") {\n    return value2;\n  }\n  throw typeError(value2, \"string\");\n}\nfunction stringOpt(value2) {\n  if (value2 === null || value2 === void 0) {\n    return void 0;\n  } else if (typeof value2 === \"string\") {\n    return value2;\n  }\n  throw typeError(value2, \"string or null\");\n}\nfunction number(value2) {\n  if (typeof value2 === \"number\") {\n    return value2;\n  }\n  throw typeError(value2, \"number\");\n}\nfunction boolean(value2) {\n  if (typeof value2 === \"boolean\") {\n    return value2;\n  }\n  throw typeError(value2, \"boolean\");\n}\nfunction array(value2) {\n  if (Array.isArray(value2)) {\n    return value2;\n  }\n  throw typeError(value2, \"array\");\n}\nfunction object(value2) {\n  if (value2 !== null && typeof value2 === \"object\" && !Array.isArray(value2)) {\n    return value2;\n  }\n  throw typeError(value2, \"object\");\n}\nfunction arrayObjectsMap(value2, fun) {\n  return array(value2).map((elemValue) => fun(object(elemValue)));\n}\nfunction typeError(value2, expected) {\n  if (value2 === void 0) {\n    return new ProtoError(`Expected ${expected}, but the property was missing`);\n  }\n  let received = typeof value2;\n  if (value2 === null) {\n    received = \"null\";\n  } else if (Array.isArray(value2)) {\n    received = \"array\";\n  }\n  return new ProtoError(`Expected ${expected}, received ${received}`);\n}\nfunction readJsonObject(value2, fun) {\n  return fun(object(value2));\n}\nfunction writeJsonObject(value2, fun) {\n  const output = [];\n  const writer = new ObjectWriter(output);\n  writer.begin();\n  fun(writer, value2);\n  writer.end();\n  return output.join(\"\");\n}\nfunction readProtobufMessage(data, def) {\n  const msgReader = new MessageReader(data);\n  const fieldReader = new FieldReader(msgReader);\n  let value2 = def.default();\n  while (!msgReader.eof()) {\n    const key = msgReader.varint();\n    const tag = key >> 3;\n    const wireType = key & 7;\n    fieldReader.setup(wireType);\n    const tagFun = def[tag];\n    if (tagFun !== void 0) {\n      const returnedValue = tagFun(fieldReader, value2);\n      if (returnedValue !== void 0) {\n        value2 = returnedValue;\n      }\n    }\n    fieldReader.maybeSkip();\n  }\n  return value2;\n}\nfunction writeProtobufMessage(value2, fun) {\n  const w3 = new MessageWriter();\n  fun(w3, value2);\n  return w3.data();\n}\nfunction impossible(value2, message) {\n  throw new InternalError(message);\n}\nfunction valueToProto(value2) {\n  if (value2 === null) {\n    return null;\n  } else if (typeof value2 === \"string\") {\n    return value2;\n  } else if (typeof value2 === \"number\") {\n    if (!Number.isFinite(value2)) {\n      throw new RangeError(\"Only finite numbers (not Infinity or NaN) can be passed as arguments\");\n    }\n    return value2;\n  } else if (typeof value2 === \"bigint\") {\n    if (value2 < minInteger || value2 > maxInteger) {\n      throw new RangeError(\"This bigint value is too large to be represented as a 64-bit integer and passed as argument\");\n    }\n    return value2;\n  } else if (typeof value2 === \"boolean\") {\n    return value2 ? 1n : 0n;\n  } else if (value2 instanceof ArrayBuffer) {\n    return new Uint8Array(value2);\n  } else if (value2 instanceof Uint8Array) {\n    return value2;\n  } else if (value2 instanceof Date) {\n    return +value2.valueOf();\n  } else if (typeof value2 === \"object\") {\n    return \"\" + value2.toString();\n  } else {\n    throw new TypeError(\"Unsupported type of value\");\n  }\n}\nfunction valueFromProto(value2, intMode) {\n  if (value2 === null) {\n    return null;\n  } else if (typeof value2 === \"number\") {\n    return value2;\n  } else if (typeof value2 === \"string\") {\n    return value2;\n  } else if (typeof value2 === \"bigint\") {\n    if (intMode === \"number\") {\n      const num = Number(value2);\n      if (!Number.isSafeInteger(num)) {\n        throw new RangeError(\"Received integer which is too large to be safely represented as a JavaScript number\");\n      }\n      return num;\n    } else if (intMode === \"bigint\") {\n      return value2;\n    } else if (intMode === \"string\") {\n      return \"\" + value2;\n    } else {\n      throw new MisuseError(\"Invalid value for IntMode\");\n    }\n  } else if (value2 instanceof Uint8Array) {\n    return value2.slice().buffer;\n  } else if (value2 === void 0) {\n    throw new ProtoError(\"Received unrecognized type of Value\");\n  } else {\n    throw impossible(value2, \"Impossible type of Value\");\n  }\n}\nfunction stmtResultFromProto(result) {\n  return {\n    affectedRowCount: result.affectedRowCount,\n    lastInsertRowid: result.lastInsertRowid,\n    columnNames: result.cols.map((col) => col.name),\n    columnDecltypes: result.cols.map((col) => col.decltype)\n  };\n}\nfunction rowsResultFromProto(result, intMode) {\n  const stmtResult = stmtResultFromProto(result);\n  const rows = result.rows.map((row) => rowFromProto(stmtResult.columnNames, row, intMode));\n  return { ...stmtResult, rows };\n}\nfunction rowResultFromProto(result, intMode) {\n  const stmtResult = stmtResultFromProto(result);\n  let row;\n  if (result.rows.length > 0) {\n    row = rowFromProto(stmtResult.columnNames, result.rows[0], intMode);\n  }\n  return { ...stmtResult, row };\n}\nfunction valueResultFromProto(result, intMode) {\n  const stmtResult = stmtResultFromProto(result);\n  let value2;\n  if (result.rows.length > 0 && stmtResult.columnNames.length > 0) {\n    value2 = valueFromProto(result.rows[0][0], intMode);\n  }\n  return { ...stmtResult, value: value2 };\n}\nfunction rowFromProto(colNames, values, intMode) {\n  const row = {};\n  Object.defineProperty(row, \"length\", { value: values.length });\n  for (let i = 0; i < values.length; ++i) {\n    const value2 = valueFromProto(values[i], intMode);\n    Object.defineProperty(row, i, { value: value2 });\n    const colName2 = colNames[i];\n    if (colName2 !== void 0 && !Object.hasOwn(row, colName2)) {\n      Object.defineProperty(row, colName2, { value: value2, enumerable: true, configurable: true, writable: true });\n    }\n  }\n  return row;\n}\nfunction errorFromProto(error4) {\n  return new ResponseError(error4.message, error4);\n}\nfunction sqlToProto(owner, sql2) {\n  if (sql2 instanceof Sql) {\n    return { sqlId: sql2._getSqlId(owner) };\n  } else {\n    return { sql: \"\" + sql2 };\n  }\n}\nfunction stmtToProto(sqlOwner, stmt, wantRows) {\n  let inSql;\n  let args = [];\n  let namedArgs = [];\n  if (stmt instanceof Stmt$2) {\n    inSql = stmt.sql;\n    args = stmt._args;\n    for (const [name, value2] of stmt._namedArgs.entries()) {\n      namedArgs.push({ name, value: value2 });\n    }\n  } else if (Array.isArray(stmt)) {\n    inSql = stmt[0];\n    if (Array.isArray(stmt[1])) {\n      args = stmt[1].map((arg) => valueToProto(arg));\n    } else {\n      namedArgs = Object.entries(stmt[1]).map(([name, value2]) => {\n        return { name, value: valueToProto(value2) };\n      });\n    }\n  } else {\n    inSql = stmt;\n  }\n  const { sql: sql2, sqlId } = sqlToProto(sqlOwner, inSql);\n  return { sql: sql2, sqlId, args, namedArgs, wantRows };\n}\nfunction executeRegular(stream, steps, batch) {\n  return stream._batch(batch).then((result) => {\n    for (let step = 0; step < steps.length; ++step) {\n      const stepResult = result.stepResults.get(step);\n      const stepError = result.stepErrors.get(step);\n      steps[step].callback(stepResult, stepError);\n    }\n  });\n}\nasync function executeCursor(stream, steps, batch) {\n  const cursor = await stream._openCursor(batch);\n  try {\n    let nextStep = 0;\n    let beginEntry = void 0;\n    let rows = [];\n    for (; ; ) {\n      const entry = await cursor.next();\n      if (entry === void 0) {\n        break;\n      }\n      if (entry.type === \"step_begin\") {\n        if (entry.step < nextStep || entry.step >= steps.length) {\n          throw new ProtoError(\"Server produced StepBeginEntry for unexpected step\");\n        } else if (beginEntry !== void 0) {\n          throw new ProtoError(\"Server produced StepBeginEntry before terminating previous step\");\n        }\n        for (let step = nextStep; step < entry.step; ++step) {\n          steps[step].callback(void 0, void 0);\n        }\n        nextStep = entry.step + 1;\n        beginEntry = entry;\n        rows = [];\n      } else if (entry.type === \"step_end\") {\n        if (beginEntry === void 0) {\n          throw new ProtoError(\"Server produced StepEndEntry but no step is active\");\n        }\n        const stmtResult = {\n          cols: beginEntry.cols,\n          rows,\n          affectedRowCount: entry.affectedRowCount,\n          lastInsertRowid: entry.lastInsertRowid\n        };\n        steps[beginEntry.step].callback(stmtResult, void 0);\n        beginEntry = void 0;\n        rows = [];\n      } else if (entry.type === \"step_error\") {\n        if (beginEntry === void 0) {\n          if (entry.step >= steps.length) {\n            throw new ProtoError(\"Server produced StepErrorEntry for unexpected step\");\n          }\n          for (let step = nextStep; step < entry.step; ++step) {\n            steps[step].callback(void 0, void 0);\n          }\n        } else {\n          if (entry.step !== beginEntry.step) {\n            throw new ProtoError(\"Server produced StepErrorEntry for unexpected step\");\n          }\n          beginEntry = void 0;\n          rows = [];\n        }\n        steps[entry.step].callback(void 0, entry.error);\n        nextStep = entry.step + 1;\n      } else if (entry.type === \"row\") {\n        if (beginEntry === void 0) {\n          throw new ProtoError(\"Server produced RowEntry but no step is active\");\n        }\n        rows.push(entry.row);\n      } else if (entry.type === \"error\") {\n        throw errorFromProto(entry.error);\n      } else if (entry.type === \"none\") {\n        throw new ProtoError(\"Server produced unrecognized CursorEntry\");\n      } else {\n        throw impossible(entry, \"Impossible CursorEntry\");\n      }\n    }\n    if (beginEntry !== void 0) {\n      throw new ProtoError(\"Server closed Cursor before terminating active step\");\n    }\n    for (let step = nextStep; step < steps.length; ++step) {\n      steps[step].callback(void 0, void 0);\n    }\n  } finally {\n    cursor.close();\n  }\n}\nfunction stepIndex(step) {\n  if (step._index === void 0) {\n    throw new MisuseError(\"Cannot add a condition referencing a step that has not been added to the batch\");\n  }\n  return step._index;\n}\nfunction checkCondBatch(expectedBatch, cond) {\n  if (cond._batch !== expectedBatch) {\n    throw new MisuseError(\"Cannot mix BatchCond objects for different Batch objects\");\n  }\n}\nfunction describeResultFromProto(result) {\n  return {\n    paramNames: result.params.map((p2) => p2.name),\n    columns: result.cols,\n    isExplain: result.isExplain,\n    isReadonly: result.isReadonly\n  };\n}\nfunction Stmt$1(w3, msg) {\n  if (msg.sql !== void 0) {\n    w3.string(\"sql\", msg.sql);\n  }\n  if (msg.sqlId !== void 0) {\n    w3.number(\"sql_id\", msg.sqlId);\n  }\n  w3.arrayObjects(\"args\", msg.args, Value$3);\n  w3.arrayObjects(\"named_args\", msg.namedArgs, NamedArg$1);\n  w3.boolean(\"want_rows\", msg.wantRows);\n}\nfunction NamedArg$1(w3, msg) {\n  w3.string(\"name\", msg.name);\n  w3.object(\"value\", msg.value, Value$3);\n}\nfunction Batch$1(w3, msg) {\n  w3.arrayObjects(\"steps\", msg.steps, BatchStep$1);\n}\nfunction BatchStep$1(w3, msg) {\n  if (msg.condition !== void 0) {\n    w3.object(\"condition\", msg.condition, BatchCond$1);\n  }\n  w3.object(\"stmt\", msg.stmt, Stmt$1);\n}\nfunction BatchCond$1(w3, msg) {\n  w3.stringRaw(\"type\", msg.type);\n  if (msg.type === \"ok\" || msg.type === \"error\") {\n    w3.number(\"step\", msg.step);\n  } else if (msg.type === \"not\") {\n    w3.object(\"cond\", msg.cond, BatchCond$1);\n  } else if (msg.type === \"and\" || msg.type === \"or\") {\n    w3.arrayObjects(\"conds\", msg.conds, BatchCond$1);\n  } else if (msg.type === \"is_autocommit\") ;\n  else {\n    throw impossible(msg, \"Impossible type of BatchCond\");\n  }\n}\nfunction Value$3(w3, msg) {\n  if (msg === null) {\n    w3.stringRaw(\"type\", \"null\");\n  } else if (typeof msg === \"bigint\") {\n    w3.stringRaw(\"type\", \"integer\");\n    w3.stringRaw(\"value\", \"\" + msg);\n  } else if (typeof msg === \"number\") {\n    w3.stringRaw(\"type\", \"float\");\n    w3.number(\"value\", msg);\n  } else if (typeof msg === \"string\") {\n    w3.stringRaw(\"type\", \"text\");\n    w3.string(\"value\", msg);\n  } else if (msg instanceof Uint8Array) {\n    w3.stringRaw(\"type\", \"blob\");\n    w3.stringRaw(\"base64\", gBase64.fromUint8Array(msg));\n  } else if (msg === void 0) ;\n  else {\n    throw impossible(msg, \"Impossible type of Value\");\n  }\n}\nfunction ClientMsg$1(w3, msg) {\n  w3.stringRaw(\"type\", msg.type);\n  if (msg.type === \"hello\") {\n    if (msg.jwt !== void 0) {\n      w3.string(\"jwt\", msg.jwt);\n    }\n  } else if (msg.type === \"request\") {\n    w3.number(\"request_id\", msg.requestId);\n    w3.object(\"request\", msg.request, Request$2);\n  } else {\n    throw impossible(msg, \"Impossible type of ClientMsg\");\n  }\n}\nfunction Request$2(w3, msg) {\n  w3.stringRaw(\"type\", msg.type);\n  if (msg.type === \"open_stream\") {\n    w3.number(\"stream_id\", msg.streamId);\n  } else if (msg.type === \"close_stream\") {\n    w3.number(\"stream_id\", msg.streamId);\n  } else if (msg.type === \"execute\") {\n    w3.number(\"stream_id\", msg.streamId);\n    w3.object(\"stmt\", msg.stmt, Stmt$1);\n  } else if (msg.type === \"batch\") {\n    w3.number(\"stream_id\", msg.streamId);\n    w3.object(\"batch\", msg.batch, Batch$1);\n  } else if (msg.type === \"open_cursor\") {\n    w3.number(\"stream_id\", msg.streamId);\n    w3.number(\"cursor_id\", msg.cursorId);\n    w3.object(\"batch\", msg.batch, Batch$1);\n  } else if (msg.type === \"close_cursor\") {\n    w3.number(\"cursor_id\", msg.cursorId);\n  } else if (msg.type === \"fetch_cursor\") {\n    w3.number(\"cursor_id\", msg.cursorId);\n    w3.number(\"max_count\", msg.maxCount);\n  } else if (msg.type === \"sequence\") {\n    w3.number(\"stream_id\", msg.streamId);\n    if (msg.sql !== void 0) {\n      w3.string(\"sql\", msg.sql);\n    }\n    if (msg.sqlId !== void 0) {\n      w3.number(\"sql_id\", msg.sqlId);\n    }\n  } else if (msg.type === \"describe\") {\n    w3.number(\"stream_id\", msg.streamId);\n    if (msg.sql !== void 0) {\n      w3.string(\"sql\", msg.sql);\n    }\n    if (msg.sqlId !== void 0) {\n      w3.number(\"sql_id\", msg.sqlId);\n    }\n  } else if (msg.type === \"store_sql\") {\n    w3.number(\"sql_id\", msg.sqlId);\n    w3.string(\"sql\", msg.sql);\n  } else if (msg.type === \"close_sql\") {\n    w3.number(\"sql_id\", msg.sqlId);\n  } else if (msg.type === \"get_autocommit\") {\n    w3.number(\"stream_id\", msg.streamId);\n  } else {\n    throw impossible(msg, \"Impossible type of Request\");\n  }\n}\nfunction Stmt2(w3, msg) {\n  if (msg.sql !== void 0) {\n    w3.string(1, msg.sql);\n  }\n  if (msg.sqlId !== void 0) {\n    w3.int32(2, msg.sqlId);\n  }\n  for (const arg of msg.args) {\n    w3.message(3, arg, Value$2);\n  }\n  for (const arg of msg.namedArgs) {\n    w3.message(4, arg, NamedArg);\n  }\n  w3.bool(5, msg.wantRows);\n}\nfunction NamedArg(w3, msg) {\n  w3.string(1, msg.name);\n  w3.message(2, msg.value, Value$2);\n}\nfunction Batch2(w3, msg) {\n  for (const step of msg.steps) {\n    w3.message(1, step, BatchStep2);\n  }\n}\nfunction BatchStep2(w3, msg) {\n  if (msg.condition !== void 0) {\n    w3.message(1, msg.condition, BatchCond2);\n  }\n  w3.message(2, msg.stmt, Stmt2);\n}\nfunction BatchCond2(w3, msg) {\n  if (msg.type === \"ok\") {\n    w3.uint32(1, msg.step);\n  } else if (msg.type === \"error\") {\n    w3.uint32(2, msg.step);\n  } else if (msg.type === \"not\") {\n    w3.message(3, msg.cond, BatchCond2);\n  } else if (msg.type === \"and\") {\n    w3.message(4, msg.conds, BatchCondList);\n  } else if (msg.type === \"or\") {\n    w3.message(5, msg.conds, BatchCondList);\n  } else if (msg.type === \"is_autocommit\") {\n    w3.message(6, void 0, Empty);\n  } else {\n    throw impossible(msg, \"Impossible type of BatchCond\");\n  }\n}\nfunction BatchCondList(w3, msg) {\n  for (const cond of msg) {\n    w3.message(1, cond, BatchCond2);\n  }\n}\nfunction Value$2(w3, msg) {\n  if (msg === null) {\n    w3.message(1, void 0, Empty);\n  } else if (typeof msg === \"bigint\") {\n    w3.sint64(2, msg);\n  } else if (typeof msg === \"number\") {\n    w3.double(3, msg);\n  } else if (typeof msg === \"string\") {\n    w3.string(4, msg);\n  } else if (msg instanceof Uint8Array) {\n    w3.bytes(5, msg);\n  } else if (msg === void 0) ;\n  else {\n    throw impossible(msg, \"Impossible type of Value\");\n  }\n}\nfunction Empty(_w, _msg) {\n}\nfunction ClientMsg(w3, msg) {\n  if (msg.type === \"hello\") {\n    w3.message(1, msg, HelloMsg);\n  } else if (msg.type === \"request\") {\n    w3.message(2, msg, RequestMsg);\n  } else {\n    throw impossible(msg, \"Impossible type of ClientMsg\");\n  }\n}\nfunction HelloMsg(w3, msg) {\n  if (msg.jwt !== void 0) {\n    w3.string(1, msg.jwt);\n  }\n}\nfunction RequestMsg(w3, msg) {\n  w3.int32(1, msg.requestId);\n  const request = msg.request;\n  if (request.type === \"open_stream\") {\n    w3.message(2, request, OpenStreamReq);\n  } else if (request.type === \"close_stream\") {\n    w3.message(3, request, CloseStreamReq$1);\n  } else if (request.type === \"execute\") {\n    w3.message(4, request, ExecuteReq);\n  } else if (request.type === \"batch\") {\n    w3.message(5, request, BatchReq);\n  } else if (request.type === \"open_cursor\") {\n    w3.message(6, request, OpenCursorReq);\n  } else if (request.type === \"close_cursor\") {\n    w3.message(7, request, CloseCursorReq);\n  } else if (request.type === \"fetch_cursor\") {\n    w3.message(8, request, FetchCursorReq);\n  } else if (request.type === \"sequence\") {\n    w3.message(9, request, SequenceReq);\n  } else if (request.type === \"describe\") {\n    w3.message(10, request, DescribeReq);\n  } else if (request.type === \"store_sql\") {\n    w3.message(11, request, StoreSqlReq);\n  } else if (request.type === \"close_sql\") {\n    w3.message(12, request, CloseSqlReq);\n  } else if (request.type === \"get_autocommit\") {\n    w3.message(13, request, GetAutocommitReq);\n  } else {\n    throw impossible(request, \"Impossible type of Request\");\n  }\n}\nfunction OpenStreamReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n}\nfunction CloseStreamReq$1(w3, msg) {\n  w3.int32(1, msg.streamId);\n}\nfunction ExecuteReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n  w3.message(2, msg.stmt, Stmt2);\n}\nfunction BatchReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n  w3.message(2, msg.batch, Batch2);\n}\nfunction OpenCursorReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n  w3.int32(2, msg.cursorId);\n  w3.message(3, msg.batch, Batch2);\n}\nfunction CloseCursorReq(w3, msg) {\n  w3.int32(1, msg.cursorId);\n}\nfunction FetchCursorReq(w3, msg) {\n  w3.int32(1, msg.cursorId);\n  w3.uint32(2, msg.maxCount);\n}\nfunction SequenceReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n  if (msg.sql !== void 0) {\n    w3.string(2, msg.sql);\n  }\n  if (msg.sqlId !== void 0) {\n    w3.int32(3, msg.sqlId);\n  }\n}\nfunction DescribeReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n  if (msg.sql !== void 0) {\n    w3.string(2, msg.sql);\n  }\n  if (msg.sqlId !== void 0) {\n    w3.int32(3, msg.sqlId);\n  }\n}\nfunction StoreSqlReq(w3, msg) {\n  w3.int32(1, msg.sqlId);\n  w3.string(2, msg.sql);\n}\nfunction CloseSqlReq(w3, msg) {\n  w3.int32(1, msg.sqlId);\n}\nfunction GetAutocommitReq(w3, msg) {\n  w3.int32(1, msg.streamId);\n}\nfunction Error$2(obj) {\n  const message = string(obj[\"message\"]);\n  const code = stringOpt(obj[\"code\"]);\n  return { message, code };\n}\nfunction StmtResult$1(obj) {\n  const cols = arrayObjectsMap(obj[\"cols\"], Col$1);\n  const rows = array(obj[\"rows\"]).map((rowObj) => arrayObjectsMap(rowObj, Value$1));\n  const affectedRowCount = number(obj[\"affected_row_count\"]);\n  const lastInsertRowidStr = stringOpt(obj[\"last_insert_rowid\"]);\n  const lastInsertRowid = lastInsertRowidStr !== void 0 ? BigInt(lastInsertRowidStr) : void 0;\n  return { cols, rows, affectedRowCount, lastInsertRowid };\n}\nfunction Col$1(obj) {\n  const name = stringOpt(obj[\"name\"]);\n  const decltype = stringOpt(obj[\"decltype\"]);\n  return { name, decltype };\n}\nfunction BatchResult$1(obj) {\n  const stepResults = /* @__PURE__ */ new Map();\n  array(obj[\"step_results\"]).forEach((value2, i) => {\n    if (value2 !== null) {\n      stepResults.set(i, StmtResult$1(object(value2)));\n    }\n  });\n  const stepErrors = /* @__PURE__ */ new Map();\n  array(obj[\"step_errors\"]).forEach((value2, i) => {\n    if (value2 !== null) {\n      stepErrors.set(i, Error$2(object(value2)));\n    }\n  });\n  return { stepResults, stepErrors };\n}\nfunction CursorEntry$1(obj) {\n  const type2 = string(obj[\"type\"]);\n  if (type2 === \"step_begin\") {\n    const step = number(obj[\"step\"]);\n    const cols = arrayObjectsMap(obj[\"cols\"], Col$1);\n    return { type: \"step_begin\", step, cols };\n  } else if (type2 === \"step_end\") {\n    const affectedRowCount = number(obj[\"affected_row_count\"]);\n    const lastInsertRowidStr = stringOpt(obj[\"last_insert_rowid\"]);\n    const lastInsertRowid = lastInsertRowidStr !== void 0 ? BigInt(lastInsertRowidStr) : void 0;\n    return { type: \"step_end\", affectedRowCount, lastInsertRowid };\n  } else if (type2 === \"step_error\") {\n    const step = number(obj[\"step\"]);\n    const error4 = Error$2(object(obj[\"error\"]));\n    return { type: \"step_error\", step, error: error4 };\n  } else if (type2 === \"row\") {\n    const row = arrayObjectsMap(obj[\"row\"], Value$1);\n    return { type: \"row\", row };\n  } else if (type2 === \"error\") {\n    const error4 = Error$2(object(obj[\"error\"]));\n    return { type: \"error\", error: error4 };\n  } else {\n    throw new ProtoError(\"Unexpected type of CursorEntry\");\n  }\n}\nfunction DescribeResult$1(obj) {\n  const params = arrayObjectsMap(obj[\"params\"], DescribeParam$1);\n  const cols = arrayObjectsMap(obj[\"cols\"], DescribeCol$1);\n  const isExplain = boolean(obj[\"is_explain\"]);\n  const isReadonly = boolean(obj[\"is_readonly\"]);\n  return { params, cols, isExplain, isReadonly };\n}\nfunction DescribeParam$1(obj) {\n  const name = stringOpt(obj[\"name\"]);\n  return { name };\n}\nfunction DescribeCol$1(obj) {\n  const name = string(obj[\"name\"]);\n  const decltype = stringOpt(obj[\"decltype\"]);\n  return { name, decltype };\n}\nfunction Value$1(obj) {\n  const type2 = string(obj[\"type\"]);\n  if (type2 === \"null\") {\n    return null;\n  } else if (type2 === \"integer\") {\n    const value2 = string(obj[\"value\"]);\n    return BigInt(value2);\n  } else if (type2 === \"float\") {\n    return number(obj[\"value\"]);\n  } else if (type2 === \"text\") {\n    return string(obj[\"value\"]);\n  } else if (type2 === \"blob\") {\n    return gBase64.toUint8Array(string(obj[\"base64\"]));\n  } else {\n    throw new ProtoError(\"Unexpected type of Value\");\n  }\n}\nfunction ServerMsg$1(obj) {\n  const type2 = string(obj[\"type\"]);\n  if (type2 === \"hello_ok\") {\n    return { type: \"hello_ok\" };\n  } else if (type2 === \"hello_error\") {\n    const error4 = Error$2(object(obj[\"error\"]));\n    return { type: \"hello_error\", error: error4 };\n  } else if (type2 === \"response_ok\") {\n    const requestId = number(obj[\"request_id\"]);\n    const response = Response$1(object(obj[\"response\"]));\n    return { type: \"response_ok\", requestId, response };\n  } else if (type2 === \"response_error\") {\n    const requestId = number(obj[\"request_id\"]);\n    const error4 = Error$2(object(obj[\"error\"]));\n    return { type: \"response_error\", requestId, error: error4 };\n  } else {\n    throw new ProtoError(\"Unexpected type of ServerMsg\");\n  }\n}\nfunction Response$1(obj) {\n  const type2 = string(obj[\"type\"]);\n  if (type2 === \"open_stream\") {\n    return { type: \"open_stream\" };\n  } else if (type2 === \"close_stream\") {\n    return { type: \"close_stream\" };\n  } else if (type2 === \"execute\") {\n    const result = StmtResult$1(object(obj[\"result\"]));\n    return { type: \"execute\", result };\n  } else if (type2 === \"batch\") {\n    const result = BatchResult$1(object(obj[\"result\"]));\n    return { type: \"batch\", result };\n  } else if (type2 === \"open_cursor\") {\n    return { type: \"open_cursor\" };\n  } else if (type2 === \"close_cursor\") {\n    return { type: \"close_cursor\" };\n  } else if (type2 === \"fetch_cursor\") {\n    const entries = arrayObjectsMap(obj[\"entries\"], CursorEntry$1);\n    const done = boolean(obj[\"done\"]);\n    return { type: \"fetch_cursor\", entries, done };\n  } else if (type2 === \"sequence\") {\n    return { type: \"sequence\" };\n  } else if (type2 === \"describe\") {\n    const result = DescribeResult$1(object(obj[\"result\"]));\n    return { type: \"describe\", result };\n  } else if (type2 === \"store_sql\") {\n    return { type: \"store_sql\" };\n  } else if (type2 === \"close_sql\") {\n    return { type: \"close_sql\" };\n  } else if (type2 === \"get_autocommit\") {\n    const isAutocommit = boolean(obj[\"is_autocommit\"]);\n    return { type: \"get_autocommit\", isAutocommit };\n  } else {\n    throw new ProtoError(\"Unexpected type of Response\");\n  }\n}\nfunction PipelineRespBody$1(obj) {\n  const baton = stringOpt(obj[\"baton\"]);\n  const baseUrl = stringOpt(obj[\"base_url\"]);\n  const results = arrayObjectsMap(obj[\"results\"], StreamResult$1);\n  return { baton, baseUrl, results };\n}\nfunction StreamResult$1(obj) {\n  const type2 = string(obj[\"type\"]);\n  if (type2 === \"ok\") {\n    const response = StreamResponse$1(object(obj[\"response\"]));\n    return { type: \"ok\", response };\n  } else if (type2 === \"error\") {\n    const error4 = Error$2(object(obj[\"error\"]));\n    return { type: \"error\", error: error4 };\n  } else {\n    throw new ProtoError(\"Unexpected type of StreamResult\");\n  }\n}\nfunction StreamResponse$1(obj) {\n  const type2 = string(obj[\"type\"]);\n  if (type2 === \"close\") {\n    return { type: \"close\" };\n  } else if (type2 === \"execute\") {\n    const result = StmtResult$1(object(obj[\"result\"]));\n    return { type: \"execute\", result };\n  } else if (type2 === \"batch\") {\n    const result = BatchResult$1(object(obj[\"result\"]));\n    return { type: \"batch\", result };\n  } else if (type2 === \"sequence\") {\n    return { type: \"sequence\" };\n  } else if (type2 === \"describe\") {\n    const result = DescribeResult$1(object(obj[\"result\"]));\n    return { type: \"describe\", result };\n  } else if (type2 === \"store_sql\") {\n    return { type: \"store_sql\" };\n  } else if (type2 === \"close_sql\") {\n    return { type: \"close_sql\" };\n  } else if (type2 === \"get_autocommit\") {\n    const isAutocommit = boolean(obj[\"is_autocommit\"]);\n    return { type: \"get_autocommit\", isAutocommit };\n  } else {\n    throw new ProtoError(\"Unexpected type of StreamResponse\");\n  }\n}\nfunction CursorRespBody$1(obj) {\n  const baton = stringOpt(obj[\"baton\"]);\n  const baseUrl = stringOpt(obj[\"base_url\"]);\n  return { baton, baseUrl };\n}\nfunction PipelineReqBody$1(w3, msg) {\n  if (msg.baton !== void 0) {\n    w3.string(\"baton\", msg.baton);\n  }\n  w3.arrayObjects(\"requests\", msg.requests, StreamRequest$1);\n}\nfunction StreamRequest$1(w3, msg) {\n  w3.stringRaw(\"type\", msg.type);\n  if (msg.type === \"close\") ;\n  else if (msg.type === \"execute\") {\n    w3.object(\"stmt\", msg.stmt, Stmt$1);\n  } else if (msg.type === \"batch\") {\n    w3.object(\"batch\", msg.batch, Batch$1);\n  } else if (msg.type === \"sequence\") {\n    if (msg.sql !== void 0) {\n      w3.string(\"sql\", msg.sql);\n    }\n    if (msg.sqlId !== void 0) {\n      w3.number(\"sql_id\", msg.sqlId);\n    }\n  } else if (msg.type === \"describe\") {\n    if (msg.sql !== void 0) {\n      w3.string(\"sql\", msg.sql);\n    }\n    if (msg.sqlId !== void 0) {\n      w3.number(\"sql_id\", msg.sqlId);\n    }\n  } else if (msg.type === \"store_sql\") {\n    w3.number(\"sql_id\", msg.sqlId);\n    w3.string(\"sql\", msg.sql);\n  } else if (msg.type === \"close_sql\") {\n    w3.number(\"sql_id\", msg.sqlId);\n  } else if (msg.type === \"get_autocommit\") ;\n  else {\n    throw impossible(msg, \"Impossible type of StreamRequest\");\n  }\n}\nfunction CursorReqBody$1(w3, msg) {\n  if (msg.baton !== void 0) {\n    w3.string(\"baton\", msg.baton);\n  }\n  w3.object(\"batch\", msg.batch, Batch$1);\n}\nfunction PipelineReqBody(w3, msg) {\n  if (msg.baton !== void 0) {\n    w3.string(1, msg.baton);\n  }\n  for (const req of msg.requests) {\n    w3.message(2, req, StreamRequest);\n  }\n}\nfunction StreamRequest(w3, msg) {\n  if (msg.type === \"close\") {\n    w3.message(1, msg, CloseStreamReq);\n  } else if (msg.type === \"execute\") {\n    w3.message(2, msg, ExecuteStreamReq);\n  } else if (msg.type === \"batch\") {\n    w3.message(3, msg, BatchStreamReq);\n  } else if (msg.type === \"sequence\") {\n    w3.message(4, msg, SequenceStreamReq);\n  } else if (msg.type === \"describe\") {\n    w3.message(5, msg, DescribeStreamReq);\n  } else if (msg.type === \"store_sql\") {\n    w3.message(6, msg, StoreSqlStreamReq);\n  } else if (msg.type === \"close_sql\") {\n    w3.message(7, msg, CloseSqlStreamReq);\n  } else if (msg.type === \"get_autocommit\") {\n    w3.message(8, msg, GetAutocommitStreamReq);\n  } else {\n    throw impossible(msg, \"Impossible type of StreamRequest\");\n  }\n}\nfunction CloseStreamReq(_w, _msg) {\n}\nfunction ExecuteStreamReq(w3, msg) {\n  w3.message(1, msg.stmt, Stmt2);\n}\nfunction BatchStreamReq(w3, msg) {\n  w3.message(1, msg.batch, Batch2);\n}\nfunction SequenceStreamReq(w3, msg) {\n  if (msg.sql !== void 0) {\n    w3.string(1, msg.sql);\n  }\n  if (msg.sqlId !== void 0) {\n    w3.int32(2, msg.sqlId);\n  }\n}\nfunction DescribeStreamReq(w3, msg) {\n  if (msg.sql !== void 0) {\n    w3.string(1, msg.sql);\n  }\n  if (msg.sqlId !== void 0) {\n    w3.int32(2, msg.sqlId);\n  }\n}\nfunction StoreSqlStreamReq(w3, msg) {\n  w3.int32(1, msg.sqlId);\n  w3.string(2, msg.sql);\n}\nfunction CloseSqlStreamReq(w3, msg) {\n  w3.int32(1, msg.sqlId);\n}\nfunction GetAutocommitStreamReq(_w, _msg) {\n}\nfunction CursorReqBody(w3, msg) {\n  if (msg.baton !== void 0) {\n    w3.string(1, msg.baton);\n  }\n  w3.message(2, msg.batch, Batch2);\n}\nfunction handlePipelineResponse(pipeline, respBody) {\n  if (respBody.results.length !== pipeline.length) {\n    throw new ProtoError(\"Server returned unexpected number of pipeline results\");\n  }\n  for (let i = 0; i < pipeline.length; ++i) {\n    const result = respBody.results[i];\n    const entry = pipeline[i];\n    if (result.type === \"ok\") {\n      if (result.response.type !== entry.request.type) {\n        throw new ProtoError(\"Received unexpected type of response\");\n      }\n      entry.responseCallback(result.response);\n    } else if (result.type === \"error\") {\n      entry.errorCallback(errorFromProto(result.error));\n    } else if (result.type === \"none\") {\n      throw new ProtoError(\"Received unrecognized type of StreamResult\");\n    } else {\n      throw impossible(result, \"Received impossible type of StreamResult\");\n    }\n  }\n}\nasync function decodePipelineResponse(resp, encoding) {\n  if (encoding === \"json\") {\n    const respJson = await resp.json();\n    return readJsonObject(respJson, PipelineRespBody$1);\n  }\n  if (encoding === \"protobuf\") {\n    const respData = await resp.arrayBuffer();\n    return readProtobufMessage(new Uint8Array(respData), PipelineRespBody);\n  }\n  await resp.body?.cancel();\n  throw impossible(encoding, \"Impossible encoding\");\n}\nasync function errorFromResponse(resp) {\n  const respType = resp.headers.get(\"content-type\") ?? \"text/plain\";\n  let message = `Server returned HTTP status ${resp.status}`;\n  if (respType === \"application/json\") {\n    const respBody = await resp.json();\n    if (\"message\" in respBody) {\n      return errorFromProto(respBody);\n    }\n    return new HttpServerError(message, resp.status);\n  }\n  if (respType === \"text/plain\") {\n    const respBody = (await resp.text()).trim();\n    if (respBody !== \"\") {\n      message += `: ${respBody}`;\n    }\n    return new HttpServerError(message, resp.status);\n  }\n  await resp.body?.cancel();\n  return new HttpServerError(message, resp.status);\n}\nasync function findEndpoint(customFetch2, clientUrl) {\n  const fetch2 = customFetch2;\n  for (const endpoint of checkEndpoints) {\n    const url = new URL(endpoint.versionPath, clientUrl);\n    const request = new _Request(url.toString(), { method: \"GET\" });\n    const response = await fetch2(request);\n    await response.arrayBuffer();\n    if (response.ok) {\n      return endpoint;\n    }\n  }\n  return fallbackEndpoint;\n}\nfunction openWs(url, jwt2, protocolVersion = 2) {\n  if (typeof _WebSocket === \"undefined\") {\n    throw new WebSocketUnsupportedError(\"WebSockets are not supported in this environment\");\n  }\n  var subprotocols = void 0;\n  if (protocolVersion == 3) {\n    subprotocols = Array.from(subprotocolsV3.keys());\n  } else {\n    subprotocols = Array.from(subprotocolsV2.keys());\n  }\n  const socket = new _WebSocket(url, subprotocols);\n  return new WsClient$1(socket, jwt2);\n}\nfunction openHttp(url, jwt2, customFetch2, protocolVersion = 2) {\n  return new HttpClient$1(url instanceof URL ? url : new URL(url), jwt2, customFetch2, protocolVersion);\n}\nasync function executeHranaBatch(mode, version3, batch, hranaStmts, disableForeignKeys = false) {\n  if (disableForeignKeys) {\n    batch.step().run(\"PRAGMA foreign_keys=off\");\n  }\n  const beginStep = batch.step();\n  const beginPromise = beginStep.run(transactionModeToBegin(mode));\n  let lastStep = beginStep;\n  const stmtPromises = hranaStmts.map((hranaStmt) => {\n    const stmtStep = batch.step().condition(BatchCond$2.ok(lastStep));\n    if (version3 >= 3) {\n      stmtStep.condition(BatchCond$2.not(BatchCond$2.isAutocommit(batch)));\n    }\n    const stmtPromise = stmtStep.query(hranaStmt);\n    lastStep = stmtStep;\n    return stmtPromise;\n  });\n  const commitStep = batch.step().condition(BatchCond$2.ok(lastStep));\n  if (version3 >= 3) {\n    commitStep.condition(BatchCond$2.not(BatchCond$2.isAutocommit(batch)));\n  }\n  const commitPromise = commitStep.run(\"COMMIT\");\n  const rollbackStep = batch.step().condition(BatchCond$2.not(BatchCond$2.ok(commitStep)));\n  rollbackStep.run(\"ROLLBACK\").catch((_3) => void 0);\n  if (disableForeignKeys) {\n    batch.step().run(\"PRAGMA foreign_keys=on\");\n  }\n  await batch.execute();\n  const resultSets = [];\n  await beginPromise;\n  for (const stmtPromise of stmtPromises) {\n    const hranaRows = await stmtPromise;\n    if (hranaRows === void 0) {\n      throw new LibsqlError(\"Statement in a batch was not executed, probably because the transaction has been rolled back\", \"TRANSACTION_CLOSED\");\n    }\n    resultSets.push(resultSetFromHrana(hranaRows));\n  }\n  await commitPromise;\n  return resultSets;\n}\nfunction stmtToHrana(stmt) {\n  let sql2;\n  let args;\n  if (Array.isArray(stmt)) {\n    [sql2, args] = stmt;\n  } else if (typeof stmt === \"string\") {\n    sql2 = stmt;\n  } else {\n    sql2 = stmt.sql;\n    args = stmt.args;\n  }\n  const hranaStmt = new Stmt$2(sql2);\n  if (args) {\n    if (Array.isArray(args)) {\n      hranaStmt.bindIndexes(args);\n    } else {\n      for (const [key, value2] of Object.entries(args)) {\n        hranaStmt.bindName(key, value2);\n      }\n    }\n  }\n  return hranaStmt;\n}\nfunction resultSetFromHrana(hranaRows) {\n  const columns = hranaRows.columnNames.map((c) => c ?? \"\");\n  const columnTypes = hranaRows.columnDecltypes.map((c) => c ?? \"\");\n  const rows = hranaRows.rows;\n  const rowsAffected = hranaRows.affectedRowCount;\n  const lastInsertRowid = hranaRows.lastInsertRowid !== void 0 ? hranaRows.lastInsertRowid : void 0;\n  return new ResultSetImpl(columns, columnTypes, rows, rowsAffected, lastInsertRowid);\n}\nfunction mapHranaError(e) {\n  if (e instanceof ClientError) {\n    const code = mapHranaErrorCode(e);\n    return new LibsqlError(e.message, code, void 0, e);\n  }\n  return e;\n}\nfunction mapHranaErrorCode(e) {\n  if (e instanceof ResponseError && e.code !== void 0) {\n    return e.code;\n  } else if (e instanceof ProtoError) {\n    return \"HRANA_PROTO_ERROR\";\n  } else if (e instanceof ClosedError) {\n    return e.cause instanceof ClientError ? mapHranaErrorCode(e.cause) : \"HRANA_CLOSED_ERROR\";\n  } else if (e instanceof WebSocketError) {\n    return \"HRANA_WEBSOCKET_ERROR\";\n  } else if (e instanceof HttpServerError) {\n    return \"SERVER_ERROR\";\n  } else if (e instanceof ProtocolVersionError) {\n    return \"PROTOCOL_VERSION_ERROR\";\n  } else if (e instanceof InternalError) {\n    return \"INTERNAL_ERROR\";\n  } else {\n    return \"UNKNOWN\";\n  }\n}\nfunction requirePromiseLimit() {\n  if (hasRequiredPromiseLimit) return promiseLimit$1;\n  hasRequiredPromiseLimit = 1;\n  function limiter(count3) {\n    var outstanding = 0;\n    var jobs = [];\n    function remove() {\n      outstanding--;\n      if (outstanding < count3) {\n        dequeue();\n      }\n    }\n    __name(remove, \"remove\");\n    function dequeue() {\n      var job = jobs.shift();\n      semaphore.queue = jobs.length;\n      if (job) {\n        run(job.fn).then(job.resolve).catch(job.reject);\n      }\n    }\n    __name(dequeue, \"dequeue\");\n    function queue(fn2) {\n      return new Promise(function(resolve, reject) {\n        jobs.push({ fn: fn2, resolve, reject });\n        semaphore.queue = jobs.length;\n      });\n    }\n    __name(queue, \"queue\");\n    function run(fn2) {\n      outstanding++;\n      try {\n        return Promise.resolve(fn2()).then(function(result) {\n          remove();\n          return result;\n        }, function(error4) {\n          remove();\n          throw error4;\n        });\n      } catch (err) {\n        remove();\n        return Promise.reject(err);\n      }\n    }\n    __name(run, \"run\");\n    var semaphore = /* @__PURE__ */ __name(function(fn2) {\n      if (outstanding >= count3) {\n        return queue(fn2);\n      } else {\n        return run(fn2);\n      }\n    }, \"semaphore\");\n    return semaphore;\n  }\n  __name(limiter, \"limiter\");\n  function map2(items, mapper) {\n    var failed = false;\n    var limit = this;\n    return Promise.all(items.map(function() {\n      var args = arguments;\n      return limit(function() {\n        if (!failed) {\n          return mapper.apply(void 0, args).catch(function(e) {\n            failed = true;\n            throw e;\n          });\n        }\n      });\n    }));\n  }\n  __name(map2, \"map\");\n  function addExtras(fn2) {\n    fn2.queue = 0;\n    fn2.map = map2;\n    return fn2;\n  }\n  __name(addExtras, \"addExtras\");\n  promiseLimit$1 = /* @__PURE__ */ __name(function(count3) {\n    if (count3) {\n      return addExtras(limiter(count3));\n    } else {\n      return addExtras(function(fn2) {\n        return fn2();\n      });\n    }\n  }, \"promiseLimit$1\");\n  return promiseLimit$1;\n}\nfunction _createClient$2(config3) {\n  if (config3.scheme !== \"wss\" && config3.scheme !== \"ws\") {\n    throw new LibsqlError(`The WebSocket client supports only \"libsql:\", \"wss:\" and \"ws:\" URLs, got ${JSON.stringify(config3.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n  }\n  if (config3.encryptionKey !== void 0) {\n    throw new LibsqlError(\"Encryption key is not supported by the remote client.\", \"ENCRYPTION_KEY_NOT_SUPPORTED\");\n  }\n  if (config3.scheme === \"ws\" && config3.tls) {\n    throw new LibsqlError(`A \"ws:\" URL cannot opt into TLS by using ?tls=1`, \"URL_INVALID\");\n  } else if (config3.scheme === \"wss\" && !config3.tls) {\n    throw new LibsqlError(`A \"wss:\" URL cannot opt out of TLS by using ?tls=0`, \"URL_INVALID\");\n  }\n  const url = encodeBaseUrl(config3.scheme, config3.authority, config3.path);\n  let client;\n  try {\n    client = openWs(url, config3.authToken);\n  } catch (e) {\n    if (e instanceof WebSocketUnsupportedError) {\n      const suggestedScheme = config3.scheme === \"wss\" ? \"https\" : \"http\";\n      const suggestedUrl = encodeBaseUrl(suggestedScheme, config3.authority, config3.path);\n      throw new LibsqlError(`This environment does not support WebSockets, please switch to the HTTP client by using a \"${suggestedScheme}:\" URL (${JSON.stringify(suggestedUrl)}). For more information, please read ${supportedUrlLink}`, \"WEBSOCKETS_NOT_SUPPORTED\");\n    }\n    throw mapHranaError(e);\n  }\n  return new WsClient2(client, url, config3.authToken, config3.intMode, config3.concurrency);\n}\nfunction _createClient$1(config3) {\n  if (config3.scheme !== \"https\" && config3.scheme !== \"http\") {\n    throw new LibsqlError(`The HTTP client supports only \"libsql:\", \"https:\" and \"http:\" URLs, got ${JSON.stringify(config3.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n  }\n  if (config3.encryptionKey !== void 0) {\n    throw new LibsqlError(\"Encryption key is not supported by the remote client.\", \"ENCRYPTION_KEY_NOT_SUPPORTED\");\n  }\n  if (config3.scheme === \"http\" && config3.tls) {\n    throw new LibsqlError(`A \"http:\" URL cannot opt into TLS by using ?tls=1`, \"URL_INVALID\");\n  } else if (config3.scheme === \"https\" && !config3.tls) {\n    throw new LibsqlError(`A \"https:\" URL cannot opt out of TLS by using ?tls=0`, \"URL_INVALID\");\n  }\n  const url = encodeBaseUrl(config3.scheme, config3.authority, config3.path);\n  return new HttpClient2(url, config3.authToken, config3.intMode, config3.fetch, config3.concurrency);\n}\nfunction createClient(config3) {\n  return _createClient(expandConfig(config3));\n}\nfunction _createClient(config3) {\n  if (config3.scheme === \"ws\" || config3.scheme === \"wss\") {\n    return _createClient$2(config3);\n  } else if (config3.scheme === \"http\" || config3.scheme === \"https\") {\n    return _createClient$1(config3);\n  } else {\n    throw new LibsqlError(`The client that uses Web standard APIs supports only \"libsql:\", \"wss:\", \"ws:\", \"https:\" and \"http:\" URLs, got ${JSON.stringify(config3.scheme + \":\")}. For more information, please read ${supportedUrlLink}`, \"URL_SCHEME_NOT_SUPPORTED\");\n  }\n}\nfunction getJsonObjectArgs(node, table3) {\n  const args = [];\n  for (const { selection: s2 } of node.selections ?? []) {\n    if (ReferenceNode.is(s2) && ColumnNode.is(s2.column)) {\n      args.push(colName(s2.column.column.name), colRef(table3, s2.column.column.name));\n    } else if (ColumnNode.is(s2)) {\n      args.push(colName(s2.column.name), colRef(table3, s2.column.name));\n    } else if (AliasNode.is(s2) && IdentifierNode.is(s2.alias)) {\n      args.push(colName(s2.alias.name), colRef(table3, s2.alias.name));\n    } else {\n      throw new Error(`can't extract column names from the select query node`);\n    }\n  }\n  return args;\n}\nfunction colName(col) {\n  return new ExpressionWrapper(ValueNode.createImmediate(col));\n}\nfunction colRef(table3, col) {\n  return new ExpressionWrapper(ReferenceNode.create(ColumnNode.create(col), TableNode.create(table3)));\n}\nfunction jsonArrayFrom(expr) {\n  return sql`(select coalesce(json_group_array(json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), \"agg\"))})), '[]') from ${expr} as agg)`;\n}\nfunction jsonObjectFrom(expr) {\n  return sql`(select json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), \"obj\"))}) from ${expr} as obj)`;\n}\nfunction jsonBuildObject(obj) {\n  return sql`json_object(${sql.join(Object.keys(obj).flatMap((k2) => [sql.lit(k2), obj[k2]]))})`;\n}\nfunction getSqliteJsonObjectArgs(node, table3) {\n  try {\n    return getJsonObjectArgs(node, table3);\n  } catch {\n    throw new Error(\"SQLite jsonArrayFrom and jsonObjectFrom functions can only handle explicit selections due to limitations of the json_object function. selectAll() is not allowed in the subquery.\");\n  }\n}\nasync function signing(privateKey, alg, data) {\n  const algorithm2 = getKeyAlgorithm(alg);\n  const cryptoKey = await importPrivateKey(privateKey, algorithm2);\n  return await crypto.subtle.sign(algorithm2, cryptoKey, data);\n}\nasync function verifying(publicKey, alg, signature, data) {\n  const algorithm2 = getKeyAlgorithm(alg);\n  const cryptoKey = await importPublicKey(publicKey, algorithm2);\n  return await crypto.subtle.verify(algorithm2, cryptoKey, signature, data);\n}\nfunction pemToBinary(pem) {\n  return decodeBase642(pem.replace(/-+(BEGIN|END).*/g, \"\").replace(/\\s/g, \"\"));\n}\nasync function importPrivateKey(key, alg) {\n  if (!crypto.subtle || !crypto.subtle.importKey) {\n    throw new Error(\"`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.\");\n  }\n  if (isCryptoKey$1(key)) {\n    if (key.type !== \"private\" && key.type !== \"secret\") {\n      throw new Error(\n        `unexpected key type: CryptoKey.type is ${key.type}, expected private or secret`\n      );\n    }\n    return key;\n  }\n  const usages = [CryptoKeyUsage.Sign];\n  if (typeof key === \"object\") {\n    return await crypto.subtle.importKey(\"jwk\", key, alg, false, usages);\n  }\n  if (key.includes(\"PRIVATE\")) {\n    return await crypto.subtle.importKey(\"pkcs8\", pemToBinary(key), alg, false, usages);\n  }\n  return await crypto.subtle.importKey(\"raw\", utf8Encoder.encode(key), alg, false, usages);\n}\nasync function importPublicKey(key, alg) {\n  if (!crypto.subtle || !crypto.subtle.importKey) {\n    throw new Error(\"`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.\");\n  }\n  if (isCryptoKey$1(key)) {\n    if (key.type === \"public\" || key.type === \"secret\") {\n      return key;\n    }\n    key = await exportPublicJwkFrom(key);\n  }\n  if (typeof key === \"string\" && key.includes(\"PRIVATE\")) {\n    const privateKey = await crypto.subtle.importKey(\"pkcs8\", pemToBinary(key), alg, true, [\n      CryptoKeyUsage.Sign\n    ]);\n    key = await exportPublicJwkFrom(privateKey);\n  }\n  const usages = [CryptoKeyUsage.Verify];\n  if (typeof key === \"object\") {\n    return await crypto.subtle.importKey(\"jwk\", key, alg, false, usages);\n  }\n  if (key.includes(\"PUBLIC\")) {\n    return await crypto.subtle.importKey(\"spki\", pemToBinary(key), alg, false, usages);\n  }\n  return await crypto.subtle.importKey(\"raw\", utf8Encoder.encode(key), alg, false, usages);\n}\nasync function exportPublicJwkFrom(privateKey) {\n  if (privateKey.type !== \"private\") {\n    throw new Error(`unexpected key type: ${privateKey.type}`);\n  }\n  if (!privateKey.extractable) {\n    throw new Error(\"unexpected private key is unextractable\");\n  }\n  const jwk = await crypto.subtle.exportKey(\"jwk\", privateKey);\n  const { kty } = jwk;\n  const { alg, e, n: n27 } = jwk;\n  const { crv, x, y: y3 } = jwk;\n  return { kty, alg, e, n: n27, crv, x, y: y3, key_ops: [CryptoKeyUsage.Verify] };\n}\nfunction getKeyAlgorithm(name) {\n  switch (name) {\n    case \"HS256\":\n      return {\n        name: \"HMAC\",\n        hash: {\n          name: \"SHA-256\"\n        }\n      };\n    case \"HS384\":\n      return {\n        name: \"HMAC\",\n        hash: {\n          name: \"SHA-384\"\n        }\n      };\n    case \"HS512\":\n      return {\n        name: \"HMAC\",\n        hash: {\n          name: \"SHA-512\"\n        }\n      };\n    case \"RS256\":\n      return {\n        name: \"RSASSA-PKCS1-v1_5\",\n        hash: {\n          name: \"SHA-256\"\n        }\n      };\n    case \"RS384\":\n      return {\n        name: \"RSASSA-PKCS1-v1_5\",\n        hash: {\n          name: \"SHA-384\"\n        }\n      };\n    case \"RS512\":\n      return {\n        name: \"RSASSA-PKCS1-v1_5\",\n        hash: {\n          name: \"SHA-512\"\n        }\n      };\n    case \"PS256\":\n      return {\n        name: \"RSA-PSS\",\n        hash: {\n          name: \"SHA-256\"\n        },\n        saltLength: 32\n      };\n    case \"PS384\":\n      return {\n        name: \"RSA-PSS\",\n        hash: {\n          name: \"SHA-384\"\n        },\n        saltLength: 48\n      };\n    case \"PS512\":\n      return {\n        name: \"RSA-PSS\",\n        hash: {\n          name: \"SHA-512\"\n        },\n        saltLength: 64\n      };\n    case \"ES256\":\n      return {\n        name: \"ECDSA\",\n        hash: {\n          name: \"SHA-256\"\n        },\n        namedCurve: \"P-256\"\n      };\n    case \"ES384\":\n      return {\n        name: \"ECDSA\",\n        hash: {\n          name: \"SHA-384\"\n        },\n        namedCurve: \"P-384\"\n      };\n    case \"ES512\":\n      return {\n        name: \"ECDSA\",\n        hash: {\n          name: \"SHA-512\"\n        },\n        namedCurve: \"P-521\"\n      };\n    case \"EdDSA\":\n      return {\n        name: \"Ed25519\",\n        namedCurve: \"Ed25519\"\n      };\n    default:\n      throw new JwtAlgorithmNotImplemented(name);\n  }\n}\nfunction isCryptoKey$1(key) {\n  const runtime = getRuntimeKey();\n  if (runtime === \"node\" && !!crypto.webcrypto) {\n    return key instanceof crypto.webcrypto.CryptoKey;\n  }\n  return key instanceof CryptoKey;\n}\nfunction isTokenHeader(obj) {\n  if (typeof obj === \"object\" && obj !== null) {\n    const objWithAlg = obj;\n    return \"alg\" in objWithAlg && Object.values(AlgorithmTypes).includes(objWithAlg.alg) && (!(\"typ\" in objWithAlg) || objWithAlg.typ === \"JWT\");\n  }\n  return false;\n}\nasync function parseFormData(request, options) {\n  const formData = await request.formData();\n  if (formData) {\n    return convertFormDataToBodyData(formData, options);\n  }\n  return {};\n}\nfunction convertFormDataToBodyData(formData, options) {\n  const form2 = /* @__PURE__ */ Object.create(null);\n  formData.forEach((value2, key) => {\n    const shouldParseAllValues = options.all || key.endsWith(\"[]\");\n    if (!shouldParseAllValues) {\n      form2[key] = value2;\n    } else {\n      handleParsingAllValues(form2, key, value2);\n    }\n  });\n  if (options.dot) {\n    Object.entries(form2).forEach(([key, value2]) => {\n      const shouldParseDotValues = key.includes(\".\");\n      if (shouldParseDotValues) {\n        handleParsingNestedValues(form2, key, value2);\n        delete form2[key];\n      }\n    });\n  }\n  return form2;\n}\nfunction compareKey(a2, b3) {\n  if (a2.length === 1) {\n    return b3.length === 1 ? a2 < b3 ? -1 : 1 : -1;\n  }\n  if (b3.length === 1) {\n    return 1;\n  }\n  if (a2 === ONLY_WILDCARD_REG_EXP_STR || a2 === TAIL_WILDCARD_REG_EXP_STR) {\n    return 1;\n  } else if (b3 === ONLY_WILDCARD_REG_EXP_STR || b3 === TAIL_WILDCARD_REG_EXP_STR) {\n    return -1;\n  }\n  if (a2 === LABEL_REG_EXP_STR) {\n    return 1;\n  } else if (b3 === LABEL_REG_EXP_STR) {\n    return -1;\n  }\n  return a2.length === b3.length ? a2 < b3 ? -1 : 1 : b3.length - a2.length;\n}\nfunction buildWildcardRegExp(path) {\n  return wildcardRegExpCache[path] ??= new RegExp(\n    path === \"*\" ? \"\" : `^${path.replace(\n      /\\/\\*$|([.\\\\+*[^\\]$()])/g,\n      (_3, metaChar) => metaChar ? `\\\\${metaChar}` : \"(?:|/.*)\"\n    )}$`\n  );\n}\nfunction clearWildcardRegExpCache() {\n  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n}\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n  const trie = new Trie();\n  const handlerData = [];\n  if (routes.length === 0) {\n    return nullMatcher;\n  }\n  const routesWithStaticPathFlag = routes.map(\n    (route) => [!/\\*|\\/:/.test(route[0]), ...route]\n  ).sort(\n    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length\n  );\n  const staticMap = /* @__PURE__ */ Object.create(null);\n  for (let i = 0, j3 = -1, len = routesWithStaticPathFlag.length; i < len; i++) {\n    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n    if (pathErrorCheckOnly) {\n      staticMap[path] = [handlers.map(([h3]) => [h3, /* @__PURE__ */ Object.create(null)]), emptyParam];\n    } else {\n      j3++;\n    }\n    let paramAssoc;\n    try {\n      paramAssoc = trie.insert(path, j3, pathErrorCheckOnly);\n    } catch (e) {\n      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;\n    }\n    if (pathErrorCheckOnly) {\n      continue;\n    }\n    handlerData[j3] = handlers.map(([h3, paramCount]) => {\n      const paramIndexMap = /* @__PURE__ */ Object.create(null);\n      paramCount -= 1;\n      for (; paramCount >= 0; paramCount--) {\n        const [key, value2] = paramAssoc[paramCount];\n        paramIndexMap[key] = value2;\n      }\n      return [h3, paramIndexMap];\n    });\n  }\n  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n  for (let i = 0, len = handlerData.length; i < len; i++) {\n    for (let j3 = 0, len2 = handlerData[i].length; j3 < len2; j3++) {\n      const map2 = handlerData[i][j3]?.[1];\n      if (!map2) {\n        continue;\n      }\n      const keys2 = Object.keys(map2);\n      for (let k2 = 0, len3 = keys2.length; k2 < len3; k2++) {\n        map2[keys2[k2]] = paramReplacementMap[map2[keys2[k2]]];\n      }\n    }\n  }\n  const handlerMap = [];\n  for (const i in indexReplacementMap) {\n    handlerMap[i] = handlerData[indexReplacementMap[i]];\n  }\n  return [regexp, handlerMap, staticMap];\n}\nfunction findMiddleware(middleware2, path) {\n  if (!middleware2) {\n    return void 0;\n  }\n  for (const k2 of Object.keys(middleware2).sort((a2, b3) => b3.length - a2.length)) {\n    if (buildWildcardRegExp(k2).test(path)) {\n      return [...middleware2[k2]];\n    }\n  }\n  return void 0;\n}\nfunction looseInstanceOf(input2, expected) {\n  if (input2 == null) {\n    return false;\n  }\n  try {\n    return input2 instanceof expected || Object.getPrototypeOf(input2)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n  } catch {\n    return false;\n  }\n}\nfunction buf(input2) {\n  if (typeof input2 === \"string\") {\n    return encoder2.encode(input2);\n  }\n  return decoder2.decode(input2);\n}\nfunction encodeBase64Url(input2) {\n  if (input2 instanceof ArrayBuffer) {\n    input2 = new Uint8Array(input2);\n  }\n  const arr = [];\n  for (let i = 0; i < input2.byteLength; i += CHUNK_SIZE) {\n    arr.push(String.fromCharCode.apply(null, input2.subarray(i, i + CHUNK_SIZE)));\n  }\n  return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input2) {\n  try {\n    const binary2 = atob(input2.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n    const bytes = new Uint8Array(binary2.length);\n    for (let i = 0; i < binary2.length; i++) {\n      bytes[i] = binary2.charCodeAt(i);\n    }\n    return bytes;\n  } catch (cause) {\n    throw new OPE(\"The input to be decoded is not correctly encoded.\", { cause });\n  }\n}\nfunction b64u(input2) {\n  if (typeof input2 === \"string\") {\n    return decodeBase64Url(input2);\n  }\n  return encodeBase64Url(input2);\n}\nfunction isCryptoKey(key) {\n  return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n  return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n  return isCryptoKey(key) && key.type === \"public\";\n}\nfunction processDpopNonce(response) {\n  try {\n    const nonce = response.headers.get(\"dpop-nonce\");\n    if (nonce) {\n      dpopNonces.set(new URL(response.url).origin, nonce);\n    }\n  } catch {\n  }\n  return response;\n}\nfunction isJsonObject(input2) {\n  if (input2 === null || typeof input2 !== \"object\" || Array.isArray(input2)) {\n    return false;\n  }\n  return true;\n}\nfunction prepareHeaders(input2) {\n  if (looseInstanceOf(input2, Headers)) {\n    input2 = Object.fromEntries(input2.entries());\n  }\n  const headers = new Headers(input2);\n  if (USER_AGENT && !headers.has(\"user-agent\")) {\n    headers.set(\"user-agent\", USER_AGENT);\n  }\n  if (headers.has(\"authorization\")) {\n    throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n  }\n  if (headers.has(\"dpop\")) {\n    throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n  }\n  return headers;\n}\nfunction signal(value2) {\n  if (typeof value2 === \"function\") {\n    value2 = value2();\n  }\n  if (!(value2 instanceof AbortSignal)) {\n    throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n  }\n  return value2;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n  if (!(issuerIdentifier instanceof URL)) {\n    throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n  }\n  if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n    throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n  }\n  const url = new URL(issuerIdentifier.href);\n  switch (options?.algorithm) {\n    case void 0:\n    case \"oidc\":\n      url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n      break;\n    case \"oauth2\":\n      if (url.pathname === \"/\") {\n        url.pathname = \".well-known/oauth-authorization-server\";\n      } else {\n        url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n      }\n      break;\n    default:\n      throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n  }\n  const headers = prepareHeaders(options?.headers);\n  headers.set(\"accept\", \"application/json\");\n  return (options?.[customFetch] || fetch)(url.href, {\n    headers: Object.fromEntries(headers.entries()),\n    method: \"GET\",\n    redirect: \"manual\",\n    signal: null\n  }).then(processDpopNonce);\n}\nfunction validateString(input2) {\n  return typeof input2 === \"string\" && input2.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n  if (!(expectedIssuerIdentifier instanceof URL)) {\n    throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n  }\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', { cause });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.issuer)) {\n    throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n  }\n  if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n    throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n  }\n  return json;\n}\nfunction randomBytes$1() {\n  return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n  return randomBytes$1();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n  if (!validateString(codeVerifier)) {\n    throw new TypeError('\"codeVerifier\" must be a non-empty string');\n  }\n  return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction formUrlEncode(token) {\n  return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n  const username = formUrlEncode(clientId);\n  const password = formUrlEncode(clientSecret);\n  const credentials = btoa(`${username}:${password}`);\n  return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n  switch (key.algorithm.hash.name) {\n    case \"SHA-256\":\n      return \"PS256\";\n    case \"SHA-384\":\n      return \"PS384\";\n    case \"SHA-512\":\n      return \"PS512\";\n    default:\n      throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n  }\n}\nfunction rsAlg(key) {\n  switch (key.algorithm.hash.name) {\n    case \"SHA-256\":\n      return \"RS256\";\n    case \"SHA-384\":\n      return \"RS384\";\n    case \"SHA-512\":\n      return \"RS512\";\n    default:\n      throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n  }\n}\nfunction esAlg(key) {\n  switch (key.algorithm.namedCurve) {\n    case \"P-256\":\n      return \"ES256\";\n    case \"P-384\":\n      return \"ES384\";\n    case \"P-521\":\n      return \"ES512\";\n    default:\n      throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n  }\n}\nfunction keyToJws(key) {\n  switch (key.algorithm.name) {\n    case \"RSA-PSS\":\n      return psAlg(key);\n    case \"RSASSA-PKCS1-v1_5\":\n      return rsAlg(key);\n    case \"ECDSA\":\n      return esAlg(key);\n    case \"Ed25519\":\n    case \"Ed448\":\n      return \"EdDSA\";\n    default:\n      throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n  }\n}\nfunction getClockSkew(client) {\n  const skew = client?.[clockSkew];\n  return typeof skew === \"number\" && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n  const tolerance = client?.[clockTolerance];\n  return typeof tolerance === \"number\" && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;\n}\nfunction epochTime() {\n  return Math.floor(Date.now() / 1e3);\n}\nfunction assertAs(as2) {\n  if (typeof as2 !== \"object\" || as2 === null) {\n    throw new TypeError('\"as\" must be an object');\n  }\n  if (!validateString(as2.issuer)) {\n    throw new TypeError('\"as.issuer\" property must be a non-empty string');\n  }\n  return true;\n}\nfunction assertClient(client) {\n  if (typeof client !== \"object\" || client === null) {\n    throw new TypeError('\"client\" must be an object');\n  }\n  if (!validateString(client.client_id)) {\n    throw new TypeError('\"client.client_id\" property must be a non-empty string');\n  }\n  return true;\n}\nfunction assertClientSecret(clientSecret) {\n  if (!validateString(clientSecret)) {\n    throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n  }\n  return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n  if (clientSecret !== void 0) {\n    throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n  }\n}\nasync function clientAuthentication(as2, client, body, headers, clientPrivateKey) {\n  body.delete(\"client_secret\");\n  body.delete(\"client_assertion_type\");\n  body.delete(\"client_assertion\");\n  switch (client.token_endpoint_auth_method) {\n    case void 0:\n    case \"client_secret_basic\": {\n      headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n      break;\n    }\n    case \"client_secret_post\": {\n      body.set(\"client_id\", client.client_id);\n      body.set(\"client_secret\", assertClientSecret(client.client_secret));\n      break;\n    }\n    case \"private_key_jwt\": {\n      assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n      {\n        throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n      }\n    }\n    case \"tls_client_auth\":\n    case \"self_signed_tls_client_auth\":\n    case \"none\": {\n      assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n      assertNoClientPrivateKey(client.token_endpoint_auth_method);\n      body.set(\"client_id\", client.client_id);\n      break;\n    }\n    default:\n      throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n  }\n}\nasync function jwt(header, payload, key) {\n  if (!key.usages.includes(\"sign\")) {\n    throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n  }\n  const input2 = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n  const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input2)));\n  return `${input2}.${signature}`;\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew2, accessToken) {\n  const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n  if (!isPrivateKey(privateKey)) {\n    throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n  }\n  if (!isPublicKey(publicKey)) {\n    throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n  }\n  if (nonce !== void 0 && !validateString(nonce)) {\n    throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n  }\n  if (!publicKey.extractable) {\n    throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n  }\n  const now = epochTime() + clockSkew2;\n  const header = {\n    alg: keyToJws(privateKey),\n    typ: \"dpop+jwt\",\n    jwk: await publicJwk(publicKey)\n  };\n  const payload = {\n    iat: now,\n    jti: randomBytes$1(),\n    htm,\n    nonce,\n    htu: `${url.origin}${url.pathname}`,\n    ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : void 0\n  };\n  options[modifyAssertion]?.(header, payload);\n  headers.set(\"dpop\", await jwt(header, payload, privateKey));\n}\nasync function getSetPublicJwkCache(key) {\n  const { kty, e, n: n27, x, y: y3, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n  const jwk = { kty, e, n: n27, x, y: y3, crv };\n  jwkCache.set(key, jwk);\n  return jwk;\n}\nasync function publicJwk(key) {\n  jwkCache || (jwkCache = /* @__PURE__ */ new WeakMap());\n  return jwkCache.get(key) || getSetPublicJwkCache(key);\n}\nfunction validateEndpoint(value2, endpoint, useMtlsAlias2) {\n  if (typeof value2 !== \"string\") {\n    if (useMtlsAlias2) {\n      throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n    }\n    throw new TypeError(`\"as.${endpoint}\" must be a string`);\n  }\n  return new URL(value2);\n}\nfunction resolveEndpoint(as2, endpoint, useMtlsAlias2 = false) {\n  if (useMtlsAlias2 && as2.mtls_endpoint_aliases && endpoint in as2.mtls_endpoint_aliases) {\n    return validateEndpoint(as2.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias2);\n  }\n  return validateEndpoint(as2[endpoint], endpoint, useMtlsAlias2);\n}\nfunction alias(client, options) {\n  if (client.use_mtls_endpoint_aliases || options?.[useMtlsAlias]) {\n    return true;\n  }\n  return false;\n}\nfunction isOAuth2Error(input2) {\n  const value2 = input2;\n  if (typeof value2 !== \"object\" || Array.isArray(value2) || value2 === null) {\n    return false;\n  }\n  return value2.error !== void 0;\n}\nfunction unquote(value2) {\n  if (value2.length >= 2 && value2[0] === '\"' && value2[value2.length - 1] === '\"') {\n    return value2.slice(1, -1);\n  }\n  return value2;\n}\nfunction wwwAuth(scheme, params) {\n  const arr = params.split(SPLIT_REGEXP).slice(1);\n  if (!arr.length) {\n    return { scheme: scheme.toLowerCase(), parameters: {} };\n  }\n  arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n  const parameters = {};\n  for (let i = 1; i < arr.length; i += 2) {\n    const idx = i;\n    if (arr[idx][0] === '\"') {\n      while (arr[idx].slice(-1) !== '\"' && ++i < arr.length) {\n        arr[idx] += arr[i];\n      }\n    }\n    const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n    parameters[key] = unquote(arr[idx]);\n  }\n  return {\n    scheme: scheme.toLowerCase(),\n    parameters\n  };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  const header = response.headers.get(\"www-authenticate\");\n  if (header === null) {\n    return void 0;\n  }\n  const result = [];\n  for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)) {\n    result.push([scheme, index]);\n  }\n  if (!result.length) {\n    return void 0;\n  }\n  const challenges = result.map(([scheme, indexOf], i, others) => {\n    const next = others[i + 1];\n    let parameters;\n    if (next) {\n      parameters = header.slice(indexOf, next[1]);\n    } else {\n      parameters = header.slice(indexOf);\n    }\n    return wwwAuth(scheme, parameters);\n  });\n  return challenges;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n  if (!validateString(accessToken)) {\n    throw new TypeError('\"accessToken\" must be a non-empty string');\n  }\n  if (!(url instanceof URL)) {\n    throw new TypeError('\"url\" must be an instance of URL');\n  }\n  headers = prepareHeaders(headers);\n  if (options?.DPoP === void 0) {\n    headers.set(\"authorization\", `Bearer ${accessToken}`);\n  } else {\n    await dpopProofJwt(headers, options.DPoP, url, method.toUpperCase(), getClockSkew({ [clockSkew]: options?.[clockSkew] }), accessToken);\n    headers.set(\"authorization\", `DPoP ${accessToken}`);\n  }\n  return (options?.[customFetch] || fetch)(url.href, {\n    body,\n    headers: Object.fromEntries(headers.entries()),\n    method,\n    redirect: \"manual\",\n    signal: options?.signal ? signal(options.signal) : null\n  }).then(processDpopNonce);\n}\nasync function userInfoRequest(as2, client, accessToken, options) {\n  assertAs(as2);\n  assertClient(client);\n  const url = resolveEndpoint(as2, \"userinfo_endpoint\", alias(client, options));\n  const headers = prepareHeaders(options?.headers);\n  if (client.userinfo_signed_response_alg) {\n    headers.set(\"accept\", \"application/jwt\");\n  } else {\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwt\");\n  }\n  return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n    ...options,\n    [clockSkew]: getClockSkew(client)\n  });\n}\nfunction getContentType(response) {\n  return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as2, client, expectedSubject, response) {\n  assertAs(as2);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n  }\n  let json;\n  if (getContentType(response) === \"application/jwt\") {\n    assertReadableResponse(response);\n    const { claims, jwt: jwt2 } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(void 0, client.userinfo_signed_response_alg, as2.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt]).then(validateOptionalAudience.bind(void 0, client.client_id)).then(validateOptionalIssuer.bind(void 0, as2.issuer));\n    jwtResponseBodies.set(response, jwt2);\n    json = claims;\n  } else {\n    if (client.userinfo_signed_response_alg) {\n      throw new OPE(\"JWT UserInfo Response expected\");\n    }\n    assertReadableResponse(response);\n    try {\n      json = await response.json();\n    } catch (cause) {\n      throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.sub)) {\n    throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n  }\n  switch (expectedSubject) {\n    case skipSubjectCheck:\n      break;\n    default:\n      if (!validateString(expectedSubject)) {\n        throw new OPE('\"expectedSubject\" must be a non-empty string');\n      }\n      if (json.sub !== expectedSubject) {\n        throw new OPE('unexpected \"response\" body \"sub\" value');\n      }\n  }\n  return json;\n}\nasync function authenticatedRequest(as2, client, method, url, body, headers, options) {\n  await clientAuthentication(as2, client, body, headers);\n  headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n  return (options?.[customFetch] || fetch)(url.href, {\n    body,\n    headers: Object.fromEntries(headers.entries()),\n    method,\n    redirect: \"manual\",\n    signal: null\n  }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as2, client, grantType, parameters, options) {\n  const url = resolveEndpoint(as2, \"token_endpoint\", alias(client, options));\n  parameters.set(\"grant_type\", grantType);\n  const headers = prepareHeaders(options?.headers);\n  headers.set(\"accept\", \"application/json\");\n  return authenticatedRequest(as2, client, \"POST\", url, parameters, headers, options);\n}\nfunction getValidatedIdTokenClaims(ref) {\n  if (!ref.id_token) {\n    return void 0;\n  }\n  const claims = idTokenClaims.get(ref);\n  if (!claims) {\n    throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n  }\n  return claims[0];\n}\nasync function processGenericAccessTokenResponse(as2, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n  assertAs(as2);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    let err;\n    if (err = await handleOAuthBodyError(response)) {\n      return err;\n    }\n    throw new OPE('\"response\" is not a conform Token Endpoint response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', { cause });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.access_token)) {\n    throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n  }\n  if (!validateString(json.token_type)) {\n    throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n  }\n  json.token_type = json.token_type.toLowerCase();\n  if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n    throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n  }\n  if (json.expires_in !== void 0 && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n    throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n  }\n  if (!ignoreRefreshToken && json.refresh_token !== void 0 && !validateString(json.refresh_token)) {\n    throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n  }\n  if (json.scope !== void 0 && typeof json.scope !== \"string\") {\n    throw new OPE('\"response\" body \"scope\" property must be a string');\n  }\n  if (!ignoreIdToken) {\n    if (json.id_token !== void 0 && !validateString(json.id_token)) {\n      throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    if (json.id_token) {\n      const { claims, jwt: jwt2 } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(void 0, client.id_token_signed_response_alg, as2.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt]).then(validatePresence.bind(void 0, [\"aud\", \"exp\", \"iat\", \"iss\", \"sub\"])).then(validateIssuer.bind(void 0, as2.issuer)).then(validateAudience.bind(void 0, client.client_id));\n      if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n        if (claims.azp === void 0) {\n          throw new OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences');\n        }\n        if (claims.azp !== client.client_id) {\n          throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n        }\n      }\n      if (claims.auth_time !== void 0 && (!Number.isFinite(claims.auth_time) || Math.sign(claims.auth_time) !== 1)) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) must be a positive number');\n      }\n      idTokenClaims.set(json, [claims, jwt2]);\n    }\n  }\n  return json;\n}\nfunction validateOptionalAudience(expected, result) {\n  if (result.claims.aud !== void 0) {\n    return validateAudience(expected, result);\n  }\n  return result;\n}\nfunction validateAudience(expected, result) {\n  if (Array.isArray(result.claims.aud)) {\n    if (!result.claims.aud.includes(expected)) {\n      throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n  } else if (result.claims.aud !== expected) {\n    throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n  }\n  return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n  if (result.claims.iss !== void 0) {\n    return validateIssuer(expected, result);\n  }\n  return result;\n}\nfunction validateIssuer(expected, result) {\n  if (result.claims.iss !== expected) {\n    throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n  }\n  return result;\n}\nfunction brand(searchParams) {\n  branded.add(searchParams);\n  return searchParams;\n}\nasync function authorizationCodeGrantRequest(as2, client, callbackParameters, redirectUri, codeVerifier, options) {\n  assertAs(as2);\n  assertClient(client);\n  if (!branded.has(callbackParameters)) {\n    throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n  }\n  if (!validateString(redirectUri)) {\n    throw new TypeError('\"redirectUri\" must be a non-empty string');\n  }\n  if (!validateString(codeVerifier)) {\n    throw new TypeError('\"codeVerifier\" must be a non-empty string');\n  }\n  const code = getURLSearchParameter(callbackParameters, \"code\");\n  if (!code) {\n    throw new OPE('no authorization code in \"callbackParameters\"');\n  }\n  const parameters = new URLSearchParams(options?.additionalParameters);\n  parameters.set(\"redirect_uri\", redirectUri);\n  parameters.set(\"code_verifier\", codeVerifier);\n  parameters.set(\"code\", code);\n  return tokenEndpointRequest(as2, client, \"authorization_code\", parameters, options);\n}\nfunction validatePresence(required, result) {\n  for (const claim of required) {\n    if (result.claims[claim] === void 0) {\n      throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n    }\n  }\n  return result;\n}\nasync function processAuthorizationCodeOpenIDResponse(as2, client, response, expectedNonce, maxAge) {\n  const result = await processGenericAccessTokenResponse(as2, client, response);\n  if (isOAuth2Error(result)) {\n    return result;\n  }\n  if (!validateString(result.id_token)) {\n    throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n  }\n  maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n  const claims = getValidatedIdTokenClaims(result);\n  if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === void 0) {\n    throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n  }\n  if (maxAge !== skipAuthTimeCheck) {\n    if (typeof maxAge !== \"number\" || maxAge < 0) {\n      throw new TypeError('\"maxAge\" must be a non-negative number');\n    }\n    const now = epochTime() + getClockSkew(client);\n    const tolerance = getClockTolerance(client);\n    if (claims.auth_time + maxAge < now - tolerance) {\n      throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n    }\n  }\n  switch (expectedNonce) {\n    case void 0:\n    case expectNoNonce:\n      if (claims.nonce !== void 0) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n      }\n      break;\n    default:\n      if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n      }\n      if (claims.nonce === void 0) {\n        throw new OPE('ID Token \"nonce\" claim missing');\n      }\n      if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n      }\n  }\n  return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as2, client, response) {\n  const result = await processGenericAccessTokenResponse(as2, client, response, true);\n  if (isOAuth2Error(result)) {\n    return result;\n  }\n  if (result.id_token !== void 0) {\n    if (typeof result.id_token === \"string\" && result.id_token.length) {\n      throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n    }\n    delete result.id_token;\n  }\n  return result;\n}\nfunction assertReadableResponse(response) {\n  if (response.bodyUsed) {\n    throw new TypeError('\"response\" body has been used already');\n  }\n}\nasync function handleOAuthBodyError(response) {\n  if (response.status > 399 && response.status < 500) {\n    assertReadableResponse(response);\n    try {\n      const json = await response.json();\n      if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n        if (json.error_description !== void 0 && typeof json.error_description !== \"string\") {\n          delete json.error_description;\n        }\n        if (json.error_uri !== void 0 && typeof json.error_uri !== \"string\") {\n          delete json.error_uri;\n        }\n        if (json.algs !== void 0 && typeof json.algs !== \"string\") {\n          delete json.algs;\n        }\n        if (json.scope !== void 0 && typeof json.scope !== \"string\") {\n          delete json.scope;\n        }\n        return json;\n      }\n    } catch {\n    }\n  }\n  return void 0;\n}\nfunction checkRsaKeyAlgorithm(algorithm2) {\n  if (typeof algorithm2.modulusLength !== \"number\" || algorithm2.modulusLength < 2048) {\n    throw new OPE(`${algorithm2.name} modulusLength must be at least 2048 bits`);\n  }\n}\nfunction ecdsaHashName(namedCurve) {\n  switch (namedCurve) {\n    case \"P-256\":\n      return \"SHA-256\";\n    case \"P-384\":\n      return \"SHA-384\";\n    case \"P-521\":\n      return \"SHA-512\";\n    default:\n      throw new UnsupportedOperationError();\n  }\n}\nfunction keyToSubtle(key) {\n  switch (key.algorithm.name) {\n    case \"ECDSA\":\n      return {\n        name: key.algorithm.name,\n        hash: ecdsaHashName(key.algorithm.namedCurve)\n      };\n    case \"RSA-PSS\": {\n      checkRsaKeyAlgorithm(key.algorithm);\n      switch (key.algorithm.hash.name) {\n        case \"SHA-256\":\n        case \"SHA-384\":\n        case \"SHA-512\":\n          return {\n            name: key.algorithm.name,\n            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n          };\n        default:\n          throw new UnsupportedOperationError();\n      }\n    }\n    case \"RSASSA-PKCS1-v1_5\":\n      checkRsaKeyAlgorithm(key.algorithm);\n      return key.algorithm.name;\n    case \"Ed448\":\n    case \"Ed25519\":\n      return key.algorithm.name;\n  }\n  throw new UnsupportedOperationError();\n}\nasync function validateJwsSignature(protectedHeader, payload, key, signature) {\n  const input2 = `${protectedHeader}.${payload}`;\n  const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input2));\n  if (!verified) {\n    throw new OPE(\"JWT signature verification failed\");\n  }\n}\nasync function validateJwt(jws, checkAlg, getKey, clockSkew2, clockTolerance2, decryptJwt) {\n  let { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n  if (length === 5) {\n    if (decryptJwt !== void 0) {\n      jws = await decryptJwt(jws);\n      ({ 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\"));\n    } else {\n      throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n  }\n  if (length !== 3) {\n    throw new OPE(\"Invalid JWT\");\n  }\n  let header;\n  try {\n    header = JSON.parse(buf(b64u(protectedHeader)));\n  } catch (cause) {\n    throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", { cause });\n  }\n  if (!isJsonObject(header)) {\n    throw new OPE(\"JWT Header must be a top level object\");\n  }\n  checkAlg(header);\n  if (header.crit !== void 0) {\n    throw new OPE('unexpected JWT \"crit\" header parameter');\n  }\n  const signature = b64u(encodedSignature);\n  let key;\n  if (getKey !== noSignatureCheck) {\n    key = await getKey(header);\n    await validateJwsSignature(protectedHeader, payload, key, signature);\n  }\n  let claims;\n  try {\n    claims = JSON.parse(buf(b64u(payload)));\n  } catch (cause) {\n    throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", { cause });\n  }\n  if (!isJsonObject(claims)) {\n    throw new OPE(\"JWT Payload must be a top level object\");\n  }\n  const now = epochTime() + clockSkew2;\n  if (claims.exp !== void 0) {\n    if (typeof claims.exp !== \"number\") {\n      throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n    }\n    if (claims.exp <= now - clockTolerance2) {\n      throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n    }\n  }\n  if (claims.iat !== void 0) {\n    if (typeof claims.iat !== \"number\") {\n      throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n    }\n  }\n  if (claims.iss !== void 0) {\n    if (typeof claims.iss !== \"string\") {\n      throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n    }\n  }\n  if (claims.nbf !== void 0) {\n    if (typeof claims.nbf !== \"number\") {\n      throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n    }\n    if (claims.nbf > now + clockTolerance2) {\n      throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n    }\n  }\n  if (claims.aud !== void 0) {\n    if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n      throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n    }\n  }\n  return { header, claims, signature, key, jwt: jws };\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n  if (client !== void 0) {\n    if (header.alg !== client) {\n      throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n    return;\n  }\n  if (Array.isArray(issuer)) {\n    if (!issuer.includes(header.alg)) {\n      throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n    return;\n  }\n  if (header.alg !== \"RS256\") {\n    throw new OPE('unexpected JWT \"alg\" header parameter');\n  }\n}\nfunction getURLSearchParameter(parameters, name) {\n  const { 0: value2, length } = parameters.getAll(name);\n  if (length > 1) {\n    throw new OPE(`\"${name}\" parameter must be provided only once`);\n  }\n  return value2;\n}\nfunction validateAuthResponse(as2, client, parameters, expectedState) {\n  assertAs(as2);\n  assertClient(client);\n  if (parameters instanceof URL) {\n    parameters = parameters.searchParams;\n  }\n  if (!(parameters instanceof URLSearchParams)) {\n    throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n  }\n  if (getURLSearchParameter(parameters, \"response\")) {\n    throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n  }\n  const iss = getURLSearchParameter(parameters, \"iss\");\n  const state = getURLSearchParameter(parameters, \"state\");\n  if (!iss && as2.authorization_response_iss_parameter_supported) {\n    throw new OPE('response parameter \"iss\" (issuer) missing');\n  }\n  if (iss && iss !== as2.issuer) {\n    throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n  }\n  switch (expectedState) {\n    case void 0:\n    case expectNoState:\n      if (state !== void 0) {\n        throw new OPE('unexpected \"state\" response parameter encountered');\n      }\n      break;\n    case skipStateCheck:\n      break;\n    default:\n      if (!validateString(expectedState)) {\n        throw new OPE('\"expectedState\" must be a non-empty string');\n      }\n      if (state === void 0) {\n        throw new OPE('response parameter \"state\" missing');\n      }\n      if (state !== expectedState) {\n        throw new OPE('unexpected \"state\" response parameter value');\n      }\n  }\n  const error4 = getURLSearchParameter(parameters, \"error\");\n  if (error4) {\n    return {\n      error: error4,\n      error_description: getURLSearchParameter(parameters, \"error_description\"),\n      error_uri: getURLSearchParameter(parameters, \"error_uri\")\n    };\n  }\n  const id_token = getURLSearchParameter(parameters, \"id_token\");\n  const token = getURLSearchParameter(parameters, \"token\");\n  if (id_token !== void 0 || token !== void 0) {\n    throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n  }\n  return brand(new URLSearchParams(parameters));\n}\nfunction randomBytes2(len) {\n  try {\n    return crypto.getRandomValues(new Uint8Array(len));\n  } catch {\n  }\n  try {\n    return nodeCrypto.randomBytes(len);\n  } catch {\n  }\n  {\n    throw Error(\n      \"Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative\"\n    );\n  }\n}\nfunction genSaltSync(rounds, seed_length) {\n  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;\n  if (typeof rounds !== \"number\")\n    throw Error(\n      \"Illegal arguments: \" + typeof rounds + \", \" + typeof seed_length\n    );\n  if (rounds < 4) rounds = 4;\n  else if (rounds > 31) rounds = 31;\n  var salt = [];\n  salt.push(\"$2b$\");\n  if (rounds < 10) salt.push(\"0\");\n  salt.push(rounds.toString());\n  salt.push(\"$\");\n  salt.push(base64_encode(randomBytes2(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));\n  return salt.join(\"\");\n}\nfunction genSalt(rounds, seed_length, callback) {\n  if (typeof seed_length === \"function\")\n    callback = seed_length, seed_length = void 0;\n  if (typeof rounds === \"function\") callback = rounds, rounds = void 0;\n  if (typeof rounds === \"undefined\") rounds = GENSALT_DEFAULT_LOG2_ROUNDS;\n  else if (typeof rounds !== \"number\")\n    throw Error(\"illegal arguments: \" + typeof rounds);\n  function _async(callback2) {\n    nextTick2(function() {\n      try {\n        callback2(null, genSaltSync(rounds));\n      } catch (err) {\n        callback2(err);\n      }\n    });\n  }\n  __name(_async, \"_async\");\n  if (callback) {\n    if (typeof callback !== \"function\")\n      throw Error(\"Illegal callback: \" + typeof callback);\n    _async(callback);\n  } else\n    return new Promise(function(resolve, reject) {\n      _async(function(err, res) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(res);\n      });\n    });\n}\nfunction hash2(password, salt, callback, progressCallback) {\n  function _async(callback2) {\n    if (typeof password === \"string\" && typeof salt === \"number\")\n      genSalt(salt, function(err, salt2) {\n        _hash(password, salt2, callback2, progressCallback);\n      });\n    else if (typeof password === \"string\" && typeof salt === \"string\")\n      _hash(password, salt, callback2, progressCallback);\n    else\n      nextTick2(\n        callback2.bind(\n          this,\n          Error(\"Illegal arguments: \" + typeof password + \", \" + typeof salt)\n        )\n      );\n  }\n  __name(_async, \"_async\");\n  if (callback) {\n    if (typeof callback !== \"function\")\n      throw Error(\"Illegal callback: \" + typeof callback);\n    _async(callback);\n  } else\n    return new Promise(function(resolve, reject) {\n      _async(function(err, res) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(res);\n      });\n    });\n}\nfunction safeStringCompare(known, unknown) {\n  var diff = known.length ^ unknown.length;\n  for (var i = 0; i < known.length; ++i) {\n    diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);\n  }\n  return diff === 0;\n}\nfunction compare(password, hashValue, callback, progressCallback) {\n  function _async(callback2) {\n    if (typeof password !== \"string\" || typeof hashValue !== \"string\") {\n      nextTick2(\n        callback2.bind(\n          this,\n          Error(\n            \"Illegal arguments: \" + typeof password + \", \" + typeof hashValue\n          )\n        )\n      );\n      return;\n    }\n    if (hashValue.length !== 60) {\n      nextTick2(callback2.bind(this, null, false));\n      return;\n    }\n    hash2(\n      password,\n      hashValue.substring(0, 29),\n      function(err, comp) {\n        if (err) callback2(err);\n        else callback2(null, safeStringCompare(comp, hashValue));\n      },\n      progressCallback\n    );\n  }\n  __name(_async, \"_async\");\n  if (callback) {\n    if (typeof callback !== \"function\")\n      throw Error(\"Illegal callback: \" + typeof callback);\n    _async(callback);\n  } else\n    return new Promise(function(resolve, reject) {\n      _async(function(err, res) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(res);\n      });\n    });\n}\nfunction utf8Length(string2) {\n  var len = 0, c = 0;\n  for (var i = 0; i < string2.length; ++i) {\n    c = string2.charCodeAt(i);\n    if (c < 128) len += 1;\n    else if (c < 2048) len += 2;\n    else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {\n      ++i;\n      len += 4;\n    } else len += 3;\n  }\n  return len;\n}\nfunction utf8Array(string2) {\n  var offset = 0, c1, c2;\n  var buffer = new Array(utf8Length(string2));\n  for (var i = 0, k2 = string2.length; i < k2; ++i) {\n    c1 = string2.charCodeAt(i);\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192;\n      buffer[offset++] = c1 & 63 | 128;\n    } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {\n      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n      ++i;\n      buffer[offset++] = c1 >> 18 | 240;\n      buffer[offset++] = c1 >> 12 & 63 | 128;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    } else {\n      buffer[offset++] = c1 >> 12 | 224;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    }\n  }\n  return buffer;\n}\nfunction base64_encode(b3, len) {\n  var off2 = 0, rs2 = [], c1, c2;\n  if (len <= 0 || len > b3.length) throw Error(\"Illegal len: \" + len);\n  while (off2 < len) {\n    c1 = b3[off2++] & 255;\n    rs2.push(BASE64_CODE[c1 >> 2 & 63]);\n    c1 = (c1 & 3) << 4;\n    if (off2 >= len) {\n      rs2.push(BASE64_CODE[c1 & 63]);\n      break;\n    }\n    c2 = b3[off2++] & 255;\n    c1 |= c2 >> 4 & 15;\n    rs2.push(BASE64_CODE[c1 & 63]);\n    c1 = (c2 & 15) << 2;\n    if (off2 >= len) {\n      rs2.push(BASE64_CODE[c1 & 63]);\n      break;\n    }\n    c2 = b3[off2++] & 255;\n    c1 |= c2 >> 6 & 3;\n    rs2.push(BASE64_CODE[c1 & 63]);\n    rs2.push(BASE64_CODE[c2 & 63]);\n  }\n  return rs2.join(\"\");\n}\nfunction base64_decode(s2, len) {\n  var off2 = 0, slen = s2.length, olen = 0, rs2 = [], c1, c2, c3, c4, o, code;\n  while (off2 < slen - 1 && olen < len) {\n    code = s2.charCodeAt(off2++);\n    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n    code = s2.charCodeAt(off2++);\n    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n    if (c1 == -1 || c2 == -1) break;\n    o = c1 << 2 >>> 0;\n    o |= (c2 & 48) >> 4;\n    rs2.push(String.fromCharCode(o));\n    if (++olen >= len || off2 >= slen) break;\n    code = s2.charCodeAt(off2++);\n    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n    if (c3 == -1) break;\n    o = (c2 & 15) << 4 >>> 0;\n    o |= (c3 & 60) >> 2;\n    rs2.push(String.fromCharCode(o));\n    if (++olen >= len || off2 >= slen) break;\n    code = s2.charCodeAt(off2++);\n    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n    o = (c3 & 3) << 6 >>> 0;\n    o |= c4;\n    rs2.push(String.fromCharCode(o));\n    ++olen;\n  }\n  var res = [];\n  for (off2 = 0; off2 < olen; off2++) res.push(rs2[off2].charCodeAt(0));\n  return res;\n}\nfunction _encipher(lr3, off2, P3, S2) {\n  var n27, l2 = lr3[off2], r2 = lr3[off2 + 1];\n  l2 ^= P3[0];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[1];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[2];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[3];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[4];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[5];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[6];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[7];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[8];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[9];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[10];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[11];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[12];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[13];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[14];\n  n27 = S2[l2 >>> 24];\n  n27 += S2[256 | l2 >> 16 & 255];\n  n27 ^= S2[512 | l2 >> 8 & 255];\n  n27 += S2[768 | l2 & 255];\n  r2 ^= n27 ^ P3[15];\n  n27 = S2[r2 >>> 24];\n  n27 += S2[256 | r2 >> 16 & 255];\n  n27 ^= S2[512 | r2 >> 8 & 255];\n  n27 += S2[768 | r2 & 255];\n  l2 ^= n27 ^ P3[16];\n  lr3[off2] = r2 ^ P3[BLOWFISH_NUM_ROUNDS + 1];\n  lr3[off2 + 1] = l2;\n  return lr3;\n}\nfunction _streamtoword(data, offp) {\n  for (var i = 0, word = 0; i < 4; ++i)\n    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;\n  return { key: word, offp };\n}\nfunction _key(key, P3, S2) {\n  var offset = 0, lr3 = [0, 0], plen = P3.length, slen = S2.length, sw;\n  for (var i = 0; i < plen; i++)\n    sw = _streamtoword(key, offset), offset = sw.offp, P3[i] = P3[i] ^ sw.key;\n  for (i = 0; i < plen; i += 2)\n    lr3 = _encipher(lr3, 0, P3, S2), P3[i] = lr3[0], P3[i + 1] = lr3[1];\n  for (i = 0; i < slen; i += 2)\n    lr3 = _encipher(lr3, 0, P3, S2), S2[i] = lr3[0], S2[i + 1] = lr3[1];\n}\nfunction _ekskey(data, key, P3, S2) {\n  var offp = 0, lr3 = [0, 0], plen = P3.length, slen = S2.length, sw;\n  for (var i = 0; i < plen; i++)\n    sw = _streamtoword(key, offp), offp = sw.offp, P3[i] = P3[i] ^ sw.key;\n  offp = 0;\n  for (i = 0; i < plen; i += 2)\n    sw = _streamtoword(data, offp), offp = sw.offp, lr3[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr3[1] ^= sw.key, lr3 = _encipher(lr3, 0, P3, S2), P3[i] = lr3[0], P3[i + 1] = lr3[1];\n  for (i = 0; i < slen; i += 2)\n    sw = _streamtoword(data, offp), offp = sw.offp, lr3[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr3[1] ^= sw.key, lr3 = _encipher(lr3, 0, P3, S2), S2[i] = lr3[0], S2[i + 1] = lr3[1];\n}\nfunction _crypt(b3, salt, rounds, callback, progressCallback) {\n  var cdata = C_ORIG.slice(), clen = cdata.length, err;\n  if (rounds < 4 || rounds > 31) {\n    err = Error(\"Illegal number of rounds (4-31): \" + rounds);\n    if (callback) {\n      nextTick2(callback.bind(this, err));\n      return;\n    } else throw err;\n  }\n  if (salt.length !== BCRYPT_SALT_LEN) {\n    err = Error(\n      \"Illegal salt length: \" + salt.length + \" != \" + BCRYPT_SALT_LEN\n    );\n    if (callback) {\n      nextTick2(callback.bind(this, err));\n      return;\n    } else throw err;\n  }\n  rounds = 1 << rounds >>> 0;\n  var P3, S2, i = 0, j3;\n  if (typeof Int32Array === \"function\") {\n    P3 = new Int32Array(P_ORIG);\n    S2 = new Int32Array(S_ORIG);\n  } else {\n    P3 = P_ORIG.slice();\n    S2 = S_ORIG.slice();\n  }\n  _ekskey(salt, b3, P3, S2);\n  function next() {\n    if (progressCallback) progressCallback(i / rounds);\n    if (i < rounds) {\n      var start = Date.now();\n      for (; i < rounds; ) {\n        i = i + 1;\n        _key(b3, P3, S2);\n        _key(salt, P3, S2);\n        if (Date.now() - start > MAX_EXECUTION_TIME) break;\n      }\n    } else {\n      for (i = 0; i < 64; i++)\n        for (j3 = 0; j3 < clen >> 1; j3++) _encipher(cdata, j3 << 1, P3, S2);\n      var ret = [];\n      for (i = 0; i < clen; i++)\n        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);\n      if (callback) {\n        callback(null, ret);\n        return;\n      } else return ret;\n    }\n    if (callback) nextTick2(next);\n  }\n  __name(next, \"next\");\n  if (typeof callback !== \"undefined\") {\n    next();\n  } else {\n    var res;\n    while (true) if (typeof (res = next()) !== \"undefined\") return res || [];\n  }\n}\nfunction _hash(password, salt, callback, progressCallback) {\n  var err;\n  if (typeof password !== \"string\" || typeof salt !== \"string\") {\n    err = Error(\"Invalid string / salt: Not a string\");\n    if (callback) {\n      nextTick2(callback.bind(this, err));\n      return;\n    } else throw err;\n  }\n  var minor, offset;\n  if (salt.charAt(0) !== \"$\" || salt.charAt(1) !== \"2\") {\n    err = Error(\"Invalid salt version: \" + salt.substring(0, 2));\n    if (callback) {\n      nextTick2(callback.bind(this, err));\n      return;\n    } else throw err;\n  }\n  if (salt.charAt(2) === \"$\") minor = String.fromCharCode(0), offset = 3;\n  else {\n    minor = salt.charAt(2);\n    if (minor !== \"a\" && minor !== \"b\" && minor !== \"y\" || salt.charAt(3) !== \"$\") {\n      err = Error(\"Invalid salt revision: \" + salt.substring(2, 4));\n      if (callback) {\n        nextTick2(callback.bind(this, err));\n        return;\n      } else throw err;\n    }\n    offset = 4;\n  }\n  if (salt.charAt(offset + 2) > \"$\") {\n    err = Error(\"Missing salt rounds\");\n    if (callback) {\n      nextTick2(callback.bind(this, err));\n      return;\n    } else throw err;\n  }\n  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);\n  password += minor >= \"a\" ? \"\\0\" : \"\";\n  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);\n  function finish(bytes) {\n    var res = [];\n    res.push(\"$2\");\n    if (minor >= \"a\") res.push(minor);\n    res.push(\"$\");\n    if (rounds < 10) res.push(\"0\");\n    res.push(rounds.toString());\n    res.push(\"$\");\n    res.push(base64_encode(saltb, saltb.length));\n    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));\n    return res.join(\"\");\n  }\n  __name(finish, \"finish\");\n  if (typeof callback == \"undefined\")\n    return finish(_crypt(passwordb, saltb, rounds));\n  else {\n    _crypt(\n      passwordb,\n      saltb,\n      rounds,\n      function(err2, bytes) {\n        if (err2) callback(err2, null);\n        else callback(null, finish(bytes));\n      },\n      progressCallback\n    );\n  }\n}\nfunction jsxDEV(tag, props, key) {\n  let node;\n  if (!props || !(\"children\" in props)) {\n    node = jsxFn(tag, props, []);\n  } else {\n    const children = props.children;\n    node = Array.isArray(children) ? jsxFn(tag, props, children) : jsxFn(tag, props, [children]);\n  }\n  node.key = key;\n  return node;\n}\nfunction Ir(n252, e, t) {\n  return validator(n252, (r2, i) => {\n    if (Check(e, r2)) {\n      let s2 = Decode(e, r2);\n      return s2;\n    }\n    return i.json({ success: false, errors: [...Errors(e, r2)] }, 400);\n  });\n}\nfunction Ba(n252) {\n  return n252 ? { ...Object.fromEntries(n252.entries()) } : {};\n}\nfunction Ks(n252, e) {\n  let t = Ba(n252), r2 = {};\n  for (let i of e) t[i] && (r2[i] = t[i]);\n  return r2;\n}\nfunction Js(n252, e) {\n  let t = new Headers();\n  for (let r2 of e) n252.has(r2) && t.set(r2, n252.get(r2));\n  return t;\n}\nfunction zs(n252, e) {\n  let t = \"\";\n  function r2(i) {\n    return i;\n  }\n  __name(r2, \"r\");\n  for (let i in n252) {\n    let s2 = n252[i];\n    if (s2 !== void 0) if (Array.isArray(s2)) for (let o = 0; o < s2.length; o++) t.length > 0 && (t += \"&\"), t += `${r2(i)}=${r2(s2[o])}`;\n    else typeof s2 == \"object\" && (s2 = JSON.stringify(s2)), t.length > 0 && (t += \"&\"), t += `${r2(i)}=${r2(s2)}`;\n  }\n  return \"\" + t;\n}\nfunction K$1() {\n  try {\n    return ui$1(0);\n  } catch {\n    return false;\n  }\n}\nfunction Gs() {\n  try {\n    return \"0.14.0-rc.0\";\n  } catch {\n    return \"0.0.0\";\n  }\n}\nfunction Vs(n252) {\n  return !n252 || n252.length === 0 ? n252 : n252.charAt(0).toUpperCase() + n252.slice(1);\n}\nfunction Dr$1(n252, e = false) {\n  let i = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" + (e ? \"!@#$%^&*()_+{}:\\\"<>?|[];',./`~\" : \"\"), s2 = \"\";\n  for (let o = 0; o < n252; o++) s2 += i[Math.floor(Math.random() * i.length)];\n  return s2;\n}\nfunction Ot$1(n252) {\n  return !n252 || n252.length === 0 ? n252 : n252.split(\"_\").map((e) => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()).join(\" \");\n}\nfunction Ws(n252) {\n  return n252.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction Hs(n252, e) {\n  return e instanceof RegExp ? e.test(n252) : typeof e == \"string\" && e.startsWith(\"/\") ? new RegExp(e).test(n252) : typeof e == \"string\" ? n252.startsWith(e) : false;\n}\nfunction Ys(n252, e = 50, t = \"...\") {\n  return n252.length <= e ? n252 : n252.substring(0, e) + t;\n}\nfunction Ua(n252) {\n  return Object.prototype.toString.call(n252) === \"[object Object]\";\n}\nfunction Rt$1(n252) {\n  return n252 !== null && typeof n252 == \"object\";\n}\nfunction Nr$1(n252, e) {\n  let t = new Set(e), r2 = {};\n  for (let [i, s2] of Object.entries(n252)) t.has(i) || (r2[i] = s2);\n  return r2;\n}\nfunction $r$1(n252, e = []) {\n  return n252 === null || typeof n252 != \"object\" ? n252 : Array.isArray(n252) ? n252.map((t) => $r$1(t, e)) : Object.keys(n252).reduce((t, r2) => {\n    let i = e.includes(r2) ? r2 : Ws(r2);\n    return t[i] = $r$1(n252[r2], e), t;\n  }, {});\n}\nfunction di$1(n252, e) {\n  let t = {};\n  for (let r2 in n252) e.some((s2) => r2.includes(s2)) || (typeof n252[r2] == \"object\" && n252[r2] !== null && !Array.isArray(n252[r2]) ? t[r2] = di$1(n252[r2], e) : t[r2] = n252[r2]);\n  return t;\n}\nfunction O$2(n252, e) {\n  return Object.entries(n252).reduce((t, [r2, i]) => {\n    let s2 = e(i, r2);\n    return typeof s2 < \"u\" && (t[r2] = s2), t;\n  }, {});\n}\nfunction mi$1(n252, e) {\n  Object.entries(n252).forEach(([t, r2]) => {\n    e(r2, t);\n  }, {});\n}\nfunction fi$1(n252, e = \"\") {\n  let t = [];\n  for (let r2 in n252) {\n    let i = e ? `${e}.${r2}` : r2;\n    t.push(i), typeof n252[r2] == \"object\" && n252[r2] !== null && (t = t.concat(fi$1(n252[r2], i)));\n  }\n  return t;\n}\nfunction qr$1(n252) {\n  return n252 && Object.entries(n252).reduce((e, [t, r2]) => {\n    if (r2 && Array.isArray(r2) && r2.some((i) => typeof i == \"object\")) {\n      let i = r2.map(qr$1);\n      i.length > 0 && (e[t] = i);\n    } else if (r2 && typeof r2 == \"object\" && !Array.isArray(r2)) {\n      let i = qr$1(r2);\n      Object.keys(i).length > 0 && (e[t] = i);\n    } else r2 !== \"\" && r2 !== null && r2 !== void 0 && (e[t] = r2);\n    return e;\n  }, {});\n}\nfunction yi$1(n252, e, t) {\n  for (let [r2, i] of Object.entries(e)) {\n    let s2 = t(n252[r2], i, r2, n252, e);\n    if (s2 !== void 0) {\n      n252[r2] = s2;\n      continue;\n    }\n    i !== void 0 && (!Ua(i) && !Array.isArray(i) || Array.isArray(i) && !Array.isArray(n252[r2]) ? n252[r2] = i : Rt$1(n252[r2]) ? yi$1(n252[r2], i, t) : n252[r2] = i);\n  }\n  return n252;\n}\nfunction Br$1(n252, e = 0, t = 0) {\n  let r2 = e ? `\n` : \"\", i = /* @__PURE__ */ __name((a2) => e ? \" \".repeat(e * a2) : \"\", \"i\"), s2 = i(t + 1), o = i(t);\n  if (n252 === null) return \"null\";\n  if (n252 === void 0) return \"undefined\";\n  let c = typeof n252;\n  if (c === \"string\") return JSON.stringify(n252);\n  if (c === \"number\" || c === \"boolean\") return String(n252);\n  if (Array.isArray(n252)) {\n    let a2 = n252.map((l2) => Br$1(l2, e, t + 1)).join(\", \" + (e ? r2 + s2 : \"\"));\n    return \"[\" + (e && n252.length ? r2 + s2 : \"\") + a2 + (e && n252.length ? r2 + o : \"\") + \"]\";\n  }\n  if (c === \"object\") {\n    let a2 = Object.entries(n252).map(([p2, u3]) => (/^[A-Za-z_$][\\w$]*$/.test(p2) ? p2 : JSON.stringify(p2)) + \": \" + Br$1(u3, e, t + 1)), l2 = a2.join(\", \" + (e ? r2 + s2 : \"\"));\n    return \"{\" + (e && a2.length ? r2 + s2 : \"\") + l2 + (e && a2.length ? r2 + o : \"\") + \"}\";\n  }\n  throw new TypeError(`Unsupported data type: ${c}`);\n}\nfunction Xs(n252) {\n  return new XMLParser().parse(n252);\n}\nfunction Zs(n252) {\n  try {\n    let e = n252.split(\".\").pop();\n    if (!e) return E$3.a();\n    for (let [t, r2] of Object.entries(hi$1)) if (r2.includes(e)) return `${t}/${e}`;\n    return gi$1.get(e);\n  } catch {\n    return E$3.a();\n  }\n}\nfunction Ur$1(n252, e = []) {\n  let t = n252.toLowerCase();\n  if (e.includes(t)) return false;\n  if (Object.entries(hi$1).flatMap(([r2, i]) => i.map((s2) => `${r2}/${s2}`)).includes(t)) return true;\n  for (let [r2, i] of gi$1.entries()) if (i === t && !e.includes(r2)) return true;\n  return false;\n}\nfunction Lr$1(n252) {\n  let e = n252.toLowerCase();\n  for (let [t, r2] of Object.entries(hi$1)) for (let i of r2) if (e === `${t}/${i}`) return i;\n  for (let [t, r2] of gi$1.entries()) if (r2 === e) return t;\n  return \"\";\n}\nfunction bi$1() {\n  let n252 = globalThis;\n  return n252?.process?.env?.NEXT_RUNTIME === \"nodejs\" ? \"nextjs\" : n252?.process?.env?.NEXT_RUNTIME === \"edge\" ? \"nextjs-edge\" : typeof window < \"u\" && window.__NEXT_DATA__ ? \"nextjs-client\" : getRuntimeKey();\n}\nfunction to$1(n252) {\n  return bi$1().startsWith(\"nextjs\") && (eo$1.redirects_non_fq = false), eo$1[n252];\n}\nfunction xi$1(n252, e) {\n  if (!n252) throw new Error(e);\n}\nfunction za() {\n  try {\n    let n252 = process || {}, e = n252.argv || [], t = n252.env || {};\n    return !(t.NO_COLOR || e.includes(\"--no-color\")) && (!!t.FORCE_COLOR || e.includes(\"--color\") || n252.platform === \"win32\" || (n252.stdout || {}).isTTY && t.TERM !== \"dumb\" || !!t.CI);\n  } catch {\n    return false;\n  }\n}\nfunction Ga(n252, e) {\n  let t = za(), r2 = Ei$1[n252], i = r2.color(`[${r2.prefix}]`), s2 = e.map((o) => \"args_color\" in r2 && t && typeof o == \"string\" ? r2.args_color(o) : o);\n  return r2.original(i, te$3.default.gray(Kr$1()), ...s2);\n}\nfunction Va(n252) {\n  let e = \"\";\n  typeof n252 == \"string\" ? e = n252 : n252 instanceof Headers ? e = n252.get(\"Content-Disposition\") || \"\" : n252 instanceof Request && (e = n252.headers.get(\"Content-Disposition\") || \"\");\n  let t = e.match(/filename\\*?=(?:UTF-8'')?(\"?)([^\";]+)\\1/);\n  return t ? t[2] : void 0;\n}\nfunction Wa(n252) {\n  return typeof n252 == \"object\" && n252 !== null && typeof n252.getReader == \"function\";\n}\nfunction Jr$1(n252) {\n  return typeof n252 == \"object\" && n252 !== null && typeof n252.arrayBuffer == \"function\" && typeof n252.type == \"string\";\n}\nfunction Ae$2(n252) {\n  return Jr$1(n252) && typeof n252.name == \"string\" && typeof n252.lastModified == \"number\";\n}\nfunction Ha(n252) {\n  return typeof n252 == \"object\" && n252 !== null && Object.prototype.toString.call(n252) === \"[object ArrayBuffer]\";\n}\nfunction Ya(n252) {\n  return typeof n252 == \"object\" && n252 !== null && ArrayBuffer.isView(n252);\n}\nasync function Za(n252) {\n  if (!n252) return;\n  let e;\n  if (Wa(n252)) {\n    let r2 = n252.getReader(), { value: i } = await r2.read();\n    if (!i) return;\n    e = new Uint8Array(i);\n  } else if (Jr$1(n252) || Ae$2(n252)) e = new Uint8Array(await n252.slice(0, 12).arrayBuffer());\n  else if (Ha(n252)) e = new Uint8Array(n252);\n  else if (Ya(n252)) e = new Uint8Array(n252.buffer, n252.byteOffset, n252.byteLength);\n  else if (typeof n252 == \"string\") e = new TextEncoder().encode(n252);\n  else return;\n  let t = Array.from(e.slice(0, 12)).map((r2) => r2.toString(16).padStart(2, \"0\").toUpperCase()).join(\"\");\n  for (let [r2, i] of Object.entries(Xa)) if (new RegExp(\"^\" + r2.replace(/\\?\\?/g, \"..\")).test(t)) return i;\n}\nasync function zr$1(n252) {\n  let e = n252.req.header(\"Content-Type\") ?? \"application/octet-stream\";\n  if (e?.startsWith(\"multipart/form-data\") || e?.startsWith(\"application/x-www-form-urlencoded\")) try {\n    let t = await n252.req.formData();\n    if ([...t.values()].length > 0) {\n      let r2 = [...t.values()][0];\n      return await oo(r2);\n    }\n  } catch (t) {\n    m$1.warn(\"Error parsing form data\", t);\n  }\n  else try {\n    let t = await n252.req.blob();\n    if (Ae$2(t)) return t;\n    if (Jr$1(t)) return await oo(t, { name: Va(n252.req.raw), type: e });\n  } catch (t) {\n    m$1.warn(\"Error parsing blob\", t);\n  }\n  throw new Error(\"No file found in request\");\n}\nasync function ao$1(n252, e) {\n  let t = Ae$2(n252), r2 = t ? n252.type : e;\n  xi$1(r2 && typeof r2 == \"string\" && r2.startsWith(\"image/\"), \"type must be image/*\");\n  let i = t ? await n252.arrayBuffer() : n252;\n  xi$1(i.byteLength >= 128, \"Buffer must be at least 128 bytes\");\n  let s2 = new DataView(i);\n  if (r2 === \"image/jpeg\") {\n    let o = 2;\n    for (; o < s2.byteLength; ) {\n      let c = s2.getUint16(o);\n      if (o += 2, c === 65472 || c === 65474) return { width: s2.getUint16(o + 5), height: s2.getUint16(o + 3) };\n      o += s2.getUint16(o);\n    }\n  } else {\n    if (r2 === \"image/png\") return { width: s2.getUint32(16), height: s2.getUint32(20) };\n    if (r2 === \"image/gif\") return { width: s2.getUint16(6), height: s2.getUint16(8) };\n    if (r2 === \"image/tiff\") {\n      let o = s2.getUint16(0) === 18761, c = s2.getUint32(4, o), a2 = s2.getUint32(c + 18, o), l2 = s2.getUint32(c + 10, o);\n      return { width: a2, height: l2 };\n    }\n  }\n  throw new Error(\"Unsupported image format\");\n}\nasync function oo(n252, e = {}) {\n  if (Ae$2(n252)) return n252;\n  if (!Jr$1(n252)) throw new Error(\"Not a Blob\");\n  let t = Ur$1(e.type, [\"application/octet-stream\"]) ? e.type : await Za(n252), r2 = t ? Lr$1(t) : \"\", i = e.name || [Dr$1(16), r2].filter(Boolean).join(\".\");\n  return new File([n252], i, { type: t || Zs(i), lastModified: Date.now() });\n}\nfunction Gr$1(n252) {\n  let e = structuredClone(n252);\n  return ar$1(e, false), e;\n}\nfunction ar$1(n252, e = true) {\n  if (typeof n252 == \"object\" && n252 !== null && !Array.isArray(n252)) {\n    e ? n252[Ti$1] = true : delete n252[Ti$1];\n    for (let t in n252) typeof n252[t] == \"object\" && n252[t] !== null && ar$1(n252[t], e);\n  }\n}\nfunction _$2(n252, e, t) {\n  if (!t?.forceParse && typeof e == \"object\" && Ti$1 in e) return t?.useDefaults === false ? e : Default(n252, e);\n  let r2 = t?.useDefaults === false ? e : Default(n252, e);\n  if (Check(n252, r2)) return t?.skipMark !== true && ar$1(r2, true), r2;\n  if (t?.onError) t.onError(Errors(n252, e));\n  else throw new De$2(n252, e);\n}\nfunction nc(n252) {\n  n252.Set(\"StringEnum\", (e, t) => typeof t == \"string\" && e.enum.includes(t));\n}\nfunction Kr$1(n252) {\n  return ze$2(n252).format(\"YYYY-MM-DD HH:mm:ss\");\n}\nfunction po(n252) {\n  return (n252 ? new Date(n252) : /* @__PURE__ */ new Date()).toISOString().replace(\"T\", \" \").split(\".\")[0];\n}\nfunction uo() {\n  return (/* @__PURE__ */ new Date()).getTimezoneOffset();\n}\nfunction mo() {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\nasync function fo(n252, e, t, r2) {\n  if (!sc.includes(n252)) throw new Error(`Invalid hash algorithm: ${n252}`);\n  let i = new TextEncoder().encode((t ?? \"\") + e + (r2 ?? \"\")), s2 = await crypto.subtle.digest(n252, i);\n  return Array.from(new Uint8Array(s2)).map((c) => c.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction yo(n252) {\n  let e = new Uint8Array(n252);\n  return crypto.getRandomValues(e), Array.from(e, (t) => String.fromCharCode(33 + t % 94)).join(\"\");\n}\nfunction ho() {\n  return v4();\n}\nfunction go() {\n  return v7();\n}\nfunction Wr$1(n252) {\n  return n252.map((e) => We$3(e));\n}\nfunction Sc(n252) {\n  return n252.map((e) => Literal(e));\n}\nfunction vc(n252) {\n  return IntersectEvaluated(Wr$1(n252.allOf), n252);\n}\nfunction Oc(n252) {\n  return UnionEvaluated(Wr$1(n252.anyOf), n252);\n}\nfunction Rc(n252) {\n  return UnionEvaluated(Wr$1(n252.oneOf), n252);\n}\nfunction Cc(n252) {\n  return UnionEvaluated(Sc(n252.enum));\n}\nfunction Ac(n252) {\n  return Tuple(Wr$1(n252.items), n252);\n}\nfunction Fc(n252) {\n  return Array$1(We$3(n252.items), n252);\n}\nfunction _c(n252) {\n  return Literal(n252.const, n252);\n}\nfunction kc(n252) {\n  let e = globalThis.Object.getOwnPropertyNames(n252.properties).reduce((t, r2) => ({ ...t, [r2]: n252.required?.includes(r2) ? We$3(n252.properties[r2]) : Optional(We$3(n252.properties[r2])) }), {});\n  return Object$1(e, n252);\n}\nfunction We$3(n252) {\n  return pc(n252) ? vc(n252) : uc(n252) ? Oc(n252) : dc(n252) ? Rc(n252) : lc(n252) ? Cc(n252) : Tc(n252) ? kc(n252) : mc(n252) ? Ac(n252) : fc(n252) ? Fc(n252) : yc(n252) ? _c(n252) : hc(n252) ? String$1(n252) : gc(n252) ? Number$1(n252) : bc(n252) ? Integer(n252) : xc(n252) ? Boolean$1(n252) : wc(n252) ? Null(n252) : Unknown(n252 || {});\n}\nfunction Si$1(n252) {\n  return n252 == null ? 0 : typeof n252 == \"number\" ? n252 : Number.parseInt(n252, 10);\n}\nfunction Fe$1(n252) {\n  return [\"string\", \"number\", \"boolean\"].includes(typeof n252);\n}\nfunction Ri$1(n252) {\n  return [true, false, 0, 1].includes(n252);\n}\nfunction re$3(n252, e, t) {\n  return new Oi$1(n252, e, t);\n}\nfunction Eo(n252, e) {\n  let t = n252.find((r2) => r2.key === e);\n  if (!t) throw new Error(`Expression does not exist: \"${e}\"`);\n  return t;\n}\nfunction Ci$1(n252, e, t = []) {\n  let r2 = e.map((a2) => a2.key), i = Object.keys(n252), s2 = [xo], o = {};\n  if (i.some((a2) => a2.startsWith(\"$\") && !s2.includes(a2))) throw new Error(`Invalid key '${i}'. Keys must not start with '$'.`);\n  if (t.length > 0 && i.some((a2) => s2.includes(a2))) throw new Error(`Operand ${xo} can only appear at the top level.`);\n  function c(a2, l2, p2 = []) {\n    if (Eo(e, a2).valid(l2) === false) throw new Error(`Invalid value at \"${[...p2, a2].join(\".\")}\": ${l2}`);\n  }\n  __name(c, \"c\");\n  for (let [a2, l2] of Object.entries(n252)) if (a2 === \"$or\") o.$or = Ci$1(l2, e, [...t, a2]);\n  else if (Fe$1(l2)) c(\"$eq\", l2, t), o[a2] = { $eq: l2 };\n  else if (typeof l2 == \"object\") {\n    let p2 = Object.keys(l2).filter((u3) => !r2.includes(u3));\n    if (p2.length === 0) {\n      o[a2] = {};\n      for (let [u3, d2] of Object.entries(l2)) c(u3, d2, [...t, a2]), o[a2][u3] = d2;\n    } else throw new Error(`Invalid key(s) at \"${a2}\": ${p2.join(\", \")}. Expected expressions.`);\n  }\n  return o;\n}\nfunction wo(n252, e, t) {\n  let r2 = t.convert ? Ci$1(n252, e) : n252, i = { $and: [], $or: [], keys: /* @__PURE__ */ new Set() }, { $or: s2, ...o } = r2;\n  function c(a2, l2, p2, u3 = []) {\n    let d2 = Eo(e, a2);\n    if (!d2) throw new Error(`Expression does not exist: \"${a2}\"`);\n    if (!d2.valid(l2)) throw new Error(`Invalid expected value at \"${[...u3, a2].join(\".\")}\": ${l2}`);\n    return d2.validate(l2, p2, t.exp_ctx);\n  }\n  __name(c, \"c\");\n  for (let [a2, l2] of Object.entries(o)) for (let [p2, u3] of Object.entries(l2)) {\n    let d2 = t.value_is_kv ? a2 : t.object[a2];\n    i.$and.push(c(p2, u3, d2, [a2])), i.keys.add(a2);\n  }\n  for (let [a2, l2] of Object.entries(s2 ?? {})) {\n    let p2 = t.value_is_kv ? a2 : t.object[a2];\n    for (let [u3, d2] of Object.entries(l2)) i.$or.push(c(u3, d2, p2, [a2])), i.keys.add(a2);\n  }\n  return i;\n}\nfunction jc(n252) {\n  let e = { $and: void 0, $or: void 0 };\n  return e.$and = n252.$and.every((t) => !!t), e.$or = n252.$or.some((t) => !!t), !!e.$and || !!e.$or;\n}\nfunction Ai$1(n252) {\n  return { convert: /* @__PURE__ */ __name((e) => Ci$1(e, n252), \"convert\"), build: /* @__PURE__ */ __name((e, t) => wo(e, n252, t), \"build\"), validate: /* @__PURE__ */ __name((e, t) => {\n    let r2 = wo(e, n252, t);\n    return jc(r2);\n  }, \"validate\"), expressions: n252, expressionKeys: n252.map((e) => e.key) };\n}\nfunction Ft$1(n252, e, t = \"info\") {\n  n252.req.header(\"Accept\")?.includes(\"text/html\") && setCookie(n252, Ic, JSON.stringify({ type: t, message: e }), { path: \"/\" });\n}\nfunction qc(n252) {\n  return n252 === null;\n}\nfunction J$2(n252) {\n  return !Array.isArray(n252) && typeof n252 == \"object\" && n252 !== null;\n}\nfunction _e$2(n252) {\n  return typeof n252 == \"string\";\n}\nfunction qe$2(n252) {\n  return typeof n252 == \"number\";\n}\nfunction Bc(n252) {\n  return typeof n252 == \"number\" && Number.isInteger(n252);\n}\nfunction _t$1(n252) {\n  return typeof n252 == \"boolean\";\n}\nfunction Be$2(n252) {\n  return Array.isArray(n252);\n}\nfunction Nc(n252) {\n  return typeof n252 == \"string\" && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n252);\n}\nfunction Uc(n252) {\n  return typeof n252 != \"boolean\";\n}\nfunction Lc(n252) {\n  return n252 !== void 0 && Uc(n252) && \"type\" in n252;\n}\nfunction le$2(n252) {\n  return J$2(n252) && ki$1 in n252;\n}\nfunction Qc(n252) {\n  return le$2(n252) && _t$1(n252[at$1]);\n}\nfunction Fi$1(n252, e, t) {\n  if (!n252) throw new $c(e, t);\n}\nfunction $e(n252) {\n  if (Be$2(n252)) return n252.map($e).sort();\n  if (J$2(n252)) {\n    let e = Object.entries(n252).sort(([t], [r2]) => t.localeCompare(r2)).map(([t, r2]) => [t, $e(r2)]);\n    return Object.fromEntries(e);\n  }\n  return _e$2(n252) ? n252.normalize(\"NFC\") : n252;\n}\nfunction Jc(n252, e, t = void 0) {\n  let r2 = typeof e == \"string\" ? Kc(e) : _i$1(e);\n  return Oo(n252, r2, t);\n}\nfunction Oo(n252, e, t = void 0) {\n  let r2 = typeof e == \"string\" ? e.split(/[.\\[\\]\\\"]+/).filter((i) => i) : e;\n  if (r2.length === 0) return n252;\n  try {\n    let [i, ...s2] = r2;\n    return !i || !(i in n252) ? t : Oo(n252[i], s2, t);\n  } catch {\n    if (typeof t < \"u\") return t;\n    throw new Error(`Invalid path: ${r2.join(\".\")}`);\n  }\n}\nfunction ur(n252, e, t = {}) {\n  return n252.map((r2) => r2.validate(e, Yr$1(t)).valid ? r2 : void 0).filter(Boolean);\n}\nfunction Ol(n252, e, t = {}) {\n  let r2 = { keywordPath: t.keywordPath || [], instancePath: t.instancePath || [], coerce: t.coerce || false, errors: t.errors || [], shortCircuit: t.shortCircuit || false, ignoreUnsupported: t.ignoreUnsupported || false, resolver: t.resolver || new ji$1(n252), depth: t.depth ? t.depth + 1 : 0 }, i = structuredClone(t?.coerce ? n252.coerce(e, { resolver: r2.resolver, depth: r2.depth }) : e);\n  if (t.ignoreUnsupported !== true) {\n    let s2 = [\"$defs\"];\n    for (let o of s2) if (n252[o]) throw new Error(`${o} not implemented`);\n  }\n  if (r2.resolver.hasRef(n252, i)) {\n    let s2 = r2.resolver.resolve(n252.$ref).validate(i, { ...r2, errors: [] });\n    s2.valid || r2.errors.push(...s2.errors);\n  } else for (let [s2, o] of Object.entries(vl)) {\n    if (n252[s2] === void 0) continue;\n    let c = o(n252, i, { ...r2, errors: [] });\n    if (!c.valid) {\n      if (t.shortCircuit) return c;\n      r2.errors.push(...c.errors);\n    }\n  }\n  return { valid: r2.errors.length === 0, errors: r2.errors };\n}\nfunction Rl(n252, e, t = {}) {\n  let r2 = structuredClone(e), i = { resolver: t.resolver || new ji$1(n252), depth: t.depth || 0 };\n  return i.resolver.hasRef(n252, r2) ? i.resolver.resolve(n252.$ref).coerce(r2, { ...i, depth: i.depth + 1 }) : r2;\n}\nfunction Ro(n252 = {}) {\n  let e = {};\n  if (this.properties) for (let [t, r2] of Object.entries(this.properties)) {\n    if (n252.withOptional !== true && !this.required?.includes(t)) continue;\n    let i = r2.template(n252);\n    i !== void 0 && (e[t] = i);\n  }\n  return e;\n}\nfunction Co(n252, e = {}) {\n  let t = n252;\n  if (typeof t == \"string\" && (t.match(/^\\{/) || t.match(/^\\[/)) && (t = JSON.parse(t)), !(typeof t != \"object\" || t === null)) {\n    if (this.properties) for (let [r2, i] of Object.entries(this.properties)) {\n      let s2 = t[r2];\n      s2 !== void 0 && (t[r2] = i.coerce(s2, e));\n    }\n    return t;\n  }\n}\nfunction ko$1() {\n  if (this.minimum) return this.minimum;\n  if (this.exclusiveMinimum) {\n    if (this.multipleOf) {\n      let n252 = this.exclusiveMinimum;\n      for (; n252 % this.multipleOf !== 0; ) n252++;\n      return n252;\n    }\n    return this.exclusiveMinimum + 1;\n  }\n  return 0;\n}\nfunction Pl(n252, e) {\n  try {\n    let t = typeof n252 == \"string\" ? JSON.parse(n252) : n252;\n    if (!Array.isArray(t)) return;\n    if (le$2(this.items)) for (let [r2, i] of t.entries()) t[r2] = this.items.coerce(i, e);\n    return t;\n  } catch {\n  }\n  return n252;\n}\nfunction So(n252, e) {\n  return Array.isArray(n252) ? n252.map(e) : n252 !== void 0 ? [e(n252)] : [];\n}\nfunction vo(n252, e, t = (r2) => r2) {\n  return Object.fromEntries(Object.entries(n252).map(([r2, i]) => [r2, t(e(i), r2)]));\n}\nfunction ct$1(n252) {\n  if (_t$1(n252)) return B$4(!!n252);\n  let e = structuredClone(n252);\n  if (!J$2(e)) throw new Dc(\"non-object schemas not implemented\", e);\n  \"properties\" in e && e.properties && (e.properties = vo(e.properties, ct$1, (s2, o) => \"required\" in e && Array.isArray(e.required) && e.required.includes(o) ? s2 : s2.optional()));\n  let t = [\"patternProperties\", \"dependentSchemas\", \"$defs\"];\n  for (let s2 of t) s2 in e && e[s2] && (e[s2] = vo(e[s2], ct$1));\n  let r2 = [\"additionalProperties\", \"items\", \"prefixItems\", \"propertyNames\", \"contains\", \"not\", \"if\", \"then\", \"else\"];\n  for (let s2 of r2) s2 in e && typeof e[s2] < \"u\" && (Be$2(e[s2]) ? e[s2] = So(e[s2], ct$1) : e[s2] = ct$1(e[s2]));\n  let i = [\"anyOf\", \"oneOf\", \"allOf\"];\n  for (let s2 of i) if (s2 in e) {\n    let { [s2]: o } = e;\n    e[s2] = So(o, ct$1);\n  }\n  if (Lc(e)) switch (e.type) {\n    case \"string\":\n      return Ao(e);\n    case \"number\":\n      return Fo(e);\n    case \"integer\":\n      return _o(e);\n    case \"boolean\":\n      return jo$1(e);\n    case \"object\": {\n      let { properties: s2, ...o } = e;\n      return dr(s2, o);\n    }\n    case \"array\": {\n      let { items: s2, ...o } = e;\n      return Po(s2, o);\n    }\n  }\n  return B$4(e);\n}\nfunction Bl(n252) {\n  return Object.prototype.toString.call(n252) === \"[object Object]\";\n}\nfunction Nl(n252) {\n  return n252 !== null && typeof n252 == \"object\";\n}\nfunction Ii$1(n252, ...e) {\n  for (let t of e) for (let [r2, i] of Object.entries(t)) i !== void 0 && (!Bl(i) && !Array.isArray(i) || Array.isArray(i) && !Array.isArray(n252[r2]) ? n252[r2] = i : Nl(n252[r2]) ? Ii$1(n252[r2], i) : n252[r2] = i);\n  return n252;\n}\nfunction Zr$1(n252, e) {\n  let t = Ul[e], r2 = Ll[e];\n  return t ? { parameters: Object.entries(n252.properties).map(([i, s2]) => ({ name: i, in: t, required: n252.required?.includes(i) || void 0, description: s2.description || void 0, schema: structuredClone(s2.toJSON()) })) } : r2 ? { requestBody: { content: { [r2.type]: { schema: structuredClone(n252.toJSON()), example: n252.examples?.[0] ?? n252.template({ withOptional: true }) } } } } : {};\n}\nfunction ve$3(n252) {\n  if (typeof n252 != \"string\") throw new Error(`Invalid key: ${n252}`);\n  return n252;\n}\nfunction Oe$2(n252) {\n  return new ue$2(\"text\", n252, false);\n}\nfunction gr$1(n252) {\n  return new ue$2(\"number\", n252, false);\n}\nfunction br$1(n252) {\n  return new ue$2(\"date\", { ...n252, type: \"datetime\" }, false);\n}\nfunction Ko(n252) {\n  return new ue$2(\"boolean\", n252, false);\n}\nfunction xr$1(n252) {\n  let t = { options: { type: typeof n252?.enum?.[0] != \"string\" ? \"objects\" : \"strings\", values: n252?.enum ?? [] } };\n  return new ue$2(\"enumm\", t, false);\n}\nfunction Jo(n252) {\n  return new ue$2(\"json\", n252, false);\n}\nfunction zo(n252) {\n  return new ue$2(\"jsonSchema\", n252, false);\n}\nfunction Go(n252, e) {\n  if (e instanceof ue$2) return e.make(n252);\n  throw new Error(\"Invalid field\");\n}\nfunction qt$1(n252, e, t, r2) {\n  let i = [];\n  for (let [s2, o] of Object.entries(e)) {\n    let c = o, a2 = { entity: { name: n252, fields: e }, field_name: s2, config: c.config, is_required: c.is_required };\n    i.push(c.getField(a2));\n  }\n  return new Z$1(n252, i, t, r2);\n}\nfunction xp(n252) {\n  return { manyToOne: /* @__PURE__ */ __name((e, t) => new Se$1(n252, e, t), \"manyToOne\"), oneToOne: /* @__PURE__ */ __name((e, t) => new ft$1(n252, e, t), \"oneToOne\"), manyToMany: /* @__PURE__ */ __name((e, t, r2) => {\n    let i = [];\n    if (r2) {\n      let s2 = r2, o = [], c = t?.connectionTable ?? ie$2.defaultConnectionTable(n252, e);\n      for (let [a2, l2] of Object.entries(r2)) {\n        let p2 = l2, u3 = { entity: { name: c, fields: s2 }, field_name: a2, config: p2.config, is_required: p2.is_required };\n        o.push(p2.getField(u3));\n      }\n      i.push(o);\n    }\n    return new ie$2(n252, e, t, i);\n  }, \"manyToMany\"), polyToOne: /* @__PURE__ */ __name((e, t) => new tt(n252, e, { ...t, targetCardinality: 1 }), \"polyToOne\"), polyToMany: /* @__PURE__ */ __name((e, t) => new tt(n252, e, t), \"polyToMany\") };\n}\nfunction wp(n252) {\n  return { on: /* @__PURE__ */ __name((e, t) => {\n    let r2 = e.map((i) => {\n      let s2 = n252.field(i);\n      if (!s2) throw new Error(`Field \"${String(i)}\" not found on entity \"${n252.name}\"`);\n      return s2;\n    });\n    return new Dt$1(n252, r2, t);\n  }, \"on\") };\n}\nfunction gn$1(n252, e) {\n  let t = [], r2 = [], i = /* @__PURE__ */ __name((c) => new Proxy(xp(c), { get(a2, l2) {\n    return (...p2) => (t.push(a2[l2](...p2)), i(c));\n  } }), \"i\"), s2 = /* @__PURE__ */ __name((c) => new Proxy(wp(c), { get(a2, l2) {\n    return (...p2) => (r2.push(a2[l2](...p2)), s2(c));\n  } }), \"s\");\n  e && e({ relation: i, index: s2 }, n252);\n  let o = new ps$1(n252, t, r2);\n  return { DB: o.__entities, entities: o.__entities, relations: t, indices: r2, proto: o, toJSON: /* @__PURE__ */ __name(() => o.toJSON(), \"toJSON\") };\n}\nfunction ys$1(n252, e) {\n  let t = O$2(e.fields ?? {}, (r2, i) => {\n    let { type: s2 } = r2;\n    if (!(s2 in Sn)) throw new Error(`Field type \"${s2}\" not found`);\n    let { field: o } = Sn[s2];\n    return new o(i, r2.config);\n  });\n  return new Z$1(n252, Object.values(t), e.config, e.type);\n}\nfunction hs(n252, e) {\n  return new Ho[n252.type].cls(e(n252.source), e(n252.target), n252.config);\n}\nfunction bs(n252) {\n  let e = n252 instanceof Request ? n252 : n252.req.raw;\n  return new URL(e.url).pathname;\n}\nfunction Yp(n252, e) {\n  let t = n252.get(\"auth\");\n  if (!t) throw new Error(\"auth ctx not found\");\n  if (t.skip) return true;\n  let r2 = n252.req.raw;\n  if (!e) return false;\n  let i = bs(r2), s2 = e.some((o) => Hs(i, o));\n  return t.skip = s2, s2;\n}\nfunction Ss(n252) {\n  return n252 !== null && n252.constructor.name === \"Object\";\n}\nfunction oa(n252) {\n  try {\n    return n252 == null || typeof n252 == \"string\" || typeof n252 == \"number\" || typeof n252 == \"boolean\" || Array.isArray(n252) || Ss(n252);\n  } catch {\n    return false;\n  }\n}\nfunction aa(n252, e) {\n  let t = [];\n  function r2(i, s2, o) {\n    if (!oa(i) || !oa(s2)) throw new Error(\"Diff: Only primitive types are supported\");\n    if (i !== s2) if (typeof i != typeof s2) t.push({ t: \"e\", p: o, o: i, n: s2 });\n    else if (Array.isArray(i) && Array.isArray(s2)) {\n      let c = Math.max(i.length, s2.length);\n      for (let a2 = 0; a2 < c; a2++) a2 >= i.length ? t.push({ t: \"a\", p: [...o, a2], o: void 0, n: s2[a2] }) : a2 >= s2.length ? t.push({ t: \"r\", p: [...o, a2], o: i[a2], n: void 0 }) : r2(i[a2], s2[a2], [...o, a2]);\n    } else if (Ss(i) && Ss(s2)) {\n      let c = Object.keys(i), a2 = Object.keys(s2), l2 = /* @__PURE__ */ new Set([...c, ...a2]);\n      for (let p2 of l2) p2 in i ? p2 in s2 ? r2(i[p2], s2[p2], [...o, p2]) : t.push({ t: \"r\", p: [...o, p2], o: i[p2], n: void 0 }) : t.push({ t: \"a\", p: [...o, p2], o: void 0, n: s2[p2] });\n    } else t.push({ t: \"e\", p: o, o: i, n: s2 });\n  }\n  __name(r2, \"r\");\n  return r2(n252, e, []), t;\n}\nfunction ca2(n252, e) {\n  let t = zt$1(n252);\n  for (let r2 of e) wu(t, r2);\n  return t;\n}\nfunction wu(n252, e) {\n  let { p: t, t: r2, n: i } = e, s2 = Eu(n252, t.slice(0, -1)), o = t[t.length - 1];\n  r2 === \"a\" || r2 === \"e\" ? s2[o] = i : r2 === \"r\" && (Array.isArray(s2) ? s2.splice(o, 1) : delete s2[o]);\n}\nfunction Eu(n252, e) {\n  let t = n252;\n  for (let r2 of e) t[r2] === void 0 && (t[r2] = typeof r2 == \"number\" ? [] : {}), t = t[r2];\n  return t;\n}\nfunction zt$1(n252) {\n  return JSON.parse(JSON.stringify(n252));\n}\nasync function vu(n252, e, t, r2) {\n  let i = vs.filter((a2) => a2.version > n252 && a2.version <= e), s2 = Object.assign({}, t), o = 0, c = n252;\n  for (let a2 of i) try {\n    s2 = await a2.up(s2, r2), c = a2.version, o++;\n  } catch (l2) {\n    throw console.error(l2), new Error(`Migration ${a2.version} failed: ${l2.message}`);\n  }\n  return [c, s2];\n}\nasync function pa(n252, e, t) {\n  return vu(n252, Gt$1, e, t);\n}\nfunction xt$1(n252, e) {\n  let t = /* @__PURE__ */ __name((s2) => {\n    if (typeof s2 == \"string\") switch (n252.type) {\n      case \"object\":\n      case \"array\":\n        return JSON.parse(s2);\n      case \"number\":\n        return Number.parseInt(s2);\n      case \"boolean\":\n        return s2 === \"true\" || s2 === \"1\";\n    }\n    return s2;\n  }, \"t\"), r2 = /* @__PURE__ */ __name((s2) => typeof s2 == \"string\" ? e ? e(s2) : t(s2) : s2, \"r\"), i = n252.title ?? n252.type ? Vs(n252.type) : \"Raw\";\n  return In.Transform(In.Union([{ title: i, ...n252 }, In.String({ title: \"Template\" })])).Decode(r2).Encode((s2) => s2);\n}\nfunction Xu(n252) {\n  if (!n252.includes(\".\")) return;\n  let e = n252.split(\".\");\n  return e[e.length - 1]?.toLowerCase();\n}\nfunction Ps(n252, e = 16) {\n  let t = typeof n252 == \"string\" ? n252 : n252.name;\n  if (typeof t != \"string\") throw console.error(\"Couldn't extract filename from\", n252), new Error(\"Invalid file name\");\n  let r2 = Xu(t);\n  if (!r2 && Ae$2(n252) && n252.type) {\n    let i = Lr$1(n252.type);\n    i.length > 0 && (r2 = i);\n  }\n  return [Dr$1(e), r2].filter(Boolean).join(\".\");\n}\nfunction Is() {\n  let n252 = ze$1(Ms.all(), (t, r2) => Ie$2.Object({ type: be$2(r2), config: t.schema }, { title: t.schema?.title ?? r2, description: t.schema?.description, additionalProperties: false })), e = Ie$2.Union(Object.values(n252));\n  return Ie$2.Object({ enabled: Ie$2.Boolean({ default: false }), basepath: Ie$2.String({ default: \"/api/media\" }), entity_name: Ie$2.String({ default: \"media\" }), storage: Ie$2.Object({ body_max_size: Ie$2.Optional(Ie$2.Number({ description: \"Max size of the body in bytes. Leave blank for unlimited.\" })) }, { default: {} }), adapter: Ie$2.Optional(e) }, { additionalProperties: false });\n}\nfunction Sa() {\n  return { type: \"object\", ...O$2(kr$1, (e) => e.prototype.getSchema()) };\n}\nfunction va() {\n  return O$2(kr$1, (e) => Default(e.prototype.getSchema(), {}));\n}\nfunction ud(n252, e, t) {\n  let r2 = typeof t < \"u\" ? t : e, i = [\"raw\", \"body\", \"ok\", \"status\", \"res\", \"data\", \"toJSON\"];\n  return typeof r2 != \"object\" && (r2 = {}), new Proxy(r2, { get(s2, o, c) {\n    return o === \"raw\" || o === \"res\" ? n252 : o === \"body\" ? e : o === \"data\" ? t : o === \"ok\" ? n252.ok : o === \"status\" ? n252.status : o === \"toJSON\" ? () => s2 : Reflect.get(s2, o, c);\n  }, has(s2, o) {\n    return i.includes(o) ? true : Reflect.has(s2, o);\n  }, ownKeys(s2) {\n    return Array.from(/* @__PURE__ */ new Set([...Reflect.ownKeys(s2), ...i]));\n  }, getOwnPropertyDescriptor(s2, o) {\n    return i.includes(o) ? { configurable: true, enumerable: true, value: Reflect.get({ raw: n252, body: e, ok: n252.ok, status: n252.status }, o) } : Reflect.getOwnPropertyDescriptor(s2, o);\n  } });\n}\nfunction md(n252, e) {\n  if (!n252) return null;\n  for (let t of n252.split(\"; \")) {\n    let [r2, i] = t.split(\"=\");\n    if (r2 === e && i) return decodeURIComponent(i);\n  }\n  return null;\n}\nfunction Ca(n252 = {}) {\n  let e;\n  try {\n    we$2.isConnection(n252.connection) ? e = n252.connection : typeof n252.connection == \"object\" ? \"type\" in n252.connection ? (m$1.warn(\"Using deprecated connection type 'libsql', use the 'config' object directly.\"), e = new yt$1(n252.connection.config)) : e = new yt$1(n252.connection) : (e = new yt$1({ url: \":memory:\" }), m$1.warn(\"No connection provided, using in-memory database\"));\n  } catch (t) {\n    m$1.error(\"Could not create connection\", t);\n  }\n  if (!e) throw new Error(\"Invalid connection\");\n  return new ii$1(e, n252.initialConfig, n252.options);\n}\nfunction d$2(r2, n27) {\n  let t = {}, { app: e, ...i } = r2;\n  if (e) if (typeof e == \"function\") {\n    if (!n27) throw new Error(\"args is required when config.app is a function\");\n    t = e(n27);\n  } else t = e;\n  return { ...i, ...t };\n}\nasync function s$1(r2 = {}, n27, t) {\n  let e = t?.id ?? \"app\", i = a$1.get(e);\n  return (!i || t?.force) && (i = ii$1.create(d$2(r2, n27)), a$1.set(e, i)), i;\n}\nasync function C$1(r2 = {}, n27, t) {\n  let e = await s$1(r2, n27, t);\n  return e.isBuilt() || (r2.onBuilt && e.emgr.onEvent(ii$1.Events.AppBuiltEvent, async () => {\n    await r2.onBuilt?.(e);\n  }, \"sync\"), await r2.beforeBuild?.(e), await e.build(r2.buildConfig)), e;\n}\nasync function s(r2 = {}, n27 = {}, t = {}) {\n  return await C$1(r2, n27 ?? Object.assign(__vite_import_meta_env__2, {}), t);\n}\nfunction v$3(r2 = {}, n27 = {}, t) {\n  return async (o) => (await s(r2, n27, t)).fetch(o.request);\n}\nfunction Ue$1() {\n  try {\n    let e2 = process || {}, r2 = e2.argv || [], n27 = e2.env || {};\n    return !(n27.NO_COLOR || r2.includes(\"--no-color\")) && (!!n27.FORCE_COLOR || r2.includes(\"--color\") || e2.platform === \"win32\" || (e2.stdout || {}).isTTY && n27.TERM !== \"dumb\" || !!n27.CI);\n  } catch {\n    return false;\n  }\n}\nfunction ve$2(e2, r2) {\n  let n27 = Ue$1(), t = U$2[e2], o = t.color(`[${t.prefix}]`), s2 = r2.map((f2) => \"args_color\" in t && n27 && typeof f2 == \"string\" ? t.args_color(f2) : f2);\n  return t.original(o, y$2.default.gray(ie$1()), ...s2);\n}\nfunction E$2(e2) {\n  return typeof e2 == \"object\" && e2 !== null && typeof e2.arrayBuffer == \"function\" && typeof e2.type == \"string\";\n}\nfunction A$3(e2) {\n  return E$2(e2) && typeof e2.name == \"string\" && typeof e2.lastModified == \"number\";\n}\nfunction B$3(e2, r2 = true) {\n  if (typeof e2 == \"object\" && e2 !== null && !Array.isArray(e2)) {\n    r2 ? e2[L$3] = true : delete e2[L$3];\n    for (let n27 in e2) typeof e2[n27] == \"object\" && e2[n27] !== null && B$3(e2[n27], r2);\n  }\n}\nfunction qe$1(e2, r2, n27) {\n  if (typeof r2 == \"object\" && L$3 in r2) return n27?.useDefaults === false ? r2 : Default(e2, r2);\n  let t = n27?.useDefaults === false ? r2 : Default(e2, r2);\n  if (Check(e2, t)) return B$3(t, true), t;\n  throw new w$3(e2, r2);\n}\nfunction We$2(e2) {\n  e2.Set(\"StringEnum\", (r2, n27) => typeof n27 == \"string\" && r2.enum.includes(n27));\n}\nfunction ie$1(e2) {\n  return ze$2(e2).format(\"YYYY-MM-DD HH:mm:ss\");\n}\nfunction Yn$1(e2) {\n  let r2 = new Uint8Array(e2);\n  return crypto.getRandomValues(r2), Array.from(r2, (n27) => String.fromCharCode(33 + n27 % 94)).join(\"\");\n}\nfunction je$1(r2) {\n  return r2 ? { ...Object.fromEntries(r2.entries()) } : {};\n}\nfunction H$2(r2, e) {\n  let t = je$1(r2), n27 = {};\n  for (let s2 of e) t[s2] && (n27[s2] = t[s2]);\n  return n27;\n}\nfunction ee$1(r2, e) {\n  let t = new Headers();\n  for (let n27 of e) r2.has(n27) && t.set(n27, r2.get(n27));\n  return t;\n}\nfunction M$2() {\n  try {\n    return S$1(0);\n  } catch {\n    return false;\n  }\n}\nfunction te$1(r2) {\n  return r2.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction P$2(r2, e = []) {\n  return r2 === null || typeof r2 != \"object\" ? r2 : Array.isArray(r2) ? r2.map((t) => P$2(t, e)) : Object.keys(r2).reduce((t, n27) => {\n    let s2 = e.includes(n27) ? n27 : te$1(n27);\n    return t[s2] = P$2(r2[n27], e), t;\n  }, {});\n}\nfunction re$1(r2) {\n  return new XMLParser().parse(r2);\n}\nfunction Le$1(r2) {\n  try {\n    let e = r2.split(\".\").pop();\n    if (!e) return l$1.a();\n    for (let [t, n27] of Object.entries($$2)) if (n27.includes(e)) return `${t}/${e}`;\n    return z$1.get(e);\n  } catch {\n    return l$1.a();\n  }\n}\nfunction Ie$1() {\n  try {\n    let r2 = process || {}, e = r2.argv || [], t = r2.env || {};\n    return !(t.NO_COLOR || e.includes(\"--no-color\")) && (!!t.FORCE_COLOR || e.includes(\"--color\") || r2.platform === \"win32\" || (r2.stdout || {}).isTTY && t.TERM !== \"dumb\" || !!t.CI);\n  } catch {\n    return false;\n  }\n}\nfunction Ne(r2, e) {\n  let t = Ie$1(), n27 = q$1[r2], s2 = n27.color(`[${n27.prefix}]`), i = e.map((o) => \"args_color\" in n27 && t && typeof o == \"string\" ? n27.args_color(o) : o);\n  return n27.original(s2, d$1.default.gray(le$1()), ...i);\n}\nfunction De$1(r2) {\n  return typeof r2 == \"object\" && r2 !== null && typeof r2.arrayBuffer == \"function\" && typeof r2.type == \"string\";\n}\nfunction m(r2) {\n  return De$1(r2) && typeof r2.name == \"string\" && typeof r2.lastModified == \"number\";\n}\nfunction pe$1(r2, e = true) {\n  if (typeof r2 == \"object\" && r2 !== null && !Array.isArray(r2)) {\n    e ? r2[G$1] = true : delete r2[G$1];\n    for (let t in r2) typeof r2[t] == \"object\" && r2[t] !== null && pe$1(r2[t], e);\n  }\n}\nfunction L$2(r2, e, t) {\n  if (typeof e == \"object\" && G$1 in e) return t?.useDefaults === false ? e : Default(r2, e);\n  let n27 = t?.useDefaults === false ? e : Default(r2, e);\n  if (Check(r2, n27)) return pe$1(n27, true), n27;\n  throw new Y$1(r2, e);\n}\nfunction Be$1(r2) {\n  r2.Set(\"StringEnum\", (e, t) => typeof t == \"string\" && e.enum.includes(t));\n}\nfunction le$1(r2) {\n  return ze$2(r2).format(\"YYYY-MM-DD HH:mm:ss\");\n}\nasync function me$1(r2, e, t, n27) {\n  if (!ze.includes(r2)) throw new Error(`Invalid hash algorithm: ${r2}`);\n  let s2 = new TextEncoder().encode((t ?? \"\") + e + (n27 ?? \"\")), i = await crypto.subtle.digest(r2, s2);\n  return Array.from(new Uint8Array(i)).map((a2) => a2.toString(16).padStart(2, \"0\")).join(\"\");\n}\nfunction Z() {\n  try {\n    let t = process || {}, e = t.argv || [], r2 = t.env || {};\n    return !(r2.NO_COLOR || e.includes(\"--no-color\")) && (!!r2.FORCE_COLOR || e.includes(\"--color\") || t.platform === \"win32\" || (t.stdout || {}).isTTY && r2.TERM !== \"dumb\" || !!r2.CI);\n  } catch {\n    return false;\n  }\n}\nfunction X$1(t, e) {\n  let r2 = Z(), n27 = u2[t], o = n27.color(`[${n27.prefix}]`), i = e.map((s2) => \"args_color\" in n27 && r2 && typeof s2 == \"string\" ? n27.args_color(s2) : s2);\n  return n27.original(o, a.default.gray(L$1()), ...i);\n}\nfunction L$1(t) {\n  return ze$2(t).format(\"YYYY-MM-DD HH:mm:ss\");\n}\nfunction T() {\n  return F$1 || (js.media.register(\"local\", l), F$1 = true), (t = {}) => new l(t).toJSON(true);\n}\nfunction Ie(n122) {\n  return !n122 || n122.length === 0 ? n122 : n122.split(\"_\").map((e) => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()).join(\" \");\n}\nfunction Le(n122) {\n  return n122 !== null && typeof n122 == \"object\";\n}\nfunction Ke2(n122, e) {\n  return Object.entries(n122).reduce((t, [r2, i]) => {\n    let o = e(i, r2);\n    return typeof o < \"u\" && (t[r2] = o), t;\n  }, {});\n}\nfunction nt2(n122, e = 0, t = 0) {\n  let r2 = e ? `\n` : \"\", i = /* @__PURE__ */ __name((a2) => e ? \" \".repeat(e * a2) : \"\", \"i\"), o = i(t + 1), s2 = i(t);\n  if (n122 === null) return \"null\";\n  if (n122 === void 0) return \"undefined\";\n  let l2 = typeof n122;\n  if (l2 === \"string\") return JSON.stringify(n122);\n  if (l2 === \"number\" || l2 === \"boolean\") return String(n122);\n  if (Array.isArray(n122)) {\n    let a2 = n122.map((c) => nt2(c, e, t + 1)).join(\", \" + (e ? r2 + o : \"\"));\n    return \"[\" + (e && n122.length ? r2 + o : \"\") + a2 + (e && n122.length ? r2 + s2 : \"\") + \"]\";\n  }\n  if (l2 === \"object\") {\n    let a2 = Object.entries(n122).map(([u3, f2]) => (/^[A-Za-z_$][\\w$]*$/.test(u3) ? u3 : JSON.stringify(u3)) + \": \" + nt2(f2, e, t + 1)), c = a2.join(\", \" + (e ? r2 + o : \"\"));\n    return \"{\" + (e && a2.length ? r2 + o : \"\") + c + (e && a2.length ? r2 + s2 : \"\") + \"}\";\n  }\n  throw new TypeError(`Unsupported data type: ${l2}`);\n}\nfunction vr() {\n  try {\n    let n122 = process || {}, e = n122.argv || [], t = n122.env || {};\n    return !(t.NO_COLOR || e.includes(\"--no-color\")) && (!!t.FORCE_COLOR || e.includes(\"--color\") || n122.platform === \"win32\" || (n122.stdout || {}).isTTY && t.TERM !== \"dumb\" || !!t.CI);\n  } catch {\n    return false;\n  }\n}\nfunction Or2(n122, e) {\n  let t = vr(), r2 = Pt2[n122], i = r2.color(`[${r2.prefix}]`), o = e.map((s2) => \"args_color\" in r2 && t && typeof s2 == \"string\" ? r2.args_color(s2) : s2);\n  return r2.original(i, D.default.gray(Mn2()), ...o);\n}\nfunction Dn2(n122, e = true) {\n  if (typeof n122 == \"object\" && n122 !== null && !Array.isArray(n122)) {\n    e ? n122[It2] = true : delete n122[It2];\n    for (let t in n122) typeof n122[t] == \"object\" && n122[t] !== null && Dn2(n122[t], e);\n  }\n}\nfunction _e(n122, e, t) {\n  if (typeof e == \"object\" && It2 in e) return t?.useDefaults === false ? e : Default(n122, e);\n  let r2 = t?.useDefaults === false ? e : Default(n122, e);\n  if (Check(n122, r2)) return Dn2(r2, true), r2;\n  throw new Ve(n122, e);\n}\nfunction $r(n122) {\n  n122.Set(\"StringEnum\", (e, t) => typeof t == \"string\" && e.enum.includes(t));\n}\nfunction Mn2(n122) {\n  return ze$2(n122).format(\"YYYY-MM-DD HH:mm:ss\");\n}\nfunction An2() {\n  return v7();\n}\nfunction ot(n122) {\n  return n122.map((e) => de2(e));\n}\nfunction Ur(n122) {\n  return n122.map((e) => Literal(e));\n}\nfunction Wr(n122) {\n  return IntersectEvaluated(ot(n122.allOf), n122);\n}\nfunction Gr(n122) {\n  return UnionEvaluated(ot(n122.anyOf), n122);\n}\nfunction Hr(n122) {\n  return UnionEvaluated(ot(n122.oneOf), n122);\n}\nfunction Yr(n122) {\n  return UnionEvaluated(Ur(n122.enum));\n}\nfunction Zr(n122) {\n  return Tuple(ot(n122.items), n122);\n}\nfunction Xr(n122) {\n  return Array$1(de2(n122.items), n122);\n}\nfunction ei2(n122) {\n  return Literal(n122.const, n122);\n}\nfunction ti2(n122) {\n  let e = globalThis.Object.getOwnPropertyNames(n122.properties).reduce((t, r2) => ({ ...t, [r2]: n122.required?.includes(r2) ? de2(n122.properties[r2]) : Optional(de2(n122.properties[r2])) }), {});\n  return Object$1(e, n122);\n}\nfunction de2(n122) {\n  return jr(n122) ? Wr(n122) : Mr(n122) ? Gr(n122) : Br(n122) ? Hr(n122) : kr(n122) ? Yr(n122) : zr(n122) ? ti2(n122) : Dr(n122) ? Zr(n122) : Ar2(n122) ? Xr(n122) : qr(n122) ? ei2(n122) : Nr(n122) ? String$1(n122) : Qr(n122) ? Number$1(n122) : Lr(n122) ? Integer(n122) : Kr(n122) ? Boolean$1(n122) : Vr(n122) ? Null(n122) : Unknown(n122 || {});\n}\nfunction kt(n122) {\n  return n122 == null ? 0 : typeof n122 == \"number\" ? n122 : Number.parseInt(n122, 10);\n}\nfunction X(n122) {\n  return [\"string\", \"number\", \"boolean\"].includes(typeof n122);\n}\nfunction Mt2(n122) {\n  return [true, false, 0, 1].includes(n122);\n}\nfunction A2(n122, e, t) {\n  return new jt2(n122, e, t);\n}\nfunction Qn(n122, e) {\n  let t = n122.find((r2) => r2.key === e);\n  if (!t) throw new Error(`Expression does not exist: \"${e}\"`);\n  return t;\n}\nfunction Bt2(n122, e, t = []) {\n  let r2 = e.map((a2) => a2.key), i = Object.keys(n122), o = [qn2], s2 = {};\n  if (i.some((a2) => a2.startsWith(\"$\") && !o.includes(a2))) throw new Error(`Invalid key '${i}'. Keys must not start with '$'.`);\n  if (t.length > 0 && i.some((a2) => o.includes(a2))) throw new Error(`Operand ${qn2} can only appear at the top level.`);\n  function l2(a2, c, u3 = []) {\n    if (Qn(e, a2).valid(c) === false) throw new Error(`Invalid value at \"${[...u3, a2].join(\".\")}\": ${c}`);\n  }\n  __name(l2, \"l\");\n  for (let [a2, c] of Object.entries(n122)) if (a2 === \"$or\") s2.$or = Bt2(c, e, [...t, a2]);\n  else if (X(c)) l2(\"$eq\", c, t), s2[a2] = { $eq: c };\n  else if (typeof c == \"object\") {\n    let u3 = Object.keys(c).filter((f2) => !r2.includes(f2));\n    if (u3.length === 0) {\n      s2[a2] = {};\n      for (let [f2, d2] of Object.entries(c)) l2(f2, d2, [...t, a2]), s2[a2][f2] = d2;\n    } else throw new Error(`Invalid key(s) at \"${a2}\": ${u3.join(\", \")}. Expected expressions.`);\n  }\n  return s2;\n}\nfunction Nn(n122, e, t) {\n  let r2 = t.convert ? Bt2(n122, e) : n122, i = { $and: [], $or: [], keys: /* @__PURE__ */ new Set() }, { $or: o, ...s2 } = r2;\n  function l2(a2, c, u3, f2 = []) {\n    let d2 = Qn(e, a2);\n    if (!d2) throw new Error(`Expression does not exist: \"${a2}\"`);\n    if (!d2.valid(c)) throw new Error(`Invalid expected value at \"${[...f2, a2].join(\".\")}\": ${c}`);\n    return d2.validate(c, u3, t.exp_ctx);\n  }\n  __name(l2, \"l\");\n  for (let [a2, c] of Object.entries(s2)) for (let [u3, f2] of Object.entries(c)) {\n    let d2 = t.value_is_kv ? a2 : t.object[a2];\n    i.$and.push(l2(u3, f2, d2, [a2])), i.keys.add(a2);\n  }\n  for (let [a2, c] of Object.entries(o ?? {})) {\n    let u3 = t.value_is_kv ? a2 : t.object[a2];\n    for (let [f2, d2] of Object.entries(c)) i.$or.push(l2(f2, d2, u3, [a2])), i.keys.add(a2);\n  }\n  return i;\n}\nfunction ni2(n122) {\n  let e = { $and: void 0, $or: void 0 };\n  return e.$and = n122.$and.every((t) => !!t), e.$or = n122.$or.some((t) => !!t), !!e.$and || !!e.$or;\n}\nfunction Dt2(n122) {\n  return { convert: /* @__PURE__ */ __name((e) => Bt2(e, n122), \"convert\"), build: /* @__PURE__ */ __name((e, t) => Nn(e, n122, t), \"build\"), validate: /* @__PURE__ */ __name((e, t) => {\n    let r2 = Nn(e, n122, t);\n    return ni2(r2);\n  }, \"validate\"), expressions: n122, expressionKeys: n122.map((e) => e.key) };\n}\nfunction oi(n122) {\n  return n122 === null;\n}\nfunction C(n122) {\n  return !Array.isArray(n122) && typeof n122 == \"object\" && n122 !== null;\n}\nfunction ee(n122) {\n  return typeof n122 == \"string\";\n}\nfunction ie(n122) {\n  return typeof n122 == \"number\";\n}\nfunction si(n122) {\n  return typeof n122 == \"number\" && Number.isInteger(n122);\n}\nfunction ke2(n122) {\n  return typeof n122 == \"boolean\";\n}\nfunction oe(n122) {\n  return Array.isArray(n122);\n}\nfunction ai(n122) {\n  return typeof n122 == \"string\" && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n122);\n}\nfunction li(n122) {\n  return typeof n122 != \"boolean\";\n}\nfunction ci(n122) {\n  return n122 !== void 0 && li(n122) && \"type\" in n122;\n}\nfunction L(n122) {\n  return C(n122) && Nt in n122;\n}\nfunction ui(n122) {\n  return L(n122) && ke2(n122[Ee2]);\n}\nfunction At2(n122, e, t) {\n  if (!n122) throw new ii2(e, t);\n}\nfunction re(n122) {\n  if (oe(n122)) return n122.map(re).sort();\n  if (C(n122)) {\n    let e = Object.entries(n122).sort(([t], [r2]) => t.localeCompare(r2)).map(([t, r2]) => [t, re(r2)]);\n    return Object.fromEntries(e);\n  }\n  return ee(n122) ? n122.normalize(\"NFC\") : n122;\n}\nfunction di(n122, e, t = void 0) {\n  let r2 = typeof e == \"string\" ? pi(e) : qt(e);\n  return Jn(n122, r2, t);\n}\nfunction Jn(n122, e, t = void 0) {\n  let r2 = typeof e == \"string\" ? e.split(/[.\\[\\]\\\"]+/).filter((i) => i) : e;\n  if (r2.length === 0) return n122;\n  try {\n    let [i, ...o] = r2;\n    return !i || !(i in n122) ? t : Jn(n122[i], o, t);\n  } catch {\n    if (typeof t < \"u\") return t;\n    throw new Error(`Invalid path: ${r2.join(\".\")}`);\n  }\n}\nfunction Ue(n122, e, t = {}) {\n  return n122.map((r2) => r2.validate(e, st(t)).valid ? r2 : void 0).filter(Boolean);\n}\nfunction zi2(n122, e, t = {}) {\n  let r2 = { keywordPath: t.keywordPath || [], instancePath: t.instancePath || [], coerce: t.coerce || false, errors: t.errors || [], shortCircuit: t.shortCircuit || false, ignoreUnsupported: t.ignoreUnsupported || false, resolver: t.resolver || new Lt2(n122), depth: t.depth ? t.depth + 1 : 0 }, i = structuredClone(t?.coerce ? n122.coerce(e, { resolver: r2.resolver, depth: r2.depth }) : e);\n  if (t.ignoreUnsupported !== true) {\n    let o = [\"$defs\"];\n    for (let s2 of o) if (n122[s2]) throw new Error(`${s2} not implemented`);\n  }\n  if (r2.resolver.hasRef(n122, i)) {\n    let o = r2.resolver.resolve(n122.$ref).validate(i, { ...r2, errors: [] });\n    o.valid || r2.errors.push(...o.errors);\n  } else for (let [o, s2] of Object.entries(Ji2)) {\n    if (n122[o] === void 0) continue;\n    let l2 = s2(n122, i, { ...r2, errors: [] });\n    if (!l2.valid) {\n      if (t.shortCircuit) return l2;\n      r2.errors.push(...l2.errors);\n    }\n  }\n  return { valid: r2.errors.length === 0, errors: r2.errors };\n}\nfunction Ui2(n122, e, t = {}) {\n  let r2 = structuredClone(e), i = { resolver: t.resolver || new Lt2(n122), depth: t.depth || 0 };\n  return i.resolver.hasRef(n122, r2) ? i.resolver.resolve(n122.$ref).coerce(r2, { ...i, depth: i.depth + 1 }) : r2;\n}\nfunction zn2(n122 = {}) {\n  let e = {};\n  if (this.properties) for (let [t, r2] of Object.entries(this.properties)) {\n    if (n122.withOptional !== true && !this.required?.includes(t)) continue;\n    let i = r2.template(n122);\n    i !== void 0 && (e[t] = i);\n  }\n  return e;\n}\nfunction Un2(n122, e = {}) {\n  let t = n122;\n  if (typeof t == \"string\" && (t.match(/^\\{/) || t.match(/^\\[/)) && (t = JSON.parse(t)), !(typeof t != \"object\" || t === null)) {\n    if (this.properties) for (let [r2, i] of Object.entries(this.properties)) {\n      let o = t[r2];\n      o !== void 0 && (t[r2] = i.coerce(o, e));\n    }\n    return t;\n  }\n}\nfunction Yn2() {\n  if (this.minimum) return this.minimum;\n  if (this.exclusiveMinimum) {\n    if (this.multipleOf) {\n      let n122 = this.exclusiveMinimum;\n      for (; n122 % this.multipleOf !== 0; ) n122++;\n      return n122;\n    }\n    return this.exclusiveMinimum + 1;\n  }\n  return 0;\n}\nfunction Xi(n122, e) {\n  try {\n    let t = typeof n122 == \"string\" ? JSON.parse(n122) : n122;\n    if (!Array.isArray(t)) return;\n    if (L(this.items)) for (let [r2, i] of t.entries()) t[r2] = this.items.coerce(i, e);\n    return t;\n  } catch {\n  }\n  return n122;\n}\nfunction Kn2(n122, e) {\n  return Array.isArray(n122) ? n122.map(e) : n122 !== void 0 ? [e(n122)] : [];\n}\nfunction Vn2(n122, e, t = (r2) => r2) {\n  return Object.fromEntries(Object.entries(n122).map(([r2, i]) => [r2, t(e(i), r2)]));\n}\nfunction Te2(n122) {\n  if (ke2(n122)) return v2(!!n122);\n  let e = structuredClone(n122);\n  if (!C(e)) throw new ri2(\"non-object schemas not implemented\", e);\n  \"properties\" in e && e.properties && (e.properties = Vn2(e.properties, Te2, (o, s2) => \"required\" in e && Array.isArray(e.required) && e.required.includes(s2) ? o : o.optional()));\n  let t = [\"patternProperties\", \"dependentSchemas\", \"$defs\"];\n  for (let o of t) o in e && e[o] && (e[o] = Vn2(e[o], Te2));\n  let r2 = [\"additionalProperties\", \"items\", \"prefixItems\", \"propertyNames\", \"contains\", \"not\", \"if\", \"then\", \"else\"];\n  for (let o of r2) o in e && typeof e[o] < \"u\" && (oe(e[o]) ? e[o] = Kn2(e[o], Te2) : e[o] = Te2(e[o]));\n  let i = [\"anyOf\", \"oneOf\", \"allOf\"];\n  for (let o of i) if (o in e) {\n    let { [o]: s2 } = e;\n    e[o] = Kn2(s2, Te2);\n  }\n  if (ci(e)) switch (e.type) {\n    case \"string\":\n      return Wn2(e);\n    case \"number\":\n      return Gn2(e);\n    case \"integer\":\n      return Hn2(e);\n    case \"boolean\":\n      return Xn2(e);\n    case \"object\": {\n      let { properties: o, ...s2 } = e;\n      return We(o, s2);\n    }\n    case \"array\": {\n      let { items: o, ...s2 } = e;\n      return Zn2(o, s2);\n    }\n  }\n  return v2(e);\n}\nfunction H2(n122) {\n  if (typeof n122 != \"string\") throw new Error(`Invalid key: ${n122}`);\n  return n122;\n}\nfunction $u(n122) {\n  return new B(\"text\", n122, false);\n}\nfunction Pu(n122) {\n  return new B(\"number\", n122, false);\n}\nfunction Qu(n122, e, t, r2) {\n  let i = [];\n  for (let [o, s2] of Object.entries(e)) {\n    let l2 = s2, a2 = { entity: { name: n122, fields: e }, field_name: o, config: l2.config, is_required: l2.is_required };\n    i.push(l2.getField(a2));\n  }\n  return new V2(n122, i, t, r2);\n}\nfunction qo(n122) {\n  return { manyToOne: /* @__PURE__ */ __name((e, t) => new G(n122, e, t), \"manyToOne\"), oneToOne: /* @__PURE__ */ __name((e, t) => new Fe(n122, e, t), \"oneToOne\"), manyToMany: /* @__PURE__ */ __name((e, t, r2) => {\n    let i = [];\n    if (r2) {\n      let o = r2, s2 = [], l2 = t?.connectionTable ?? N.defaultConnectionTable(n122, e);\n      for (let [a2, c] of Object.entries(r2)) {\n        let u3 = c, f2 = { entity: { name: l2, fields: o }, field_name: a2, config: u3.config, is_required: u3.is_required };\n        s2.push(u3.getField(f2));\n      }\n      i.push(s2);\n    }\n    return new N(n122, e, t, i);\n  }, \"manyToMany\"), polyToOne: /* @__PURE__ */ __name((e, t) => new xe2(n122, e, { ...t, targetCardinality: 1 }), \"polyToOne\"), polyToMany: /* @__PURE__ */ __name((e, t) => new xe2(n122, e, t), \"polyToMany\") };\n}\nfunction No(n122) {\n  return { on: /* @__PURE__ */ __name((e, t) => {\n    let r2 = e.map((i) => {\n      let o = n122.field(i);\n      if (!o) throw new Error(`Field \"${String(i)}\" not found on entity \"${n122.name}\"`);\n      return o;\n    });\n    return new dt(n122, r2, t);\n  }, \"on\") };\n}\nfunction Lu(n122, e) {\n  let t = [], r2 = [], i = /* @__PURE__ */ __name((l2) => new Proxy(qo(l2), { get(a2, c) {\n    return (...u3) => (t.push(a2[c](...u3)), i(l2));\n  } }), \"i\"), o = /* @__PURE__ */ __name((l2) => new Proxy(No(l2), { get(a2, c) {\n    return (...u3) => (r2.push(a2[c](...u3)), o(l2));\n  } }), \"o\");\n  e && e({ relation: i, index: o }, n122);\n  let s2 = new xn2(n122, t, r2);\n  return { DB: s2.__entities, entities: s2.__entities, relations: t, indices: r2, proto: s2, toJSON: /* @__PURE__ */ __name(() => s2.toJSON(), \"toJSON\") };\n}\nvar TypeSystemPolicy, map$1, format$1, map, type$1, value, TransformKind, ReadonlyKind, OptionalKind, Hint, Kind, TypeBoxError, kind, TemplateLiteralParserError, TemplateLiteralFiniteError, TemplateLiteralGenerateError, PatternBoolean, PatternNumber, PatternString, PatternNever, PatternBooleanExact, PatternNumberExact, PatternStringExact, PatternNeverExact, TemplateLiteralPatternError, Object$1, includePatternProperties, errorFunction, TypeDereferenceError, ValueHashError, ByteMarker, Accumulator, Prime, Size, Bytes, F64, F64In, F64Out, TypeGuardUnknownTypeError, KnownTypes, type, ExtendsResolverError, ExtendsResult, ValueCheckUnknownTypeError, ValueErrorType, ValueErrorsUnknownTypeError, ValueErrorIterator, TransformDecodeCheckError, TransformDecodeError, visited, splitPath, splitRoutingPath, extractGroupsFromPath, replaceGroupMarks, patternCache, getPattern, tryDecode, tryDecodeURI, getPath, getPathNoStrict, mergePath, checkOptionalParameter, _decodeURI, _getQueryParam, getQueryParam, getQueryParams, decodeURIComponent_, algorithm, getCryptoKey, makeSignature, verifySignature, validCookieNameRegEx, validCookieValueRegEx, parse$1, parseSigned, _serialize, serialize, serializeSigned, getCookie, getSignedCookie, setCookie, setSignedCookie, deleteCookie, HTTPException, bufferToFormData, jsonRegex, multipartRegex, urlencodedRegex, validator, encoder$12, HOST_SERVICES, UNSIGNABLE_HEADERS, AwsClient, AwsV4Signer, HEX_CHARS, nameStartChar, nameChar, nameRegexp, regexName, isName, defaultOptions$1, doubleQuote, singleQuote, validAttrStrRegxp, defaultOptions, buildOptions, METADATA_SYMBOL$1, XmlNode, skipWhitespace, hexRegex, numRegex, consider, eNotationRegx, OrderedObjParser, attrsRegx, parseXml, replaceEntitiesValue, METADATA_SYMBOL, XMLParser, freeGlobal, freeSelf, root, Symbol$2, objectProto$g, hasOwnProperty$d, nativeObjectToString$1, symToStringTag$1, objectProto$f, nativeObjectToString, nullTag, undefinedTag, symToStringTag, symbolTag$3, isArray, symbolProto$2, symbolToString, asyncTag, funcTag$2, genTag$1, proxyTag, coreJsData, maskSrcKey, funcProto$2, funcToString$2, reRegExpChar, reIsHostCtor, funcProto$1, objectProto$e, funcToString$1, hasOwnProperty$c, reIsNative, WeakMap$1, objectCreate, baseCreate, HOT_COUNT, HOT_SPAN, nativeNow, defineProperty, baseSetToString, setToString, MAX_SAFE_INTEGER$1, reIsUint, objectProto$d, hasOwnProperty$b, nativeMax, MAX_SAFE_INTEGER, objectProto$c, argsTag$3, objectProto$b, hasOwnProperty$a, propertyIsEnumerable$1, isArguments, freeExports$2, freeModule$2, moduleExports$2, Buffer$2, nativeIsBuffer, isBuffer, argsTag$2, arrayTag$2, boolTag$3, dateTag$3, errorTag$2, funcTag$1, mapTag$5, numberTag$3, objectTag$4, regexpTag$3, setTag$5, stringTag$3, weakMapTag$2, arrayBufferTag$3, dataViewTag$4, float32Tag$2, float64Tag$2, int8Tag$2, int16Tag$2, int32Tag$2, uint8Tag$2, uint8ClampedTag$2, uint16Tag$2, uint32Tag$2, typedArrayTags, freeExports$1, freeModule$1, moduleExports$1, freeProcess, nodeUtil, nodeIsTypedArray, isTypedArray, objectProto$a, hasOwnProperty$9, nativeKeys, objectProto$9, hasOwnProperty$8, objectProto$8, hasOwnProperty$7, reIsDeepProp, reIsPlainProp, nativeCreate, HASH_UNDEFINED$2, objectProto$7, hasOwnProperty$6, objectProto$6, hasOwnProperty$5, HASH_UNDEFINED$1, arrayProto, splice, Map$1, FUNC_ERROR_TEXT, MAX_MEMOIZE_SIZE, rePropName, reEscapeChar, stringToPath, spreadableSymbol, getPrototype, objectTag$3, funcProto, objectProto$5, funcToString, hasOwnProperty$4, objectCtorString, LARGE_ARRAY_SIZE, freeExports, freeModule, moduleExports, Buffer$1, allocUnsafe, objectProto$4, propertyIsEnumerable, nativeGetSymbols$1, getSymbols, nativeGetSymbols, getSymbolsIn, DataView$1, Promise$1, Set$1, mapTag$4, objectTag$2, promiseTag, setTag$4, weakMapTag$1, dataViewTag$3, dataViewCtorString, mapCtorString, promiseCtorString, setCtorString, weakMapCtorString, getTag$1, objectProto$3, hasOwnProperty$3, Uint8Array$2, reFlags, symbolProto$1, symbolValueOf$1, boolTag$2, dateTag$2, mapTag$3, numberTag$2, regexpTag$2, setTag$3, stringTag$2, symbolTag$2, arrayBufferTag$2, dataViewTag$2, float32Tag$1, float64Tag$1, int8Tag$1, int16Tag$1, int32Tag$1, uint8Tag$1, uint8ClampedTag$1, uint16Tag$1, uint32Tag$1, mapTag$2, nodeIsMap, isMap, setTag$2, nodeIsSet, isSet, CLONE_DEEP_FLAG$1, argsTag$1, arrayTag$1, boolTag$1, dateTag$1, errorTag$1, funcTag, genTag, mapTag$1, numberTag$1, objectTag$1, regexpTag$1, setTag$1, stringTag$1, symbolTag$1, weakMapTag, arrayBufferTag$1, dataViewTag$1, float32Tag, float64Tag, int8Tag, int16Tag, int32Tag, uint8Tag, uint8ClampedTag, uint16Tag, uint32Tag, cloneableTags, HASH_UNDEFINED, COMPARE_PARTIAL_FLAG$5, COMPARE_UNORDERED_FLAG$3, COMPARE_PARTIAL_FLAG$4, COMPARE_UNORDERED_FLAG$2, boolTag, dateTag, errorTag, mapTag, numberTag, regexpTag, setTag, stringTag, symbolTag, arrayBufferTag, dataViewTag, symbolProto, symbolValueOf, COMPARE_PARTIAL_FLAG$3, objectProto$2, hasOwnProperty$2, COMPARE_PARTIAL_FLAG$2, argsTag, arrayTag, objectTag, objectProto$1, hasOwnProperty$1, COMPARE_PARTIAL_FLAG$1, COMPARE_UNORDERED_FLAG$1, COMPARE_PARTIAL_FLAG, COMPARE_UNORDERED_FLAG, baseFor, mergeWith, objectProto, hasOwnProperty, CLONE_DEEP_FLAG, CLONE_FLAT_FLAG, CLONE_SYMBOLS_FLAG, omit, pick, knownUserAgents, getRuntimeKey, checkUserAgentEquals, TModule, Ordinal, TransformDecodeBuilder, TransformEncodeBuilder, JsonTypeBuilder, TypeBuilder, JavaScriptTypeBuilder, Type, p$1, dayjs_min$1, dayjs_min, hasRequiredDayjs_min, dayjs_minExports, ze$2, weekOfYear$1, weekOfYear, hasRequiredWeekOfYear, weekOfYearExports, Pr$1, byteToHex, getRandomValues2, rnds8, randomUUID2, native, _state, schemaArrayKeyword, schemaMapKeyword, ignoredKeyword, initialBaseURI, DATE, DAYS, TIME, HOSTNAME, URIREF, URITEMPLATE, URL_, UUID, JSON_POINTER, JSON_POINTER_URI_FRAGMENT, RELATIVE_JSON_POINTER, EMAIL, IPV4, IPV6, DURATION, format, DATE_TIME_SEPARATOR, NOT_URI_FRAGMENT, URI_PATTERN, Z_ANCHOR, Validator, toString, AlterTableNode, IdentifierNode, CreateIndexNode, CreateSchemaNode, ON_COMMIT_ACTIONS, CreateTableNode, SchemableIdentifierNode, DropIndexNode, DropSchemaNode, DropTableNode, AliasNode, TableNode, SelectModifierNode, AndNode, OrNode, OnNode, JoinNode, BinaryOperationNode, COMPARISON_OPERATORS, ARITHMETIC_OPERATORS, JSON_OPERATORS, BINARY_OPERATORS, UNARY_FILTER_OPERATORS, UNARY_OPERATORS, OPERATORS, OperatorNode, ColumnNode, SelectAllNode, ReferenceNode, DynamicReferenceBuilder, OrderByItemNode, RawNode, JSONReferenceNode, JSONOperatorChainNode, JSONPathNode, PrimitiveValueListNode, ValueListNode, ValueNode, ParensNode, OrderByNode, PartitionByNode, OverNode, FromNode, GroupByNode, HavingNode, SelectQueryNode, JoinBuilder, PartitionByItemNode, OverBuilder, SelectionNode, ValuesNode, DefaultInsertValueNode, InsertQueryNode, UpdateQueryNode, UsingNode, DeleteQueryNode, WhereNode, ReturningNode, ExplainNode, WhenNode, MergeQueryNode, OutputNode, QueryNode, ColumnUpdateNode, OnDuplicateKeyNode, InsertResult, NoResultError, OnConflictNode, OnConflictBuilder, OnConflictDoNothingBuilder, OnConflictUpdateBuilder, TopNode, InsertQueryBuilder, DeleteResult, LimitNode, DeleteQueryBuilder, UpdateResult, UpdateQueryBuilder, CommonTableExpressionNameNode, CommonTableExpressionNode, CTEBuilder, WithNode, CHARS, LazyQueryId, OperationNodeTransformer, ROOT_OPERATION_NODES, SCHEMALESS_FUNCTIONS, WithSchemaTransformer, WithSchemaPlugin, MatchedNode, Deferred, LOGGED_MESSAGES, NO_PLUGINS, QueryExecutorBase, NoopQueryExecutor, NOOP_QUERY_EXECUTOR, MergeResult, MergeQueryBuilder, WheneableMergeQueryBuilder, MatchedThenableMergeQueryBuilder, NotMatchedThenableMergeQueryBuilder, QueryCreator, OffsetNode, GroupByItemNode, SetOperationNode, ExpressionWrapper, AliasedExpressionWrapper, OrWrapper, AndWrapper, FetchNode, SelectQueryBuilderImpl, AliasedSelectQueryBuilderImpl, AggregateFunctionNode, FunctionNode, AggregateFunctionBuilder, AliasedAggregateFunctionBuilder, UnaryOperationNode, CaseNode, CaseBuilder, CaseThenBuilder, CaseWhenBuilder, CaseEndBuilder, JSONPathLegNode, JSONPathBuilder, TraversedJSONPathBuilder, AliasedJSONPathBuilder, TupleNode, SIMPLE_COLUMN_DATA_TYPES, COLUMN_DATA_TYPE_REGEX, DataTypeNode, CastNode, AddColumnNode, ColumnDefinitionNode, DropColumnNode, RenameColumnNode, CheckConstraintNode, ON_MODIFY_FOREIGN_ACTIONS, ReferencesNode, GeneratedNode, DefaultValueNode, ColumnDefinitionBuilder, ModifyColumnNode, ForeignKeyConstraintNode, ForeignKeyConstraintBuilder, AddConstraintNode, UniqueConstraintNode, DropConstraintNode, AlterColumnNode, AlterColumnBuilder, AlteredColumnBuilder, AlterTableExecutor, AlterTableAddForeignKeyConstraintBuilder, AlterTableDropConstraintBuilder, PrimaryConstraintNode, AddIndexNode, AlterTableAddIndexBuilder, UniqueConstraintNodeBuilder, AlterTableBuilder, AlterTableColumnAlteringBuilder, ImmediateValueTransformer, CreateIndexBuilder, CreateSchemaBuilder, CreateTableBuilder, DropIndexBuilder, DropSchemaBuilder, DropTableBuilder, CreateViewNode, ImmediateValuePlugin, CreateViewBuilder, DropViewNode, DropViewBuilder, CreateTypeNode, CreateTypeBuilder, DropTypeNode, DropTypeBuilder, SchemaModule, DynamicModule, DefaultConnectionProvider, DefaultQueryExecutor, RuntimeDriver, ignoreError, SingleConnectionProvider, TRANSACTION_ISOLATION_LEVELS, Log, Kysely, Transaction, ConnectionBuilder, TransactionBuilder, RawBuilderImpl, AliasedRawBuilderImpl, sql, OperationNodeVisitor, DefaultQueryCompiler, SELECT_MODIFIER_SQL, SELECT_MODIFIER_PRIORITY, JOIN_TYPE_SQL, DialectAdapterBase, ID_WRAP_REGEX, SqliteQueryCompiler, DEFAULT_MIGRATION_TABLE, DEFAULT_MIGRATION_LOCK_TABLE, SqliteIntrospector, SqliteAdapter, ParseJSONResultsPlugin, LibsqlError, URI_RE, AUTHORITY_RE, version2, VERSION, _hasBuffer, _TD, _TE, b64ch, b64chs, b64tab, b64re, _fromCC, _U8Afrom, _mkUriSafe, _tidyB64, btoaPolyfill, _btoa, _fromUint8Array, fromUint8Array, cb_utob, re_utob, utob, _encode, encode, encodeURI$1, re_btou, cb_btou, btou, atobPolyfill, _atob, _toUint8Array, toUint8Array, _decode, _unURI, decode$2, isValid, _noEnum, extendString, extendUint8Array, extendBuiltins, gBase64, supportedUrlLink, ResultSetImpl, inMemoryMode, _WebSocket, Client, ClientError, ProtoError, ResponseError, ClosedError, WebSocketUnsupportedError, WebSocketError, HttpServerError, ProtocolVersionError, InternalError, MisuseError, ObjectWriter, VARINT, FIXED_64, LENGTH_DELIMITED, FIXED_32, MessageReader, FieldReader, MessageWriter, IdAlloc, minInteger, maxInteger, Sql, Queue, Stmt$2, Batch$2, BatchStep$2, BatchCond$2, Stream, Cursor, fetchChunkSize, fetchQueueSize, WsCursor, WsStream, Error$1, StmtResult, Col, Row, BatchResult, BatchResultStepResult, BatchResultStepError, CursorEntry, StepBeginEntry, StepEndEntry, StepErrorEntry, DescribeResult, DescribeParam, DescribeCol, Value, ServerMsg, HelloErrorMsg, ResponseErrorMsg, ResponseOkMsg, ExecuteResp, BatchResp, FetchCursorResp, DescribeResp, GetAutocommitResp, subprotocolsV2, subprotocolsV3, WsClient$1, _fetch, _Request, _Headers, _queueMicrotask, ByteQueue, PipelineRespBody, StreamResult, StreamResponse, ExecuteStreamResp, BatchStreamResp, DescribeStreamResp, GetAutocommitStreamResp, CursorRespBody, HttpCursor, HttpStream, checkEndpoints, fallbackEndpoint, HttpClient$1, HranaTransaction, SqlCache, Lru, promiseLimit$1, hasRequiredPromiseLimit, promiseLimitExports, promiseLimit, maxConnAgeMillis, sqlCacheCapacity$1, WsClient2, WsTransaction, sqlCacheCapacity, HttpClient2, HttpTransaction, decodeBase64Url$1, encodeBase64Url$1, encodeBase642, decodeBase642, AlgorithmTypes, JwtAlgorithmNotImplemented, JwtTokenInvalid, JwtTokenNotBefore, JwtTokenExpired, JwtTokenIssuedAt, JwtHeaderInvalid, JwtTokenSignatureMismatched, CryptoKeyUsage, utf8Encoder, utf8Decoder, encodeJwtPart, encodeSignaturePart, decodeJwtPart, sign$1, verify$1, decode$1, Jwt, parseBody, handleParsingAllValues, handleParsingNestedValues, tryDecodeURIComponent, HonoRequest, HtmlEscapedCallbackPhase, raw, escapeRe, stringBufferToString, escapeToBuffer, resolveCallbackSync, resolveCallback, TEXT_PLAIN, setHeaders, Context, verify2, decode, sign2, compose, METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE, METHODS, MESSAGE_MATCHER_IS_ALREADY_BUILT, UnsupportedPathError, COMPOSED_HANDLER, notFoundHandler, errorHandler, Hono$1, LABEL_REG_EXP_STR, ONLY_WILDCARD_REG_EXP_STR, TAIL_WILDCARD_REG_EXP_STR, PATH_ERROR, regExpMetaChars, Node$1, Trie, emptyParam, nullMatcher, wildcardRegExpCache, RegExpRouter, SmartRouter, emptyParams, Node2, TrieRouter, Hono2, createMiddleware, USER_AGENT, clockSkew, clockTolerance, customFetch, modifyAssertion, jweDecrypt, useMtlsAlias, encoder2, decoder2, CHUNK_SIZE, LRU, UnsupportedOperationError, OperationProcessingError, OPE, dpopNonces, jwkCache, SPLIT_REGEXP, SCHEMES_REGEXP, skipSubjectCheck, idTokenClaims, jwtResponseBodies, branded, jwtClaimNames, expectNoNonce, skipAuthTimeCheck, noSignatureCheck, skipStateCheck, expectNoState, nodeCrypto, nextTick2, BASE64_CODE, BASE64_INDEX, BCRYPT_SALT_LEN, GENSALT_DEFAULT_LOG2_ROUNDS, BLOWFISH_NUM_ROUNDS, MAX_EXECUTION_TIME, P_ORIG, S_ORIG, C_ORIG, cors, html, DOM_RENDERER, DOM_ERROR_HANDLER, DOM_STASH, DOM_INTERNAL_TAG, DOM_MEMO, PERMALINK, setInternalTagFlag, createContextProviderFunction, createContext$1, globalContexts, createContext, useContext, deDupeKeyMap, domRenderers, dataPrecedenceAttr, toArray, metaTagMap, insertIntoHead, returnWithoutSpecialBehavior, documentMetadataTag$1, title$1, script$1, style$1, link$1, meta$1, newJSXNode, form$1, formActionableElement$1, input$1, button$1, intrinsicElementTags, normalizeElementKeyMap, normalizeIntrinsicElementKey, styleObjectForEach, nameSpaceContext$1, getNameSpaceContext$1, toSVGAttributeName, emptyTags, booleanAttributes, childrenToStringToBuffer, JSXNode, JSXFunctionNode, JSXFragmentNode, initDomRenderer, jsxFn, Fragment2, HONO_PORTAL_ELEMENT, eventAliasMap, nameSpaceMap, buildDataStack, refCleanupMap, nameSpaceContext, getNameSpaceContext, isNodeString, eventCache, getEventSpec, toAttributeName, applyProps, invokeTag, getNextChildren, findInsertBefore, removeNode, apply, findChildNodeIndex, cancelBuild, applyNodeObject, isSameContext, fallbackUpdateFnArrayMap, build, buildNode, updateSync, updateMap, currentUpdateSets, update, createPortal, STASH_SATE, STASH_EFFECT, STASH_CALLBACK, STASH_MEMO, resolvedPromiseValueMap, isDepsChanged, updateHook, pendingStack, useState, useCallback, use, useMemo, FormContext, actions, registerAction, composeRef, blockingPromiseMap, createdElements, documentMetadataTag, title2, script, style, link, meta, customEventFormAction, form, formActionableElement, input, button, PSEUDO_GLOBAL_SELECTOR, isPseudoGlobalSelectorRe, DEFAULT_STYLE_ID, SELECTOR, CLASS_NAME, STYLE_STRING, SELECTORS, EXTERNAL_CLASS_NAMES, CSS_ESCAPED, toHash, cssStringReStr, minifyCssRe, minify, buildStyleString, cssCommon, cxCommon, keyframesCommon, viewTransitionNameIndex, viewTransitionCommon, splitRule, createCssJsxDomObjects, createCssContext, defaultContext, css, Style, RENDER_TYPE, RENDER_TYPE_MAP, renderSwaggerUIOptions, remoteAssets, SwaggerUI, middleware, Pa, li$1, ja, Ma, Ia, Da, Ls, Je$2, $a, Qs, no$1, Oa, I$1, he$2, ui$1, Na, sr$1, ot$1, ze$1, or$1, Ct$1, hi$1, E$3, gi$1, eo$1, te$3, Ei$1, so$1, Qr$1, io$1, m$1, Xa, Ti$1, De$2, w$4, ce$2, be$2, Ve$1, sc, Vr$1, He$1, cc, lc, pc, uc, dc, mc, fc, yc, hc, gc, bc, xc, wc, Ec, Tc, At$1, lr$1, R$2, Oi$1, xo, pr, Ic, f, ki$1, Pi$1, at$1, lt$1, Dc, $c, _i$1, Kc, A$4, g$1, pt$1, Yr$1, zc, Gc, Vc, Wc, Hc, Yc, Xc, Zc, el, tl, rl, nl, il, sl, ol, al, cl, ll, pl, ul, dl, ml, fl, yl, hl, gl, bl, xl, wl, El, Tl, To, Sl, ji$1, vl, B$4, Cl, dr, Al, Fl, _l, Ao, kl, Fo, _o, Po, jo$1, jl, Ml, Il, Dl, $l, Xr$1, T$1, Ul, Ll, Ql, Mo$1, Mi$1, Kl, Di$1, S$2, M$3, ke$2, $i$1, en$1, V$2, qi$1, Bi$1, Ni$1, Ui$1, Li$1, Qi$1, Ne$2, Ki$1, Ji$1, zi$1, Gi$1, kt$1, tn$1, ne$1, rn$1, D$4, nn$1, sn$1, q$2, zl, Gl, Vl, Vi$1, Wi$1, N$3, P$3, mr$1, Hi$1, Pt$1, Ue$2, Yi$1, ut$1, X$3, Xi$1, jt$1, Io, Zi$1, Mt$1, dt$1, es$1, It$1, W$3, ts$1, Ye$1, Xe$1, fr$1, rs$1, xe$3, U$3, ns$1, Ze$1, Dt$1, Do$1, pe$3, is$1, $o$1, Z$1, qo$1, Bo$1, we$2, on$1, an$1, et$1, mt$1, Ee$2, Te$3, Le$2, lp, ss, z$2, G$2, $t, ie$2, Qe$1, Se$1, ft$1, un$1, tt, os$1, pn$1, dn$1, as, No$1, cn$1, mn$1, Uo, Lo, mp, fp, yp, hp, oe$3, cs$1, yr, ln$1, gp, fn$1, se$1, hr$1, yn$1, Pe$1, ls$1, Ke$1, hn$1, ue$2, ps$1, Bt$1, bn, xn$1, us$1, ds$1, wn, En, Tn, _p, ms, fs$1, yt$1, Sn, Ho, kp, Pp, jp, Mp, Ip, Dp, Yo, j$3, $p, qp, Bp, Np, Up, Lp, Qp, rt$1, wr$1, ht$1, vn, de$2, Q$1, Zo, gs, On, ea, Er$1, H$3, Rn, ra, na, me$3, Cn$1, Tr$1, ia, sa, Lt$1, xs, nu, nt$1, it, ee$2, ws, su, Qt$1, st$1, uu, Kt$1, k$1, mu, Es, fu, yu, hu, gu, Ts, An$1, Jt$1, Fn, gt$1, Sr$1, Ut$1, xu, vs, Gt$1, la, Vt$1, ua, Cu, _n$1, Ht$1, kn$1, Os, Pn$1, vr$1, bt$1, Wt$1, Rs, jn$1, Mn$1, In, je$3, fe$1, Cs, Dn$1, da, $n$1, ma, qn$1, Yt$1, Xt$1, Or$1, Rr, Bn, Nn$1, Mu, ae$2, wt$1, Zt$1, Un$1, As, Ar$1, Fs, qu, Et$1, Cr, fa, F$3, _s, Nu, ya, Uu, Lu$1, Qu$1, ha, Ln$1, er$1, Fr, _r$1, ks, Tt$1, ga, tr, rr$1, ba, nr$1, Qn$1, xa, ir$1, Me$1, Vu, Wu, Hu, Yu, wa, Kn$1, js, Ie$2, Ms, Jn$1, Re$2, kr$1, Ta, nd, Ds, id, zn$1, qs, Gn$1, cd, ld, Vn$1, Ce$1, Bs, Wn$1, Hn$1, Yn$2, Xn$1, Pr, vt, Zn$1, ei$1, ti$1, ri$1, ni$1, Ns, ii$1, a$1, __vite_import_meta_env__2, ue$1, V$1, ye$2, pe$2, me$2, de$1, Te$2, ge$1, xe$2, re$2, y$2, Ne$1, je$2, ne2, Pe, D$3, U$2, oe$2, h$2, te$2, L$3, w$3, Te$1, U$1, we$1, Oe$1, ve$1, Ae$1, Re$1, X$2, Ce2, _e$1, oe$1, S$1, ke$1, B$2, A$2, $$2, l$1, z$1, d$1, q$1, ce$1, F$2, ae$1, G$1, Y$1, ze, ye$1, u$1, R$1, y$1, h$1, W$2, N$2, _$1, j$2, J$1, he$1, b$2, w$2, be$1, O$1, D$2, xe$1, v$2, Ee$1, Ge$1, Ye2, We$1, Je$1, GlobalRequest, Request$1, newRequestFromIncoming, getRequestCache, requestCache, incomingKey, urlKey, abortControllerKey, getAbortController, requestPrototype, responseCache, getResponseCache, cacheKey, GlobalResponse, Response2, webFetch, D$1, b$1, P$1, N$1, j$1, A$1, M$1, $$1, H$1, E$1, h2, v$1, l, w$1, W$1, d, a, u2, B$1, p, k, F$1, mr, Ft, hr, gr, xr, br, Er2, Cn2, Tr, wr2, _n2, Y2, $n2, Sr, Ct2, Qe, Pn, D, Pt2, jn2, rt2, kn, g, It2, Ve, $2, Je, _t, ye, _r2, kr, jr, Mr, Br, Dr, Ar2, qr, Nr, Qr, Lr, Kr, Vr, Jr, zr, J2, jt2, qn2, O2, Nt, Qt2, Ee2, we2, ri2, ii2, qt, pi, b2, y2, Se, st, yi, fi, mi, hi, gi, xi, bi, Ei, Ti, wi, Si, vi, Oi2, Ri, Fi, Ci, $i2, Pi, Ii, _i, ki, ji2, Mi, Bi2, Di, Ai, qi2, Ni2, Qi2, Li2, Ki2, Ln2, Vi, Lt2, Ji2, v2, Wi, We, Gi2, Hi, Yi, Wn2, Zi, Gn2, Hn2, Zn2, Xn2, eo, to, no, ro, io, j2, fe, Kt2, at, se2, Vt, Jt, zt, Ut, Wt, Gt, ae2, Ht, Yt2, Zt, Xt, je, lt2, q, ct, R3, ut2, pt, S, so, ao, lo, en2, tn2, w2, E2, Ge, nn2, Me, le, rn2, ve, M2, on3, Be, er, sn2, De2, Oe, an, Ae, _2, ln, me, he, He, cn, z, F, un, ge, pn2, dt, nr2, K, dn2, rr, V2, ir2, or2, ce, yt2, ft2, Ze2, Re, U, W2, ue2, $o, yn2, P2, I2, qe, N, pe2, G, Fe, xt, xe2, fn, gt, bt, mn, sr, mt, Et2, ar, lr2, ko, jo, Mo, Bo, cr, hn, Xe, ht2, Do, Tt, Q, et, wt, te, gn, be, St, B, xn2, Ot, Rt, es, ts, ns, rs, is, os, fr, ls, cs, us2, ps2, ds2, ys, fs2, local, schema, config2;\nvar init_bknd_config_m27Qk_4t = __esm({\n  \"dist/_worker.js/chunks/bknd.config_m27Qk-4t.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    init_promises2();\n    init_crypto2();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    __name(IsAsyncIterator$3, \"IsAsyncIterator$3\");\n    __name(IsIterator$3, \"IsIterator$3\");\n    __name(IsPromise$2, \"IsPromise$2\");\n    __name(IsDate$3, \"IsDate$3\");\n    __name(IsMap, \"IsMap\");\n    __name(IsSet, \"IsSet\");\n    __name(IsTypedArray, \"IsTypedArray\");\n    __name(IsUint8Array$3, \"IsUint8Array$3\");\n    __name(HasPropertyKey$1, \"HasPropertyKey$1\");\n    __name(IsObject$3, \"IsObject$3\");\n    __name(IsArray$3, \"IsArray$3\");\n    __name(IsUndefined$3, \"IsUndefined$3\");\n    __name(IsNull$3, \"IsNull$3\");\n    __name(IsBoolean$3, \"IsBoolean$3\");\n    __name(IsNumber$3, \"IsNumber$3\");\n    __name(IsInteger$2, \"IsInteger$2\");\n    __name(IsBigInt$3, \"IsBigInt$3\");\n    __name(IsString$3, \"IsString$3\");\n    __name(IsFunction$3, \"IsFunction$3\");\n    __name(IsSymbol$3, \"IsSymbol$3\");\n    __name(IsValueType, \"IsValueType\");\n    (function(TypeSystemPolicy2) {\n      TypeSystemPolicy2.InstanceMode = \"default\";\n      TypeSystemPolicy2.ExactOptionalPropertyTypes = false;\n      TypeSystemPolicy2.AllowArrayObject = false;\n      TypeSystemPolicy2.AllowNaN = false;\n      TypeSystemPolicy2.AllowNullVoid = false;\n      function IsExactOptionalProperty(value2, key) {\n        return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value2 : value2[key] !== void 0;\n      }\n      __name(IsExactOptionalProperty, \"IsExactOptionalProperty\");\n      TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;\n      function IsObjectLike(value2) {\n        const isObject2 = IsObject$3(value2);\n        return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !IsArray$3(value2);\n      }\n      __name(IsObjectLike, \"IsObjectLike\");\n      TypeSystemPolicy2.IsObjectLike = IsObjectLike;\n      function IsRecordLike(value2) {\n        return IsObjectLike(value2) && !(value2 instanceof Date) && !(value2 instanceof Uint8Array);\n      }\n      __name(IsRecordLike, \"IsRecordLike\");\n      TypeSystemPolicy2.IsRecordLike = IsRecordLike;\n      function IsNumberLike(value2) {\n        return TypeSystemPolicy2.AllowNaN ? IsNumber$3(value2) : Number.isFinite(value2);\n      }\n      __name(IsNumberLike, \"IsNumberLike\");\n      TypeSystemPolicy2.IsNumberLike = IsNumberLike;\n      function IsVoidLike(value2) {\n        const isUndefined2 = IsUndefined$3(value2);\n        return TypeSystemPolicy2.AllowNullVoid ? isUndefined2 || value2 === null : isUndefined2;\n      }\n      __name(IsVoidLike, \"IsVoidLike\");\n      TypeSystemPolicy2.IsVoidLike = IsVoidLike;\n    })(TypeSystemPolicy || (TypeSystemPolicy = {}));\n    map$1 = /* @__PURE__ */ new Map();\n    __name(Entries$1, \"Entries$1\");\n    __name(Clear$1, \"Clear$1\");\n    __name(Delete$1, \"Delete$1\");\n    __name(Has$1, \"Has$1\");\n    __name(Set$3, \"Set$3\");\n    __name(Get$1, \"Get$1\");\n    format$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      Clear: Clear$1,\n      Delete: Delete$1,\n      Entries: Entries$1,\n      Get: Get$1,\n      Has: Has$1,\n      Set: Set$3\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    map = /* @__PURE__ */ new Map();\n    __name(Entries, \"Entries\");\n    __name(Clear, \"Clear\");\n    __name(Delete, \"Delete\");\n    __name(Has, \"Has\");\n    __name(Set$2, \"Set$2\");\n    __name(Get, \"Get\");\n    type$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      Clear,\n      Delete,\n      Entries,\n      Get,\n      Has,\n      Set: Set$2\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    __name(HasPropertyKey, \"HasPropertyKey\");\n    __name(IsAsyncIterator$2, \"IsAsyncIterator$2\");\n    __name(IsArray$2, \"IsArray$2\");\n    __name(IsBigInt$2, \"IsBigInt$2\");\n    __name(IsBoolean$2, \"IsBoolean$2\");\n    __name(IsDate$2, \"IsDate$2\");\n    __name(IsFunction$2, \"IsFunction$2\");\n    __name(IsIterator$2, \"IsIterator$2\");\n    __name(IsNull$2, \"IsNull$2\");\n    __name(IsNumber$2, \"IsNumber$2\");\n    __name(IsObject$2, \"IsObject$2\");\n    __name(IsRegExp$2, \"IsRegExp$2\");\n    __name(IsString$2, \"IsString$2\");\n    __name(IsSymbol$2, \"IsSymbol$2\");\n    __name(IsUint8Array$2, \"IsUint8Array$2\");\n    __name(IsUndefined$2, \"IsUndefined$2\");\n    value = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      HasPropertyKey,\n      IsArray: IsArray$2,\n      IsAsyncIterator: IsAsyncIterator$2,\n      IsBigInt: IsBigInt$2,\n      IsBoolean: IsBoolean$2,\n      IsDate: IsDate$2,\n      IsFunction: IsFunction$2,\n      IsIterator: IsIterator$2,\n      IsNull: IsNull$2,\n      IsNumber: IsNumber$2,\n      IsObject: IsObject$2,\n      IsRegExp: IsRegExp$2,\n      IsString: IsString$2,\n      IsSymbol: IsSymbol$2,\n      IsUint8Array: IsUint8Array$2,\n      IsUndefined: IsUndefined$2\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    __name(ImmutableArray, \"ImmutableArray\");\n    __name(ImmutableDate, \"ImmutableDate\");\n    __name(ImmutableUint8Array, \"ImmutableUint8Array\");\n    __name(ImmutableRegExp, \"ImmutableRegExp\");\n    __name(ImmutableObject, \"ImmutableObject\");\n    __name(Immutable, \"Immutable\");\n    __name(ArrayType$1, \"ArrayType$1\");\n    __name(DateType$1, \"DateType$1\");\n    __name(Uint8ArrayType$1, \"Uint8ArrayType$1\");\n    __name(RegExpType, \"RegExpType\");\n    __name(ObjectType$1, \"ObjectType$1\");\n    __name(Visit$8, \"Visit$8\");\n    __name(Clone$1, \"Clone$1\");\n    __name(CreateType, \"CreateType\");\n    TransformKind = Symbol.for(\"TypeBox.Transform\");\n    ReadonlyKind = Symbol.for(\"TypeBox.Readonly\");\n    OptionalKind = Symbol.for(\"TypeBox.Optional\");\n    Hint = Symbol.for(\"TypeBox.Hint\");\n    Kind = Symbol.for(\"TypeBox.Kind\");\n    __name(Unsafe, \"Unsafe\");\n    TypeBoxError = class extends Error {\n      static {\n        __name(this, \"TypeBoxError\");\n      }\n      constructor(message) {\n        super(message);\n      }\n    };\n    __name(MappedKey, \"MappedKey\");\n    __name(MappedResult, \"MappedResult\");\n    __name(DiscardKey, \"DiscardKey\");\n    __name(Discard, \"Discard\");\n    __name(Array$1, \"Array$1\");\n    __name(AsyncIterator, \"AsyncIterator\");\n    __name(Constructor, \"Constructor\");\n    __name(Function$1, \"Function$1\");\n    __name(Computed, \"Computed\");\n    __name(Never, \"Never\");\n    __name(IsReadonly$1, \"IsReadonly$1\");\n    __name(IsOptional$1, \"IsOptional$1\");\n    __name(IsAny$1, \"IsAny$1\");\n    __name(IsArgument$1, \"IsArgument$1\");\n    __name(IsArray$1, \"IsArray$1\");\n    __name(IsAsyncIterator$1, \"IsAsyncIterator$1\");\n    __name(IsBigInt$1, \"IsBigInt$1\");\n    __name(IsBoolean$1, \"IsBoolean$1\");\n    __name(IsComputed$1, \"IsComputed$1\");\n    __name(IsConstructor$1, \"IsConstructor$1\");\n    __name(IsDate$1, \"IsDate$1\");\n    __name(IsFunction$1, \"IsFunction$1\");\n    __name(IsImport$1, \"IsImport$1\");\n    __name(IsInteger$1, \"IsInteger$1\");\n    __name(IsProperties$1, \"IsProperties$1\");\n    __name(IsIntersect$1, \"IsIntersect$1\");\n    __name(IsIterator$1, \"IsIterator$1\");\n    __name(IsKindOf$1, \"IsKindOf$1\");\n    __name(IsLiteralString$1, \"IsLiteralString$1\");\n    __name(IsLiteralNumber$1, \"IsLiteralNumber$1\");\n    __name(IsLiteralBoolean$1, \"IsLiteralBoolean$1\");\n    __name(IsLiteralValue$1, \"IsLiteralValue$1\");\n    __name(IsLiteral$1, \"IsLiteral$1\");\n    __name(IsMappedKey$1, \"IsMappedKey$1\");\n    __name(IsMappedResult$1, \"IsMappedResult$1\");\n    __name(IsNever$1, \"IsNever$1\");\n    __name(IsNot$1, \"IsNot$1\");\n    __name(IsNull$1, \"IsNull$1\");\n    __name(IsNumber$1, \"IsNumber$1\");\n    __name(IsObject$1, \"IsObject$1\");\n    __name(IsPromise$1, \"IsPromise$1\");\n    __name(IsRecord$1, \"IsRecord$1\");\n    __name(IsRecursive$1, \"IsRecursive$1\");\n    __name(IsRef$1, \"IsRef$1\");\n    __name(IsRegExp$1, \"IsRegExp$1\");\n    __name(IsString$1, \"IsString$1\");\n    __name(IsSymbol$1, \"IsSymbol$1\");\n    __name(IsTemplateLiteral$1, \"IsTemplateLiteral$1\");\n    __name(IsThis$1, \"IsThis$1\");\n    __name(IsTransform$1, \"IsTransform$1\");\n    __name(IsTuple$1, \"IsTuple$1\");\n    __name(IsUndefined$1, \"IsUndefined$1\");\n    __name(IsUnion$1, \"IsUnion$1\");\n    __name(IsUint8Array$1, \"IsUint8Array$1\");\n    __name(IsUnknown$1, \"IsUnknown$1\");\n    __name(IsUnsafe$1, \"IsUnsafe$1\");\n    __name(IsVoid$1, \"IsVoid$1\");\n    __name(IsKind$1, \"IsKind$1\");\n    __name(IsSchema$1, \"IsSchema$1\");\n    kind = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      IsAny: IsAny$1,\n      IsArgument: IsArgument$1,\n      IsArray: IsArray$1,\n      IsAsyncIterator: IsAsyncIterator$1,\n      IsBigInt: IsBigInt$1,\n      IsBoolean: IsBoolean$1,\n      IsComputed: IsComputed$1,\n      IsConstructor: IsConstructor$1,\n      IsDate: IsDate$1,\n      IsFunction: IsFunction$1,\n      IsImport: IsImport$1,\n      IsInteger: IsInteger$1,\n      IsIntersect: IsIntersect$1,\n      IsIterator: IsIterator$1,\n      IsKind: IsKind$1,\n      IsKindOf: IsKindOf$1,\n      IsLiteral: IsLiteral$1,\n      IsLiteralBoolean: IsLiteralBoolean$1,\n      IsLiteralNumber: IsLiteralNumber$1,\n      IsLiteralString: IsLiteralString$1,\n      IsLiteralValue: IsLiteralValue$1,\n      IsMappedKey: IsMappedKey$1,\n      IsMappedResult: IsMappedResult$1,\n      IsNever: IsNever$1,\n      IsNot: IsNot$1,\n      IsNull: IsNull$1,\n      IsNumber: IsNumber$1,\n      IsObject: IsObject$1,\n      IsOptional: IsOptional$1,\n      IsPromise: IsPromise$1,\n      IsProperties: IsProperties$1,\n      IsReadonly: IsReadonly$1,\n      IsRecord: IsRecord$1,\n      IsRecursive: IsRecursive$1,\n      IsRef: IsRef$1,\n      IsRegExp: IsRegExp$1,\n      IsSchema: IsSchema$1,\n      IsString: IsString$1,\n      IsSymbol: IsSymbol$1,\n      IsTemplateLiteral: IsTemplateLiteral$1,\n      IsThis: IsThis$1,\n      IsTransform: IsTransform$1,\n      IsTuple: IsTuple$1,\n      IsUint8Array: IsUint8Array$1,\n      IsUndefined: IsUndefined$1,\n      IsUnion: IsUnion$1,\n      IsUnknown: IsUnknown$1,\n      IsUnsafe: IsUnsafe$1,\n      IsVoid: IsVoid$1\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    __name(RemoveOptional, \"RemoveOptional\");\n    __name(AddOptional, \"AddOptional\");\n    __name(OptionalWithFlag, \"OptionalWithFlag\");\n    __name(Optional, \"Optional\");\n    __name(FromProperties$i, \"FromProperties$i\");\n    __name(FromMappedResult$b, \"FromMappedResult$b\");\n    __name(OptionalFromMappedResult, \"OptionalFromMappedResult\");\n    __name(IntersectCreate, \"IntersectCreate\");\n    __name(IsIntersectOptional, \"IsIntersectOptional\");\n    __name(RemoveOptionalFromType$1, \"RemoveOptionalFromType$1\");\n    __name(RemoveOptionalFromRest$1, \"RemoveOptionalFromRest$1\");\n    __name(ResolveIntersect, \"ResolveIntersect\");\n    __name(IntersectEvaluated, \"IntersectEvaluated\");\n    __name(Intersect$1, \"Intersect$1\");\n    __name(UnionCreate, \"UnionCreate\");\n    __name(IsUnionOptional, \"IsUnionOptional\");\n    __name(RemoveOptionalFromRest, \"RemoveOptionalFromRest\");\n    __name(RemoveOptionalFromType, \"RemoveOptionalFromType\");\n    __name(ResolveUnion, \"ResolveUnion\");\n    __name(UnionEvaluated, \"UnionEvaluated\");\n    __name(Union$1, \"Union$1\");\n    TemplateLiteralParserError = class extends TypeBoxError {\n      static {\n        __name(this, \"TemplateLiteralParserError\");\n      }\n    };\n    __name(Unescape, \"Unescape\");\n    __name(IsNonEscaped, \"IsNonEscaped\");\n    __name(IsOpenParen, \"IsOpenParen\");\n    __name(IsCloseParen, \"IsCloseParen\");\n    __name(IsSeparator, \"IsSeparator\");\n    __name(IsGroup, \"IsGroup\");\n    __name(InGroup, \"InGroup\");\n    __name(IsPrecedenceOr, \"IsPrecedenceOr\");\n    __name(IsPrecedenceAnd, \"IsPrecedenceAnd\");\n    __name(Or$2, \"Or$2\");\n    __name(And, \"And\");\n    __name(TemplateLiteralParse, \"TemplateLiteralParse\");\n    __name(TemplateLiteralParseExact, \"TemplateLiteralParseExact\");\n    TemplateLiteralFiniteError = class extends TypeBoxError {\n      static {\n        __name(this, \"TemplateLiteralFiniteError\");\n      }\n    };\n    __name(IsNumberExpression, \"IsNumberExpression\");\n    __name(IsBooleanExpression, \"IsBooleanExpression\");\n    __name(IsStringExpression, \"IsStringExpression\");\n    __name(IsTemplateLiteralExpressionFinite, \"IsTemplateLiteralExpressionFinite\");\n    __name(IsTemplateLiteralFinite, \"IsTemplateLiteralFinite\");\n    TemplateLiteralGenerateError = class extends TypeBoxError {\n      static {\n        __name(this, \"TemplateLiteralGenerateError\");\n      }\n    };\n    __name(GenerateReduce, \"GenerateReduce\");\n    __name(GenerateAnd, \"GenerateAnd\");\n    __name(GenerateOr, \"GenerateOr\");\n    __name(GenerateConst, \"GenerateConst\");\n    __name(TemplateLiteralExpressionGenerate, \"TemplateLiteralExpressionGenerate\");\n    __name(TemplateLiteralGenerate, \"TemplateLiteralGenerate\");\n    __name(Literal, \"Literal\");\n    __name(Boolean$1, \"Boolean$1\");\n    __name(BigInt$1, \"BigInt$1\");\n    __name(Number$1, \"Number$1\");\n    __name(String$1, \"String$1\");\n    __name(FromUnion$e, \"FromUnion$e\");\n    __name(FromTerminal, \"FromTerminal\");\n    __name(FromSyntax, \"FromSyntax\");\n    __name(TemplateLiteralSyntax, \"TemplateLiteralSyntax\");\n    PatternBoolean = \"(true|false)\";\n    PatternNumber = \"(0|[1-9][0-9]*)\";\n    PatternString = \"(.*)\";\n    PatternNever = \"(?!.*)\";\n    PatternBooleanExact = `^${PatternBoolean}$`;\n    PatternNumberExact = `^${PatternNumber}$`;\n    PatternStringExact = `^${PatternString}$`;\n    PatternNeverExact = `^${PatternNever}$`;\n    TemplateLiteralPatternError = class extends TypeBoxError {\n      static {\n        __name(this, \"TemplateLiteralPatternError\");\n      }\n    };\n    __name(Escape, \"Escape\");\n    __name(Visit$7, \"Visit$7\");\n    __name(TemplateLiteralPattern, \"TemplateLiteralPattern\");\n    __name(TemplateLiteralToUnion, \"TemplateLiteralToUnion\");\n    __name(TemplateLiteral, \"TemplateLiteral\");\n    __name(FromTemplateLiteral$4, \"FromTemplateLiteral$4\");\n    __name(FromUnion$d, \"FromUnion$d\");\n    __name(FromLiteral$3, \"FromLiteral$3\");\n    __name(IndexPropertyKeys, \"IndexPropertyKeys\");\n    __name(FromProperties$h, \"FromProperties$h\");\n    __name(FromMappedResult$a, \"FromMappedResult$a\");\n    __name(IndexFromMappedResult, \"IndexFromMappedResult\");\n    __name(FromRest$6, \"FromRest$6\");\n    __name(FromIntersectRest, \"FromIntersectRest\");\n    __name(FromIntersect$c, \"FromIntersect$c\");\n    __name(FromUnionRest, \"FromUnionRest\");\n    __name(FromUnion$c, \"FromUnion$c\");\n    __name(FromTuple$9, \"FromTuple$9\");\n    __name(FromArray$b, \"FromArray$b\");\n    __name(FromProperty$2, \"FromProperty$2\");\n    __name(IndexFromPropertyKey, \"IndexFromPropertyKey\");\n    __name(IndexFromPropertyKeys, \"IndexFromPropertyKeys\");\n    __name(FromSchema, \"FromSchema\");\n    __name(IndexFromComputed, \"IndexFromComputed\");\n    __name(Index, \"Index\");\n    __name(MappedIndexPropertyKey, \"MappedIndexPropertyKey\");\n    __name(MappedIndexPropertyKeys, \"MappedIndexPropertyKeys\");\n    __name(MappedIndexProperties, \"MappedIndexProperties\");\n    __name(IndexFromMappedKey, \"IndexFromMappedKey\");\n    __name(Iterator, \"Iterator\");\n    __name(RequiredKeys, \"RequiredKeys\");\n    __name(_Object, \"_Object\");\n    Object$1 = _Object;\n    __name(Promise$2, \"Promise$2\");\n    __name(RemoveReadonly, \"RemoveReadonly\");\n    __name(AddReadonly, \"AddReadonly\");\n    __name(ReadonlyWithFlag, \"ReadonlyWithFlag\");\n    __name(Readonly, \"Readonly\");\n    __name(FromProperties$g, \"FromProperties$g\");\n    __name(FromMappedResult$9, \"FromMappedResult$9\");\n    __name(ReadonlyFromMappedResult, \"ReadonlyFromMappedResult\");\n    __name(Tuple, \"Tuple\");\n    __name(SetIncludes, \"SetIncludes\");\n    __name(SetIsSubset, \"SetIsSubset\");\n    __name(SetDistinct, \"SetDistinct\");\n    __name(SetIntersect, \"SetIntersect\");\n    __name(SetUnion, \"SetUnion\");\n    __name(SetComplement, \"SetComplement\");\n    __name(SetIntersectManyResolve, \"SetIntersectManyResolve\");\n    __name(SetIntersectMany, \"SetIntersectMany\");\n    __name(SetUnionMany, \"SetUnionMany\");\n    __name(FromMappedResult$8, \"FromMappedResult$8\");\n    __name(MappedKeyToKnownMappedResultProperties, \"MappedKeyToKnownMappedResultProperties\");\n    __name(MappedKeyToUnknownMappedResultProperties, \"MappedKeyToUnknownMappedResultProperties\");\n    __name(MappedKeyToMappedResultProperties, \"MappedKeyToMappedResultProperties\");\n    __name(FromMappedKey$3, \"FromMappedKey$3\");\n    __name(FromRest$5, \"FromRest$5\");\n    __name(FromProperties$f, \"FromProperties$f\");\n    __name(FromSchemaType, \"FromSchemaType\");\n    __name(MappedFunctionReturnType, \"MappedFunctionReturnType\");\n    __name(Mapped, \"Mapped\");\n    __name(Ref, \"Ref\");\n    __name(FromRest$4, \"FromRest$4\");\n    __name(FromIntersect$b, \"FromIntersect$b\");\n    __name(FromUnion$b, \"FromUnion$b\");\n    __name(FromTuple$8, \"FromTuple$8\");\n    __name(FromArray$a, \"FromArray$a\");\n    __name(FromProperties$e, \"FromProperties$e\");\n    __name(FromPatternProperties, \"FromPatternProperties\");\n    __name(KeyOfPropertyKeys, \"KeyOfPropertyKeys\");\n    includePatternProperties = false;\n    __name(KeyOfPattern, \"KeyOfPattern\");\n    __name(FromComputed$4, \"FromComputed$4\");\n    __name(FromRef$8, \"FromRef$8\");\n    __name(KeyOfFromType, \"KeyOfFromType\");\n    __name(KeyOfPropertyKeysToRest, \"KeyOfPropertyKeysToRest\");\n    __name(KeyOf, \"KeyOf\");\n    __name(FromProperties$d, \"FromProperties$d\");\n    __name(FromMappedResult$7, \"FromMappedResult$7\");\n    __name(KeyOfFromMappedResult, \"KeyOfFromMappedResult\");\n    __name(KeyOfPropertyEntries, \"KeyOfPropertyEntries\");\n    __name(Intersect, \"Intersect\");\n    __name(Union, \"Union\");\n    __name(Not$1, \"Not$1\");\n    __name(ExtendsUndefinedCheck, \"ExtendsUndefinedCheck\");\n    __name(DefaultErrorFunction, \"DefaultErrorFunction\");\n    errorFunction = DefaultErrorFunction;\n    __name(SetErrorFunction, \"SetErrorFunction\");\n    __name(GetErrorFunction, \"GetErrorFunction\");\n    TypeDereferenceError = class extends TypeBoxError {\n      static {\n        __name(this, \"TypeDereferenceError\");\n      }\n      constructor(schema2) {\n        super(`Unable to dereference schema with $id '${schema2.$ref}'`);\n        this.schema = schema2;\n      }\n    };\n    __name(Resolve, \"Resolve\");\n    __name(Pushref, \"Pushref\");\n    __name(Deref, \"Deref\");\n    ValueHashError = class extends TypeBoxError {\n      static {\n        __name(this, \"ValueHashError\");\n      }\n      constructor(value2) {\n        super(`Unable to hash value`);\n        this.value = value2;\n      }\n    };\n    (function(ByteMarker2) {\n      ByteMarker2[ByteMarker2[\"Undefined\"] = 0] = \"Undefined\";\n      ByteMarker2[ByteMarker2[\"Null\"] = 1] = \"Null\";\n      ByteMarker2[ByteMarker2[\"Boolean\"] = 2] = \"Boolean\";\n      ByteMarker2[ByteMarker2[\"Number\"] = 3] = \"Number\";\n      ByteMarker2[ByteMarker2[\"String\"] = 4] = \"String\";\n      ByteMarker2[ByteMarker2[\"Object\"] = 5] = \"Object\";\n      ByteMarker2[ByteMarker2[\"Array\"] = 6] = \"Array\";\n      ByteMarker2[ByteMarker2[\"Date\"] = 7] = \"Date\";\n      ByteMarker2[ByteMarker2[\"Uint8Array\"] = 8] = \"Uint8Array\";\n      ByteMarker2[ByteMarker2[\"Symbol\"] = 9] = \"Symbol\";\n      ByteMarker2[ByteMarker2[\"BigInt\"] = 10] = \"BigInt\";\n    })(ByteMarker || (ByteMarker = {}));\n    Accumulator = BigInt(\"14695981039346656037\");\n    [Prime, Size] = [BigInt(\"1099511628211\"), BigInt(\n      \"18446744073709551616\"\n      /* 2 ^ 64 */\n    )];\n    Bytes = Array.from({ length: 256 }).map((_3, i) => BigInt(i));\n    F64 = new Float64Array(1);\n    F64In = new DataView(F64.buffer);\n    F64Out = new Uint8Array(F64.buffer);\n    __name(NumberToBytes, \"NumberToBytes\");\n    __name(ArrayType, \"ArrayType\");\n    __name(BooleanType, \"BooleanType\");\n    __name(BigIntType, \"BigIntType\");\n    __name(DateType, \"DateType\");\n    __name(NullType, \"NullType\");\n    __name(NumberType, \"NumberType\");\n    __name(ObjectType, \"ObjectType\");\n    __name(StringType, \"StringType\");\n    __name(SymbolType, \"SymbolType\");\n    __name(Uint8ArrayType, \"Uint8ArrayType\");\n    __name(UndefinedType, \"UndefinedType\");\n    __name(Visit$6, \"Visit$6\");\n    __name(FNV1A64, \"FNV1A64\");\n    __name(Hash$1, \"Hash$1\");\n    __name(Any, \"Any\");\n    __name(Unknown, \"Unknown\");\n    TypeGuardUnknownTypeError = class extends TypeBoxError {\n      static {\n        __name(this, \"TypeGuardUnknownTypeError\");\n      }\n    };\n    KnownTypes = [\n      \"Argument\",\n      \"Any\",\n      \"Array\",\n      \"AsyncIterator\",\n      \"BigInt\",\n      \"Boolean\",\n      \"Computed\",\n      \"Constructor\",\n      \"Date\",\n      \"Enum\",\n      \"Function\",\n      \"Integer\",\n      \"Intersect\",\n      \"Iterator\",\n      \"Literal\",\n      \"MappedKey\",\n      \"MappedResult\",\n      \"Not\",\n      \"Null\",\n      \"Number\",\n      \"Object\",\n      \"Promise\",\n      \"Record\",\n      \"Ref\",\n      \"RegExp\",\n      \"String\",\n      \"Symbol\",\n      \"TemplateLiteral\",\n      \"This\",\n      \"Tuple\",\n      \"Undefined\",\n      \"Union\",\n      \"Uint8Array\",\n      \"Unknown\",\n      \"Void\"\n    ];\n    __name(IsPattern, \"IsPattern\");\n    __name(IsControlCharacterFree, \"IsControlCharacterFree\");\n    __name(IsAdditionalProperties, \"IsAdditionalProperties\");\n    __name(IsOptionalBigInt, \"IsOptionalBigInt\");\n    __name(IsOptionalNumber, \"IsOptionalNumber\");\n    __name(IsOptionalBoolean, \"IsOptionalBoolean\");\n    __name(IsOptionalString, \"IsOptionalString\");\n    __name(IsOptionalPattern, \"IsOptionalPattern\");\n    __name(IsOptionalFormat, \"IsOptionalFormat\");\n    __name(IsOptionalSchema, \"IsOptionalSchema\");\n    __name(IsReadonly, \"IsReadonly\");\n    __name(IsOptional, \"IsOptional\");\n    __name(IsAny, \"IsAny\");\n    __name(IsArgument, \"IsArgument\");\n    __name(IsArray, \"IsArray\");\n    __name(IsAsyncIterator, \"IsAsyncIterator\");\n    __name(IsBigInt, \"IsBigInt\");\n    __name(IsBoolean, \"IsBoolean\");\n    __name(IsComputed, \"IsComputed\");\n    __name(IsConstructor, \"IsConstructor\");\n    __name(IsDate, \"IsDate\");\n    __name(IsFunction, \"IsFunction\");\n    __name(IsImport, \"IsImport\");\n    __name(IsInteger, \"IsInteger\");\n    __name(IsProperties, \"IsProperties\");\n    __name(IsIntersect, \"IsIntersect\");\n    __name(IsIterator, \"IsIterator\");\n    __name(IsKindOf, \"IsKindOf\");\n    __name(IsLiteralString, \"IsLiteralString\");\n    __name(IsLiteralNumber, \"IsLiteralNumber\");\n    __name(IsLiteralBoolean, \"IsLiteralBoolean\");\n    __name(IsLiteral, \"IsLiteral\");\n    __name(IsLiteralValue, \"IsLiteralValue\");\n    __name(IsMappedKey, \"IsMappedKey\");\n    __name(IsMappedResult, \"IsMappedResult\");\n    __name(IsNever, \"IsNever\");\n    __name(IsNot, \"IsNot\");\n    __name(IsNull, \"IsNull\");\n    __name(IsNumber, \"IsNumber\");\n    __name(IsObject, \"IsObject\");\n    __name(IsPromise, \"IsPromise\");\n    __name(IsRecord, \"IsRecord\");\n    __name(IsRecursive, \"IsRecursive\");\n    __name(IsRef, \"IsRef\");\n    __name(IsRegExp, \"IsRegExp\");\n    __name(IsString, \"IsString\");\n    __name(IsSymbol, \"IsSymbol\");\n    __name(IsTemplateLiteral, \"IsTemplateLiteral\");\n    __name(IsThis, \"IsThis\");\n    __name(IsTransform, \"IsTransform\");\n    __name(IsTuple, \"IsTuple\");\n    __name(IsUndefined, \"IsUndefined\");\n    __name(IsUnionLiteral, \"IsUnionLiteral\");\n    __name(IsUnion, \"IsUnion\");\n    __name(IsUint8Array, \"IsUint8Array\");\n    __name(IsUnknown, \"IsUnknown\");\n    __name(IsUnsafe, \"IsUnsafe\");\n    __name(IsVoid, \"IsVoid\");\n    __name(IsKind, \"IsKind\");\n    __name(IsSchema, \"IsSchema\");\n    type = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      IsAny,\n      IsArgument,\n      IsArray,\n      IsAsyncIterator,\n      IsBigInt,\n      IsBoolean,\n      IsComputed,\n      IsConstructor,\n      IsDate,\n      IsFunction,\n      IsImport,\n      IsInteger,\n      IsIntersect,\n      IsIterator,\n      IsKind,\n      IsKindOf,\n      IsLiteral,\n      IsLiteralBoolean,\n      IsLiteralNumber,\n      IsLiteralString,\n      IsLiteralValue,\n      IsMappedKey,\n      IsMappedResult,\n      IsNever,\n      IsNot,\n      IsNull,\n      IsNumber,\n      IsObject,\n      IsOptional,\n      IsPromise,\n      IsProperties,\n      IsReadonly,\n      IsRecord,\n      IsRecursive,\n      IsRef,\n      IsRegExp,\n      IsSchema,\n      IsString,\n      IsSymbol,\n      IsTemplateLiteral,\n      IsThis,\n      IsTransform,\n      IsTuple,\n      IsUint8Array,\n      IsUndefined,\n      IsUnion,\n      IsUnionLiteral,\n      IsUnknown,\n      IsUnsafe,\n      IsVoid,\n      TypeGuardUnknownTypeError\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    ExtendsResolverError = class extends TypeBoxError {\n      static {\n        __name(this, \"ExtendsResolverError\");\n      }\n    };\n    (function(ExtendsResult2) {\n      ExtendsResult2[ExtendsResult2[\"Union\"] = 0] = \"Union\";\n      ExtendsResult2[ExtendsResult2[\"True\"] = 1] = \"True\";\n      ExtendsResult2[ExtendsResult2[\"False\"] = 2] = \"False\";\n    })(ExtendsResult || (ExtendsResult = {}));\n    __name(IntoBooleanResult, \"IntoBooleanResult\");\n    __name(Throw, \"Throw\");\n    __name(IsStructuralRight, \"IsStructuralRight\");\n    __name(StructuralRight, \"StructuralRight\");\n    __name(FromAnyRight, \"FromAnyRight\");\n    __name(FromAny$2, \"FromAny$2\");\n    __name(FromArrayRight, \"FromArrayRight\");\n    __name(FromArray$9, \"FromArray$9\");\n    __name(FromAsyncIterator$5, \"FromAsyncIterator$5\");\n    __name(FromBigInt$2, \"FromBigInt$2\");\n    __name(FromBooleanRight, \"FromBooleanRight\");\n    __name(FromBoolean$2, \"FromBoolean$2\");\n    __name(FromConstructor$5, \"FromConstructor$5\");\n    __name(FromDate$4, \"FromDate$4\");\n    __name(FromFunction$5, \"FromFunction$5\");\n    __name(FromIntegerRight, \"FromIntegerRight\");\n    __name(FromInteger$2, \"FromInteger$2\");\n    __name(FromIntersectRight, \"FromIntersectRight\");\n    __name(FromIntersect$a, \"FromIntersect$a\");\n    __name(FromIterator$5, \"FromIterator$5\");\n    __name(FromLiteral$2, \"FromLiteral$2\");\n    __name(FromNeverRight, \"FromNeverRight\");\n    __name(FromNever$2, \"FromNever$2\");\n    __name(UnwrapTNot, \"UnwrapTNot\");\n    __name(FromNot$4, \"FromNot$4\");\n    __name(FromNull$2, \"FromNull$2\");\n    __name(FromNumberRight, \"FromNumberRight\");\n    __name(FromNumber$2, \"FromNumber$2\");\n    __name(IsObjectPropertyCount, \"IsObjectPropertyCount\");\n    __name(IsObjectStringLike, \"IsObjectStringLike\");\n    __name(IsObjectSymbolLike, \"IsObjectSymbolLike\");\n    __name(IsObjectNumberLike, \"IsObjectNumberLike\");\n    __name(IsObjectBooleanLike, \"IsObjectBooleanLike\");\n    __name(IsObjectBigIntLike, \"IsObjectBigIntLike\");\n    __name(IsObjectDateLike, \"IsObjectDateLike\");\n    __name(IsObjectUint8ArrayLike, \"IsObjectUint8ArrayLike\");\n    __name(IsObjectFunctionLike, \"IsObjectFunctionLike\");\n    __name(IsObjectConstructorLike, \"IsObjectConstructorLike\");\n    __name(IsObjectArrayLike, \"IsObjectArrayLike\");\n    __name(IsObjectPromiseLike, \"IsObjectPromiseLike\");\n    __name(Property, \"Property\");\n    __name(FromObjectRight, \"FromObjectRight\");\n    __name(FromObject$c, \"FromObject$c\");\n    __name(FromPromise$5, \"FromPromise$5\");\n    __name(RecordKey$1, \"RecordKey$1\");\n    __name(RecordValue$1, \"RecordValue$1\");\n    __name(FromRecordRight, \"FromRecordRight\");\n    __name(FromRecord$7, \"FromRecord$7\");\n    __name(FromRegExp$2, \"FromRegExp$2\");\n    __name(FromStringRight, \"FromStringRight\");\n    __name(FromString$2, \"FromString$2\");\n    __name(FromSymbol$2, \"FromSymbol$2\");\n    __name(FromTemplateLiteral$3, \"FromTemplateLiteral$3\");\n    __name(IsArrayOfTuple, \"IsArrayOfTuple\");\n    __name(FromTupleRight, \"FromTupleRight\");\n    __name(FromTuple$7, \"FromTuple$7\");\n    __name(FromUint8Array$2, \"FromUint8Array$2\");\n    __name(FromUndefined$2, \"FromUndefined$2\");\n    __name(FromUnionRight, \"FromUnionRight\");\n    __name(FromUnion$a, \"FromUnion$a\");\n    __name(FromUnknownRight, \"FromUnknownRight\");\n    __name(FromUnknown$2, \"FromUnknown$2\");\n    __name(FromVoidRight, \"FromVoidRight\");\n    __name(FromVoid$2, \"FromVoid$2\");\n    __name(Visit$5, \"Visit$5\");\n    __name(ExtendsCheck, \"ExtendsCheck\");\n    __name(FromProperties$c, \"FromProperties$c\");\n    __name(FromMappedResult$6, \"FromMappedResult$6\");\n    __name(ExtendsFromMappedResult, \"ExtendsFromMappedResult\");\n    __name(ExtendsResolve, \"ExtendsResolve\");\n    __name(Extends, \"Extends\");\n    __name(FromPropertyKey$2, \"FromPropertyKey$2\");\n    __name(FromPropertyKeys$2, \"FromPropertyKeys$2\");\n    __name(FromMappedKey$2, \"FromMappedKey$2\");\n    __name(ExtendsFromMappedKey, \"ExtendsFromMappedKey\");\n    ValueCheckUnknownTypeError = class extends TypeBoxError {\n      static {\n        __name(this, \"ValueCheckUnknownTypeError\");\n      }\n      constructor(schema2) {\n        super(`Unknown type`);\n        this.schema = schema2;\n      }\n    };\n    __name(IsAnyOrUnknown, \"IsAnyOrUnknown\");\n    __name(IsDefined$1, \"IsDefined$1\");\n    __name(FromAny$1, \"FromAny$1\");\n    __name(FromArgument$2, \"FromArgument$2\");\n    __name(FromArray$8, \"FromArray$8\");\n    __name(FromAsyncIterator$4, \"FromAsyncIterator$4\");\n    __name(FromBigInt$1, \"FromBigInt$1\");\n    __name(FromBoolean$1, \"FromBoolean$1\");\n    __name(FromConstructor$4, \"FromConstructor$4\");\n    __name(FromDate$3, \"FromDate$3\");\n    __name(FromFunction$4, \"FromFunction$4\");\n    __name(FromImport$4, \"FromImport$4\");\n    __name(FromInteger$1, \"FromInteger$1\");\n    __name(FromIntersect$9, \"FromIntersect$9\");\n    __name(FromIterator$4, \"FromIterator$4\");\n    __name(FromLiteral$1, \"FromLiteral$1\");\n    __name(FromNever$1, \"FromNever$1\");\n    __name(FromNot$3, \"FromNot$3\");\n    __name(FromNull$1, \"FromNull$1\");\n    __name(FromNumber$1, \"FromNumber$1\");\n    __name(FromObject$b, \"FromObject$b\");\n    __name(FromPromise$4, \"FromPromise$4\");\n    __name(FromRecord$6, \"FromRecord$6\");\n    __name(FromRef$7, \"FromRef$7\");\n    __name(FromRegExp$1, \"FromRegExp$1\");\n    __name(FromString$1, \"FromString$1\");\n    __name(FromSymbol$1, \"FromSymbol$1\");\n    __name(FromTemplateLiteral$2, \"FromTemplateLiteral$2\");\n    __name(FromThis$4, \"FromThis$4\");\n    __name(FromTuple$6, \"FromTuple$6\");\n    __name(FromUndefined$1, \"FromUndefined$1\");\n    __name(FromUnion$9, \"FromUnion$9\");\n    __name(FromUint8Array$1, \"FromUint8Array$1\");\n    __name(FromUnknown$1, \"FromUnknown$1\");\n    __name(FromVoid$1, \"FromVoid$1\");\n    __name(FromKind$1, \"FromKind$1\");\n    __name(Visit$4, \"Visit$4\");\n    __name(Check, \"Check\");\n    (function(ValueErrorType2) {\n      ValueErrorType2[ValueErrorType2[\"ArrayContains\"] = 0] = \"ArrayContains\";\n      ValueErrorType2[ValueErrorType2[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n      ValueErrorType2[ValueErrorType2[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n      ValueErrorType2[ValueErrorType2[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n      ValueErrorType2[ValueErrorType2[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n      ValueErrorType2[ValueErrorType2[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n      ValueErrorType2[ValueErrorType2[\"Array\"] = 6] = \"Array\";\n      ValueErrorType2[ValueErrorType2[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n      ValueErrorType2[ValueErrorType2[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n      ValueErrorType2[ValueErrorType2[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n      ValueErrorType2[ValueErrorType2[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n      ValueErrorType2[ValueErrorType2[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n      ValueErrorType2[ValueErrorType2[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n      ValueErrorType2[ValueErrorType2[\"BigInt\"] = 13] = \"BigInt\";\n      ValueErrorType2[ValueErrorType2[\"Boolean\"] = 14] = \"Boolean\";\n      ValueErrorType2[ValueErrorType2[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n      ValueErrorType2[ValueErrorType2[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n      ValueErrorType2[ValueErrorType2[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n      ValueErrorType2[ValueErrorType2[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n      ValueErrorType2[ValueErrorType2[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n      ValueErrorType2[ValueErrorType2[\"Date\"] = 20] = \"Date\";\n      ValueErrorType2[ValueErrorType2[\"Function\"] = 21] = \"Function\";\n      ValueErrorType2[ValueErrorType2[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n      ValueErrorType2[ValueErrorType2[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n      ValueErrorType2[ValueErrorType2[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n      ValueErrorType2[ValueErrorType2[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n      ValueErrorType2[ValueErrorType2[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n      ValueErrorType2[ValueErrorType2[\"Integer\"] = 27] = \"Integer\";\n      ValueErrorType2[ValueErrorType2[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n      ValueErrorType2[ValueErrorType2[\"Intersect\"] = 29] = \"Intersect\";\n      ValueErrorType2[ValueErrorType2[\"Iterator\"] = 30] = \"Iterator\";\n      ValueErrorType2[ValueErrorType2[\"Kind\"] = 31] = \"Kind\";\n      ValueErrorType2[ValueErrorType2[\"Literal\"] = 32] = \"Literal\";\n      ValueErrorType2[ValueErrorType2[\"Never\"] = 33] = \"Never\";\n      ValueErrorType2[ValueErrorType2[\"Not\"] = 34] = \"Not\";\n      ValueErrorType2[ValueErrorType2[\"Null\"] = 35] = \"Null\";\n      ValueErrorType2[ValueErrorType2[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n      ValueErrorType2[ValueErrorType2[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n      ValueErrorType2[ValueErrorType2[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n      ValueErrorType2[ValueErrorType2[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n      ValueErrorType2[ValueErrorType2[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n      ValueErrorType2[ValueErrorType2[\"Number\"] = 41] = \"Number\";\n      ValueErrorType2[ValueErrorType2[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n      ValueErrorType2[ValueErrorType2[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n      ValueErrorType2[ValueErrorType2[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n      ValueErrorType2[ValueErrorType2[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n      ValueErrorType2[ValueErrorType2[\"Object\"] = 46] = \"Object\";\n      ValueErrorType2[ValueErrorType2[\"Promise\"] = 47] = \"Promise\";\n      ValueErrorType2[ValueErrorType2[\"RegExp\"] = 48] = \"RegExp\";\n      ValueErrorType2[ValueErrorType2[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n      ValueErrorType2[ValueErrorType2[\"StringFormat\"] = 50] = \"StringFormat\";\n      ValueErrorType2[ValueErrorType2[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n      ValueErrorType2[ValueErrorType2[\"StringMinLength\"] = 52] = \"StringMinLength\";\n      ValueErrorType2[ValueErrorType2[\"StringPattern\"] = 53] = \"StringPattern\";\n      ValueErrorType2[ValueErrorType2[\"String\"] = 54] = \"String\";\n      ValueErrorType2[ValueErrorType2[\"Symbol\"] = 55] = \"Symbol\";\n      ValueErrorType2[ValueErrorType2[\"TupleLength\"] = 56] = \"TupleLength\";\n      ValueErrorType2[ValueErrorType2[\"Tuple\"] = 57] = \"Tuple\";\n      ValueErrorType2[ValueErrorType2[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n      ValueErrorType2[ValueErrorType2[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n      ValueErrorType2[ValueErrorType2[\"Uint8Array\"] = 60] = \"Uint8Array\";\n      ValueErrorType2[ValueErrorType2[\"Undefined\"] = 61] = \"Undefined\";\n      ValueErrorType2[ValueErrorType2[\"Union\"] = 62] = \"Union\";\n      ValueErrorType2[ValueErrorType2[\"Void\"] = 63] = \"Void\";\n    })(ValueErrorType || (ValueErrorType = {}));\n    ValueErrorsUnknownTypeError = class extends TypeBoxError {\n      static {\n        __name(this, \"ValueErrorsUnknownTypeError\");\n      }\n      constructor(schema2) {\n        super(\"Unknown type\");\n        this.schema = schema2;\n      }\n    };\n    __name(EscapeKey, \"EscapeKey\");\n    __name(IsDefined, \"IsDefined\");\n    ValueErrorIterator = class {\n      static {\n        __name(this, \"ValueErrorIterator\");\n      }\n      constructor(iterator) {\n        this.iterator = iterator;\n      }\n      [Symbol.iterator]() {\n        return this.iterator;\n      }\n      /** Returns the first value error or undefined if no errors */\n      First() {\n        const next = this.iterator.next();\n        return next.done ? void 0 : next.value;\n      }\n    };\n    __name(Create, \"Create\");\n    __name(FromAny, \"FromAny\");\n    __name(FromArgument$1, \"FromArgument$1\");\n    __name(FromArray$7, \"FromArray$7\");\n    __name(FromAsyncIterator$3, \"FromAsyncIterator$3\");\n    __name(FromBigInt, \"FromBigInt\");\n    __name(FromBoolean, \"FromBoolean\");\n    __name(FromConstructor$3, \"FromConstructor$3\");\n    __name(FromDate$2, \"FromDate$2\");\n    __name(FromFunction$3, \"FromFunction$3\");\n    __name(FromImport$3, \"FromImport$3\");\n    __name(FromInteger, \"FromInteger\");\n    __name(FromIntersect$8, \"FromIntersect$8\");\n    __name(FromIterator$3, \"FromIterator$3\");\n    __name(FromLiteral, \"FromLiteral\");\n    __name(FromNever, \"FromNever\");\n    __name(FromNot$2, \"FromNot$2\");\n    __name(FromNull, \"FromNull\");\n    __name(FromNumber, \"FromNumber\");\n    __name(FromObject$a, \"FromObject$a\");\n    __name(FromPromise$3, \"FromPromise$3\");\n    __name(FromRecord$5, \"FromRecord$5\");\n    __name(FromRef$6, \"FromRef$6\");\n    __name(FromRegExp, \"FromRegExp\");\n    __name(FromString, \"FromString\");\n    __name(FromSymbol, \"FromSymbol\");\n    __name(FromTemplateLiteral$1, \"FromTemplateLiteral$1\");\n    __name(FromThis$3, \"FromThis$3\");\n    __name(FromTuple$5, \"FromTuple$5\");\n    __name(FromUndefined, \"FromUndefined\");\n    __name(FromUnion$8, \"FromUnion$8\");\n    __name(FromUint8Array, \"FromUint8Array\");\n    __name(FromUnknown, \"FromUnknown\");\n    __name(FromVoid, \"FromVoid\");\n    __name(FromKind, \"FromKind\");\n    __name(Visit$3, \"Visit$3\");\n    __name(Errors, \"Errors\");\n    __name(FromObject$9, \"FromObject$9\");\n    __name(FromArray$6, \"FromArray$6\");\n    __name(FromTypedArray, \"FromTypedArray\");\n    __name(FromMap, \"FromMap\");\n    __name(FromSet, \"FromSet\");\n    __name(FromDate$1, \"FromDate$1\");\n    __name(FromValue$1, \"FromValue$1\");\n    __name(Clone, \"Clone\");\n    TransformDecodeCheckError = class extends TypeBoxError {\n      static {\n        __name(this, \"TransformDecodeCheckError\");\n      }\n      constructor(schema2, value2, error4) {\n        super(`Unable to decode value as it does not match the expected schema`);\n        this.schema = schema2;\n        this.value = value2;\n        this.error = error4;\n      }\n    };\n    TransformDecodeError = class extends TypeBoxError {\n      static {\n        __name(this, \"TransformDecodeError\");\n      }\n      constructor(schema2, path, value2, error4) {\n        super(error4 instanceof Error ? error4.message : \"Unknown error\");\n        this.schema = schema2;\n        this.path = path;\n        this.value = value2;\n        this.error = error4;\n      }\n    };\n    __name(Default$1, \"Default$1\");\n    __name(FromArray$5, \"FromArray$5\");\n    __name(FromIntersect$7, \"FromIntersect$7\");\n    __name(FromImport$2, \"FromImport$2\");\n    __name(FromNot$1, \"FromNot$1\");\n    __name(FromObject$8, \"FromObject$8\");\n    __name(FromRecord$4, \"FromRecord$4\");\n    __name(FromRef$5, \"FromRef$5\");\n    __name(FromThis$2, \"FromThis$2\");\n    __name(FromTuple$4, \"FromTuple$4\");\n    __name(FromUnion$7, \"FromUnion$7\");\n    __name(Visit$2, \"Visit$2\");\n    __name(TransformDecode, \"TransformDecode\");\n    __name(FromArray$4, \"FromArray$4\");\n    __name(FromAsyncIterator$2, \"FromAsyncIterator$2\");\n    __name(FromConstructor$2, \"FromConstructor$2\");\n    __name(FromFunction$2, \"FromFunction$2\");\n    __name(FromIntersect$6, \"FromIntersect$6\");\n    __name(FromImport$1, \"FromImport$1\");\n    __name(FromIterator$2, \"FromIterator$2\");\n    __name(FromNot, \"FromNot\");\n    __name(FromObject$7, \"FromObject$7\");\n    __name(FromPromise$2, \"FromPromise$2\");\n    __name(FromRecord$3, \"FromRecord$3\");\n    __name(FromRef$4, \"FromRef$4\");\n    __name(FromThis$1, \"FromThis$1\");\n    __name(FromTuple$3, \"FromTuple$3\");\n    __name(FromUnion$6, \"FromUnion$6\");\n    __name(Visit$1, \"Visit$1\");\n    visited = /* @__PURE__ */ new Set();\n    __name(HasTransform, \"HasTransform\");\n    __name(Decode, \"Decode\");\n    __name(ValueOrDefault, \"ValueOrDefault\");\n    __name(HasDefaultProperty, \"HasDefaultProperty\");\n    __name(FromArray$3, \"FromArray$3\");\n    __name(FromDate, \"FromDate\");\n    __name(FromImport, \"FromImport\");\n    __name(FromIntersect$5, \"FromIntersect$5\");\n    __name(FromObject$6, \"FromObject$6\");\n    __name(FromRecord$2, \"FromRecord$2\");\n    __name(FromRef$3, \"FromRef$3\");\n    __name(FromThis, \"FromThis\");\n    __name(FromTuple$2, \"FromTuple$2\");\n    __name(FromUnion$5, \"FromUnion$5\");\n    __name(Visit, \"Visit\");\n    __name(Default, \"Default\");\n    splitPath = /* @__PURE__ */ __name((path) => {\n      const paths = path.split(\"/\");\n      if (paths[0] === \"\") {\n        paths.shift();\n      }\n      return paths;\n    }, \"splitPath\");\n    splitRoutingPath = /* @__PURE__ */ __name((routePath) => {\n      const { groups, path } = extractGroupsFromPath(routePath);\n      const paths = splitPath(path);\n      return replaceGroupMarks(paths, groups);\n    }, \"splitRoutingPath\");\n    extractGroupsFromPath = /* @__PURE__ */ __name((path) => {\n      const groups = [];\n      path = path.replace(/\\{[^}]+\\}/g, (match, index) => {\n        const mark = `@${index}`;\n        groups.push([mark, match]);\n        return mark;\n      });\n      return { groups, path };\n    }, \"extractGroupsFromPath\");\n    replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {\n      for (let i = groups.length - 1; i >= 0; i--) {\n        const [mark] = groups[i];\n        for (let j3 = paths.length - 1; j3 >= 0; j3--) {\n          if (paths[j3].includes(mark)) {\n            paths[j3] = paths[j3].replace(mark, groups[i][1]);\n            break;\n          }\n        }\n      }\n      return paths;\n    }, \"replaceGroupMarks\");\n    patternCache = {};\n    getPattern = /* @__PURE__ */ __name((label, next) => {\n      if (label === \"*\") {\n        return \"*\";\n      }\n      const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n      if (match) {\n        const cacheKey2 = `${label}#${next}`;\n        if (!patternCache[cacheKey2]) {\n          if (match[2]) {\n            patternCache[cacheKey2] = next && next[0] !== \":\" && next[0] !== \"*\" ? [cacheKey2, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];\n          } else {\n            patternCache[cacheKey2] = [label, match[1], true];\n          }\n        }\n        return patternCache[cacheKey2];\n      }\n      return null;\n    }, \"getPattern\");\n    tryDecode = /* @__PURE__ */ __name((str, decoder3) => {\n      try {\n        return decoder3(str);\n      } catch {\n        return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {\n          try {\n            return decoder3(match);\n          } catch {\n            return match;\n          }\n        });\n      }\n    }, \"tryDecode\");\n    tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), \"tryDecodeURI\");\n    getPath = /* @__PURE__ */ __name((request) => {\n      const url = request.url;\n      const start = url.indexOf(\"/\", 8);\n      let i = start;\n      for (; i < url.length; i++) {\n        const charCode = url.charCodeAt(i);\n        if (charCode === 37) {\n          const queryIndex = url.indexOf(\"?\", i);\n          const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);\n          return tryDecodeURI(path.includes(\"%25\") ? path.replace(/%25/g, \"%2525\") : path);\n        } else if (charCode === 63) {\n          break;\n        }\n      }\n      return url.slice(start, i);\n    }, \"getPath\");\n    getPathNoStrict = /* @__PURE__ */ __name((request) => {\n      const result = getPath(request);\n      return result.length > 1 && result.at(-1) === \"/\" ? result.slice(0, -1) : result;\n    }, \"getPathNoStrict\");\n    mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {\n      if (rest.length) {\n        sub = mergePath(sub, ...rest);\n      }\n      return `${base?.[0] === \"/\" ? \"\" : \"/\"}${base}${sub === \"/\" ? \"\" : `${base?.at(-1) === \"/\" ? \"\" : \"/\"}${sub?.[0] === \"/\" ? sub.slice(1) : sub}`}`;\n    }, \"mergePath\");\n    checkOptionalParameter = /* @__PURE__ */ __name((path) => {\n      if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(\":\")) {\n        return null;\n      }\n      const segments = path.split(\"/\");\n      const results = [];\n      let basePath = \"\";\n      segments.forEach((segment) => {\n        if (segment !== \"\" && !/\\:/.test(segment)) {\n          basePath += \"/\" + segment;\n        } else if (/\\:/.test(segment)) {\n          if (/\\?/.test(segment)) {\n            if (results.length === 0 && basePath === \"\") {\n              results.push(\"/\");\n            } else {\n              results.push(basePath);\n            }\n            const optionalSegment = segment.replace(\"?\", \"\");\n            basePath += \"/\" + optionalSegment;\n            results.push(basePath);\n          } else {\n            basePath += \"/\" + segment;\n          }\n        }\n      });\n      return results.filter((v3, i, a2) => a2.indexOf(v3) === i);\n    }, \"checkOptionalParameter\");\n    _decodeURI = /* @__PURE__ */ __name((value2) => {\n      if (!/[%+]/.test(value2)) {\n        return value2;\n      }\n      if (value2.indexOf(\"+\") !== -1) {\n        value2 = value2.replace(/\\+/g, \" \");\n      }\n      return value2.indexOf(\"%\") !== -1 ? decodeURIComponent_(value2) : value2;\n    }, \"_decodeURI\");\n    _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {\n      let encoded;\n      if (!multiple && key && !/[%+]/.test(key)) {\n        let keyIndex2 = url.indexOf(`?${key}`, 8);\n        if (keyIndex2 === -1) {\n          keyIndex2 = url.indexOf(`&${key}`, 8);\n        }\n        while (keyIndex2 !== -1) {\n          const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n          if (trailingKeyCode === 61) {\n            const valueIndex = keyIndex2 + key.length + 2;\n            const endIndex = url.indexOf(\"&\", valueIndex);\n            return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n          } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {\n            return \"\";\n          }\n          keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n        }\n        encoded = /[%+]/.test(url);\n        if (!encoded) {\n          return void 0;\n        }\n      }\n      const results = {};\n      encoded ??= /[%+]/.test(url);\n      let keyIndex = url.indexOf(\"?\", 8);\n      while (keyIndex !== -1) {\n        const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n        let valueIndex = url.indexOf(\"=\", keyIndex);\n        if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {\n          valueIndex = -1;\n        }\n        let name = url.slice(\n          keyIndex + 1,\n          valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex\n        );\n        if (encoded) {\n          name = _decodeURI(name);\n        }\n        keyIndex = nextKeyIndex;\n        if (name === \"\") {\n          continue;\n        }\n        let value2;\n        if (valueIndex === -1) {\n          value2 = \"\";\n        } else {\n          value2 = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n          if (encoded) {\n            value2 = _decodeURI(value2);\n          }\n        }\n        if (multiple) {\n          if (!(results[name] && Array.isArray(results[name]))) {\n            results[name] = [];\n          }\n          results[name].push(value2);\n        } else {\n          results[name] ??= value2;\n        }\n      }\n      return key ? results[key] : results;\n    }, \"_getQueryParam\");\n    getQueryParam = _getQueryParam;\n    getQueryParams = /* @__PURE__ */ __name((url, key) => {\n      return _getQueryParam(url, key, true);\n    }, \"getQueryParams\");\n    decodeURIComponent_ = decodeURIComponent;\n    algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n    getCryptoKey = /* @__PURE__ */ __name(async (secret) => {\n      const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n      return await crypto.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n    }, \"getCryptoKey\");\n    makeSignature = /* @__PURE__ */ __name(async (value2, secret) => {\n      const key = await getCryptoKey(secret);\n      const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value2));\n      return btoa(String.fromCharCode(...new Uint8Array(signature)));\n    }, \"makeSignature\");\n    verifySignature = /* @__PURE__ */ __name(async (base64Signature, value2, secret) => {\n      try {\n        const signatureBinStr = atob(base64Signature);\n        const signature = new Uint8Array(signatureBinStr.length);\n        for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n          signature[i] = signatureBinStr.charCodeAt(i);\n        }\n        return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value2));\n      } catch {\n        return false;\n      }\n    }, \"verifySignature\");\n    validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\n    validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\n    parse$1 = /* @__PURE__ */ __name((cookie, name) => {\n      if (name && cookie.indexOf(name) === -1) {\n        return {};\n      }\n      const pairs = cookie.trim().split(\";\");\n      const parsedCookie = {};\n      for (let pairStr of pairs) {\n        pairStr = pairStr.trim();\n        const valueStartPos = pairStr.indexOf(\"=\");\n        if (valueStartPos === -1) {\n          continue;\n        }\n        const cookieName = pairStr.substring(0, valueStartPos).trim();\n        if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n          continue;\n        }\n        let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n        if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n          cookieValue = cookieValue.slice(1, -1);\n        }\n        if (validCookieValueRegEx.test(cookieValue)) {\n          parsedCookie[cookieName] = decodeURIComponent_(cookieValue);\n          if (name) {\n            break;\n          }\n        }\n      }\n      return parsedCookie;\n    }, \"parse$1\");\n    parseSigned = /* @__PURE__ */ __name(async (cookie, secret, name) => {\n      const parsedCookie = {};\n      const secretKey = await getCryptoKey(secret);\n      for (const [key, value2] of Object.entries(parse$1(cookie, name))) {\n        const signatureStartPos = value2.lastIndexOf(\".\");\n        if (signatureStartPos < 1) {\n          continue;\n        }\n        const signedValue = value2.substring(0, signatureStartPos);\n        const signature = value2.substring(signatureStartPos + 1);\n        if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n          continue;\n        }\n        const isVerified = await verifySignature(signature, signedValue, secretKey);\n        parsedCookie[key] = isVerified ? signedValue : false;\n      }\n      return parsedCookie;\n    }, \"parseSigned\");\n    _serialize = /* @__PURE__ */ __name((name, value2, opt = {}) => {\n      let cookie = `${name}=${value2}`;\n      if (name.startsWith(\"__Secure-\") && !opt.secure) {\n        throw new Error(\"__Secure- Cookie must have Secure attributes\");\n      }\n      if (name.startsWith(\"__Host-\")) {\n        if (!opt.secure) {\n          throw new Error(\"__Host- Cookie must have Secure attributes\");\n        }\n        if (opt.path !== \"/\") {\n          throw new Error('__Host- Cookie must have Path attributes with \"/\"');\n        }\n        if (opt.domain) {\n          throw new Error(\"__Host- Cookie must not have Domain attributes\");\n        }\n      }\n      if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n        if (opt.maxAge > 3456e4) {\n          throw new Error(\n            \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n          );\n        }\n        cookie += `; Max-Age=${opt.maxAge | 0}`;\n      }\n      if (opt.domain && opt.prefix !== \"host\") {\n        cookie += `; Domain=${opt.domain}`;\n      }\n      if (opt.path) {\n        cookie += `; Path=${opt.path}`;\n      }\n      if (opt.expires) {\n        if (opt.expires.getTime() - Date.now() > 3456e7) {\n          throw new Error(\n            \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n          );\n        }\n        cookie += `; Expires=${opt.expires.toUTCString()}`;\n      }\n      if (opt.httpOnly) {\n        cookie += \"; HttpOnly\";\n      }\n      if (opt.secure) {\n        cookie += \"; Secure\";\n      }\n      if (opt.sameSite) {\n        cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n      }\n      if (opt.priority) {\n        cookie += `; Priority=${opt.priority}`;\n      }\n      if (opt.partitioned) {\n        if (!opt.secure) {\n          throw new Error(\"Partitioned Cookie must have Secure attributes\");\n        }\n        cookie += \"; Partitioned\";\n      }\n      return cookie;\n    }, \"_serialize\");\n    serialize = /* @__PURE__ */ __name((name, value2, opt) => {\n      value2 = encodeURIComponent(value2);\n      return _serialize(name, value2, opt);\n    }, \"serialize\");\n    serializeSigned = /* @__PURE__ */ __name(async (name, value2, secret, opt = {}) => {\n      const signature = await makeSignature(value2, secret);\n      value2 = `${value2}.${signature}`;\n      value2 = encodeURIComponent(value2);\n      return _serialize(name, value2, opt);\n    }, \"serializeSigned\");\n    getCookie = /* @__PURE__ */ __name((c, key, prefix) => {\n      const cookie = c.req.raw.headers.get(\"Cookie\");\n      if (typeof key === \"string\") {\n        if (!cookie) {\n          return void 0;\n        }\n        let finalKey = key;\n        if (prefix === \"secure\") {\n          finalKey = \"__Secure-\" + key;\n        } else if (prefix === \"host\") {\n          finalKey = \"__Host-\" + key;\n        }\n        const obj2 = parse$1(cookie, finalKey);\n        return obj2[finalKey];\n      }\n      if (!cookie) {\n        return {};\n      }\n      const obj = parse$1(cookie);\n      return obj;\n    }, \"getCookie\");\n    getSignedCookie = /* @__PURE__ */ __name(async (c, secret, key, prefix) => {\n      const cookie = c.req.raw.headers.get(\"Cookie\");\n      if (typeof key === \"string\") {\n        if (!cookie) {\n          return void 0;\n        }\n        let finalKey = key;\n        const obj2 = await parseSigned(cookie, secret, finalKey);\n        return obj2[finalKey];\n      }\n      if (!cookie) {\n        return {};\n      }\n      const obj = await parseSigned(cookie, secret);\n      return obj;\n    }, \"getSignedCookie\");\n    setCookie = /* @__PURE__ */ __name((c, name, value2, opt) => {\n      let cookie;\n      if (opt?.prefix === \"secure\") {\n        cookie = serialize(\"__Secure-\" + name, value2, { path: \"/\", ...opt, secure: true });\n      } else if (opt?.prefix === \"host\") {\n        cookie = serialize(\"__Host-\" + name, value2, {\n          ...opt,\n          path: \"/\",\n          secure: true,\n          domain: void 0\n        });\n      } else {\n        cookie = serialize(name, value2, { path: \"/\", ...opt });\n      }\n      c.header(\"Set-Cookie\", cookie, { append: true });\n    }, \"setCookie\");\n    setSignedCookie = /* @__PURE__ */ __name(async (c, name, value2, secret, opt) => {\n      let cookie;\n      if (opt?.prefix === \"secure\") {\n        cookie = await serializeSigned(\"__Secure-\" + name, value2, secret, {\n          path: \"/\",\n          ...opt,\n          secure: true\n        });\n      } else if (opt?.prefix === \"host\") {\n        cookie = await serializeSigned(\"__Host-\" + name, value2, secret, {\n          ...opt,\n          path: \"/\",\n          secure: true,\n          domain: void 0\n        });\n      } else {\n        cookie = await serializeSigned(name, value2, secret, { path: \"/\", ...opt });\n      }\n      c.header(\"set-cookie\", cookie, { append: true });\n    }, \"setSignedCookie\");\n    deleteCookie = /* @__PURE__ */ __name((c, name, opt) => {\n      const deletedCookie = getCookie(c, name, opt?.prefix);\n      setCookie(c, name, \"\", { ...opt, maxAge: 0 });\n      return deletedCookie;\n    }, \"deleteCookie\");\n    HTTPException = class extends Error {\n      static {\n        __name(this, \"HTTPException\");\n      }\n      res;\n      status;\n      constructor(status = 500, options) {\n        super(options?.message, { cause: options?.cause });\n        this.res = options?.res;\n        this.status = status;\n      }\n      getResponse() {\n        if (this.res) {\n          const newResponse = new Response(this.res.body, {\n            status: this.status,\n            headers: this.res.headers\n          });\n          return newResponse;\n        }\n        return new Response(this.message, {\n          status: this.status\n        });\n      }\n    };\n    bufferToFormData = /* @__PURE__ */ __name((arrayBuffer, contentType) => {\n      const response = new Response(arrayBuffer, {\n        headers: {\n          \"Content-Type\": contentType\n        }\n      });\n      return response.formData();\n    }, \"bufferToFormData\");\n    jsonRegex = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\n    multipartRegex = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9'\"()+_,\\-./:=?]+)?$/;\n    urlencodedRegex = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\n    validator = /* @__PURE__ */ __name((target, validationFunc) => {\n      return async (c, next) => {\n        let value2 = {};\n        const contentType = c.req.header(\"Content-Type\");\n        switch (target) {\n          case \"json\":\n            if (!contentType || !jsonRegex.test(contentType)) {\n              break;\n            }\n            try {\n              value2 = await c.req.json();\n            } catch {\n              const message = \"Malformed JSON in request body\";\n              throw new HTTPException(400, { message });\n            }\n            break;\n          case \"form\": {\n            if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {\n              break;\n            }\n            let formData;\n            if (c.req.bodyCache.formData) {\n              formData = await c.req.bodyCache.formData;\n            } else {\n              try {\n                const arrayBuffer = await c.req.arrayBuffer();\n                formData = await bufferToFormData(arrayBuffer, contentType);\n                c.req.bodyCache.formData = formData;\n              } catch (e) {\n                let message = \"Malformed FormData request.\";\n                message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;\n                throw new HTTPException(400, { message });\n              }\n            }\n            const form2 = {};\n            formData.forEach((value22, key) => {\n              if (key.endsWith(\"[]\")) {\n                (form2[key] ??= []).push(value22);\n              } else if (Array.isArray(form2[key])) {\n                form2[key].push(value22);\n              } else if (key in form2) {\n                form2[key] = [form2[key], value22];\n              } else {\n                form2[key] = value22;\n              }\n            });\n            value2 = form2;\n            break;\n          }\n          case \"query\":\n            value2 = Object.fromEntries(\n              Object.entries(c.req.queries()).map(([k2, v3]) => {\n                return v3.length === 1 ? [k2, v3[0]] : [k2, v3];\n              })\n            );\n            break;\n          case \"param\":\n            value2 = c.req.param();\n            break;\n          case \"header\":\n            value2 = c.req.header();\n            break;\n          case \"cookie\":\n            value2 = getCookie(c);\n            break;\n        }\n        const res = await validationFunc(value2, c);\n        if (res instanceof Response) {\n          return res;\n        }\n        c.req.addValidatedData(target, res);\n        await next();\n      };\n    }, \"validator\");\n    encoder$12 = new TextEncoder();\n    HOST_SERVICES = {\n      appstream2: \"appstream\",\n      cloudhsmv2: \"cloudhsm\",\n      email: \"ses\",\n      marketplace: \"aws-marketplace\",\n      mobile: \"AWSMobileHubService\",\n      pinpoint: \"mobiletargeting\",\n      queue: \"sqs\",\n      \"git-codecommit\": \"codecommit\",\n      \"mturk-requester-sandbox\": \"mturk-requester\",\n      \"personalize-runtime\": \"personalize\"\n    };\n    UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([\n      \"authorization\",\n      \"content-type\",\n      \"content-length\",\n      \"user-agent\",\n      \"presigned-expires\",\n      \"expect\",\n      \"x-amzn-trace-id\",\n      \"range\",\n      \"connection\"\n    ]);\n    AwsClient = class {\n      static {\n        __name(this, \"AwsClient\");\n      }\n      constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {\n        if (accessKeyId == null) throw new TypeError(\"accessKeyId is a required option\");\n        if (secretAccessKey == null) throw new TypeError(\"secretAccessKey is a required option\");\n        this.accessKeyId = accessKeyId;\n        this.secretAccessKey = secretAccessKey;\n        this.sessionToken = sessionToken;\n        this.service = service;\n        this.region = region;\n        this.cache = cache || /* @__PURE__ */ new Map();\n        this.retries = retries != null ? retries : 10;\n        this.initRetryMs = initRetryMs || 50;\n      }\n      async sign(input2, init2) {\n        if (input2 instanceof Request) {\n          const { method, url, headers, body } = input2;\n          init2 = Object.assign({ method, url, headers }, init2);\n          if (init2.body == null && headers.has(\"Content-Type\")) {\n            init2.body = body != null && headers.has(\"X-Amz-Content-Sha256\") ? body : await input2.clone().arrayBuffer();\n          }\n          input2 = url;\n        }\n        const signer = new AwsV4Signer(Object.assign({ url: input2.toString() }, init2, this, init2 && init2.aws));\n        const signed = Object.assign({}, init2, await signer.sign());\n        delete signed.aws;\n        try {\n          return new Request(signed.url.toString(), signed);\n        } catch (e) {\n          if (e instanceof TypeError) {\n            return new Request(signed.url.toString(), Object.assign({ duplex: \"half\" }, signed));\n          }\n          throw e;\n        }\n      }\n      async fetch(input2, init2) {\n        for (let i = 0; i <= this.retries; i++) {\n          const fetched = fetch(await this.sign(input2, init2));\n          if (i === this.retries) {\n            return fetched;\n          }\n          const res = await fetched;\n          if (res.status < 500 && res.status !== 429) {\n            return res;\n          }\n          await new Promise((resolve) => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));\n        }\n        throw new Error(\"An unknown error occurred, ensure retries is not negative\");\n      }\n    };\n    AwsV4Signer = class {\n      static {\n        __name(this, \"AwsV4Signer\");\n      }\n      constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {\n        if (url == null) throw new TypeError(\"url is a required option\");\n        if (accessKeyId == null) throw new TypeError(\"accessKeyId is a required option\");\n        if (secretAccessKey == null) throw new TypeError(\"secretAccessKey is a required option\");\n        this.method = method || (body ? \"POST\" : \"GET\");\n        this.url = new URL(url);\n        this.headers = new Headers(headers || {});\n        this.body = body;\n        this.accessKeyId = accessKeyId;\n        this.secretAccessKey = secretAccessKey;\n        this.sessionToken = sessionToken;\n        let guessedService, guessedRegion;\n        if (!service || !region) {\n          [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);\n        }\n        this.service = service || guessedService || \"\";\n        this.region = region || guessedRegion || \"us-east-1\";\n        this.cache = cache || /* @__PURE__ */ new Map();\n        this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\\.\\d{3}/g, \"\");\n        this.signQuery = signQuery;\n        this.appendSessionToken = appendSessionToken || this.service === \"iotdevicegateway\";\n        this.headers.delete(\"Host\");\n        if (this.service === \"s3\" && !this.signQuery && !this.headers.has(\"X-Amz-Content-Sha256\")) {\n          this.headers.set(\"X-Amz-Content-Sha256\", \"UNSIGNED-PAYLOAD\");\n        }\n        const params = this.signQuery ? this.url.searchParams : this.headers;\n        params.set(\"X-Amz-Date\", this.datetime);\n        if (this.sessionToken && !this.appendSessionToken) {\n          params.set(\"X-Amz-Security-Token\", this.sessionToken);\n        }\n        this.signableHeaders = [\"host\", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();\n        this.signedHeaders = this.signableHeaders.join(\";\");\n        this.canonicalHeaders = this.signableHeaders.map((header) => header + \":\" + (header === \"host\" ? this.url.host : (this.headers.get(header) || \"\").replace(/\\s+/g, \" \"))).join(\"\\n\");\n        this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, \"aws4_request\"].join(\"/\");\n        if (this.signQuery) {\n          if (this.service === \"s3\" && !params.has(\"X-Amz-Expires\")) {\n            params.set(\"X-Amz-Expires\", \"86400\");\n          }\n          params.set(\"X-Amz-Algorithm\", \"AWS4-HMAC-SHA256\");\n          params.set(\"X-Amz-Credential\", this.accessKeyId + \"/\" + this.credentialString);\n          params.set(\"X-Amz-SignedHeaders\", this.signedHeaders);\n        }\n        if (this.service === \"s3\") {\n          try {\n            this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\\+/g, \" \"));\n          } catch (e) {\n            this.encodedPath = this.url.pathname;\n          }\n        } else {\n          this.encodedPath = this.url.pathname.replace(/\\/+/g, \"/\");\n        }\n        if (!singleEncode) {\n          this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, \"/\");\n        }\n        this.encodedPath = encodeRfc3986(this.encodedPath);\n        const seenKeys = /* @__PURE__ */ new Set();\n        this.encodedSearch = [...this.url.searchParams].filter(([k2]) => {\n          if (!k2) return false;\n          if (this.service === \"s3\") {\n            if (seenKeys.has(k2)) return false;\n            seenKeys.add(k2);\n          }\n          return true;\n        }).map((pair) => pair.map((p2) => encodeRfc3986(encodeURIComponent(p2)))).sort(([k1, v1], [k2, v22]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v22 ? -1 : v1 > v22 ? 1 : 0).map((pair) => pair.join(\"=\")).join(\"&\");\n      }\n      async sign() {\n        if (this.signQuery) {\n          this.url.searchParams.set(\"X-Amz-Signature\", await this.signature());\n          if (this.sessionToken && this.appendSessionToken) {\n            this.url.searchParams.set(\"X-Amz-Security-Token\", this.sessionToken);\n          }\n        } else {\n          this.headers.set(\"Authorization\", await this.authHeader());\n        }\n        return {\n          method: this.method,\n          url: this.url,\n          headers: this.headers,\n          body: this.body\n        };\n      }\n      async authHeader() {\n        return [\n          \"AWS4-HMAC-SHA256 Credential=\" + this.accessKeyId + \"/\" + this.credentialString,\n          \"SignedHeaders=\" + this.signedHeaders,\n          \"Signature=\" + await this.signature()\n        ].join(\", \");\n      }\n      async signature() {\n        const date2 = this.datetime.slice(0, 8);\n        const cacheKey2 = [this.secretAccessKey, date2, this.region, this.service].join();\n        let kCredentials = this.cache.get(cacheKey2);\n        if (!kCredentials) {\n          const kDate = await hmac(\"AWS4\" + this.secretAccessKey, date2);\n          const kRegion = await hmac(kDate, this.region);\n          const kService = await hmac(kRegion, this.service);\n          kCredentials = await hmac(kService, \"aws4_request\");\n          this.cache.set(cacheKey2, kCredentials);\n        }\n        return buf2hex(await hmac(kCredentials, await this.stringToSign()));\n      }\n      async stringToSign() {\n        return [\n          \"AWS4-HMAC-SHA256\",\n          this.datetime,\n          this.credentialString,\n          buf2hex(await hash$1(await this.canonicalString()))\n        ].join(\"\\n\");\n      }\n      async canonicalString() {\n        return [\n          this.method.toUpperCase(),\n          this.encodedPath,\n          this.encodedSearch,\n          this.canonicalHeaders + \"\\n\",\n          this.signedHeaders,\n          await this.hexBodyHash()\n        ].join(\"\\n\");\n      }\n      async hexBodyHash() {\n        let hashHeader = this.headers.get(\"X-Amz-Content-Sha256\") || (this.service === \"s3\" && this.signQuery ? \"UNSIGNED-PAYLOAD\" : null);\n        if (hashHeader == null) {\n          if (this.body && typeof this.body !== \"string\" && !(\"byteLength\" in this.body)) {\n            throw new Error(\"body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header\");\n          }\n          hashHeader = buf2hex(await hash$1(this.body || \"\"));\n        }\n        return hashHeader;\n      }\n    };\n    __name(hmac, \"hmac\");\n    __name(hash$1, \"hash$1\");\n    HEX_CHARS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n    __name(buf2hex, \"buf2hex\");\n    __name(encodeRfc3986, \"encodeRfc3986\");\n    __name(guessServiceRegion, \"guessServiceRegion\");\n    nameStartChar = \":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n    nameChar = nameStartChar + \"\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n    nameRegexp = \"[\" + nameStartChar + \"][\" + nameChar + \"]*\";\n    regexName = new RegExp(\"^\" + nameRegexp + \"$\");\n    __name(getAllMatches, \"getAllMatches\");\n    isName = /* @__PURE__ */ __name(function(string2) {\n      const match = regexName.exec(string2);\n      return !(match === null || typeof match === \"undefined\");\n    }, \"isName\");\n    __name(isExist, \"isExist\");\n    defaultOptions$1 = {\n      allowBooleanAttributes: false,\n      //A tag can have attributes without any value\n      unpairedTags: []\n    };\n    __name(validate$1, \"validate$1\");\n    __name(isWhiteSpace, \"isWhiteSpace\");\n    __name(readPI, \"readPI\");\n    __name(readCommentAndCDATA, \"readCommentAndCDATA\");\n    doubleQuote = '\"';\n    singleQuote = \"'\";\n    __name(readAttributeStr, \"readAttributeStr\");\n    validAttrStrRegxp = new RegExp(`(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\"])(([\\\\s\\\\S])*?)\\\\5)?`, \"g\");\n    __name(validateAttributeString, \"validateAttributeString\");\n    __name(validateNumberAmpersand, \"validateNumberAmpersand\");\n    __name(validateAmpersand, \"validateAmpersand\");\n    __name(getErrorObject, \"getErrorObject\");\n    __name(validateAttrName, \"validateAttrName\");\n    __name(validateTagName, \"validateTagName\");\n    __name(getLineNumberForPosition, \"getLineNumberForPosition\");\n    __name(getPositionFromMatch, \"getPositionFromMatch\");\n    defaultOptions = {\n      preserveOrder: false,\n      attributeNamePrefix: \"@_\",\n      attributesGroupName: false,\n      textNodeName: \"#text\",\n      ignoreAttributes: true,\n      removeNSPrefix: false,\n      // remove NS from tag name or attribute name if true\n      allowBooleanAttributes: false,\n      //a tag can have attributes without any value\n      //ignoreRootElement : false,\n      parseTagValue: true,\n      parseAttributeValue: false,\n      trimValues: true,\n      //Trim string values of tag and attributes\n      cdataPropName: false,\n      numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n      },\n      tagValueProcessor: /* @__PURE__ */ __name(function(tagName, val) {\n        return val;\n      }, \"tagValueProcessor\"),\n      attributeValueProcessor: /* @__PURE__ */ __name(function(attrName, val) {\n        return val;\n      }, \"attributeValueProcessor\"),\n      stopNodes: [],\n      //nested tags will not be parsed even for errors\n      alwaysCreateTextNode: false,\n      isArray: /* @__PURE__ */ __name(() => false, \"isArray\"),\n      commentPropName: false,\n      unpairedTags: [],\n      processEntities: true,\n      htmlEntities: false,\n      ignoreDeclaration: false,\n      ignorePiTags: false,\n      transformTagName: false,\n      transformAttributeName: false,\n      updateTag: /* @__PURE__ */ __name(function(tagName, jPath, attrs) {\n        return tagName;\n      }, \"updateTag\"),\n      // skipEmptyListItem: false\n      captureMetaData: false\n    };\n    buildOptions = /* @__PURE__ */ __name(function(options) {\n      return Object.assign({}, defaultOptions, options);\n    }, \"buildOptions\");\n    if (typeof Symbol !== \"function\") {\n      METADATA_SYMBOL$1 = \"@@xmlMetadata\";\n    } else {\n      METADATA_SYMBOL$1 = Symbol(\"XML Node Metadata\");\n    }\n    XmlNode = class {\n      static {\n        __name(this, \"XmlNode\");\n      }\n      constructor(tagname) {\n        this.tagname = tagname;\n        this.child = [];\n        this[\":@\"] = {};\n      }\n      add(key, val) {\n        if (key === \"__proto__\") key = \"#__proto__\";\n        this.child.push({ [key]: val });\n      }\n      addChild(node, startIndex) {\n        if (node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n        if (node[\":@\"] && Object.keys(node[\":@\"]).length > 0) {\n          this.child.push({ [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n        } else {\n          this.child.push({ [node.tagname]: node.child });\n        }\n        if (startIndex !== void 0) {\n          this.child[this.child.length - 1][METADATA_SYMBOL$1] = { startIndex };\n        }\n      }\n      /** symbol used for metadata */\n      static getMetaDataSymbol() {\n        return METADATA_SYMBOL$1;\n      }\n    };\n    __name(readDocType, \"readDocType\");\n    skipWhitespace = /* @__PURE__ */ __name((data, index) => {\n      while (index < data.length && /\\s/.test(data[index])) {\n        index++;\n      }\n      return index;\n    }, \"skipWhitespace\");\n    __name(readEntityExp, \"readEntityExp\");\n    __name(readNotationExp, \"readNotationExp\");\n    __name(readIdentifierVal, \"readIdentifierVal\");\n    __name(readElementExp, \"readElementExp\");\n    __name(hasSeq, \"hasSeq\");\n    __name(validateEntityName, \"validateEntityName\");\n    hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\n    numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n    consider = {\n      hex: true,\n      // oct: false,\n      leadingZeros: true,\n      decimalPoint: \".\",\n      eNotation: true\n      //skipLike: /regex/\n    };\n    __name(toNumber, \"toNumber\");\n    eNotationRegx = /^([-+])?(0*)(\\d*(\\.\\d*)?[eE][-\\+]?\\d+)$/;\n    __name(resolveEnotation, \"resolveEnotation\");\n    __name(trimZeros, \"trimZeros\");\n    __name(parse_int, \"parse_int\");\n    __name(getIgnoreAttributesFn, \"getIgnoreAttributesFn\");\n    OrderedObjParser = class {\n      static {\n        __name(this, \"OrderedObjParser\");\n      }\n      constructor(options) {\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n          \"apos\": { regex: /&(apos|#39|#x27);/g, val: \"'\" },\n          \"gt\": { regex: /&(gt|#62|#x3E);/g, val: \">\" },\n          \"lt\": { regex: /&(lt|#60|#x3C);/g, val: \"<\" },\n          \"quot\": { regex: /&(quot|#34|#x22);/g, val: '\"' }\n        };\n        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: \"&\" };\n        this.htmlEntities = {\n          \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n          // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n          // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n          // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n          // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n          // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n          \"cent\": { regex: /&(cent|#162);/g, val: \"\\xA2\" },\n          \"pound\": { regex: /&(pound|#163);/g, val: \"\\xA3\" },\n          \"yen\": { regex: /&(yen|#165);/g, val: \"\\xA5\" },\n          \"euro\": { regex: /&(euro|#8364);/g, val: \"\\u20AC\" },\n          \"copyright\": { regex: /&(copy|#169);/g, val: \"\\xA9\" },\n          \"reg\": { regex: /&(reg|#174);/g, val: \"\\xAE\" },\n          \"inr\": { regex: /&(inr|#8377);/g, val: \"\\u20B9\" },\n          \"num_dec\": { regex: /&#([0-9]{1,7});/g, val: /* @__PURE__ */ __name((_3, str) => String.fromCodePoint(Number.parseInt(str, 10)), \"val\") },\n          \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: /* @__PURE__ */ __name((_3, str) => String.fromCodePoint(Number.parseInt(str, 16)), \"val\") }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);\n      }\n    };\n    __name(addExternalEntities, \"addExternalEntities\");\n    __name(parseTextData, \"parseTextData\");\n    __name(resolveNameSpace, \"resolveNameSpace\");\n    attrsRegx = new RegExp(`([^\\\\s=]+)\\\\s*(=\\\\s*(['\"])([\\\\s\\\\S]*?)\\\\3)?`, \"gm\");\n    __name(buildAttributesMap, \"buildAttributesMap\");\n    parseXml = /* @__PURE__ */ __name(function(xmlData) {\n      xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n      const xmlObj = new XmlNode(\"!xml\");\n      let currentNode = xmlObj;\n      let textData = \"\";\n      let jPath = \"\";\n      for (let i = 0; i < xmlData.length; i++) {\n        const ch = xmlData[i];\n        if (ch === \"<\") {\n          if (xmlData[i + 1] === \"/\") {\n            const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n            let tagName = xmlData.substring(i + 2, closeIndex).trim();\n            if (this.options.removeNSPrefix) {\n              const colonIndex = tagName.indexOf(\":\");\n              if (colonIndex !== -1) {\n                tagName = tagName.substr(colonIndex + 1);\n              }\n            }\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            if (currentNode) {\n              textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            }\n            const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n            }\n            let propIndex = 0;\n            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n              propIndex = jPath.lastIndexOf(\".\", jPath.lastIndexOf(\".\") - 1);\n              this.tagsNodeStack.pop();\n            } else {\n              propIndex = jPath.lastIndexOf(\".\");\n            }\n            jPath = jPath.substring(0, propIndex);\n            currentNode = this.tagsNodeStack.pop();\n            textData = \"\";\n            i = closeIndex;\n          } else if (xmlData[i + 1] === \"?\") {\n            let tagData = readTagExp(xmlData, i, false, \"?>\");\n            if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n            textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) ;\n            else {\n              const childNode = new XmlNode(tagData.tagName);\n              childNode.add(this.options.textNodeName, \"\");\n              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n              }\n              this.addChild(currentNode, childNode, jPath, i);\n            }\n            i = tagData.closeIndex + 1;\n          } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n            const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n            if (this.options.commentPropName) {\n              const comment = xmlData.substring(i + 4, endIndex - 2);\n              textData = this.saveTextToParentTag(textData, currentNode, jPath);\n              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);\n            }\n            i = endIndex;\n          } else if (xmlData.substr(i + 1, 2) === \"!D\") {\n            const result = readDocType(xmlData, i);\n            this.docTypeEntities = result.entities;\n            i = result.i;\n          } else if (xmlData.substr(i + 1, 2) === \"![\") {\n            const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n            const tagExp = xmlData.substring(i + 9, closeIndex);\n            textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n            if (val == void 0) val = \"\";\n            if (this.options.cdataPropName) {\n              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);\n            } else {\n              currentNode.add(this.options.textNodeName, val);\n            }\n            i = closeIndex + 2;\n          } else {\n            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n            let tagName = result.tagName;\n            const rawTagName = result.rawTagName;\n            let tagExp = result.tagExp;\n            let attrExpPresent = result.attrExpPresent;\n            let closeIndex = result.closeIndex;\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            if (currentNode && textData) {\n              if (currentNode.tagname !== \"!xml\") {\n                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n              }\n            }\n            const lastTag = currentNode;\n            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n              currentNode = this.tagsNodeStack.pop();\n              jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n            }\n            if (tagName !== xmlObj.tagname) {\n              jPath += jPath ? \".\" + tagName : tagName;\n            }\n            const startIndex = i;\n            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n              let tagContent = \"\";\n              if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                if (tagName[tagName.length - 1] === \"/\") {\n                  tagName = tagName.substr(0, tagName.length - 1);\n                  jPath = jPath.substr(0, jPath.length - 1);\n                  tagExp = tagName;\n                } else {\n                  tagExp = tagExp.substr(0, tagExp.length - 1);\n                }\n                i = result.closeIndex;\n              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                i = result.closeIndex;\n              } else {\n                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n                if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);\n                i = result2.i;\n                tagContent = result2.tagContent;\n              }\n              const childNode = new XmlNode(tagName);\n              if (tagName !== tagExp && attrExpPresent) {\n                childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n              }\n              if (tagContent) {\n                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n              }\n              jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n              childNode.add(this.options.textNodeName, tagContent);\n              this.addChild(currentNode, childNode, jPath, startIndex);\n            } else {\n              if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                if (tagName[tagName.length - 1] === \"/\") {\n                  tagName = tagName.substr(0, tagName.length - 1);\n                  jPath = jPath.substr(0, jPath.length - 1);\n                  tagExp = tagName;\n                } else {\n                  tagExp = tagExp.substr(0, tagExp.length - 1);\n                }\n                if (this.options.transformTagName) {\n                  tagName = this.options.transformTagName(tagName);\n                }\n                const childNode = new XmlNode(tagName);\n                if (tagName !== tagExp && attrExpPresent) {\n                  childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                }\n                this.addChild(currentNode, childNode, jPath, startIndex);\n                jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n              } else {\n                const childNode = new XmlNode(tagName);\n                this.tagsNodeStack.push(currentNode);\n                if (tagName !== tagExp && attrExpPresent) {\n                  childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                }\n                this.addChild(currentNode, childNode, jPath, startIndex);\n                currentNode = childNode;\n              }\n              textData = \"\";\n              i = closeIndex;\n            }\n          }\n        } else {\n          textData += xmlData[i];\n        }\n      }\n      return xmlObj.child;\n    }, \"parseXml\");\n    __name(addChild, \"addChild\");\n    replaceEntitiesValue = /* @__PURE__ */ __name(function(val) {\n      if (this.options.processEntities) {\n        for (let entityName in this.docTypeEntities) {\n          const entity = this.docTypeEntities[entityName];\n          val = val.replace(entity.regx, entity.val);\n        }\n        for (let entityName in this.lastEntities) {\n          const entity = this.lastEntities[entityName];\n          val = val.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n          for (let entityName in this.htmlEntities) {\n            const entity = this.htmlEntities[entityName];\n            val = val.replace(entity.regex, entity.val);\n          }\n        }\n        val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n      }\n      return val;\n    }, \"replaceEntitiesValue\");\n    __name(saveTextToParentTag, \"saveTextToParentTag\");\n    __name(isItStopNode, \"isItStopNode\");\n    __name(tagExpWithClosingIndex, \"tagExpWithClosingIndex\");\n    __name(findClosingIndex, \"findClosingIndex\");\n    __name(readTagExp, \"readTagExp\");\n    __name(readStopNodeData, \"readStopNodeData\");\n    __name(parseValue, \"parseValue\");\n    METADATA_SYMBOL = XmlNode.getMetaDataSymbol();\n    __name(prettify, \"prettify\");\n    __name(compress, \"compress\");\n    __name(propName, \"propName\");\n    __name(assignAttributes, \"assignAttributes\");\n    __name(isLeafTag, \"isLeafTag\");\n    XMLParser = class {\n      static {\n        __name(this, \"XMLParser\");\n      }\n      constructor(options) {\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n      }\n      /**\n       * Parse XML dats to JS object \n       * @param {string|Buffer} xmlData \n       * @param {boolean|Object} validationOption \n       */\n      parse(xmlData, validationOption) {\n        if (typeof xmlData === \"string\") ;\n        else if (xmlData.toString) {\n          xmlData = xmlData.toString();\n        } else {\n          throw new Error(\"XML data is accepted in String or Bytes[] form.\");\n        }\n        if (validationOption) {\n          if (validationOption === true) validationOption = {};\n          const result = validate$1(xmlData, validationOption);\n          if (result !== true) {\n            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n          }\n        }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;\n        else return prettify(orderedResult, this.options);\n      }\n      /**\n       * Add Entity which is not by default supported by this library\n       * @param {string} key \n       * @param {string} value \n       */\n      addEntity(key, value2) {\n        if (value2.indexOf(\"&\") !== -1) {\n          throw new Error(\"Entity value can't have '&'\");\n        } else if (key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1) {\n          throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n        } else if (value2 === \"&\") {\n          throw new Error(\"An entity with value '&' is not permitted\");\n        } else {\n          this.externalEntities[key] = value2;\n        }\n      }\n      /**\n       * Returns a Symbol that can be used to access the metadata\n       * property on a node.\n       * \n       * If Symbol is not available in the environment, an ordinary property is used\n       * and the name of the property is here returned.\n       * \n       * The XMLMetaData property is only present when `captureMetaData`\n       * is true in the options.\n       */\n      static getMetaDataSymbol() {\n        return XmlNode.getMetaDataSymbol();\n      }\n    };\n    freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    root = freeGlobal || freeSelf || Function(\"return this\")();\n    Symbol$2 = root.Symbol;\n    objectProto$g = Object.prototype;\n    hasOwnProperty$d = objectProto$g.hasOwnProperty;\n    nativeObjectToString$1 = objectProto$g.toString;\n    symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;\n    __name(getRawTag, \"getRawTag\");\n    objectProto$f = Object.prototype;\n    nativeObjectToString = objectProto$f.toString;\n    __name(objectToString, \"objectToString\");\n    nullTag = \"[object Null]\";\n    undefinedTag = \"[object Undefined]\";\n    symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;\n    __name(baseGetTag, \"baseGetTag\");\n    __name(isObjectLike, \"isObjectLike\");\n    symbolTag$3 = \"[object Symbol]\";\n    __name(isSymbol, \"isSymbol\");\n    __name(arrayMap, \"arrayMap\");\n    isArray = Array.isArray;\n    symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0;\n    symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;\n    __name(baseToString, \"baseToString\");\n    __name(isObject$1, \"isObject$1\");\n    __name(identity2, \"identity\");\n    asyncTag = \"[object AsyncFunction]\";\n    funcTag$2 = \"[object Function]\";\n    genTag$1 = \"[object GeneratorFunction]\";\n    proxyTag = \"[object Proxy]\";\n    __name(isFunction$1, \"isFunction$1\");\n    coreJsData = root[\"__core-js_shared__\"];\n    maskSrcKey = function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    __name(isMasked, \"isMasked\");\n    funcProto$2 = Function.prototype;\n    funcToString$2 = funcProto$2.toString;\n    __name(toSource, \"toSource\");\n    reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    funcProto$1 = Function.prototype;\n    objectProto$e = Object.prototype;\n    funcToString$1 = funcProto$1.toString;\n    hasOwnProperty$c = objectProto$e.hasOwnProperty;\n    reIsNative = RegExp(\n      \"^\" + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n    );\n    __name(baseIsNative, \"baseIsNative\");\n    __name(getValue, \"getValue\");\n    __name(getNative, \"getNative\");\n    WeakMap$1 = getNative(root, \"WeakMap\");\n    objectCreate = Object.create;\n    baseCreate = /* @__PURE__ */ function() {\n      function object2() {\n      }\n      __name(object2, \"object\");\n      return function(proto) {\n        if (!isObject$1(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object2.prototype = proto;\n        var result = new object2();\n        object2.prototype = void 0;\n        return result;\n      };\n    }();\n    __name(apply$1, \"apply$1\");\n    __name(copyArray, \"copyArray\");\n    HOT_COUNT = 800;\n    HOT_SPAN = 16;\n    nativeNow = Date.now;\n    __name(shortOut, \"shortOut\");\n    __name(constant, \"constant\");\n    defineProperty = function() {\n      try {\n        var func = getNative(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n      } catch (e) {\n      }\n    }();\n    baseSetToString = !defineProperty ? identity2 : function(func, string2) {\n      return defineProperty(func, \"toString\", {\n        \"configurable\": true,\n        \"enumerable\": false,\n        \"value\": constant(string2),\n        \"writable\": true\n      });\n    };\n    setToString = shortOut(baseSetToString);\n    __name(arrayEach, \"arrayEach\");\n    MAX_SAFE_INTEGER$1 = 9007199254740991;\n    reIsUint = /^(?:0|[1-9]\\d*)$/;\n    __name(isIndex, \"isIndex\");\n    __name(baseAssignValue, \"baseAssignValue\");\n    __name(eq, \"eq\");\n    objectProto$d = Object.prototype;\n    hasOwnProperty$b = objectProto$d.hasOwnProperty;\n    __name(assignValue, \"assignValue\");\n    __name(copyObject, \"copyObject\");\n    nativeMax = Math.max;\n    __name(overRest, \"overRest\");\n    __name(baseRest, \"baseRest\");\n    MAX_SAFE_INTEGER = 9007199254740991;\n    __name(isLength, \"isLength\");\n    __name(isArrayLike, \"isArrayLike\");\n    __name(isIterateeCall, \"isIterateeCall\");\n    __name(createAssigner, \"createAssigner\");\n    objectProto$c = Object.prototype;\n    __name(isPrototype, \"isPrototype\");\n    __name(baseTimes, \"baseTimes\");\n    argsTag$3 = \"[object Arguments]\";\n    __name(baseIsArguments, \"baseIsArguments\");\n    objectProto$b = Object.prototype;\n    hasOwnProperty$a = objectProto$b.hasOwnProperty;\n    propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;\n    isArguments = baseIsArguments(/* @__PURE__ */ function() {\n      return arguments;\n    }()) ? baseIsArguments : function(value2) {\n      return isObjectLike(value2) && hasOwnProperty$a.call(value2, \"callee\") && !propertyIsEnumerable$1.call(value2, \"callee\");\n    };\n    __name(stubFalse, \"stubFalse\");\n    freeExports$2 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    freeModule$2 = freeExports$2 && typeof module == \"object\" && module && !module.nodeType && module;\n    moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;\n    Buffer$2 = moduleExports$2 ? root.Buffer : void 0;\n    nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;\n    isBuffer = nativeIsBuffer || stubFalse;\n    argsTag$2 = \"[object Arguments]\";\n    arrayTag$2 = \"[object Array]\";\n    boolTag$3 = \"[object Boolean]\";\n    dateTag$3 = \"[object Date]\";\n    errorTag$2 = \"[object Error]\";\n    funcTag$1 = \"[object Function]\";\n    mapTag$5 = \"[object Map]\";\n    numberTag$3 = \"[object Number]\";\n    objectTag$4 = \"[object Object]\";\n    regexpTag$3 = \"[object RegExp]\";\n    setTag$5 = \"[object Set]\";\n    stringTag$3 = \"[object String]\";\n    weakMapTag$2 = \"[object WeakMap]\";\n    arrayBufferTag$3 = \"[object ArrayBuffer]\";\n    dataViewTag$4 = \"[object DataView]\";\n    float32Tag$2 = \"[object Float32Array]\";\n    float64Tag$2 = \"[object Float64Array]\";\n    int8Tag$2 = \"[object Int8Array]\";\n    int16Tag$2 = \"[object Int16Array]\";\n    int32Tag$2 = \"[object Int32Array]\";\n    uint8Tag$2 = \"[object Uint8Array]\";\n    uint8ClampedTag$2 = \"[object Uint8ClampedArray]\";\n    uint16Tag$2 = \"[object Uint16Array]\";\n    uint32Tag$2 = \"[object Uint32Array]\";\n    typedArrayTags = {};\n    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;\n    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;\n    __name(baseIsTypedArray, \"baseIsTypedArray\");\n    __name(baseUnary, \"baseUnary\");\n    freeExports$1 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    freeModule$1 = freeExports$1 && typeof module == \"object\" && module && !module.nodeType && module;\n    moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n    freeProcess = moduleExports$1 && freeGlobal.process;\n    nodeUtil = function() {\n      try {\n        var types = freeModule$1 && freeModule$1.require && freeModule$1.require(\"util\").types;\n        if (types) {\n          return types;\n        }\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e) {\n      }\n    }();\n    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n    isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n    objectProto$a = Object.prototype;\n    hasOwnProperty$9 = objectProto$a.hasOwnProperty;\n    __name(arrayLikeKeys, \"arrayLikeKeys\");\n    __name(overArg, \"overArg\");\n    nativeKeys = overArg(Object.keys, Object);\n    objectProto$9 = Object.prototype;\n    hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n    __name(baseKeys, \"baseKeys\");\n    __name(keys, \"keys\");\n    __name(nativeKeysIn, \"nativeKeysIn\");\n    objectProto$8 = Object.prototype;\n    hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n    __name(baseKeysIn, \"baseKeysIn\");\n    __name(keysIn, \"keysIn\");\n    reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\n    reIsPlainProp = /^\\w*$/;\n    __name(isKey, \"isKey\");\n    nativeCreate = getNative(Object, \"create\");\n    __name(hashClear, \"hashClear\");\n    __name(hashDelete, \"hashDelete\");\n    HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\n    objectProto$7 = Object.prototype;\n    hasOwnProperty$6 = objectProto$7.hasOwnProperty;\n    __name(hashGet, \"hashGet\");\n    objectProto$6 = Object.prototype;\n    hasOwnProperty$5 = objectProto$6.hasOwnProperty;\n    __name(hashHas, \"hashHas\");\n    HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n    __name(hashSet, \"hashSet\");\n    __name(Hash2, \"Hash\");\n    Hash2.prototype.clear = hashClear;\n    Hash2.prototype[\"delete\"] = hashDelete;\n    Hash2.prototype.get = hashGet;\n    Hash2.prototype.has = hashHas;\n    Hash2.prototype.set = hashSet;\n    __name(listCacheClear, \"listCacheClear\");\n    __name(assocIndexOf, \"assocIndexOf\");\n    arrayProto = Array.prototype;\n    splice = arrayProto.splice;\n    __name(listCacheDelete, \"listCacheDelete\");\n    __name(listCacheGet, \"listCacheGet\");\n    __name(listCacheHas, \"listCacheHas\");\n    __name(listCacheSet, \"listCacheSet\");\n    __name(ListCache, \"ListCache\");\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype[\"delete\"] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    Map$1 = getNative(root, \"Map\");\n    __name(mapCacheClear, \"mapCacheClear\");\n    __name(isKeyable, \"isKeyable\");\n    __name(getMapData, \"getMapData\");\n    __name(mapCacheDelete, \"mapCacheDelete\");\n    __name(mapCacheGet, \"mapCacheGet\");\n    __name(mapCacheHas, \"mapCacheHas\");\n    __name(mapCacheSet, \"mapCacheSet\");\n    __name(MapCache, \"MapCache\");\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype[\"delete\"] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    FUNC_ERROR_TEXT = \"Expected a function\";\n    __name(memoize, \"memoize\");\n    memoize.Cache = MapCache;\n    MAX_MEMOIZE_SIZE = 500;\n    __name(memoizeCapped, \"memoizeCapped\");\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    reEscapeChar = /\\\\(\\\\)?/g;\n    stringToPath = memoizeCapped(function(string2) {\n      var result = [];\n      if (string2.charCodeAt(0) === 46) {\n        result.push(\"\");\n      }\n      string2.replace(rePropName, function(match, number2, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number2 || match);\n      });\n      return result;\n    });\n    __name(toString$1, \"toString$1\");\n    __name(castPath, \"castPath\");\n    __name(toKey, \"toKey\");\n    __name(baseGet, \"baseGet\");\n    __name(get, \"get\");\n    __name(arrayPush, \"arrayPush\");\n    spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;\n    __name(isFlattenable, \"isFlattenable\");\n    __name(baseFlatten, \"baseFlatten\");\n    __name(flatten, \"flatten\");\n    __name(flatRest, \"flatRest\");\n    getPrototype = overArg(Object.getPrototypeOf, Object);\n    objectTag$3 = \"[object Object]\";\n    funcProto = Function.prototype;\n    objectProto$5 = Object.prototype;\n    funcToString = funcProto.toString;\n    hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n    objectCtorString = funcToString.call(Object);\n    __name(isPlainObject$1, \"isPlainObject$1\");\n    __name(baseSlice, \"baseSlice\");\n    __name(stackClear, \"stackClear\");\n    __name(stackDelete, \"stackDelete\");\n    __name(stackGet, \"stackGet\");\n    __name(stackHas, \"stackHas\");\n    LARGE_ARRAY_SIZE = 200;\n    __name(stackSet, \"stackSet\");\n    __name(Stack, \"Stack\");\n    Stack.prototype.clear = stackClear;\n    Stack.prototype[\"delete\"] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n    freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n    moduleExports = freeModule && freeModule.exports === freeExports;\n    Buffer$1 = moduleExports ? root.Buffer : void 0;\n    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;\n    __name(cloneBuffer, \"cloneBuffer\");\n    __name(arrayFilter, \"arrayFilter\");\n    __name(stubArray, \"stubArray\");\n    objectProto$4 = Object.prototype;\n    propertyIsEnumerable = objectProto$4.propertyIsEnumerable;\n    nativeGetSymbols$1 = Object.getOwnPropertySymbols;\n    getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {\n      if (object2 == null) {\n        return [];\n      }\n      object2 = Object(object2);\n      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {\n        return propertyIsEnumerable.call(object2, symbol);\n      });\n    };\n    nativeGetSymbols = Object.getOwnPropertySymbols;\n    getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {\n      var result = [];\n      while (object2) {\n        arrayPush(result, getSymbols(object2));\n        object2 = getPrototype(object2);\n      }\n      return result;\n    };\n    __name(baseGetAllKeys, \"baseGetAllKeys\");\n    __name(getAllKeys, \"getAllKeys\");\n    __name(getAllKeysIn, \"getAllKeysIn\");\n    DataView$1 = getNative(root, \"DataView\");\n    Promise$1 = getNative(root, \"Promise\");\n    Set$1 = getNative(root, \"Set\");\n    mapTag$4 = \"[object Map]\";\n    objectTag$2 = \"[object Object]\";\n    promiseTag = \"[object Promise]\";\n    setTag$4 = \"[object Set]\";\n    weakMapTag$1 = \"[object WeakMap]\";\n    dataViewTag$3 = \"[object DataView]\";\n    dataViewCtorString = toSource(DataView$1);\n    mapCtorString = toSource(Map$1);\n    promiseCtorString = toSource(Promise$1);\n    setCtorString = toSource(Set$1);\n    weakMapCtorString = toSource(WeakMap$1);\n    getTag$1 = baseGetTag;\n    if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag$1(new Map$1()) != mapTag$4 || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag$4 || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag$1) {\n      getTag$1 = /* @__PURE__ */ __name(function(value2) {\n        var result = baseGetTag(value2), Ctor = result == objectTag$2 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag$3;\n            case mapCtorString:\n              return mapTag$4;\n            case promiseCtorString:\n              return promiseTag;\n            case setCtorString:\n              return setTag$4;\n            case weakMapCtorString:\n              return weakMapTag$1;\n          }\n        }\n        return result;\n      }, \"getTag$1\");\n    }\n    objectProto$3 = Object.prototype;\n    hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n    __name(initCloneArray, \"initCloneArray\");\n    Uint8Array$2 = root.Uint8Array;\n    __name(cloneArrayBuffer, \"cloneArrayBuffer\");\n    __name(cloneDataView, \"cloneDataView\");\n    reFlags = /\\w*$/;\n    __name(cloneRegExp, \"cloneRegExp\");\n    symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0;\n    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;\n    __name(cloneSymbol, \"cloneSymbol\");\n    __name(cloneTypedArray, \"cloneTypedArray\");\n    boolTag$2 = \"[object Boolean]\";\n    dateTag$2 = \"[object Date]\";\n    mapTag$3 = \"[object Map]\";\n    numberTag$2 = \"[object Number]\";\n    regexpTag$2 = \"[object RegExp]\";\n    setTag$3 = \"[object Set]\";\n    stringTag$2 = \"[object String]\";\n    symbolTag$2 = \"[object Symbol]\";\n    arrayBufferTag$2 = \"[object ArrayBuffer]\";\n    dataViewTag$2 = \"[object DataView]\";\n    float32Tag$1 = \"[object Float32Array]\";\n    float64Tag$1 = \"[object Float64Array]\";\n    int8Tag$1 = \"[object Int8Array]\";\n    int16Tag$1 = \"[object Int16Array]\";\n    int32Tag$1 = \"[object Int32Array]\";\n    uint8Tag$1 = \"[object Uint8Array]\";\n    uint8ClampedTag$1 = \"[object Uint8ClampedArray]\";\n    uint16Tag$1 = \"[object Uint16Array]\";\n    uint32Tag$1 = \"[object Uint32Array]\";\n    __name(initCloneByTag, \"initCloneByTag\");\n    __name(initCloneObject, \"initCloneObject\");\n    mapTag$2 = \"[object Map]\";\n    __name(baseIsMap, \"baseIsMap\");\n    nodeIsMap = nodeUtil && nodeUtil.isMap;\n    isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n    setTag$2 = \"[object Set]\";\n    __name(baseIsSet, \"baseIsSet\");\n    nodeIsSet = nodeUtil && nodeUtil.isSet;\n    isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n    CLONE_DEEP_FLAG$1 = 1;\n    argsTag$1 = \"[object Arguments]\";\n    arrayTag$1 = \"[object Array]\";\n    boolTag$1 = \"[object Boolean]\";\n    dateTag$1 = \"[object Date]\";\n    errorTag$1 = \"[object Error]\";\n    funcTag = \"[object Function]\";\n    genTag = \"[object GeneratorFunction]\";\n    mapTag$1 = \"[object Map]\";\n    numberTag$1 = \"[object Number]\";\n    objectTag$1 = \"[object Object]\";\n    regexpTag$1 = \"[object RegExp]\";\n    setTag$1 = \"[object Set]\";\n    stringTag$1 = \"[object String]\";\n    symbolTag$1 = \"[object Symbol]\";\n    weakMapTag = \"[object WeakMap]\";\n    arrayBufferTag$1 = \"[object ArrayBuffer]\";\n    dataViewTag$1 = \"[object DataView]\";\n    float32Tag = \"[object Float32Array]\";\n    float64Tag = \"[object Float64Array]\";\n    int8Tag = \"[object Int8Array]\";\n    int16Tag = \"[object Int16Array]\";\n    int32Tag = \"[object Int32Array]\";\n    uint8Tag = \"[object Uint8Array]\";\n    uint8ClampedTag = \"[object Uint8ClampedArray]\";\n    uint16Tag = \"[object Uint16Array]\";\n    uint32Tag = \"[object Uint32Array]\";\n    cloneableTags = {};\n    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n    __name(baseClone, \"baseClone\");\n    HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    __name(setCacheAdd, \"setCacheAdd\");\n    __name(setCacheHas, \"setCacheHas\");\n    __name(SetCache, \"SetCache\");\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n    __name(arraySome, \"arraySome\");\n    __name(cacheHas, \"cacheHas\");\n    COMPARE_PARTIAL_FLAG$5 = 1;\n    COMPARE_UNORDERED_FLAG$3 = 2;\n    __name(equalArrays, \"equalArrays\");\n    __name(mapToArray, \"mapToArray\");\n    __name(setToArray, \"setToArray\");\n    COMPARE_PARTIAL_FLAG$4 = 1;\n    COMPARE_UNORDERED_FLAG$2 = 2;\n    boolTag = \"[object Boolean]\";\n    dateTag = \"[object Date]\";\n    errorTag = \"[object Error]\";\n    mapTag = \"[object Map]\";\n    numberTag = \"[object Number]\";\n    regexpTag = \"[object RegExp]\";\n    setTag = \"[object Set]\";\n    stringTag = \"[object String]\";\n    symbolTag = \"[object Symbol]\";\n    arrayBufferTag = \"[object ArrayBuffer]\";\n    dataViewTag = \"[object DataView]\";\n    symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;\n    symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\n    __name(equalByTag, \"equalByTag\");\n    COMPARE_PARTIAL_FLAG$3 = 1;\n    objectProto$2 = Object.prototype;\n    hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n    __name(equalObjects, \"equalObjects\");\n    COMPARE_PARTIAL_FLAG$2 = 1;\n    argsTag = \"[object Arguments]\";\n    arrayTag = \"[object Array]\";\n    objectTag = \"[object Object]\";\n    objectProto$1 = Object.prototype;\n    hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n    __name(baseIsEqualDeep, \"baseIsEqualDeep\");\n    __name(baseIsEqual, \"baseIsEqual\");\n    COMPARE_PARTIAL_FLAG$1 = 1;\n    COMPARE_UNORDERED_FLAG$1 = 2;\n    __name(baseIsMatch, \"baseIsMatch\");\n    __name(isStrictComparable, \"isStrictComparable\");\n    __name(getMatchData, \"getMatchData\");\n    __name(matchesStrictComparable, \"matchesStrictComparable\");\n    __name(baseMatches, \"baseMatches\");\n    __name(baseHasIn, \"baseHasIn\");\n    __name(hasPath, \"hasPath\");\n    __name(hasIn, \"hasIn\");\n    COMPARE_PARTIAL_FLAG = 1;\n    COMPARE_UNORDERED_FLAG = 2;\n    __name(baseMatchesProperty, \"baseMatchesProperty\");\n    __name(baseProperty, \"baseProperty\");\n    __name(basePropertyDeep, \"basePropertyDeep\");\n    __name(property, \"property\");\n    __name(baseIteratee, \"baseIteratee\");\n    __name(createBaseFor, \"createBaseFor\");\n    baseFor = createBaseFor();\n    __name(baseForOwn, \"baseForOwn\");\n    __name(assignMergeValue, \"assignMergeValue\");\n    __name(isArrayLikeObject, \"isArrayLikeObject\");\n    __name(safeGet, \"safeGet\");\n    __name(toPlainObject, \"toPlainObject\");\n    __name(baseMergeDeep, \"baseMergeDeep\");\n    __name(baseMerge, \"baseMerge\");\n    mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {\n      baseMerge(object2, source, srcIndex, customizer);\n    });\n    __name(last, \"last\");\n    objectProto = Object.prototype;\n    hasOwnProperty = objectProto.hasOwnProperty;\n    __name(baseHas, \"baseHas\");\n    __name(has, \"has\");\n    __name(parent, \"parent\");\n    __name(isEqual, \"isEqual\");\n    __name(baseUnset, \"baseUnset\");\n    __name(customOmitClone, \"customOmitClone\");\n    CLONE_DEEP_FLAG = 1;\n    CLONE_FLAT_FLAG = 2;\n    CLONE_SYMBOLS_FLAG = 4;\n    omit = flatRest(function(object2, paths) {\n      var result = {};\n      if (object2 == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object2);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object2, getAllKeysIn(object2), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n    __name(baseSet, \"baseSet\");\n    __name(basePickBy, \"basePickBy\");\n    __name(basePick, \"basePick\");\n    pick = flatRest(function(object2, paths) {\n      return object2 == null ? {} : basePick(object2, paths);\n    });\n    __name(set, \"set\");\n    __name(transform, \"transform\");\n    knownUserAgents = {\n      deno: \"Deno\",\n      bun: \"Bun\",\n      workerd: \"Cloudflare-Workers\",\n      node: \"Node.js\"\n    };\n    getRuntimeKey = /* @__PURE__ */ __name(() => {\n      const global2 = globalThis;\n      const userAgentSupported = typeof navigator !== \"undefined\" && typeof navigator.userAgent === \"string\";\n      if (userAgentSupported) {\n        for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {\n          if (checkUserAgentEquals(userAgent)) {\n            return runtimeKey;\n          }\n        }\n      }\n      if (typeof global2?.EdgeRuntime === \"string\") {\n        return \"edge-light\";\n      }\n      if (global2?.fastly !== void 0) {\n        return \"fastly\";\n      }\n      if (global2?.process?.release?.name === \"node\") {\n        return \"node\";\n      }\n      return \"other\";\n    }, \"getRuntimeKey\");\n    checkUserAgentEquals = /* @__PURE__ */ __name((platform2) => {\n      const userAgent = navigator.userAgent;\n      return userAgent.startsWith(platform2);\n    }, \"checkUserAgentEquals\");\n    __name(CloneRest, \"CloneRest\");\n    __name(CloneType, \"CloneType\");\n    __name(Increment, \"Increment\");\n    __name(Argument, \"Argument\");\n    __name(FromComputed$3, \"FromComputed$3\");\n    __name(FromRef$2, \"FromRef$2\");\n    __name(FromIntersect$4, \"FromIntersect$4\");\n    __name(FromUnion$4, \"FromUnion$4\");\n    __name(FromPromise$1, \"FromPromise$1\");\n    __name(FromRest$3, \"FromRest$3\");\n    __name(Awaited, \"Awaited\");\n    __name(CompositeKeys, \"CompositeKeys\");\n    __name(FilterNever, \"FilterNever\");\n    __name(CompositeProperty, \"CompositeProperty\");\n    __name(CompositeProperties, \"CompositeProperties\");\n    __name(Composite, \"Composite\");\n    __name(Date$1, \"Date$1\");\n    __name(Null, \"Null\");\n    __name(Symbol$1, \"Symbol$1\");\n    __name(Undefined, \"Undefined\");\n    __name(Uint8Array$1, \"Uint8Array$1\");\n    __name(FromArray$2, \"FromArray$2\");\n    __name(FromProperties$b, \"FromProperties$b\");\n    __name(ConditionalReadonly, \"ConditionalReadonly\");\n    __name(FromValue, \"FromValue\");\n    __name(Const, \"Const\");\n    __name(ConstructorParameters, \"ConstructorParameters\");\n    __name(Enum, \"Enum\");\n    __name(ExcludeFromTemplateLiteral, \"ExcludeFromTemplateLiteral\");\n    __name(ExcludeRest, \"ExcludeRest\");\n    __name(Exclude, \"Exclude\");\n    __name(FromProperties$a, \"FromProperties$a\");\n    __name(FromMappedResult$5, \"FromMappedResult$5\");\n    __name(ExcludeFromMappedResult, \"ExcludeFromMappedResult\");\n    __name(ExtractFromTemplateLiteral, \"ExtractFromTemplateLiteral\");\n    __name(ExtractRest, \"ExtractRest\");\n    __name(Extract, \"Extract\");\n    __name(FromProperties$9, \"FromProperties$9\");\n    __name(FromMappedResult$4, \"FromMappedResult$4\");\n    __name(ExtractFromMappedResult, \"ExtractFromMappedResult\");\n    __name(InstanceType, \"InstanceType\");\n    __name(ReadonlyOptional, \"ReadonlyOptional\");\n    __name(RecordCreateFromPattern, \"RecordCreateFromPattern\");\n    __name(RecordCreateFromKeys, \"RecordCreateFromKeys\");\n    __name(FromTemplateLiteralKey, \"FromTemplateLiteralKey\");\n    __name(FromUnionKey, \"FromUnionKey\");\n    __name(FromLiteralKey, \"FromLiteralKey\");\n    __name(FromRegExpKey, \"FromRegExpKey\");\n    __name(FromStringKey, \"FromStringKey\");\n    __name(FromAnyKey, \"FromAnyKey\");\n    __name(FromNeverKey, \"FromNeverKey\");\n    __name(FromBooleanKey, \"FromBooleanKey\");\n    __name(FromIntegerKey, \"FromIntegerKey\");\n    __name(FromNumberKey, \"FromNumberKey\");\n    __name(Record, \"Record\");\n    __name(RecordPattern, \"RecordPattern\");\n    __name(RecordKey, \"RecordKey\");\n    __name(RecordValue, \"RecordValue\");\n    __name(FromConstructor$1, \"FromConstructor$1\");\n    __name(FromFunction$1, \"FromFunction$1\");\n    __name(FromIntersect$3, \"FromIntersect$3\");\n    __name(FromUnion$3, \"FromUnion$3\");\n    __name(FromTuple$1, \"FromTuple$1\");\n    __name(FromArray$1, \"FromArray$1\");\n    __name(FromAsyncIterator$1, \"FromAsyncIterator$1\");\n    __name(FromIterator$1, \"FromIterator$1\");\n    __name(FromPromise, \"FromPromise\");\n    __name(FromObject$5, \"FromObject$5\");\n    __name(FromRecord$1, \"FromRecord$1\");\n    __name(FromArgument, \"FromArgument\");\n    __name(FromProperty$1, \"FromProperty$1\");\n    __name(FromProperties$8, \"FromProperties$8\");\n    __name(FromTypes$1, \"FromTypes$1\");\n    __name(FromType$1, \"FromType$1\");\n    __name(Instantiate, \"Instantiate\");\n    __name(Integer, \"Integer\");\n    __name(MappedIntrinsicPropertyKey, \"MappedIntrinsicPropertyKey\");\n    __name(MappedIntrinsicPropertyKeys, \"MappedIntrinsicPropertyKeys\");\n    __name(MappedIntrinsicProperties, \"MappedIntrinsicProperties\");\n    __name(IntrinsicFromMappedKey, \"IntrinsicFromMappedKey\");\n    __name(ApplyUncapitalize, \"ApplyUncapitalize\");\n    __name(ApplyCapitalize, \"ApplyCapitalize\");\n    __name(ApplyUppercase, \"ApplyUppercase\");\n    __name(ApplyLowercase, \"ApplyLowercase\");\n    __name(FromTemplateLiteral, \"FromTemplateLiteral\");\n    __name(FromLiteralValue, \"FromLiteralValue\");\n    __name(FromRest$2, \"FromRest$2\");\n    __name(Intrinsic, \"Intrinsic\");\n    __name(Capitalize, \"Capitalize\");\n    __name(Lowercase, \"Lowercase\");\n    __name(Uncapitalize, \"Uncapitalize\");\n    __name(Uppercase, \"Uppercase\");\n    __name(FromProperties$7, \"FromProperties$7\");\n    __name(FromMappedResult$3, \"FromMappedResult$3\");\n    __name(OmitFromMappedResult, \"OmitFromMappedResult\");\n    __name(FromIntersect$2, \"FromIntersect$2\");\n    __name(FromUnion$2, \"FromUnion$2\");\n    __name(FromProperty, \"FromProperty\");\n    __name(FromProperties$6, \"FromProperties$6\");\n    __name(FromObject$4, \"FromObject$4\");\n    __name(UnionFromPropertyKeys$1, \"UnionFromPropertyKeys$1\");\n    __name(OmitResolve, \"OmitResolve\");\n    __name(Omit, \"Omit\");\n    __name(FromPropertyKey$1, \"FromPropertyKey$1\");\n    __name(FromPropertyKeys$1, \"FromPropertyKeys$1\");\n    __name(FromMappedKey$1, \"FromMappedKey$1\");\n    __name(OmitFromMappedKey, \"OmitFromMappedKey\");\n    __name(FromProperties$5, \"FromProperties$5\");\n    __name(FromMappedResult$2, \"FromMappedResult$2\");\n    __name(PickFromMappedResult, \"PickFromMappedResult\");\n    __name(FromIntersect$1, \"FromIntersect$1\");\n    __name(FromUnion$1, \"FromUnion$1\");\n    __name(FromProperties$4, \"FromProperties$4\");\n    __name(FromObject$3, \"FromObject$3\");\n    __name(UnionFromPropertyKeys, \"UnionFromPropertyKeys\");\n    __name(PickResolve, \"PickResolve\");\n    __name(Pick, \"Pick\");\n    __name(FromPropertyKey, \"FromPropertyKey\");\n    __name(FromPropertyKeys, \"FromPropertyKeys\");\n    __name(FromMappedKey, \"FromMappedKey\");\n    __name(PickFromMappedKey, \"PickFromMappedKey\");\n    __name(FromComputed$2, \"FromComputed$2\");\n    __name(FromRef$1, \"FromRef$1\");\n    __name(FromProperties$3, \"FromProperties$3\");\n    __name(FromObject$2, \"FromObject$2\");\n    __name(FromRest$1, \"FromRest$1\");\n    __name(PartialResolve, \"PartialResolve\");\n    __name(Partial, \"Partial\");\n    __name(FromProperties$2, \"FromProperties$2\");\n    __name(FromMappedResult$1, \"FromMappedResult$1\");\n    __name(PartialFromMappedResult, \"PartialFromMappedResult\");\n    __name(FromComputed$1, \"FromComputed$1\");\n    __name(FromRef, \"FromRef\");\n    __name(FromProperties$1, \"FromProperties$1\");\n    __name(FromObject$1, \"FromObject$1\");\n    __name(FromRest, \"FromRest\");\n    __name(RequiredResolve, \"RequiredResolve\");\n    __name(Required, \"Required\");\n    __name(FromProperties, \"FromProperties\");\n    __name(FromMappedResult, \"FromMappedResult\");\n    __name(RequiredFromMappedResult, \"RequiredFromMappedResult\");\n    __name(DereferenceParameters, \"DereferenceParameters\");\n    __name(Dereference, \"Dereference\");\n    __name(FromAwaited, \"FromAwaited\");\n    __name(FromIndex, \"FromIndex\");\n    __name(FromKeyOf, \"FromKeyOf\");\n    __name(FromPartial, \"FromPartial\");\n    __name(FromOmit, \"FromOmit\");\n    __name(FromPick, \"FromPick\");\n    __name(FromRequired, \"FromRequired\");\n    __name(FromComputed, \"FromComputed\");\n    __name(FromArray, \"FromArray\");\n    __name(FromAsyncIterator, \"FromAsyncIterator\");\n    __name(FromConstructor, \"FromConstructor\");\n    __name(FromFunction, \"FromFunction\");\n    __name(FromIntersect, \"FromIntersect\");\n    __name(FromIterator, \"FromIterator\");\n    __name(FromObject, \"FromObject\");\n    __name(FromRecord, \"FromRecord\");\n    __name(FromTransform, \"FromTransform\");\n    __name(FromTuple, \"FromTuple\");\n    __name(FromUnion, \"FromUnion\");\n    __name(FromTypes, \"FromTypes\");\n    __name(FromType, \"FromType\");\n    __name(ComputeType, \"ComputeType\");\n    __name(ComputeModuleProperties, \"ComputeModuleProperties\");\n    TModule = class {\n      static {\n        __name(this, \"TModule\");\n      }\n      constructor($defs) {\n        const computed = ComputeModuleProperties($defs);\n        const identified = this.WithIdentifiers(computed);\n        this.$defs = identified;\n      }\n      /** `[Json]` Imports a Type by Key. */\n      Import(key, options) {\n        const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };\n        return CreateType({ [Kind]: \"Import\", $defs, $ref: key });\n      }\n      // prettier-ignore\n      WithIdentifiers($defs) {\n        return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {\n          return { ...result, [key]: { ...$defs[key], $id: key } };\n        }, {});\n      }\n    };\n    __name(Module, \"Module\");\n    __name(Not, \"Not\");\n    __name(Parameters, \"Parameters\");\n    Ordinal = 0;\n    __name(Recursive, \"Recursive\");\n    __name(RegExp$1, \"RegExp$1\");\n    __name(RestResolve, \"RestResolve\");\n    __name(Rest, \"Rest\");\n    __name(ReturnType, \"ReturnType\");\n    TransformDecodeBuilder = class {\n      static {\n        __name(this, \"TransformDecodeBuilder\");\n      }\n      constructor(schema2) {\n        this.schema = schema2;\n      }\n      Decode(decode2) {\n        return new TransformEncodeBuilder(this.schema, decode2);\n      }\n    };\n    TransformEncodeBuilder = class {\n      static {\n        __name(this, \"TransformEncodeBuilder\");\n      }\n      constructor(schema2, decode2) {\n        this.schema = schema2;\n        this.decode = decode2;\n      }\n      EncodeTransform(encode2, schema2) {\n        const Encode = /* @__PURE__ */ __name((value2) => schema2[TransformKind].Encode(encode2(value2)), \"Encode\");\n        const Decode2 = /* @__PURE__ */ __name((value2) => this.decode(schema2[TransformKind].Decode(value2)), \"Decode\");\n        const Codec = { Encode, Decode: Decode2 };\n        return { ...schema2, [TransformKind]: Codec };\n      }\n      EncodeSchema(encode2, schema2) {\n        const Codec = { Decode: this.decode, Encode: encode2 };\n        return { ...schema2, [TransformKind]: Codec };\n      }\n      Encode(encode2) {\n        return IsTransform$1(this.schema) ? this.EncodeTransform(encode2, this.schema) : this.EncodeSchema(encode2, this.schema);\n      }\n    };\n    __name(Transform, \"Transform\");\n    __name(Void, \"Void\");\n    JsonTypeBuilder = class {\n      static {\n        __name(this, \"JsonTypeBuilder\");\n      }\n      // ------------------------------------------------------------------------\n      // Modifiers\n      // ------------------------------------------------------------------------\n      /** `[Json]` Creates a Readonly and Optional property */\n      ReadonlyOptional(type2) {\n        return ReadonlyOptional(type2);\n      }\n      /** `[Json]` Creates a Readonly property */\n      Readonly(type2, enable) {\n        return Readonly(type2, enable ?? true);\n      }\n      /** `[Json]` Creates a Optional property */\n      Optional(type2, enable) {\n        return Optional(type2, enable ?? true);\n      }\n      // ------------------------------------------------------------------------\n      // Types\n      // ------------------------------------------------------------------------\n      /** `[Json]` Creates an Any type */\n      Any(options) {\n        return Any(options);\n      }\n      /** `[Json]` Creates an Array type */\n      Array(items, options) {\n        return Array$1(items, options);\n      }\n      /** `[Json]` Creates a Boolean type */\n      Boolean(options) {\n        return Boolean$1(options);\n      }\n      /** `[Json]` Intrinsic function to Capitalize LiteralString types */\n      Capitalize(schema2, options) {\n        return Capitalize(schema2, options);\n      }\n      /** `[Json]` Creates a Composite object type */\n      Composite(schemas, options) {\n        return Composite(schemas, options);\n      }\n      /** `[JavaScript]` Creates a readonly const type from the given value. */\n      Const(value2, options) {\n        return Const(value2, options);\n      }\n      /** `[Json]` Creates a Enum type */\n      Enum(item, options) {\n        return Enum(item, options);\n      }\n      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\n      Exclude(unionType, excludedMembers, options) {\n        return Exclude(unionType, excludedMembers, options);\n      }\n      /** `[Json]` Creates a Conditional type */\n      Extends(L2, R4, T2, F2, options) {\n        return Extends(L2, R4, T2, F2, options);\n      }\n      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\n      Extract(type2, union, options) {\n        return Extract(type2, union, options);\n      }\n      /** `[Json]` Returns an Indexed property type for the given keys */\n      Index(type2, key, options) {\n        return Index(type2, key, options);\n      }\n      /** `[Json]` Creates an Integer type */\n      Integer(options) {\n        return Integer(options);\n      }\n      /** `[Json]` Creates an Intersect type */\n      Intersect(types, options) {\n        return Intersect$1(types, options);\n      }\n      /** `[Json]` Creates a KeyOf type */\n      KeyOf(type2, options) {\n        return KeyOf(type2, options);\n      }\n      /** `[Json]` Creates a Literal type */\n      Literal(literalValue, options) {\n        return Literal(literalValue, options);\n      }\n      /** `[Json]` Intrinsic function to Lowercase LiteralString types */\n      Lowercase(type2, options) {\n        return Lowercase(type2, options);\n      }\n      /** `[Json]` Creates a Mapped object type */\n      Mapped(key, map2, options) {\n        return Mapped(key, map2, options);\n      }\n      /** `[Json]` Creates a Type Definition Module. */\n      Module(properties) {\n        return Module(properties);\n      }\n      /** `[Json]` Creates a Never type */\n      Never(options) {\n        return Never(options);\n      }\n      /** `[Json]` Creates a Not type */\n      Not(type2, options) {\n        return Not(type2, options);\n      }\n      /** `[Json]` Creates a Null type */\n      Null(options) {\n        return Null(options);\n      }\n      /** `[Json]` Creates a Number type */\n      Number(options) {\n        return Number$1(options);\n      }\n      /** `[Json]` Creates an Object type */\n      Object(properties, options) {\n        return Object$1(properties, options);\n      }\n      /** `[Json]` Constructs a type whose keys are omitted from the given type */\n      Omit(schema2, selector, options) {\n        return Omit(schema2, selector, options);\n      }\n      /** `[Json]` Constructs a type where all properties are optional */\n      Partial(type2, options) {\n        return Partial(type2, options);\n      }\n      /** `[Json]` Constructs a type whose keys are picked from the given type */\n      Pick(type2, key, options) {\n        return Pick(type2, key, options);\n      }\n      /** `[Json]` Creates a Record type */\n      Record(key, value2, options) {\n        return Record(key, value2, options);\n      }\n      /** `[Json]` Creates a Recursive type */\n      Recursive(callback, options) {\n        return Recursive(callback, options);\n      }\n      /** `[Json]` Creates a Ref type. The referenced type must contain a $id */\n      Ref(...args) {\n        return Ref(args[0], args[1]);\n      }\n      /** `[Json]` Constructs a type where all properties are required */\n      Required(type2, options) {\n        return Required(type2, options);\n      }\n      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\n      Rest(type2) {\n        return Rest(type2);\n      }\n      /** `[Json]` Creates a String type */\n      String(options) {\n        return String$1(options);\n      }\n      /** `[Json]` Creates a TemplateLiteral type */\n      TemplateLiteral(unresolved, options) {\n        return TemplateLiteral(unresolved, options);\n      }\n      /** `[Json]` Creates a Transform type */\n      Transform(type2) {\n        return Transform(type2);\n      }\n      /** `[Json]` Creates a Tuple type */\n      Tuple(types, options) {\n        return Tuple(types, options);\n      }\n      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\n      Uncapitalize(type2, options) {\n        return Uncapitalize(type2, options);\n      }\n      /** `[Json]` Creates a Union type */\n      Union(types, options) {\n        return Union$1(types, options);\n      }\n      /** `[Json]` Creates an Unknown type */\n      Unknown(options) {\n        return Unknown(options);\n      }\n      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\n      Unsafe(options) {\n        return Unsafe(options);\n      }\n      /** `[Json]` Intrinsic function to Uppercase LiteralString types */\n      Uppercase(schema2, options) {\n        return Uppercase(schema2, options);\n      }\n    };\n    TypeBuilder = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      Any,\n      Argument,\n      Array: Array$1,\n      AsyncIterator,\n      Awaited,\n      BigInt: BigInt$1,\n      Boolean: Boolean$1,\n      Capitalize,\n      Composite,\n      Const,\n      Constructor,\n      ConstructorParameters,\n      Date: Date$1,\n      Enum,\n      Exclude,\n      Extends,\n      Extract,\n      Function: Function$1,\n      Index,\n      InstanceType,\n      Instantiate,\n      Integer,\n      Intersect: Intersect$1,\n      Iterator,\n      KeyOf,\n      Literal,\n      Lowercase,\n      Mapped,\n      Module,\n      Never,\n      Not,\n      Null,\n      Number: Number$1,\n      Object: Object$1,\n      Omit,\n      Optional,\n      Parameters,\n      Partial,\n      Pick,\n      Promise: Promise$2,\n      Readonly,\n      ReadonlyOptional,\n      Record,\n      Recursive,\n      Ref,\n      RegExp: RegExp$1,\n      Required,\n      Rest,\n      ReturnType,\n      String: String$1,\n      Symbol: Symbol$1,\n      TemplateLiteral,\n      Transform,\n      Tuple,\n      Uint8Array: Uint8Array$1,\n      Uncapitalize,\n      Undefined,\n      Union: Union$1,\n      Unknown,\n      Unsafe,\n      Uppercase,\n      Void\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    JavaScriptTypeBuilder = class extends JsonTypeBuilder {\n      static {\n        __name(this, \"JavaScriptTypeBuilder\");\n      }\n      /** `[JavaScript]` Creates a Generic Argument Type */\n      Argument(index) {\n        return Argument(index);\n      }\n      /** `[JavaScript]` Creates a AsyncIterator type */\n      AsyncIterator(items, options) {\n        return AsyncIterator(items, options);\n      }\n      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\n      Awaited(schema2, options) {\n        return Awaited(schema2, options);\n      }\n      /** `[JavaScript]` Creates a BigInt type */\n      BigInt(options) {\n        return BigInt$1(options);\n      }\n      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\n      ConstructorParameters(schema2, options) {\n        return ConstructorParameters(schema2, options);\n      }\n      /** `[JavaScript]` Creates a Constructor type */\n      Constructor(parameters, instanceType, options) {\n        return Constructor(parameters, instanceType, options);\n      }\n      /** `[JavaScript]` Creates a Date type */\n      Date(options = {}) {\n        return Date$1(options);\n      }\n      /** `[JavaScript]` Creates a Function type */\n      Function(parameters, returnType, options) {\n        return Function$1(parameters, returnType, options);\n      }\n      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\n      InstanceType(schema2, options) {\n        return InstanceType(schema2, options);\n      }\n      /** `[JavaScript]` Instantiates a type with the given parameters */\n      Instantiate(schema2, parameters) {\n        return Instantiate(schema2, parameters);\n      }\n      /** `[JavaScript]` Creates an Iterator type */\n      Iterator(items, options) {\n        return Iterator(items, options);\n      }\n      /** `[JavaScript]` Extracts the Parameters from the given Function type */\n      Parameters(schema2, options) {\n        return Parameters(schema2, options);\n      }\n      /** `[JavaScript]` Creates a Promise type */\n      Promise(item, options) {\n        return Promise$2(item, options);\n      }\n      /** `[JavaScript]` Creates a RegExp type */\n      RegExp(unresolved, options) {\n        return RegExp$1(unresolved, options);\n      }\n      /** `[JavaScript]` Extracts the ReturnType from the given Function type */\n      ReturnType(type2, options) {\n        return ReturnType(type2, options);\n      }\n      /** `[JavaScript]` Creates a Symbol type */\n      Symbol(options) {\n        return Symbol$1(options);\n      }\n      /** `[JavaScript]` Creates a Undefined type */\n      Undefined(options) {\n        return Undefined(options);\n      }\n      /** `[JavaScript]` Creates a Uint8Array type */\n      Uint8Array(options) {\n        return Uint8Array$1(options);\n      }\n      /** `[JavaScript]` Creates a Void type */\n      Void(options) {\n        return Void(options);\n      }\n    };\n    Type = TypeBuilder;\n    p$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      Any,\n      Argument,\n      Array: Array$1,\n      AsyncIterator,\n      Awaited,\n      BigInt: BigInt$1,\n      Boolean: Boolean$1,\n      Capitalize,\n      Clone: Clone$1,\n      CloneRest,\n      CloneType,\n      Composite,\n      Const,\n      Constructor,\n      ConstructorParameters,\n      CreateType,\n      Date: Date$1,\n      Enum,\n      Exclude,\n      ExcludeFromMappedResult,\n      ExcludeFromTemplateLiteral,\n      Extends,\n      ExtendsCheck,\n      ExtendsFromMappedKey,\n      ExtendsFromMappedResult,\n      ExtendsResolverError,\n      get ExtendsResult() {\n        return ExtendsResult;\n      },\n      ExtendsUndefinedCheck,\n      Extract,\n      ExtractFromMappedResult,\n      ExtractFromTemplateLiteral,\n      FormatRegistry: format$1,\n      FromTypes: FromTypes$1,\n      Function: Function$1,\n      Hint,\n      Increment,\n      Index,\n      IndexFromComputed,\n      IndexFromMappedKey,\n      IndexFromMappedResult,\n      IndexFromPropertyKey,\n      IndexFromPropertyKeys,\n      IndexPropertyKeys,\n      InstanceType,\n      Instantiate,\n      Integer,\n      Intersect: Intersect$1,\n      IntersectEvaluated,\n      Intrinsic,\n      IntrinsicFromMappedKey,\n      IsTemplateLiteralExpressionFinite,\n      IsTemplateLiteralFinite,\n      Iterator,\n      JavaScriptTypeBuilder,\n      JsonTypeBuilder,\n      KeyOf,\n      KeyOfFromMappedResult,\n      KeyOfPattern,\n      KeyOfPropertyEntries,\n      KeyOfPropertyKeys,\n      KeyOfPropertyKeysToRest,\n      Kind,\n      KindGuard: kind,\n      Literal,\n      Lowercase,\n      Mapped,\n      MappedFunctionReturnType,\n      MappedKey,\n      MappedResult,\n      Module,\n      Never,\n      Not,\n      Null,\n      Number: Number$1,\n      Object: Object$1,\n      Omit,\n      OmitFromMappedKey,\n      OmitFromMappedResult,\n      Optional,\n      OptionalFromMappedResult,\n      OptionalKind,\n      Parameters,\n      Partial,\n      PartialFromMappedResult,\n      PatternBoolean,\n      PatternBooleanExact,\n      PatternNever,\n      PatternNeverExact,\n      PatternNumber,\n      PatternNumberExact,\n      PatternString,\n      PatternStringExact,\n      Pick,\n      PickFromMappedKey,\n      PickFromMappedResult,\n      Promise: Promise$2,\n      Readonly,\n      ReadonlyFromMappedResult,\n      ReadonlyKind,\n      ReadonlyOptional,\n      Record,\n      RecordKey,\n      RecordPattern,\n      RecordValue,\n      Recursive,\n      Ref,\n      RegExp: RegExp$1,\n      Required,\n      RequiredFromMappedResult,\n      Rest,\n      ReturnType,\n      SetComplement,\n      SetDistinct,\n      SetIncludes,\n      SetIntersect,\n      SetIntersectMany,\n      SetIsSubset,\n      SetUnion,\n      SetUnionMany,\n      String: String$1,\n      Symbol: Symbol$1,\n      TModule,\n      TemplateLiteral,\n      TemplateLiteralExpressionGenerate,\n      TemplateLiteralFiniteError,\n      TemplateLiteralGenerate,\n      TemplateLiteralGenerateError,\n      TemplateLiteralParse,\n      TemplateLiteralParseExact,\n      TemplateLiteralParserError,\n      TemplateLiteralPattern,\n      TemplateLiteralPatternError,\n      TemplateLiteralSyntax,\n      TemplateLiteralToUnion,\n      Transform,\n      TransformDecodeBuilder,\n      TransformEncodeBuilder,\n      TransformKind,\n      Tuple,\n      Type,\n      TypeBoxError,\n      TypeGuard: type,\n      TypeRegistry: type$1,\n      Uint8Array: Uint8Array$1,\n      Uncapitalize,\n      Undefined,\n      Union: Union$1,\n      UnionEvaluated,\n      Unknown,\n      Unsafe,\n      Uppercase,\n      ValueGuard: value,\n      Void\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    dayjs_min$1 = { exports: {} };\n    dayjs_min = dayjs_min$1.exports;\n    __name(requireDayjs_min, \"requireDayjs_min\");\n    dayjs_minExports = requireDayjs_min();\n    ze$2 = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);\n    weekOfYear$1 = { exports: {} };\n    weekOfYear = weekOfYear$1.exports;\n    __name(requireWeekOfYear, \"requireWeekOfYear\");\n    weekOfYearExports = requireWeekOfYear();\n    Pr$1 = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);\n    byteToHex = [];\n    for (let i = 0; i < 256; ++i) {\n      byteToHex.push((i + 256).toString(16).slice(1));\n    }\n    __name(unsafeStringify, \"unsafeStringify\");\n    rnds8 = new Uint8Array(16);\n    __name(rng, \"rng\");\n    randomUUID2 = typeof crypto !== \"undefined\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n    native = { randomUUID: randomUUID2 };\n    __name(v4, \"v4\");\n    _state = {};\n    __name(v7, \"v7\");\n    __name(updateV7State, \"updateV7State\");\n    __name(v7Bytes, \"v7Bytes\");\n    __name(deepCompareStrict, \"deepCompareStrict\");\n    __name(encodePointer, \"encodePointer\");\n    __name(escapePointer, \"escapePointer\");\n    schemaArrayKeyword = {\n      prefixItems: true,\n      items: true,\n      allOf: true,\n      anyOf: true,\n      oneOf: true\n    };\n    schemaMapKeyword = {\n      $defs: true,\n      definitions: true,\n      properties: true,\n      patternProperties: true,\n      dependentSchemas: true\n    };\n    ignoredKeyword = {\n      id: true,\n      $id: true,\n      $ref: true,\n      $schema: true,\n      $anchor: true,\n      $vocabulary: true,\n      $comment: true,\n      default: true,\n      enum: true,\n      const: true,\n      required: true,\n      type: true,\n      maximum: true,\n      minimum: true,\n      exclusiveMaximum: true,\n      exclusiveMinimum: true,\n      multipleOf: true,\n      maxLength: true,\n      minLength: true,\n      pattern: true,\n      format: true,\n      maxItems: true,\n      minItems: true,\n      uniqueItems: true,\n      maxProperties: true,\n      minProperties: true\n    };\n    initialBaseURI = typeof self !== \"undefined\" && self.location && self.location.origin !== \"null\" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL(\"https://github.com/cfworker\");\n    __name(dereference, \"dereference\");\n    DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n    DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\n    HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\n    URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n    URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n    URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\n    UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\n    JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\n    JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\n    RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n    EMAIL = /* @__PURE__ */ __name((input2) => {\n      if (input2[0] === '\"')\n        return false;\n      const [name, host, ...rest] = input2.split(\"@\");\n      if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)\n        return false;\n      if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\"))\n        return false;\n      if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))\n        return false;\n      return host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n    }, \"EMAIL\");\n    IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\n    IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\n    DURATION = /* @__PURE__ */ __name((input2) => input2.length > 1 && input2.length < 80 && (/^P\\d+([.,]\\d+)?W$/.test(input2) || /^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input2) && /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input2)), \"DURATION\");\n    __name(bind, \"bind\");\n    format = {\n      date,\n      time: time3.bind(void 0, false),\n      \"date-time\": date_time,\n      duration: DURATION,\n      uri,\n      \"uri-reference\": bind(URIREF),\n      \"uri-template\": bind(URITEMPLATE),\n      url: bind(URL_),\n      email: EMAIL,\n      hostname: bind(HOSTNAME),\n      ipv4: bind(IPV4),\n      ipv6: bind(IPV6),\n      regex,\n      uuid: bind(UUID),\n      \"json-pointer\": bind(JSON_POINTER),\n      \"json-pointer-uri-fragment\": bind(JSON_POINTER_URI_FRAGMENT),\n      \"relative-json-pointer\": bind(RELATIVE_JSON_POINTER)\n    };\n    __name(isLeapYear, \"isLeapYear\");\n    __name(date, \"date\");\n    __name(time3, \"time\");\n    DATE_TIME_SEPARATOR = /t|\\s/i;\n    __name(date_time, \"date_time\");\n    NOT_URI_FRAGMENT = /\\/|:/;\n    URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n    __name(uri, \"uri\");\n    Z_ANCHOR = /[^\\\\]\\\\Z/;\n    __name(regex, \"regex\");\n    __name(ucs2length, \"ucs2length\");\n    __name(validate, \"validate\");\n    Validator = class {\n      static {\n        __name(this, \"Validator\");\n      }\n      schema;\n      draft;\n      shortCircuit;\n      lookup;\n      constructor(schema2, draft = \"2019-09\", shortCircuit = true) {\n        this.schema = schema2;\n        this.draft = draft;\n        this.shortCircuit = shortCircuit;\n        this.lookup = dereference(schema2);\n      }\n      validate(instance) {\n        return validate(instance, this.schema, this.draft, this.lookup, this.shortCircuit);\n      }\n      addSchema(schema2, id2) {\n        if (id2) {\n          schema2 = { ...schema2, $id: id2 };\n        }\n        dereference(schema2, this.lookup);\n      }\n    };\n    __name(isUndefined, \"isUndefined\");\n    __name(isString2, \"isString\");\n    __name(isNumber, \"isNumber\");\n    __name(isBoolean, \"isBoolean\");\n    __name(isNull, \"isNull\");\n    __name(isDate, \"isDate\");\n    __name(isBigInt, \"isBigInt\");\n    __name(isFunction, \"isFunction\");\n    __name(isObject, \"isObject\");\n    __name(isPlainObject, \"isPlainObject\");\n    __name(freeze, \"freeze\");\n    __name(asArray, \"asArray\");\n    __name(isReadonlyArray, \"isReadonlyArray\");\n    __name(noop2, \"noop\");\n    toString = Object.prototype.toString;\n    __name(getTag, \"getTag\");\n    AlterTableNode = freeze({\n      is(node) {\n        return node.kind === \"AlterTableNode\";\n      },\n      create(table3) {\n        return freeze({\n          kind: \"AlterTableNode\",\n          table: table3\n        });\n      },\n      cloneWithTableProps(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      },\n      cloneWithColumnAlteration(node, columnAlteration) {\n        return freeze({\n          ...node,\n          columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]\n        });\n      }\n    });\n    IdentifierNode = freeze({\n      is(node) {\n        return node.kind === \"IdentifierNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"IdentifierNode\",\n          name\n        });\n      }\n    });\n    CreateIndexNode = freeze({\n      is(node) {\n        return node.kind === \"CreateIndexNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"CreateIndexNode\",\n          name: IdentifierNode.create(name)\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      },\n      cloneWithColumns(node, columns) {\n        return freeze({\n          ...node,\n          columns: [...node.columns || [], ...columns]\n        });\n      }\n    });\n    CreateSchemaNode = freeze({\n      is(node) {\n        return node.kind === \"CreateSchemaNode\";\n      },\n      create(schema2, params) {\n        return freeze({\n          kind: \"CreateSchemaNode\",\n          schema: IdentifierNode.create(schema2),\n          ...params\n        });\n      },\n      cloneWith(createSchema, params) {\n        return freeze({\n          ...createSchema,\n          ...params\n        });\n      }\n    });\n    ON_COMMIT_ACTIONS = [\"preserve rows\", \"delete rows\", \"drop\"];\n    CreateTableNode = freeze({\n      is(node) {\n        return node.kind === \"CreateTableNode\";\n      },\n      create(table3) {\n        return freeze({\n          kind: \"CreateTableNode\",\n          table: table3,\n          columns: freeze([])\n        });\n      },\n      cloneWithColumn(createTable, column) {\n        return freeze({\n          ...createTable,\n          columns: freeze([...createTable.columns, column])\n        });\n      },\n      cloneWithConstraint(createTable, constraint) {\n        return freeze({\n          ...createTable,\n          constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])\n        });\n      },\n      cloneWithFrontModifier(createTable, modifier) {\n        return freeze({\n          ...createTable,\n          frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])\n        });\n      },\n      cloneWithEndModifier(createTable, modifier) {\n        return freeze({\n          ...createTable,\n          endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])\n        });\n      },\n      cloneWith(createTable, params) {\n        return freeze({\n          ...createTable,\n          ...params\n        });\n      }\n    });\n    SchemableIdentifierNode = freeze({\n      is(node) {\n        return node.kind === \"SchemableIdentifierNode\";\n      },\n      create(identifier) {\n        return freeze({\n          kind: \"SchemableIdentifierNode\",\n          identifier: IdentifierNode.create(identifier)\n        });\n      },\n      createWithSchema(schema2, identifier) {\n        return freeze({\n          kind: \"SchemableIdentifierNode\",\n          schema: IdentifierNode.create(schema2),\n          identifier: IdentifierNode.create(identifier)\n        });\n      }\n    });\n    DropIndexNode = freeze({\n      is(node) {\n        return node.kind === \"DropIndexNode\";\n      },\n      create(name, params) {\n        return freeze({\n          kind: \"DropIndexNode\",\n          name: SchemableIdentifierNode.create(name),\n          ...params\n        });\n      },\n      cloneWith(dropIndex, props) {\n        return freeze({\n          ...dropIndex,\n          ...props\n        });\n      }\n    });\n    DropSchemaNode = freeze({\n      is(node) {\n        return node.kind === \"DropSchemaNode\";\n      },\n      create(schema2, params) {\n        return freeze({\n          kind: \"DropSchemaNode\",\n          schema: IdentifierNode.create(schema2),\n          ...params\n        });\n      },\n      cloneWith(dropSchema, params) {\n        return freeze({\n          ...dropSchema,\n          ...params\n        });\n      }\n    });\n    DropTableNode = freeze({\n      is(node) {\n        return node.kind === \"DropTableNode\";\n      },\n      create(table3, params) {\n        return freeze({\n          kind: \"DropTableNode\",\n          table: table3,\n          ...params\n        });\n      },\n      cloneWith(dropIndex, params) {\n        return freeze({\n          ...dropIndex,\n          ...params\n        });\n      }\n    });\n    AliasNode = freeze({\n      is(node) {\n        return node.kind === \"AliasNode\";\n      },\n      create(node, alias2) {\n        return freeze({\n          kind: \"AliasNode\",\n          node,\n          alias: alias2\n        });\n      }\n    });\n    TableNode = freeze({\n      is(node) {\n        return node.kind === \"TableNode\";\n      },\n      create(table3) {\n        return freeze({\n          kind: \"TableNode\",\n          table: SchemableIdentifierNode.create(table3)\n        });\n      },\n      createWithSchema(schema2, table3) {\n        return freeze({\n          kind: \"TableNode\",\n          table: SchemableIdentifierNode.createWithSchema(schema2, table3)\n        });\n      }\n    });\n    __name(isOperationNodeSource, \"isOperationNodeSource\");\n    __name(isExpression, \"isExpression\");\n    __name(isAliasedExpression, \"isAliasedExpression\");\n    SelectModifierNode = freeze({\n      is(node) {\n        return node.kind === \"SelectModifierNode\";\n      },\n      create(modifier, of) {\n        return freeze({\n          kind: \"SelectModifierNode\",\n          modifier,\n          of\n        });\n      },\n      createWithExpression(modifier) {\n        return freeze({\n          kind: \"SelectModifierNode\",\n          rawModifier: modifier\n        });\n      }\n    });\n    AndNode = freeze({\n      is(node) {\n        return node.kind === \"AndNode\";\n      },\n      create(left, right) {\n        return freeze({\n          kind: \"AndNode\",\n          left,\n          right\n        });\n      }\n    });\n    OrNode = freeze({\n      is(node) {\n        return node.kind === \"OrNode\";\n      },\n      create(left, right) {\n        return freeze({\n          kind: \"OrNode\",\n          left,\n          right\n        });\n      }\n    });\n    OnNode = freeze({\n      is(node) {\n        return node.kind === \"OnNode\";\n      },\n      create(filter) {\n        return freeze({\n          kind: \"OnNode\",\n          on: filter\n        });\n      },\n      cloneWithOperation(onNode, operator, operation) {\n        return freeze({\n          ...onNode,\n          on: operator === \"And\" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)\n        });\n      }\n    });\n    JoinNode = freeze({\n      is(node) {\n        return node.kind === \"JoinNode\";\n      },\n      create(joinType, table3) {\n        return freeze({\n          kind: \"JoinNode\",\n          joinType,\n          table: table3,\n          on: void 0\n        });\n      },\n      createWithOn(joinType, table3, on4) {\n        return freeze({\n          kind: \"JoinNode\",\n          joinType,\n          table: table3,\n          on: OnNode.create(on4)\n        });\n      },\n      cloneWithOn(joinNode, operation) {\n        return freeze({\n          ...joinNode,\n          on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, \"And\", operation) : OnNode.create(operation)\n        });\n      }\n    });\n    BinaryOperationNode = freeze({\n      is(node) {\n        return node.kind === \"BinaryOperationNode\";\n      },\n      create(leftOperand, operator, rightOperand) {\n        return freeze({\n          kind: \"BinaryOperationNode\",\n          leftOperand,\n          operator,\n          rightOperand\n        });\n      }\n    });\n    COMPARISON_OPERATORS = [\n      \"=\",\n      \"==\",\n      \"!=\",\n      \"<>\",\n      \">\",\n      \">=\",\n      \"<\",\n      \"<=\",\n      \"in\",\n      \"not in\",\n      \"is\",\n      \"is not\",\n      \"like\",\n      \"not like\",\n      \"match\",\n      \"ilike\",\n      \"not ilike\",\n      \"@>\",\n      \"<@\",\n      \"^@\",\n      \"&&\",\n      \"?\",\n      \"?&\",\n      \"?|\",\n      \"!<\",\n      \"!>\",\n      \"<=>\",\n      \"!~\",\n      \"~\",\n      \"~*\",\n      \"!~*\",\n      \"@@\",\n      \"@@@\",\n      \"!!\",\n      \"<->\",\n      \"regexp\",\n      \"is distinct from\",\n      \"is not distinct from\"\n    ];\n    ARITHMETIC_OPERATORS = [\n      \"+\",\n      \"-\",\n      \"*\",\n      \"/\",\n      \"%\",\n      \"^\",\n      \"&\",\n      \"|\",\n      \"#\",\n      \"<<\",\n      \">>\"\n    ];\n    JSON_OPERATORS = [\"->\", \"->>\"];\n    BINARY_OPERATORS = [\n      ...COMPARISON_OPERATORS,\n      ...ARITHMETIC_OPERATORS,\n      \"&&\",\n      \"||\"\n    ];\n    UNARY_FILTER_OPERATORS = [\"exists\", \"not exists\"];\n    UNARY_OPERATORS = [\"not\", \"-\", ...UNARY_FILTER_OPERATORS];\n    OPERATORS = [\n      ...BINARY_OPERATORS,\n      ...JSON_OPERATORS,\n      ...UNARY_OPERATORS,\n      \"between\",\n      \"between symmetric\"\n    ];\n    OperatorNode = freeze({\n      is(node) {\n        return node.kind === \"OperatorNode\";\n      },\n      create(operator) {\n        return freeze({\n          kind: \"OperatorNode\",\n          operator\n        });\n      }\n    });\n    __name(isJSONOperator, \"isJSONOperator\");\n    ColumnNode = freeze({\n      is(node) {\n        return node.kind === \"ColumnNode\";\n      },\n      create(column) {\n        return freeze({\n          kind: \"ColumnNode\",\n          column: IdentifierNode.create(column)\n        });\n      }\n    });\n    SelectAllNode = freeze({\n      is(node) {\n        return node.kind === \"SelectAllNode\";\n      },\n      create() {\n        return freeze({\n          kind: \"SelectAllNode\"\n        });\n      }\n    });\n    ReferenceNode = freeze({\n      is(node) {\n        return node.kind === \"ReferenceNode\";\n      },\n      create(column, table3) {\n        return freeze({\n          kind: \"ReferenceNode\",\n          table: table3,\n          column\n        });\n      },\n      createSelectAll(table3) {\n        return freeze({\n          kind: \"ReferenceNode\",\n          table: table3,\n          column: SelectAllNode.create()\n        });\n      }\n    });\n    DynamicReferenceBuilder = class {\n      static {\n        __name(this, \"DynamicReferenceBuilder\");\n      }\n      #dynamicReference;\n      get dynamicReference() {\n        return this.#dynamicReference;\n      }\n      /**\n       * @private\n       *\n       * This needs to be here just so that the typings work. Without this\n       * the generated .d.ts file contains no reference to the type param R\n       * which causes this type to be equal to DynamicReferenceBuilder with\n       * any R.\n       */\n      get refType() {\n        return void 0;\n      }\n      constructor(reference) {\n        this.#dynamicReference = reference;\n      }\n      toOperationNode() {\n        return parseSimpleReferenceExpression(this.#dynamicReference);\n      }\n    };\n    __name(isDynamicReferenceBuilder, \"isDynamicReferenceBuilder\");\n    OrderByItemNode = freeze({\n      is(node) {\n        return node.kind === \"OrderByItemNode\";\n      },\n      create(orderBy, direction) {\n        return freeze({\n          kind: \"OrderByItemNode\",\n          orderBy,\n          direction\n        });\n      }\n    });\n    RawNode = freeze({\n      is(node) {\n        return node.kind === \"RawNode\";\n      },\n      create(sqlFragments, parameters) {\n        return freeze({\n          kind: \"RawNode\",\n          sqlFragments: freeze(sqlFragments),\n          parameters: freeze(parameters)\n        });\n      },\n      createWithSql(sql2) {\n        return RawNode.create([sql2], []);\n      },\n      createWithChild(child) {\n        return RawNode.create([\"\", \"\"], [child]);\n      },\n      createWithChildren(children) {\n        return RawNode.create(new Array(children.length + 1).fill(\"\"), children);\n      }\n    });\n    __name(isOrderByDirection, \"isOrderByDirection\");\n    __name(parseOrderBy, \"parseOrderBy\");\n    __name(parseOrderByItem, \"parseOrderByItem\");\n    __name(parseOrderByExpression, \"parseOrderByExpression\");\n    __name(parseOrderByDirectionExpression, \"parseOrderByDirectionExpression\");\n    JSONReferenceNode = freeze({\n      is(node) {\n        return node.kind === \"JSONReferenceNode\";\n      },\n      create(reference, traversal) {\n        return freeze({\n          kind: \"JSONReferenceNode\",\n          reference,\n          traversal\n        });\n      },\n      cloneWithTraversal(node, traversal) {\n        return freeze({\n          ...node,\n          traversal\n        });\n      }\n    });\n    JSONOperatorChainNode = freeze({\n      is(node) {\n        return node.kind === \"JSONOperatorChainNode\";\n      },\n      create(operator) {\n        return freeze({\n          kind: \"JSONOperatorChainNode\",\n          operator,\n          values: freeze([])\n        });\n      },\n      cloneWithValue(node, value2) {\n        return freeze({\n          ...node,\n          values: freeze([...node.values, value2])\n        });\n      }\n    });\n    JSONPathNode = freeze({\n      is(node) {\n        return node.kind === \"JSONPathNode\";\n      },\n      create(inOperator) {\n        return freeze({\n          kind: \"JSONPathNode\",\n          inOperator,\n          pathLegs: freeze([])\n        });\n      },\n      cloneWithLeg(jsonPathNode, pathLeg) {\n        return freeze({\n          ...jsonPathNode,\n          pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])\n        });\n      }\n    });\n    __name(parseSimpleReferenceExpression, \"parseSimpleReferenceExpression\");\n    __name(parseReferenceExpressionOrList, \"parseReferenceExpressionOrList\");\n    __name(parseReferenceExpression, \"parseReferenceExpression\");\n    __name(parseJSONReference, \"parseJSONReference\");\n    __name(parseStringReference, \"parseStringReference\");\n    __name(parseAliasedStringReference, \"parseAliasedStringReference\");\n    __name(parseColumnName, \"parseColumnName\");\n    __name(parseOrderedColumnName, \"parseOrderedColumnName\");\n    __name(parseStringReferenceWithTableAndSchema, \"parseStringReferenceWithTableAndSchema\");\n    __name(parseStringReferenceWithTable, \"parseStringReferenceWithTable\");\n    __name(trim$2, \"trim$2\");\n    PrimitiveValueListNode = freeze({\n      is(node) {\n        return node.kind === \"PrimitiveValueListNode\";\n      },\n      create(values) {\n        return freeze({\n          kind: \"PrimitiveValueListNode\",\n          values: freeze([...values])\n        });\n      }\n    });\n    ValueListNode = freeze({\n      is(node) {\n        return node.kind === \"ValueListNode\";\n      },\n      create(values) {\n        return freeze({\n          kind: \"ValueListNode\",\n          values: freeze(values)\n        });\n      }\n    });\n    ValueNode = freeze({\n      is(node) {\n        return node.kind === \"ValueNode\";\n      },\n      create(value2) {\n        return freeze({\n          kind: \"ValueNode\",\n          value: value2\n        });\n      },\n      createImmediate(value2) {\n        return freeze({\n          kind: \"ValueNode\",\n          value: value2,\n          immediate: true\n        });\n      }\n    });\n    __name(parseValueExpressionOrList, \"parseValueExpressionOrList\");\n    __name(parseValueExpression, \"parseValueExpression\");\n    __name(isSafeImmediateValue, \"isSafeImmediateValue\");\n    __name(parseSafeImmediateValue, \"parseSafeImmediateValue\");\n    __name(parseValueExpressionList, \"parseValueExpressionList\");\n    ParensNode = freeze({\n      is(node) {\n        return node.kind === \"ParensNode\";\n      },\n      create(node) {\n        return freeze({\n          kind: \"ParensNode\",\n          node\n        });\n      }\n    });\n    __name(parseValueBinaryOperationOrExpression, \"parseValueBinaryOperationOrExpression\");\n    __name(parseValueBinaryOperation, \"parseValueBinaryOperation\");\n    __name(parseReferentialBinaryOperation, \"parseReferentialBinaryOperation\");\n    __name(parseFilterObject, \"parseFilterObject\");\n    __name(parseFilterList, \"parseFilterList\");\n    __name(isIsOperator, \"isIsOperator\");\n    __name(needsIsOperator, \"needsIsOperator\");\n    __name(parseOperator, \"parseOperator\");\n    __name(toOperationNode, \"toOperationNode\");\n    OrderByNode = freeze({\n      is(node) {\n        return node.kind === \"OrderByNode\";\n      },\n      create(items) {\n        return freeze({\n          kind: \"OrderByNode\",\n          items: freeze([...items])\n        });\n      },\n      cloneWithItems(orderBy, items) {\n        return freeze({\n          ...orderBy,\n          items: freeze([...orderBy.items, ...items])\n        });\n      }\n    });\n    PartitionByNode = freeze({\n      is(node) {\n        return node.kind === \"PartitionByNode\";\n      },\n      create(items) {\n        return freeze({\n          kind: \"PartitionByNode\",\n          items: freeze(items)\n        });\n      },\n      cloneWithItems(partitionBy, items) {\n        return freeze({\n          ...partitionBy,\n          items: freeze([...partitionBy.items, ...items])\n        });\n      }\n    });\n    OverNode = freeze({\n      is(node) {\n        return node.kind === \"OverNode\";\n      },\n      create() {\n        return freeze({\n          kind: \"OverNode\"\n        });\n      },\n      cloneWithOrderByItems(overNode, items) {\n        return freeze({\n          ...overNode,\n          orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)\n        });\n      },\n      cloneWithPartitionByItems(overNode, items) {\n        return freeze({\n          ...overNode,\n          partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)\n        });\n      }\n    });\n    FromNode = freeze({\n      is(node) {\n        return node.kind === \"FromNode\";\n      },\n      create(froms) {\n        return freeze({\n          kind: \"FromNode\",\n          froms: freeze(froms)\n        });\n      },\n      cloneWithFroms(from, froms) {\n        return freeze({\n          ...from,\n          froms: freeze([...from.froms, ...froms])\n        });\n      }\n    });\n    GroupByNode = freeze({\n      is(node) {\n        return node.kind === \"GroupByNode\";\n      },\n      create(items) {\n        return freeze({\n          kind: \"GroupByNode\",\n          items: freeze(items)\n        });\n      },\n      cloneWithItems(groupBy, items) {\n        return freeze({\n          ...groupBy,\n          items: freeze([...groupBy.items, ...items])\n        });\n      }\n    });\n    HavingNode = freeze({\n      is(node) {\n        return node.kind === \"HavingNode\";\n      },\n      create(filter) {\n        return freeze({\n          kind: \"HavingNode\",\n          having: filter\n        });\n      },\n      cloneWithOperation(havingNode, operator, operation) {\n        return freeze({\n          ...havingNode,\n          having: operator === \"And\" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)\n        });\n      }\n    });\n    SelectQueryNode = freeze({\n      is(node) {\n        return node.kind === \"SelectQueryNode\";\n      },\n      create(withNode) {\n        return freeze({\n          kind: \"SelectQueryNode\",\n          ...withNode && { with: withNode }\n        });\n      },\n      createFrom(fromItems, withNode) {\n        return freeze({\n          kind: \"SelectQueryNode\",\n          from: FromNode.create(fromItems),\n          ...withNode && { with: withNode }\n        });\n      },\n      cloneWithSelections(select, selections) {\n        return freeze({\n          ...select,\n          selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)\n        });\n      },\n      cloneWithDistinctOn(select, expressions) {\n        return freeze({\n          ...select,\n          distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)\n        });\n      },\n      cloneWithFrontModifier(select, modifier) {\n        return freeze({\n          ...select,\n          frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])\n        });\n      },\n      cloneWithOrderByItems(selectNode, items) {\n        return freeze({\n          ...selectNode,\n          orderBy: selectNode.orderBy ? OrderByNode.cloneWithItems(selectNode.orderBy, items) : OrderByNode.create(items)\n        });\n      },\n      cloneWithGroupByItems(selectNode, items) {\n        return freeze({\n          ...selectNode,\n          groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)\n        });\n      },\n      cloneWithLimit(selectNode, limit) {\n        return freeze({\n          ...selectNode,\n          limit\n        });\n      },\n      cloneWithOffset(selectNode, offset) {\n        return freeze({\n          ...selectNode,\n          offset\n        });\n      },\n      cloneWithFetch(selectNode, fetch2) {\n        return freeze({\n          ...selectNode,\n          fetch: fetch2\n        });\n      },\n      cloneWithHaving(selectNode, operation) {\n        return freeze({\n          ...selectNode,\n          having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, \"And\", operation) : HavingNode.create(operation)\n        });\n      },\n      cloneWithSetOperations(selectNode, setOperations) {\n        return freeze({\n          ...selectNode,\n          setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])\n        });\n      },\n      cloneWithoutSelections(select) {\n        return freeze({\n          ...select,\n          selections: []\n        });\n      },\n      cloneWithoutLimit(select) {\n        return freeze({\n          ...select,\n          limit: void 0\n        });\n      },\n      cloneWithoutOffset(select) {\n        return freeze({\n          ...select,\n          offset: void 0\n        });\n      },\n      cloneWithoutOrderBy(select) {\n        return freeze({\n          ...select,\n          orderBy: void 0\n        });\n      },\n      cloneWithoutGroupBy(select) {\n        return freeze({\n          ...select,\n          groupBy: void 0\n        });\n      }\n    });\n    __name(preventAwait, \"preventAwait\");\n    JoinBuilder = class _JoinBuilder {\n      static {\n        __name(this, \"JoinBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      on(...args) {\n        return new _JoinBuilder({\n          ...this.#props,\n          joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      /**\n       * Just like {@link WhereInterface.whereRef} but adds an item to the join's\n       * `on` clause instead.\n       *\n       * See {@link WhereInterface.whereRef} for documentation and examples.\n       */\n      onRef(lhs, op, rhs) {\n        return new _JoinBuilder({\n          ...this.#props,\n          joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      /**\n       * Adds `on true`.\n       */\n      onTrue() {\n        return new _JoinBuilder({\n          ...this.#props,\n          joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql(\"true\"))\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.joinNode;\n      }\n    };\n    preventAwait(JoinBuilder, \"don't await JoinBuilder instances. They are never executed directly and are always just a part of a query.\");\n    PartitionByItemNode = freeze({\n      is(node) {\n        return node.kind === \"PartitionByItemNode\";\n      },\n      create(partitionBy) {\n        return freeze({\n          kind: \"PartitionByItemNode\",\n          partitionBy\n        });\n      }\n    });\n    __name(parsePartitionBy, \"parsePartitionBy\");\n    OverBuilder = class _OverBuilder {\n      static {\n        __name(this, \"OverBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Adds an order by clause item inside the over function.\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .select(\n       *     (eb) => eb.fn.avg<number>('age').over(\n       *       ob => ob.orderBy('first_name', 'asc').orderBy('last_name', 'asc')\n       *     ).as('average_age')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select avg(\"age\") over(order by \"first_name\" asc, \"last_name\" asc) as \"average_age\"\n       * from \"person\"\n       * ```\n       */\n      orderBy(orderBy, direction) {\n        return new _OverBuilder({\n          overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy([orderBy, direction]))\n        });\n      }\n      partitionBy(partitionBy) {\n        return new _OverBuilder({\n          overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.overNode;\n      }\n    };\n    preventAwait(OverBuilder, \"don't await OverBuilder instances. They are never executed directly and are always just a part of a query.\");\n    SelectionNode = freeze({\n      is(node) {\n        return node.kind === \"SelectionNode\";\n      },\n      create(selection) {\n        return freeze({\n          kind: \"SelectionNode\",\n          selection\n        });\n      },\n      createSelectAll() {\n        return freeze({\n          kind: \"SelectionNode\",\n          selection: SelectAllNode.create()\n        });\n      },\n      createSelectAllFromTable(table3) {\n        return freeze({\n          kind: \"SelectionNode\",\n          selection: ReferenceNode.createSelectAll(table3)\n        });\n      }\n    });\n    __name(parseSelectArg, \"parseSelectArg\");\n    __name(parseSelectExpression, \"parseSelectExpression\");\n    __name(parseSelectAll, \"parseSelectAll\");\n    __name(parseSelectAllArg, \"parseSelectAllArg\");\n    ValuesNode = freeze({\n      is(node) {\n        return node.kind === \"ValuesNode\";\n      },\n      create(values) {\n        return freeze({\n          kind: \"ValuesNode\",\n          values: freeze(values)\n        });\n      }\n    });\n    DefaultInsertValueNode = freeze({\n      is(node) {\n        return node.kind === \"DefaultInsertValueNode\";\n      },\n      create() {\n        return freeze({\n          kind: \"DefaultInsertValueNode\"\n        });\n      }\n    });\n    __name(parseInsertExpression, \"parseInsertExpression\");\n    __name(parseInsertColumnsAndValues, \"parseInsertColumnsAndValues\");\n    __name(parseColumnNamesAndIndexes, \"parseColumnNamesAndIndexes\");\n    __name(parseRowValues, \"parseRowValues\");\n    InsertQueryNode = freeze({\n      is(node) {\n        return node.kind === \"InsertQueryNode\";\n      },\n      create(into, withNode, replace2) {\n        return freeze({\n          kind: \"InsertQueryNode\",\n          into,\n          ...withNode && { with: withNode },\n          replace: replace2\n        });\n      },\n      createWithoutInto() {\n        return freeze({\n          kind: \"InsertQueryNode\"\n        });\n      },\n      cloneWith(insertQuery, props) {\n        return freeze({\n          ...insertQuery,\n          ...props\n        });\n      }\n    });\n    UpdateQueryNode = freeze({\n      is(node) {\n        return node.kind === \"UpdateQueryNode\";\n      },\n      create(table3, withNode) {\n        return freeze({\n          kind: \"UpdateQueryNode\",\n          table: table3,\n          ...withNode && { with: withNode }\n        });\n      },\n      createWithoutTable() {\n        return freeze({\n          kind: \"UpdateQueryNode\"\n        });\n      },\n      cloneWithFromItems(updateQuery, fromItems) {\n        return freeze({\n          ...updateQuery,\n          from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)\n        });\n      },\n      cloneWithUpdates(updateQuery, updates) {\n        return freeze({\n          ...updateQuery,\n          updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates\n        });\n      },\n      cloneWithLimit(updateQuery, limit) {\n        return freeze({\n          ...updateQuery,\n          limit\n        });\n      }\n    });\n    UsingNode = freeze({\n      is(node) {\n        return node.kind === \"UsingNode\";\n      },\n      create(tables) {\n        return freeze({\n          kind: \"UsingNode\",\n          tables: freeze(tables)\n        });\n      },\n      cloneWithTables(using, tables) {\n        return freeze({\n          ...using,\n          tables: freeze([...using.tables, ...tables])\n        });\n      }\n    });\n    DeleteQueryNode = freeze({\n      is(node) {\n        return node.kind === \"DeleteQueryNode\";\n      },\n      create(fromItems, withNode) {\n        return freeze({\n          kind: \"DeleteQueryNode\",\n          from: FromNode.create(fromItems),\n          ...withNode && { with: withNode }\n        });\n      },\n      cloneWithOrderByItems(deleteNode, items) {\n        return freeze({\n          ...deleteNode,\n          orderBy: deleteNode.orderBy ? OrderByNode.cloneWithItems(deleteNode.orderBy, items) : OrderByNode.create(items)\n        });\n      },\n      cloneWithoutOrderBy(deleteNode) {\n        return freeze({\n          ...deleteNode,\n          orderBy: void 0\n        });\n      },\n      cloneWithLimit(deleteNode, limit) {\n        return freeze({\n          ...deleteNode,\n          limit\n        });\n      },\n      cloneWithoutLimit(deleteNode) {\n        return freeze({\n          ...deleteNode,\n          limit: void 0\n        });\n      },\n      cloneWithUsing(deleteNode, tables) {\n        return freeze({\n          ...deleteNode,\n          using: deleteNode.using !== void 0 ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)\n        });\n      }\n    });\n    WhereNode = freeze({\n      is(node) {\n        return node.kind === \"WhereNode\";\n      },\n      create(filter) {\n        return freeze({\n          kind: \"WhereNode\",\n          where: filter\n        });\n      },\n      cloneWithOperation(whereNode, operator, operation) {\n        return freeze({\n          ...whereNode,\n          where: operator === \"And\" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)\n        });\n      }\n    });\n    ReturningNode = freeze({\n      is(node) {\n        return node.kind === \"ReturningNode\";\n      },\n      create(selections) {\n        return freeze({\n          kind: \"ReturningNode\",\n          selections: freeze(selections)\n        });\n      },\n      cloneWithSelections(returning, selections) {\n        return freeze({\n          ...returning,\n          selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)\n        });\n      }\n    });\n    ExplainNode = freeze({\n      is(node) {\n        return node.kind === \"ExplainNode\";\n      },\n      create(format2, options) {\n        return freeze({\n          kind: \"ExplainNode\",\n          format: format2,\n          options\n        });\n      }\n    });\n    WhenNode = freeze({\n      is(node) {\n        return node.kind === \"WhenNode\";\n      },\n      create(condition) {\n        return freeze({\n          kind: \"WhenNode\",\n          condition\n        });\n      },\n      cloneWithResult(whenNode, result) {\n        return freeze({\n          ...whenNode,\n          result\n        });\n      }\n    });\n    MergeQueryNode = freeze({\n      is(node) {\n        return node.kind === \"MergeQueryNode\";\n      },\n      create(into, withNode) {\n        return freeze({\n          kind: \"MergeQueryNode\",\n          into,\n          ...withNode && { with: withNode }\n        });\n      },\n      cloneWithUsing(mergeNode, using) {\n        return freeze({\n          ...mergeNode,\n          using\n        });\n      },\n      cloneWithWhen(mergeNode, when) {\n        return freeze({\n          ...mergeNode,\n          whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])\n        });\n      },\n      cloneWithThen(mergeNode, then) {\n        return freeze({\n          ...mergeNode,\n          whens: mergeNode.whens ? freeze([\n            ...mergeNode.whens.slice(0, -1),\n            WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)\n          ]) : void 0\n        });\n      }\n    });\n    OutputNode = freeze({\n      is(node) {\n        return node.kind === \"OutputNode\";\n      },\n      create(selections) {\n        return freeze({\n          kind: \"OutputNode\",\n          selections: freeze(selections)\n        });\n      },\n      cloneWithSelections(output, selections) {\n        return freeze({\n          ...output,\n          selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)\n        });\n      }\n    });\n    QueryNode = freeze({\n      is(node) {\n        return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);\n      },\n      cloneWithEndModifier(node, modifier) {\n        return freeze({\n          ...node,\n          endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : freeze([modifier])\n        });\n      },\n      cloneWithWhere(node, operation) {\n        return freeze({\n          ...node,\n          where: node.where ? WhereNode.cloneWithOperation(node.where, \"And\", operation) : WhereNode.create(operation)\n        });\n      },\n      cloneWithJoin(node, join) {\n        return freeze({\n          ...node,\n          joins: node.joins ? freeze([...node.joins, join]) : freeze([join])\n        });\n      },\n      cloneWithReturning(node, selections) {\n        return freeze({\n          ...node,\n          returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)\n        });\n      },\n      cloneWithoutReturning(node) {\n        return freeze({\n          ...node,\n          returning: void 0\n        });\n      },\n      cloneWithoutWhere(node) {\n        return freeze({\n          ...node,\n          where: void 0\n        });\n      },\n      cloneWithExplain(node, format2, options) {\n        return freeze({\n          ...node,\n          explain: ExplainNode.create(format2, options?.toOperationNode())\n        });\n      },\n      cloneWithTop(node, top) {\n        return freeze({\n          ...node,\n          top\n        });\n      },\n      cloneWithOutput(node, selections) {\n        return freeze({\n          ...node,\n          output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)\n        });\n      }\n    });\n    ColumnUpdateNode = freeze({\n      is(node) {\n        return node.kind === \"ColumnUpdateNode\";\n      },\n      create(column, value2) {\n        return freeze({\n          kind: \"ColumnUpdateNode\",\n          column,\n          value: value2\n        });\n      }\n    });\n    __name(parseUpdate, \"parseUpdate\");\n    __name(parseUpdateObjectExpression, \"parseUpdateObjectExpression\");\n    OnDuplicateKeyNode = freeze({\n      is(node) {\n        return node.kind === \"OnDuplicateKeyNode\";\n      },\n      create(updates) {\n        return freeze({\n          kind: \"OnDuplicateKeyNode\",\n          updates\n        });\n      }\n    });\n    InsertResult = class {\n      static {\n        __name(this, \"InsertResult\");\n      }\n      /**\n       * The auto incrementing primary key of the inserted row.\n       *\n       * This property can be undefined when the query contains an `on conflict`\n       * clause that makes the query succeed even when nothing gets inserted.\n       *\n       * This property is always undefined on dialects like PostgreSQL that\n       * don't return the inserted id by default. On those dialects you need\n       * to use the {@link ReturningInterface.returning | returning} method.\n       */\n      insertId;\n      /**\n       * Affected rows count.\n       */\n      numInsertedOrUpdatedRows;\n      constructor(insertId, numInsertedOrUpdatedRows) {\n        this.insertId = insertId;\n        this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;\n      }\n    };\n    NoResultError = class extends Error {\n      static {\n        __name(this, \"NoResultError\");\n      }\n      /**\n       * The operation node tree of the query that was executed.\n       */\n      node;\n      constructor(node) {\n        super(\"no result\");\n        this.node = node;\n      }\n    };\n    __name(isNoResultErrorConstructor, \"isNoResultErrorConstructor\");\n    OnConflictNode = freeze({\n      is(node) {\n        return node.kind === \"OnConflictNode\";\n      },\n      create() {\n        return freeze({\n          kind: \"OnConflictNode\"\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      },\n      cloneWithIndexWhere(node, operation) {\n        return freeze({\n          ...node,\n          indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, \"And\", operation) : WhereNode.create(operation)\n        });\n      },\n      cloneWithIndexOrWhere(node, operation) {\n        return freeze({\n          ...node,\n          indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, \"Or\", operation) : WhereNode.create(operation)\n        });\n      },\n      cloneWithUpdateWhere(node, operation) {\n        return freeze({\n          ...node,\n          updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, \"And\", operation) : WhereNode.create(operation)\n        });\n      },\n      cloneWithUpdateOrWhere(node, operation) {\n        return freeze({\n          ...node,\n          updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, \"Or\", operation) : WhereNode.create(operation)\n        });\n      },\n      cloneWithoutIndexWhere(node) {\n        return freeze({\n          ...node,\n          indexWhere: void 0\n        });\n      },\n      cloneWithoutUpdateWhere(node) {\n        return freeze({\n          ...node,\n          updateWhere: void 0\n        });\n      }\n    });\n    OnConflictBuilder = class _OnConflictBuilder {\n      static {\n        __name(this, \"OnConflictBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Specify a single column as the conflict target.\n       *\n       * Also see the {@link columns}, {@link constraint} and {@link expression}\n       * methods for alternative ways to specify the conflict target.\n       */\n      column(column) {\n        const columnNode = ColumnNode.create(column);\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {\n            columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])\n          })\n        });\n      }\n      /**\n       * Specify a list of columns as the conflict target.\n       *\n       * Also see the {@link column}, {@link constraint} and {@link expression}\n       * methods for alternative ways to specify the conflict target.\n       */\n      columns(columns) {\n        const columnNodes = columns.map(ColumnNode.create);\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {\n            columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)\n          })\n        });\n      }\n      /**\n       * Specify a specific constraint by name as the conflict target.\n       *\n       * Also see the {@link column}, {@link columns} and {@link expression}\n       * methods for alternative ways to specify the conflict target.\n       */\n      constraint(constraintName) {\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {\n            constraint: IdentifierNode.create(constraintName)\n          })\n        });\n      }\n      /**\n       * Specify an expression as the conflict target.\n       *\n       * This can be used if the unique index is an expression index.\n       *\n       * Also see the {@link column}, {@link columns} and {@link constraint}\n       * methods for alternative ways to specify the conflict target.\n       */\n      expression(expression) {\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {\n            indexExpression: expression.toOperationNode()\n          })\n        });\n      }\n      where(...args) {\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      whereRef(lhs, op, rhs) {\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      clearWhere() {\n        return new _OnConflictBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)\n        });\n      }\n      /**\n       * Adds the \"do nothing\" conflict action.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const id = 1\n       * const first_name = 'John'\n       *\n       * await db\n       *   .insertInto('person')\n       *   .values({ first_name, id })\n       *   .onConflict((oc) => oc\n       *     .column('id')\n       *     .doNothing()\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"id\")\n       * values ($1, $2)\n       * on conflict (\"id\") do nothing\n       * ```\n       */\n      doNothing() {\n        return new OnConflictDoNothingBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {\n            doNothing: true\n          })\n        });\n      }\n      /**\n       * Adds the \"do update set\" conflict action.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const id = 1\n       * const first_name = 'John'\n       *\n       * await db\n       *   .insertInto('person')\n       *   .values({ first_name, id })\n       *   .onConflict((oc) => oc\n       *     .column('id')\n       *     .doUpdateSet({ first_name })\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"id\")\n       * values ($1, $2)\n       * on conflict (\"id\")\n       * do update set \"first_name\" = $3\n       * ```\n       *\n       * In the next example we use the `ref` method to reference\n       * columns of the virtual table `excluded` in a type-safe way\n       * to create an upsert operation:\n       *\n       * ```ts\n       * import type { NewPerson } from 'type-editor' // imaginary module\n       *\n       * async function upsertPerson(person: NewPerson): Promise<void> {\n       *   await db.insertInto('person')\n       *     .values(person)\n       *     .onConflict((oc) => oc\n       *       .column('id')\n       *       .doUpdateSet((eb) => ({\n       *         first_name: eb.ref('excluded.first_name'),\n       *         last_name: eb.ref('excluded.last_name')\n       *       })\n       *     )\n       *   )\n       *   .execute()\n       * }\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"last_name\")\n       * values ($1, $2)\n       * on conflict (\"id\")\n       * do update set\n       *  \"first_name\" = excluded.\"first_name\",\n       *  \"last_name\" = excluded.\"last_name\"\n       * ```\n       */\n      doUpdateSet(update2) {\n        return new OnConflictUpdateBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {\n            updates: parseUpdateObjectExpression(update2)\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n    };\n    preventAwait(OnConflictBuilder, \"don't await OnConflictBuilder instances.\");\n    OnConflictDoNothingBuilder = class {\n      static {\n        __name(this, \"OnConflictDoNothingBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      toOperationNode() {\n        return this.#props.onConflictNode;\n      }\n    };\n    preventAwait(OnConflictDoNothingBuilder, \"don't await OnConflictDoNothingBuilder instances.\");\n    OnConflictUpdateBuilder = class _OnConflictUpdateBuilder {\n      static {\n        __name(this, \"OnConflictUpdateBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      where(...args) {\n        return new _OnConflictUpdateBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      /**\n       * Specify a where condition for the update operation.\n       *\n       * See {@link WhereInterface.whereRef} for more info.\n       */\n      whereRef(lhs, op, rhs) {\n        return new _OnConflictUpdateBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      clearWhere() {\n        return new _OnConflictUpdateBuilder({\n          ...this.#props,\n          onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.onConflictNode;\n      }\n    };\n    preventAwait(OnConflictUpdateBuilder, \"don't await OnConflictUpdateBuilder instances.\");\n    TopNode = freeze({\n      is(node) {\n        return node.kind === \"TopNode\";\n      },\n      create(expression, modifiers) {\n        return freeze({\n          kind: \"TopNode\",\n          expression,\n          modifiers\n        });\n      }\n    });\n    __name(parseTop, \"parseTop\");\n    __name(isTopModifiers, \"isTopModifiers\");\n    InsertQueryBuilder = class _InsertQueryBuilder {\n      static {\n        __name(this, \"InsertQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Sets the values to insert for an {@link Kysely.insertInto | insert} query.\n       *\n       * This method takes an object whose keys are column names and values are\n       * values to insert. In addition to the column's type, the values can be\n       * raw {@link sql} snippets or select queries.\n       *\n       * You must provide all fields you haven't explicitly marked as nullable\n       * or optional using {@link Generated} or {@link ColumnType}.\n       *\n       * The return value of an `insert` query is an instance of {@link InsertResult}. The\n       * {@link InsertResult.insertId | insertId} field holds the auto incremented primary\n       * key if the database returned one.\n       *\n       * On PostgreSQL and some other dialects, you need to call `returning` to get\n       * something out of the query.\n       *\n       * Also see the {@link expression} method for inserting the result of a select\n       * query or any other expression.\n       *\n       * ### Examples\n       *\n       * <!-- siteExample(\"insert\", \"Single row\", 10) -->\n       *\n       * Insert a single row:\n       *\n       * ```ts\n       * const result = await db\n       *   .insertInto('person')\n       *   .values({\n       *     first_name: 'Jennifer',\n       *     last_name: 'Aniston',\n       *     age: 40\n       *   })\n       *   .executeTakeFirst()\n       *\n       * // `insertId` is only available on dialects that\n       * // automatically return the id of the inserted row\n       * // such as MySQL and SQLite. On PostgreSQL, for example,\n       * // you need to add a `returning` clause to the query to\n       * // get anything out. See the \"returning data\" example.\n       * console.log(result.insertId)\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)\n       * ```\n       *\n       * <!-- siteExample(\"insert\", \"Multiple rows\", 20) -->\n       *\n       * On dialects that support it (for example PostgreSQL) you can insert multiple\n       * rows by providing an array. Note that the return value is once again very\n       * dialect-specific. Some databases may only return the id of the *last* inserted\n       * row and some return nothing at all unless you call `returning`.\n       *\n       * ```ts\n       * await db\n       *   .insertInto('person')\n       *   .values([{\n       *     first_name: 'Jennifer',\n       *     last_name: 'Aniston',\n       *     age: 40,\n       *   }, {\n       *     first_name: 'Arnold',\n       *     last_name: 'Schwarzenegger',\n       *     age: 70,\n       *   }])\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"last_name\", \"age\") values (($1, $2, $3), ($4, $5, $6))\n       * ```\n       *\n       * <!-- siteExample(\"insert\", \"Returning data\", 30) -->\n       *\n       * On supported dialects like PostgreSQL you need to chain `returning` to the query to get\n       * the inserted row's columns (or any other expression) as the return value. `returning`\n       * works just like `select`. Refer to `select` method's examples and documentation for\n       * more info.\n       *\n       * ```ts\n       * const result = await db\n       *   .insertInto('person')\n       *   .values({\n       *     first_name: 'Jennifer',\n       *     last_name: 'Aniston',\n       *     age: 40,\n       *   })\n       *   .returning(['id', 'first_name as name'])\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"last_name\", \"age\") values ($1, $2, $3) returning \"id\", \"first_name\" as \"name\"\n       * ```\n       *\n       * <!-- siteExample(\"insert\", \"Complex values\", 40) -->\n       *\n       * In addition to primitives, the values can also be arbitrary expressions.\n       * You can build the expressions by using a callback and calling the methods\n       * on the expression builder passed to it:\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * const ani = \"Ani\"\n       * const ston = \"ston\"\n       *\n       * const result = await db\n       *   .insertInto('person')\n       *   .values(({ ref, selectFrom, fn }) => ({\n       *     first_name: 'Jennifer',\n       *     last_name: sql<string>`concat(${ani}, ${ston})`,\n       *     middle_name: ref('first_name'),\n       *     age: selectFrom('person')\n       *       .select(fn.avg<number>('age').as('avg_age')),\n       *   }))\n       *   .executeTakeFirst()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\n       *   \"first_name\",\n       *   \"last_name\",\n       *   \"middle_name\",\n       *   \"age\"\n       * )\n       * values (\n       *   $1,\n       *   concat($2, $3),\n       *   \"first_name\",\n       *   (select avg(\"age\") as \"avg_age\" from \"person\")\n       * )\n       * ```\n       *\n       * You can also use the callback version of subqueries or raw expressions:\n       *\n       * ```ts\n       * await db.with('jennifer', (db) => db\n       *   .selectFrom('person')\n       *   .where('first_name', '=', 'Jennifer')\n       *   .select(['id', 'first_name', 'gender'])\n       *   .limit(1)\n       * ).insertInto('pet').values((eb) => ({\n       *   owner_id: eb.selectFrom('jennifer').select('id'),\n       *   name: eb.selectFrom('jennifer').select('first_name'),\n       *   species: 'cat',\n       * }))\n       * .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * with \"jennifer\" as (\n       *   select \"id\", \"first_name\", \"gender\"\n       *   from \"person\"\n       *   where \"first_name\" = $1\n       *   limit $2\n       * )\n       * insert into \"pet\" (\"owner_id\", \"name\", \"species\")\n       * values (\n       *  (select \"id\" from \"jennifer\"),\n       *  (select \"first_name\" from \"jennifer\"),\n       *  $3\n       * )\n       * ```\n       */\n      values(insert) {\n        const [columns, values] = parseInsertExpression(insert);\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            columns,\n            values\n          })\n        });\n      }\n      /**\n       * Sets the columns to insert.\n       *\n       * The {@link values} method sets both the columns and the values and this method\n       * is not needed. But if you are using the {@link expression} method, you can use\n       * this method to set the columns to insert.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.insertInto('person')\n       *   .columns(['first_name'])\n       *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\")\n       * select \"pet\".\"name\" from \"pet\"\n       * ```\n       */\n      columns(columns) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            columns: freeze(columns.map(ColumnNode.create))\n          })\n        });\n      }\n      /**\n       * Insert an arbitrary expression. For example the result of a select query.\n       *\n       * ### Examples\n       *\n       * <!-- siteExample(\"insert\", \"Insert subquery\", 50) -->\n       *\n       * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.\n       * This API doesn't follow our WYSIWYG principles and might be a bit difficult to\n       * remember. The reasons for this design stem from implementation difficulties.\n       *\n       * ```ts\n       * const result = await db.insertInto('person')\n       *   .columns(['first_name', 'last_name', 'age'])\n       *   .expression((eb) => eb\n       *     .selectFrom('pet')\n       *     .select((eb) => [\n       *       'pet.name',\n       *       eb.val('Petson').as('last_name'),\n       *       eb.lit(7).as('age'),\n       *     ])\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"last_name\", \"age\")\n       * select \"pet\".\"name\", $1 as \"last_name\", 7 as \"age from \"pet\"\n       * ```\n       */\n      expression(expression) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            values: parseExpression(expression)\n          })\n        });\n      }\n      /**\n       * Creates an `insert into \"person\" default values` query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.insertInto('person')\n       *   .defaultValues()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" default values\n       * ```\n       */\n      defaultValues() {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            defaultValues: true\n          })\n        });\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.insertInto('person')\n       *   .values({\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *     gender: 'male',\n       *   })\n       *   .modifyEnd(sql`-- This is a comment`)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * insert into `person` (\"first_name\", \"last_name\", \"gender\")\n       * values (?, ?, ?) -- This is a comment\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())\n        });\n      }\n      /**\n       * Changes an `insert into` query to an `insert ignore into` query.\n       *\n       * If you use the ignore modifier, ignorable errors that occur while executing the\n       * insert statement are ignored. For example, without ignore, a row that duplicates\n       * an existing unique index or primary key value in the table causes a duplicate-key\n       * error and the statement is aborted. With ignore, the row is discarded and no error\n       * occurs.\n       *\n       * This is only supported on some dialects like MySQL. On most dialects you should\n       * use the {@link onConflict} method.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.insertInto('person')\n       *   .ignore()\n       *   .values({\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *     gender: 'female',\n       *   })\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * insert ignore into `person` (\"first_name\", \"last_name\", \"gender\") values (?, ?, ?)\n       * ```\n       */\n      ignore() {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            ignore: true\n          })\n        });\n      }\n      /**\n       * Changes an `insert into` query to an `insert top into` query.\n       *\n       * `top` clause is only supported by some dialects like MS SQL Server.\n       *\n       * ### Examples\n       *\n       * Insert the first 5 rows:\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.insertInto('person')\n       *   .top(5)\n       *   .columns(['first_name', 'gender'])\n       *   .expression(\n       *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * insert top(5) into \"person\" (\"first_name\", \"gender\") select \"name\", 'other' as \"gender\" from \"pet\"\n       * ```\n       *\n       * Insert the first 50 percent of rows:\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.insertInto('person')\n       *   .top(50, 'percent')\n       *   .columns(['first_name', 'gender'])\n       *   .expression(\n       *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * insert top(50) percent into \"person\" (\"first_name\", \"gender\") select \"name\", 'other' as \"gender\" from \"pet\"\n       * ```\n       */\n      top(expression, modifiers) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))\n        });\n      }\n      /**\n       * Adds an `on conflict` clause to the query.\n       *\n       * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL\n       * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db\n       *   .insertInto('pet')\n       *   .values({\n       *     name: 'Catto',\n       *     species: 'cat',\n       *     owner_id: 3,\n       *   })\n       *   .onConflict((oc) => oc\n       *     .column('name')\n       *     .doUpdateSet({ species: 'hamster' })\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"pet\" (\"name\", \"species\", \"owner_id\")\n       * values ($1, $2, $3)\n       * on conflict (\"name\")\n       * do update set \"species\" = $4\n       * ```\n       *\n       * You can provide the name of the constraint instead of a column name:\n       *\n       * ```ts\n       * await db\n       *   .insertInto('pet')\n       *   .values({\n       *     name: 'Catto',\n       *     species: 'cat',\n       *     owner_id: 3,\n       *   })\n       *   .onConflict((oc) => oc\n       *     .constraint('pet_name_key')\n       *     .doUpdateSet({ species: 'hamster' })\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"pet\" (\"name\", \"species\", \"owner_id\")\n       * values ($1, $2, $3)\n       * on conflict on constraint \"pet_name_key\"\n       * do update set \"species\" = $4\n       * ```\n       *\n       * You can also specify an expression as the conflict target in case\n       * the unique index is an expression index:\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db\n       *   .insertInto('pet')\n       *   .values({\n       *     name: 'Catto',\n       *     species: 'cat',\n       *     owner_id: 3,\n       *   })\n       *   .onConflict((oc) => oc\n       *     .expression(sql<string>`lower(name)`)\n       *     .doUpdateSet({ species: 'hamster' })\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"pet\" (\"name\", \"species\", \"owner_id\")\n       * values ($1, $2, $3)\n       * on conflict (lower(name))\n       * do update set \"species\" = $4\n       * ```\n       *\n       * You can add a filter for the update statement like this:\n       *\n       * ```ts\n       * await db\n       *   .insertInto('pet')\n       *   .values({\n       *     name: 'Catto',\n       *     species: 'cat',\n       *     owner_id: 3,\n       *   })\n       *   .onConflict((oc) => oc\n       *     .column('name')\n       *     .doUpdateSet({ species: 'hamster' })\n       *     .where('excluded.name', '!=', 'Catto')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"pet\" (\"name\", \"species\", \"owner_id\")\n       * values ($1, $2, $3)\n       * on conflict (\"name\")\n       * do update set \"species\" = $4\n       * where \"excluded\".\"name\" != $5\n       * ```\n       *\n       * You can create an `on conflict do nothing` clauses like this:\n       *\n       * ```ts\n       * await db\n       *   .insertInto('pet')\n       *   .values({\n       *     name: 'Catto',\n       *     species: 'cat',\n       *     owner_id: 3,\n       *   })\n       *   .onConflict((oc) => oc\n       *     .column('name')\n       *     .doNothing()\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"pet\" (\"name\", \"species\", \"owner_id\")\n       * values ($1, $2, $3)\n       * on conflict (\"name\") do nothing\n       * ```\n       *\n       * You can refer to the columns of the virtual `excluded` table\n       * in a type-safe way using a callback and the `ref` method of\n       * `ExpressionBuilder`:\n       *\n       * ```ts\n       * await db.insertInto('person')\n       *   .values({\n       *     id: 1,\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *     gender: 'male',\n       *   })\n       *   .onConflict(oc => oc\n       *     .column('id')\n       *     .doUpdateSet({\n       *       first_name: (eb) => eb.ref('excluded.first_name'),\n       *       last_name: (eb) => eb.ref('excluded.last_name')\n       *     })\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"id\", \"first_name\", \"last_name\", \"gender\")\n       * values ($1, $2, $3, $4)\n       * on conflict (\"id\")\n       * do update set\n       *  \"first_name\" = \"excluded\".\"first_name\",\n       *  \"last_name\" = \"excluded\".\"last_name\"\n       * ```\n       */\n      onConflict(callback) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            onConflict: callback(new OnConflictBuilder({\n              onConflictNode: OnConflictNode.create()\n            })).toOperationNode()\n          })\n        });\n      }\n      /**\n       * Adds `on duplicate key update` to the query.\n       *\n       * If you specify `on duplicate key update`, and a row is inserted that would cause\n       * a duplicate value in a unique index or primary key, an update of the old row occurs.\n       *\n       * This is only implemented by some dialects like MySQL. On most dialects you should\n       * use {@link onConflict} instead.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db\n       *   .insertInto('person')\n       *   .values({\n       *     id: 1,\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *     gender: 'male',\n       *   })\n       *   .onDuplicateKeyUpdate({ updated_at: new Date().toISOString() })\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * insert into `person` (`id`, `first_name`, `last_name`, `gender`)\n       * values (?, ?, ?, ?)\n       * on duplicate key update `updated_at` = ?\n       * ```\n       */\n      onDuplicateKeyUpdate(update2) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {\n            onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update2))\n          })\n        });\n      }\n      returning(selection) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))\n        });\n      }\n      returningAll() {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())\n        });\n      }\n      output(args) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))\n        });\n      }\n      outputAll(table3) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      /**\n       * Clears all `returning` clauses from the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.insertInto('person')\n       *   .values({ first_name: 'James', last_name: 'Smith', gender: 'male' })\n       *   .returning(['first_name'])\n       *   .clearReturning()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL(PostgreSQL):\n       *\n       * ```sql\n       * insert into \"person\" (\"first_name\", \"last_name\", \"gender\") values ($1, $2, $3)\n       * ```\n       */\n      clearReturning() {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       *\n       * If you want to conditionally call a method on `this`, see\n       * the {@link $if} method.\n       *\n       * ### Examples\n       *\n       * The next example uses a helper function `log` to log a query:\n       *\n       * ```ts\n       * import type { Compilable } from 'kysely'\n       *\n       * function log<T extends Compilable>(qb: T): T {\n       *   console.log(qb.compile())\n       *   return qb\n       * }\n       *\n       * await db.insertInto('person')\n       *   .values({ first_name: 'John', last_name: 'Doe', gender: 'male' })\n       *   .$call(log)\n       *   .execute()\n       * ```\n       */\n      $call(func) {\n        return func(this);\n      }\n      /**\n       * Call `func(this)` if `condition` is true.\n       *\n       * This method is especially handy with optional selects. Any `returning` or `returningAll`\n       * method calls add columns as optional fields to the output type when called inside\n       * the `func` callback. This is because we can't know if those selections were actually\n       * made before running the code.\n       *\n       * You can also call any other methods inside the callback.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import type { NewPerson } from 'type-editor' // imaginary module\n       *\n       * async function insertPerson(values: NewPerson, returnLastName: boolean) {\n       *   return await db\n       *     .insertInto('person')\n       *     .values(values)\n       *     .returning(['id', 'first_name'])\n       *     .$if(returnLastName, (qb) => qb.returning('last_name'))\n       *     .executeTakeFirstOrThrow()\n       * }\n       * ```\n       *\n       * Any selections added inside the `if` callback will be added as optional fields to the\n       * output type since we can't know if the selections were actually made before running\n       * the code. In the example above the return type of the `insertPerson` function is:\n       *\n       * ```ts\n       * Promise<{\n       *   id: number\n       *   first_name: string\n       *   last_name?: string\n       * }>\n       * ```\n       */\n      $if(condition, func) {\n        if (condition) {\n          return func(this);\n        }\n        return new _InsertQueryBuilder({\n          ...this.#props\n        });\n      }\n      /**\n       * Change the output type of the query.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `InsertQueryBuilder` with a new output type.\n       */\n      $castTo() {\n        return new _InsertQueryBuilder(this.#props);\n      }\n      /**\n       * Narrows (parts of) the output type of the query.\n       *\n       * Kysely tries to be as type-safe as possible, but in some cases we have to make\n       * compromises for better maintainability and compilation performance. At present,\n       * Kysely doesn't narrow the output type of the query based on {@link values} input\n       * when using {@link returning} or {@link returningAll}.\n       *\n       * This utility method is very useful for these situations, as it removes unncessary\n       * runtime assertion/guard code. Its input type is limited to the output type\n       * of the query, so you can't add a column that doesn't exist, or change a column's\n       * type to something that doesn't exist in its union type.\n       *\n       * ### Examples\n       *\n       * Turn this code:\n       *\n       * ```ts\n       * import type { Person } from 'type-editor' // imaginary module\n       *\n       * const person = await db.insertInto('person')\n       *   .values({\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *     gender: 'male',\n       *     nullable_column: 'hell yeah!'\n       *   })\n       *   .returningAll()\n       *   .executeTakeFirstOrThrow()\n       *\n       * if (isWithNoNullValue(person)) {\n       *   functionThatExpectsPersonWithNonNullValue(person)\n       * }\n       *\n       * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {\n       *   return person.nullable_column != null\n       * }\n       * ```\n       *\n       * Into this:\n       *\n       * ```ts\n       * import type { NotNull } from 'kysely'\n       *\n       * const person = await db.insertInto('person')\n       *   .values({\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *     gender: 'male',\n       *     nullable_column: 'hell yeah!'\n       *   })\n       *   .returningAll()\n       *   .$narrowType<{ nullable_column: NotNull }>()\n       *   .executeTakeFirstOrThrow()\n       *\n       * functionThatExpectsPersonWithNonNullValue(person)\n       * ```\n       */\n      $narrowType() {\n        return new _InsertQueryBuilder(this.#props);\n      }\n      /**\n       * Asserts that query's output row type equals the given type `T`.\n       *\n       * This method can be used to simplify excessively complex types to make TypeScript happy\n       * and much faster.\n       *\n       * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much\n       * for TypeScript and you get errors like this:\n       *\n       * ```\n       * error TS2589: Type instantiation is excessively deep and possibly infinite.\n       * ```\n       *\n       * In these case you can often use this method to help TypeScript a little bit. When you use this\n       * method to assert the output type of a query, Kysely can drop the complex output type that\n       * consists of multiple nested helper types and replace it with the simple asserted type.\n       *\n       * Using this method doesn't reduce type safety at all. You have to pass in a type that is\n       * structurally equal to the current type.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import type { NewPerson, NewPet, Species } from 'type-editor' // imaginary module\n       *\n       * async function insertPersonAndPet(person: NewPerson, pet: Omit<NewPet, 'owner_id'>) {\n       *   return await db\n       *     .with('new_person', (qb) => qb\n       *       .insertInto('person')\n       *       .values(person)\n       *       .returning('id')\n       *       .$assertType<{ id: number }>()\n       *     )\n       *     .with('new_pet', (qb) => qb\n       *       .insertInto('pet')\n       *       .values((eb) => ({\n       *         owner_id: eb.selectFrom('new_person').select('id'),\n       *         ...pet\n       *       }))\n       *       .returning(['name as pet_name', 'species'])\n       *       .$assertType<{ pet_name: string, species: Species }>()\n       *     )\n       *     .selectFrom(['new_person', 'new_pet'])\n       *     .selectAll()\n       *     .executeTakeFirstOrThrow()\n       * }\n       * ```\n       */\n      $assertType() {\n        return new _InsertQueryBuilder(this.#props);\n      }\n      /**\n       * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.\n       */\n      withPlugin(plugin) {\n        return new _InsertQueryBuilder({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      /**\n       * Executes the query and returns an array of rows.\n       *\n       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.\n       */\n      async execute() {\n        const compiledQuery = this.compile();\n        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);\n        const { adapter } = this.#props.executor;\n        const query = compiledQuery.query;\n        if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {\n          return result.rows;\n        }\n        return [\n          new InsertResult(\n            result.insertId,\n            // TODO: remove numUpdatedOrDeletedRows.\n            result.numAffectedRows ?? result.numUpdatedOrDeletedRows\n          )\n        ];\n      }\n      /**\n       * Executes the query and returns the first result or undefined if\n       * the query returned no result.\n       */\n      async executeTakeFirst() {\n        const [result] = await this.execute();\n        return result;\n      }\n      /**\n       * Executes the query and returns the first result or throws if\n       * the query returned no result.\n       *\n       * By default an instance of {@link NoResultError} is thrown, but you can\n       * provide a custom error class, or callback as the only argument to throw a different\n       * error.\n       */\n      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {\n        const result = await this.executeTakeFirst();\n        if (result === void 0) {\n          const error4 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());\n          throw error4;\n        }\n        return result;\n      }\n      async *stream(chunkSize = 100) {\n        const compiledQuery = this.compile();\n        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);\n        for await (const item of stream) {\n          yield* item.rows;\n        }\n      }\n      async explain(format2, options) {\n        const builder = new _InsertQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)\n        });\n        return await builder.execute();\n      }\n    };\n    preventAwait(InsertQueryBuilder, \"don't await InsertQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.\");\n    DeleteResult = class {\n      static {\n        __name(this, \"DeleteResult\");\n      }\n      numDeletedRows;\n      constructor(numDeletedRows) {\n        this.numDeletedRows = numDeletedRows;\n      }\n    };\n    LimitNode = freeze({\n      is(node) {\n        return node.kind === \"LimitNode\";\n      },\n      create(limit) {\n        return freeze({\n          kind: \"LimitNode\",\n          limit\n        });\n      }\n    });\n    DeleteQueryBuilder = class _DeleteQueryBuilder {\n      static {\n        __name(this, \"DeleteQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      where(...args) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      whereRef(lhs, op, rhs) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      clearWhere() {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)\n        });\n      }\n      /**\n       * Changes a `delete from` query into a `delete top from` query.\n       *\n       * `top` clause is only supported by some dialects like MS SQL Server.\n       *\n       * ### Examples\n       *\n       * Delete the first 5 rows:\n       *\n       * ```ts\n       * await db\n       *   .deleteFrom('person')\n       *   .top(5)\n       *   .where('age', '>', 18)\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * delete top(5) from \"person\" where \"age\" > @1\n       * ```\n       *\n       * Delete the first 50% of rows:\n       *\n       * ```ts\n       * await db\n       *   .deleteFrom('person')\n       *   .top(50, 'percent')\n       *   .where('age', '>', 18)\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * delete top(50) percent from \"person\" where \"age\" > @1\n       * ```\n       */\n      top(expression, modifiers) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))\n        });\n      }\n      using(tables) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))\n        });\n      }\n      innerJoin(...args) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"InnerJoin\", args))\n        });\n      }\n      leftJoin(...args) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"LeftJoin\", args))\n        });\n      }\n      rightJoin(...args) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"RightJoin\", args))\n        });\n      }\n      fullJoin(...args) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"FullJoin\", args))\n        });\n      }\n      returning(selection) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))\n        });\n      }\n      returningAll(table3) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      output(args) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))\n        });\n      }\n      outputAll(table3) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      /**\n       * Clears all `returning` clauses from the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.deleteFrom('pet')\n       *   .returningAll()\n       *   .where('name', '=', 'Max')\n       *   .clearReturning()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL(PostgreSQL):\n       *\n       * ```sql\n       * delete from \"pet\" where \"name\" = \"Max\"\n       * ```\n       */\n      clearReturning() {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)\n        });\n      }\n      /**\n       * Clears the `limit` clause from the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.deleteFrom('pet')\n       *   .returningAll()\n       *   .where('name', '=', 'Max')\n       *   .limit(5)\n       *   .clearLimit()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL(PostgreSQL):\n       *\n       * ```sql\n       * delete from \"pet\" where \"name\" = \"Max\" returning *\n       * ```\n       */\n      clearLimit() {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)\n        });\n      }\n      /**\n       * Clears the `order by` clause from the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.deleteFrom('pet')\n       *   .returningAll()\n       *   .where('name', '=', 'Max')\n       *   .orderBy('id')\n       *   .clearOrderBy()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL(PostgreSQL):\n       *\n       * ```sql\n       * delete from \"pet\" where \"name\" = \"Max\" returning *\n       * ```\n       */\n      clearOrderBy() {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: DeleteQueryNode.cloneWithoutOrderBy(this.#props.queryNode)\n        });\n      }\n      /**\n       * Adds an `order by` clause to the query.\n       *\n       * `orderBy` calls are additive. To order by multiple columns, call `orderBy`\n       * multiple times.\n       *\n       * The first argument is the expression to order by and the second is the\n       * order (`asc` or `desc`).\n       *\n       * An `order by` clause in a delete query is only supported by some dialects\n       * like MySQL.\n       *\n       * See {@link SelectQueryBuilder.orderBy} for more examples.\n       *\n       * ### Examples\n       *\n       * Delete 5 oldest items in a table:\n       *\n       * ```ts\n       * await db\n       *   .deleteFrom('pet')\n       *   .orderBy('created_at')\n       *   .limit(5)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * delete from `pet`\n       * order by `created_at`\n       * limit ?\n       * ```\n       */\n      orderBy(orderBy, direction) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: DeleteQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy([orderBy, direction]))\n        });\n      }\n      /**\n       * Adds a limit clause to the query.\n       *\n       * A limit clause in a delete query is only supported by some dialects\n       * like MySQL.\n       *\n       * ### Examples\n       *\n       * Delete 5 oldest items in a table:\n       *\n       * ```ts\n       * await db\n       *   .deleteFrom('pet')\n       *   .orderBy('created_at')\n       *   .limit(5)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * delete from `pet` order by `created_at` limit ?\n       * ```\n       */\n      limit(limit) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))\n        });\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.deleteFrom('person')\n       *   .where('first_name', '=', 'John')\n       *   .modifyEnd(sql`-- This is a comment`)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * delete from `person`\n       * where `first_name` = \"John\" -- This is a comment\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       *\n       * If you want to conditionally call a method on `this`, see\n       * the {@link $if} method.\n       *\n       * ### Examples\n       *\n       * The next example uses a helper function `log` to log a query:\n       *\n       * ```ts\n       * import type { Compilable } from 'kysely'\n       *\n       * function log<T extends Compilable>(qb: T): T {\n       *   console.log(qb.compile())\n       *   return qb\n       * }\n       *\n       * await db.deleteFrom('person')\n       *   .$call(log)\n       *   .execute()\n       * ```\n       */\n      $call(func) {\n        return func(this);\n      }\n      /**\n       * Call `func(this)` if `condition` is true.\n       *\n       * This method is especially handy with optional selects. Any `returning` or `returningAll`\n       * method calls add columns as optional fields to the output type when called inside\n       * the `func` callback. This is because we can't know if those selections were actually\n       * made before running the code.\n       *\n       * You can also call any other methods inside the callback.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * async function deletePerson(id: number, returnLastName: boolean) {\n       *   return await db\n       *     .deleteFrom('person')\n       *     .where('id', '=', id)\n       *     .returning(['id', 'first_name'])\n       *     .$if(returnLastName, (qb) => qb.returning('last_name'))\n       *     .executeTakeFirstOrThrow()\n       * }\n       * ```\n       *\n       * Any selections added inside the `if` callback will be added as optional fields to the\n       * output type since we can't know if the selections were actually made before running\n       * the code. In the example above the return type of the `deletePerson` function is:\n       *\n       * ```ts\n       * Promise<{\n       *   id: number\n       *   first_name: string\n       *   last_name?: string\n       * }>\n       * ```\n       */\n      $if(condition, func) {\n        if (condition) {\n          return func(this);\n        }\n        return new _DeleteQueryBuilder({\n          ...this.#props\n        });\n      }\n      /**\n       * Change the output type of the query.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `DeleteQueryBuilder` with a new output type.\n       */\n      $castTo() {\n        return new _DeleteQueryBuilder(this.#props);\n      }\n      /**\n       * Narrows (parts of) the output type of the query.\n       *\n       * Kysely tries to be as type-safe as possible, but in some cases we have to make\n       * compromises for better maintainability and compilation performance. At present,\n       * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.\n       *\n       * This utility method is very useful for these situations, as it removes unncessary\n       * runtime assertion/guard code. Its input type is limited to the output type\n       * of the query, so you can't add a column that doesn't exist, or change a column's\n       * type to something that doesn't exist in its union type.\n       *\n       * ### Examples\n       *\n       * Turn this code:\n       *\n       * ```ts\n       * import type { Person } from 'type-editor' // imaginary module\n       *\n       * const person = await db.deleteFrom('person')\n       *   .where('id', '=', 3)\n       *   .where('nullable_column', 'is not', null)\n       *   .returningAll()\n       *   .executeTakeFirstOrThrow()\n       *\n       * if (isWithNoNullValue(person)) {\n       *   functionThatExpectsPersonWithNonNullValue(person)\n       * }\n       *\n       * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {\n       *   return person.nullable_column != null\n       * }\n       * ```\n       *\n       * Into this:\n       *\n       * ```ts\n       * import type { NotNull } from 'kysely'\n       *\n       * const person = await db.deleteFrom('person')\n       *   .where('id', '=', 3)\n       *   .where('nullable_column', 'is not', null)\n       *   .returningAll()\n       *   .$narrowType<{ nullable_column: NotNull }>()\n       *   .executeTakeFirstOrThrow()\n       *\n       * functionThatExpectsPersonWithNonNullValue(person)\n       * ```\n       */\n      $narrowType() {\n        return new _DeleteQueryBuilder(this.#props);\n      }\n      /**\n       * Asserts that query's output row type equals the given type `T`.\n       *\n       * This method can be used to simplify excessively complex types to make TypeScript happy\n       * and much faster.\n       *\n       * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much\n       * for TypeScript and you get errors like this:\n       *\n       * ```\n       * error TS2589: Type instantiation is excessively deep and possibly infinite.\n       * ```\n       *\n       * In these case you can often use this method to help TypeScript a little bit. When you use this\n       * method to assert the output type of a query, Kysely can drop the complex output type that\n       * consists of multiple nested helper types and replace it with the simple asserted type.\n       *\n       * Using this method doesn't reduce type safety at all. You have to pass in a type that is\n       * structurally equal to the current type.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import type { Species } from 'type-editor' // imaginary module\n       *\n       * async function deletePersonAndPets(personId: number) {\n       *   return await db\n       *     .with('deleted_person', (qb) => qb\n       *        .deleteFrom('person')\n       *        .where('id', '=', personId)\n       *        .returning('first_name')\n       *        .$assertType<{ first_name: string }>()\n       *     )\n       *     .with('deleted_pets', (qb) => qb\n       *       .deleteFrom('pet')\n       *       .where('owner_id', '=', personId)\n       *       .returning(['name as pet_name', 'species'])\n       *       .$assertType<{ pet_name: string, species: Species }>()\n       *     )\n       *     .selectFrom(['deleted_person', 'deleted_pets'])\n       *     .selectAll()\n       *     .execute()\n       * }\n       * ```\n       */\n      $assertType() {\n        return new _DeleteQueryBuilder(this.#props);\n      }\n      /**\n       * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.\n       */\n      withPlugin(plugin) {\n        return new _DeleteQueryBuilder({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      /**\n       * Executes the query and returns an array of rows.\n       *\n       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.\n       */\n      async execute() {\n        const compiledQuery = this.compile();\n        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);\n        const { adapter } = this.#props.executor;\n        const query = compiledQuery.query;\n        if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {\n          return result.rows;\n        }\n        return [\n          new DeleteResult(\n            // TODO: remove numUpdatedOrDeletedRows.\n            result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0)\n          )\n        ];\n      }\n      /**\n       * Executes the query and returns the first result or undefined if\n       * the query returned no result.\n       */\n      async executeTakeFirst() {\n        const [result] = await this.execute();\n        return result;\n      }\n      /**\n       * Executes the query and returns the first result or throws if\n       * the query returned no result.\n       *\n       * By default an instance of {@link NoResultError} is thrown, but you can\n       * provide a custom error class, or callback as the only argument to throw a different\n       * error.\n       */\n      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {\n        const result = await this.executeTakeFirst();\n        if (result === void 0) {\n          const error4 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());\n          throw error4;\n        }\n        return result;\n      }\n      async *stream(chunkSize = 100) {\n        const compiledQuery = this.compile();\n        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);\n        for await (const item of stream) {\n          yield* item.rows;\n        }\n      }\n      async explain(format2, options) {\n        const builder = new _DeleteQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)\n        });\n        return await builder.execute();\n      }\n    };\n    preventAwait(DeleteQueryBuilder, \"don't await DeleteQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.\");\n    UpdateResult = class {\n      static {\n        __name(this, \"UpdateResult\");\n      }\n      /**\n       * The number of rows the update query updated (even if not changed).\n       */\n      numUpdatedRows;\n      /**\n       * The number of rows the update query changed.\n       *\n       * This is **optional** and only supported in dialects such as MySQL.\n       * You would probably use {@link numUpdatedRows} in most cases.\n       */\n      numChangedRows;\n      constructor(numUpdatedRows, numChangedRows) {\n        this.numUpdatedRows = numUpdatedRows;\n        this.numChangedRows = numChangedRows;\n      }\n    };\n    UpdateQueryBuilder = class _UpdateQueryBuilder {\n      static {\n        __name(this, \"UpdateQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      where(...args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      whereRef(lhs, op, rhs) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      clearWhere() {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)\n        });\n      }\n      /**\n       * Changes an `update` query into a `update top` query.\n       *\n       * `top` clause is only supported by some dialects like MS SQL Server.\n       *\n       * ### Examples\n       *\n       * Update the first row:\n       *\n       * ```ts\n       * await db.updateTable('person')\n       *   .top(1)\n       *   .set({ first_name: 'Foo' })\n       *   .where('age', '>', 18)\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * update top(1) \"person\" set \"first_name\" = @1 where \"age\" > @2\n       * ```\n       *\n       * Update the 50% first rows:\n       *\n       * ```ts\n       * await db.updateTable('person')\n       *   .top(50, 'percent')\n       *   .set({ first_name: 'Foo' })\n       *   .where('age', '>', 18)\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * update top(50) percent \"person\" set \"first_name\" = @1 where \"age\" > @2\n       * ```\n       */\n      top(expression, modifiers) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))\n        });\n      }\n      from(from) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))\n        });\n      }\n      innerJoin(...args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"InnerJoin\", args))\n        });\n      }\n      leftJoin(...args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"LeftJoin\", args))\n        });\n      }\n      rightJoin(...args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"RightJoin\", args))\n        });\n      }\n      fullJoin(...args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"FullJoin\", args))\n        });\n      }\n      /**\n       * Adds a limit clause to the update query for supported databases, such as MySQL.\n       *\n       * ### Examples\n       *\n       * Update the first 2 rows in the 'person' table:\n       *\n       * ```ts\n       * await db\n       *   .updateTable('person')\n       *   .set({ first_name: 'Foo' })\n       *   .limit(2)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * update `person` set `first_name` = ? limit ?\n       * ```\n       */\n      limit(limit) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))\n        });\n      }\n      set(...args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))\n        });\n      }\n      returning(selection) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))\n        });\n      }\n      returningAll(table3) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      output(args) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))\n        });\n      }\n      outputAll(table3) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.updateTable('person')\n       *   .set({ age: 39 })\n       *   .where('first_name', '=', 'John')\n       *   .modifyEnd(sql.raw('-- This is a comment'))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * update `person`\n       * set `age` = 39\n       * where `first_name` = \"John\" -- This is a comment\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())\n        });\n      }\n      /**\n       * Clears all `returning` clauses from the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * db.updateTable('person')\n       *   .returningAll()\n       *   .set({ age: 39 })\n       *   .where('first_name', '=', 'John')\n       *   .clearReturning()\n       * ```\n       *\n       * The generated SQL(PostgreSQL):\n       *\n       * ```sql\n       * update \"person\" set \"age\" = 39 where \"first_name\" = \"John\"\n       * ```\n       */\n      clearReturning() {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       *\n       * If you want to conditionally call a method on `this`, see\n       * the {@link $if} method.\n       *\n       * ### Examples\n       *\n       * The next example uses a helper function `log` to log a query:\n       *\n       * ```ts\n       * import type { Compilable } from 'kysely'\n       * import type { PersonUpdate } from 'type-editor' // imaginary module\n       *\n       * function log<T extends Compilable>(qb: T): T {\n       *   console.log(qb.compile())\n       *   return qb\n       * }\n       *\n       * const values = {\n       *   first_name: 'John',\n       * } satisfies PersonUpdate\n       *\n       * db.updateTable('person')\n       *   .set(values)\n       *   .$call(log)\n       *   .execute()\n       * ```\n       */\n      $call(func) {\n        return func(this);\n      }\n      /**\n       * Call `func(this)` if `condition` is true.\n       *\n       * This method is especially handy with optional selects. Any `returning` or `returningAll`\n       * method calls add columns as optional fields to the output type when called inside\n       * the `func` callback. This is because we can't know if those selections were actually\n       * made before running the code.\n       *\n       * You can also call any other methods inside the callback.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import type { PersonUpdate } from 'type-editor' // imaginary module\n       *\n       * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {\n       *   return await db\n       *     .updateTable('person')\n       *     .set(updates)\n       *     .where('id', '=', id)\n       *     .returning(['id', 'first_name'])\n       *     .$if(returnLastName, (qb) => qb.returning('last_name'))\n       *     .executeTakeFirstOrThrow()\n       * }\n       * ```\n       *\n       * Any selections added inside the `if` callback will be added as optional fields to the\n       * output type since we can't know if the selections were actually made before running\n       * the code. In the example above the return type of the `updatePerson` function is:\n       *\n       * ```ts\n       * Promise<{\n       *   id: number\n       *   first_name: string\n       *   last_name?: string\n       * }>\n       * ```\n       */\n      $if(condition, func) {\n        if (condition) {\n          return func(this);\n        }\n        return new _UpdateQueryBuilder({\n          ...this.#props\n        });\n      }\n      /**\n       * Change the output type of the query.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `UpdateQueryBuilder` with a new output type.\n       */\n      $castTo() {\n        return new _UpdateQueryBuilder(this.#props);\n      }\n      /**\n       * Narrows (parts of) the output type of the query.\n       *\n       * Kysely tries to be as type-safe as possible, but in some cases we have to make\n       * compromises for better maintainability and compilation performance. At present,\n       * Kysely doesn't narrow the output type of the query based on {@link set} input\n       * when using {@link where} and/or {@link returning} or {@link returningAll}.\n       *\n       * This utility method is very useful for these situations, as it removes unncessary\n       * runtime assertion/guard code. Its input type is limited to the output type\n       * of the query, so you can't add a column that doesn't exist, or change a column's\n       * type to something that doesn't exist in its union type.\n       *\n       * ### Examples\n       *\n       * Turn this code:\n       *\n       * ```ts\n       * import type { Person } from 'type-editor' // imaginary module\n       *\n       * const id = 1\n       * const now = new Date().toISOString()\n       *\n       * const person = await db.updateTable('person')\n       *   .set({ deleted_at: now })\n       *   .where('id', '=', id)\n       *   .where('nullable_column', 'is not', null)\n       *   .returningAll()\n       *   .executeTakeFirstOrThrow()\n       *\n       * if (isWithNoNullValue(person)) {\n       *   functionThatExpectsPersonWithNonNullValue(person)\n       * }\n       *\n       * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {\n       *   return person.nullable_column != null\n       * }\n       * ```\n       *\n       * Into this:\n       *\n       * ```ts\n       * import type { NotNull } from 'kysely'\n       *\n       * const id = 1\n       * const now = new Date().toISOString()\n       *\n       * const person = await db.updateTable('person')\n       *   .set({ deleted_at: now })\n       *   .where('id', '=', id)\n       *   .where('nullable_column', 'is not', null)\n       *   .returningAll()\n       *   .$narrowType<{ deleted_at: Date; nullable_column: NotNull }>()\n       *   .executeTakeFirstOrThrow()\n       *\n       * functionThatExpectsPersonWithNonNullValue(person)\n       * ```\n       */\n      $narrowType() {\n        return new _UpdateQueryBuilder(this.#props);\n      }\n      /**\n       * Asserts that query's output row type equals the given type `T`.\n       *\n       * This method can be used to simplify excessively complex types to make TypeScript happy\n       * and much faster.\n       *\n       * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much\n       * for TypeScript and you get errors like this:\n       *\n       * ```\n       * error TS2589: Type instantiation is excessively deep and possibly infinite.\n       * ```\n       *\n       * In these case you can often use this method to help TypeScript a little bit. When you use this\n       * method to assert the output type of a query, Kysely can drop the complex output type that\n       * consists of multiple nested helper types and replace it with the simple asserted type.\n       *\n       * Using this method doesn't reduce type safety at all. You have to pass in a type that is\n       * structurally equal to the current type.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import type { PersonUpdate, PetUpdate, Species } from 'type-editor' // imaginary module\n       *\n       * const person = {\n       *   id: 1,\n       *   gender: 'other',\n       * } satisfies PersonUpdate\n       *\n       * const pet = {\n       *   name: 'Fluffy',\n       * } satisfies PetUpdate\n       *\n       * const result = await db\n       *   .with('updated_person', (qb) => qb\n       *     .updateTable('person')\n       *     .set(person)\n       *     .where('id', '=', person.id)\n       *     .returning('first_name')\n       *     .$assertType<{ first_name: string }>()\n       *   )\n       *   .with('updated_pet', (qb) => qb\n       *     .updateTable('pet')\n       *     .set(pet)\n       *     .where('owner_id', '=', person.id)\n       *     .returning(['name as pet_name', 'species'])\n       *     .$assertType<{ pet_name: string, species: Species }>()\n       *   )\n       *   .selectFrom(['updated_person', 'updated_pet'])\n       *   .selectAll()\n       *   .executeTakeFirstOrThrow()\n       * ```\n       */\n      $assertType() {\n        return new _UpdateQueryBuilder(this.#props);\n      }\n      /**\n       * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.\n       */\n      withPlugin(plugin) {\n        return new _UpdateQueryBuilder({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      /**\n       * Executes the query and returns an array of rows.\n       *\n       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.\n       */\n      async execute() {\n        const compiledQuery = this.compile();\n        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);\n        const { adapter } = this.#props.executor;\n        const query = compiledQuery.query;\n        if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {\n          return result.rows;\n        }\n        return [\n          new UpdateResult(\n            // TODO: remove numUpdatedOrDeletedRows.\n            // TODO: https://github.com/kysely-org/kysely/pull/431#discussion_r1172330899\n            result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0),\n            result.numChangedRows\n          )\n        ];\n      }\n      /**\n       * Executes the query and returns the first result or undefined if\n       * the query returned no result.\n       */\n      async executeTakeFirst() {\n        const [result] = await this.execute();\n        return result;\n      }\n      /**\n       * Executes the query and returns the first result or throws if\n       * the query returned no result.\n       *\n       * By default an instance of {@link NoResultError} is thrown, but you can\n       * provide a custom error class, or callback as the only argument to throw a different\n       * error.\n       */\n      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {\n        const result = await this.executeTakeFirst();\n        if (result === void 0) {\n          const error4 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());\n          throw error4;\n        }\n        return result;\n      }\n      async *stream(chunkSize = 100) {\n        const compiledQuery = this.compile();\n        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);\n        for await (const item of stream) {\n          yield* item.rows;\n        }\n      }\n      async explain(format2, options) {\n        const builder = new _UpdateQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)\n        });\n        return await builder.execute();\n      }\n    };\n    preventAwait(UpdateQueryBuilder, \"don't await UpdateQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.\");\n    CommonTableExpressionNameNode = freeze({\n      is(node) {\n        return node.kind === \"CommonTableExpressionNameNode\";\n      },\n      create(tableName, columnNames) {\n        return freeze({\n          kind: \"CommonTableExpressionNameNode\",\n          table: TableNode.create(tableName),\n          columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : void 0\n        });\n      }\n    });\n    CommonTableExpressionNode = freeze({\n      is(node) {\n        return node.kind === \"CommonTableExpressionNode\";\n      },\n      create(name, expression) {\n        return freeze({\n          kind: \"CommonTableExpressionNode\",\n          name,\n          expression\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      }\n    });\n    CTEBuilder = class _CTEBuilder {\n      static {\n        __name(this, \"CTEBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Makes the common table expression materialized.\n       */\n      materialized() {\n        return new _CTEBuilder({\n          ...this.#props,\n          node: CommonTableExpressionNode.cloneWith(this.#props.node, {\n            materialized: true\n          })\n        });\n      }\n      /**\n       * Makes the common table expression not materialized.\n       */\n      notMaterialized() {\n        return new _CTEBuilder({\n          ...this.#props,\n          node: CommonTableExpressionNode.cloneWith(this.#props.node, {\n            materialized: false\n          })\n        });\n      }\n      toOperationNode() {\n        return this.#props.node;\n      }\n    };\n    preventAwait(CTEBuilder, \"don't await CTEBuilder instances. They are never executed directly and are always just a part of a query.\");\n    __name(parseCommonTableExpression, \"parseCommonTableExpression\");\n    __name(cteBuilderFactory, \"cteBuilderFactory\");\n    __name(parseCommonTableExpressionName, \"parseCommonTableExpressionName\");\n    WithNode = freeze({\n      is(node) {\n        return node.kind === \"WithNode\";\n      },\n      create(expression, params) {\n        return freeze({\n          kind: \"WithNode\",\n          expressions: freeze([expression]),\n          ...params\n        });\n      },\n      cloneWithExpression(withNode, expression) {\n        return freeze({\n          ...withNode,\n          expressions: freeze([...withNode.expressions, expression])\n        });\n      }\n    });\n    CHARS = [\n      \"A\",\n      \"B\",\n      \"C\",\n      \"D\",\n      \"E\",\n      \"F\",\n      \"G\",\n      \"H\",\n      \"I\",\n      \"J\",\n      \"K\",\n      \"L\",\n      \"M\",\n      \"N\",\n      \"O\",\n      \"P\",\n      \"Q\",\n      \"R\",\n      \"S\",\n      \"T\",\n      \"U\",\n      \"V\",\n      \"W\",\n      \"X\",\n      \"Y\",\n      \"Z\",\n      \"a\",\n      \"b\",\n      \"c\",\n      \"d\",\n      \"e\",\n      \"f\",\n      \"g\",\n      \"h\",\n      \"i\",\n      \"j\",\n      \"k\",\n      \"l\",\n      \"m\",\n      \"n\",\n      \"o\",\n      \"p\",\n      \"q\",\n      \"r\",\n      \"s\",\n      \"t\",\n      \"u\",\n      \"v\",\n      \"w\",\n      \"x\",\n      \"y\",\n      \"z\",\n      \"0\",\n      \"1\",\n      \"2\",\n      \"3\",\n      \"4\",\n      \"5\",\n      \"6\",\n      \"7\",\n      \"8\",\n      \"9\"\n    ];\n    __name(randomString, \"randomString\");\n    __name(randomChar, \"randomChar\");\n    __name(createQueryId, \"createQueryId\");\n    LazyQueryId = class {\n      static {\n        __name(this, \"LazyQueryId\");\n      }\n      #queryId;\n      get queryId() {\n        if (this.#queryId === void 0) {\n          this.#queryId = randomString(8);\n        }\n        return this.#queryId;\n      }\n    };\n    __name(requireAllProps, \"requireAllProps\");\n    OperationNodeTransformer = class {\n      static {\n        __name(this, \"OperationNodeTransformer\");\n      }\n      nodeStack = [];\n      #transformers = freeze({\n        AliasNode: this.transformAlias.bind(this),\n        ColumnNode: this.transformColumn.bind(this),\n        IdentifierNode: this.transformIdentifier.bind(this),\n        SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),\n        RawNode: this.transformRaw.bind(this),\n        ReferenceNode: this.transformReference.bind(this),\n        SelectQueryNode: this.transformSelectQuery.bind(this),\n        SelectionNode: this.transformSelection.bind(this),\n        TableNode: this.transformTable.bind(this),\n        FromNode: this.transformFrom.bind(this),\n        SelectAllNode: this.transformSelectAll.bind(this),\n        AndNode: this.transformAnd.bind(this),\n        OrNode: this.transformOr.bind(this),\n        ValueNode: this.transformValue.bind(this),\n        ValueListNode: this.transformValueList.bind(this),\n        PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),\n        ParensNode: this.transformParens.bind(this),\n        JoinNode: this.transformJoin.bind(this),\n        OperatorNode: this.transformOperator.bind(this),\n        WhereNode: this.transformWhere.bind(this),\n        InsertQueryNode: this.transformInsertQuery.bind(this),\n        DeleteQueryNode: this.transformDeleteQuery.bind(this),\n        ReturningNode: this.transformReturning.bind(this),\n        CreateTableNode: this.transformCreateTable.bind(this),\n        AddColumnNode: this.transformAddColumn.bind(this),\n        ColumnDefinitionNode: this.transformColumnDefinition.bind(this),\n        DropTableNode: this.transformDropTable.bind(this),\n        DataTypeNode: this.transformDataType.bind(this),\n        OrderByNode: this.transformOrderBy.bind(this),\n        OrderByItemNode: this.transformOrderByItem.bind(this),\n        GroupByNode: this.transformGroupBy.bind(this),\n        GroupByItemNode: this.transformGroupByItem.bind(this),\n        UpdateQueryNode: this.transformUpdateQuery.bind(this),\n        ColumnUpdateNode: this.transformColumnUpdate.bind(this),\n        LimitNode: this.transformLimit.bind(this),\n        OffsetNode: this.transformOffset.bind(this),\n        OnConflictNode: this.transformOnConflict.bind(this),\n        OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),\n        CreateIndexNode: this.transformCreateIndex.bind(this),\n        DropIndexNode: this.transformDropIndex.bind(this),\n        ListNode: this.transformList.bind(this),\n        PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),\n        UniqueConstraintNode: this.transformUniqueConstraint.bind(this),\n        ReferencesNode: this.transformReferences.bind(this),\n        CheckConstraintNode: this.transformCheckConstraint.bind(this),\n        WithNode: this.transformWith.bind(this),\n        CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),\n        CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),\n        HavingNode: this.transformHaving.bind(this),\n        CreateSchemaNode: this.transformCreateSchema.bind(this),\n        DropSchemaNode: this.transformDropSchema.bind(this),\n        AlterTableNode: this.transformAlterTable.bind(this),\n        DropColumnNode: this.transformDropColumn.bind(this),\n        RenameColumnNode: this.transformRenameColumn.bind(this),\n        AlterColumnNode: this.transformAlterColumn.bind(this),\n        ModifyColumnNode: this.transformModifyColumn.bind(this),\n        AddConstraintNode: this.transformAddConstraint.bind(this),\n        DropConstraintNode: this.transformDropConstraint.bind(this),\n        ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),\n        CreateViewNode: this.transformCreateView.bind(this),\n        DropViewNode: this.transformDropView.bind(this),\n        GeneratedNode: this.transformGenerated.bind(this),\n        DefaultValueNode: this.transformDefaultValue.bind(this),\n        OnNode: this.transformOn.bind(this),\n        ValuesNode: this.transformValues.bind(this),\n        SelectModifierNode: this.transformSelectModifier.bind(this),\n        CreateTypeNode: this.transformCreateType.bind(this),\n        DropTypeNode: this.transformDropType.bind(this),\n        ExplainNode: this.transformExplain.bind(this),\n        DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),\n        AggregateFunctionNode: this.transformAggregateFunction.bind(this),\n        OverNode: this.transformOver.bind(this),\n        PartitionByNode: this.transformPartitionBy.bind(this),\n        PartitionByItemNode: this.transformPartitionByItem.bind(this),\n        SetOperationNode: this.transformSetOperation.bind(this),\n        BinaryOperationNode: this.transformBinaryOperation.bind(this),\n        UnaryOperationNode: this.transformUnaryOperation.bind(this),\n        UsingNode: this.transformUsing.bind(this),\n        FunctionNode: this.transformFunction.bind(this),\n        CaseNode: this.transformCase.bind(this),\n        WhenNode: this.transformWhen.bind(this),\n        JSONReferenceNode: this.transformJSONReference.bind(this),\n        JSONPathNode: this.transformJSONPath.bind(this),\n        JSONPathLegNode: this.transformJSONPathLeg.bind(this),\n        JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),\n        TupleNode: this.transformTuple.bind(this),\n        MergeQueryNode: this.transformMergeQuery.bind(this),\n        MatchedNode: this.transformMatched.bind(this),\n        AddIndexNode: this.transformAddIndex.bind(this),\n        CastNode: this.transformCast.bind(this),\n        FetchNode: this.transformFetch.bind(this),\n        TopNode: this.transformTop.bind(this),\n        OutputNode: this.transformOutput.bind(this)\n      });\n      transformNode(node) {\n        if (!node) {\n          return node;\n        }\n        this.nodeStack.push(node);\n        const out = this.transformNodeImpl(node);\n        this.nodeStack.pop();\n        return freeze(out);\n      }\n      transformNodeImpl(node) {\n        return this.#transformers[node.kind](node);\n      }\n      transformNodeList(list) {\n        if (!list) {\n          return list;\n        }\n        return freeze(list.map((node) => this.transformNode(node)));\n      }\n      transformSelectQuery(node) {\n        return requireAllProps({\n          kind: \"SelectQueryNode\",\n          from: this.transformNode(node.from),\n          selections: this.transformNodeList(node.selections),\n          distinctOn: this.transformNodeList(node.distinctOn),\n          joins: this.transformNodeList(node.joins),\n          groupBy: this.transformNode(node.groupBy),\n          orderBy: this.transformNode(node.orderBy),\n          where: this.transformNode(node.where),\n          frontModifiers: this.transformNodeList(node.frontModifiers),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          limit: this.transformNode(node.limit),\n          offset: this.transformNode(node.offset),\n          with: this.transformNode(node.with),\n          having: this.transformNode(node.having),\n          explain: this.transformNode(node.explain),\n          setOperations: this.transformNodeList(node.setOperations),\n          fetch: this.transformNode(node.fetch),\n          top: this.transformNode(node.top)\n        });\n      }\n      transformSelection(node) {\n        return requireAllProps({\n          kind: \"SelectionNode\",\n          selection: this.transformNode(node.selection)\n        });\n      }\n      transformColumn(node) {\n        return requireAllProps({\n          kind: \"ColumnNode\",\n          column: this.transformNode(node.column)\n        });\n      }\n      transformAlias(node) {\n        return requireAllProps({\n          kind: \"AliasNode\",\n          node: this.transformNode(node.node),\n          alias: this.transformNode(node.alias)\n        });\n      }\n      transformTable(node) {\n        return requireAllProps({\n          kind: \"TableNode\",\n          table: this.transformNode(node.table)\n        });\n      }\n      transformFrom(node) {\n        return requireAllProps({\n          kind: \"FromNode\",\n          froms: this.transformNodeList(node.froms)\n        });\n      }\n      transformReference(node) {\n        return requireAllProps({\n          kind: \"ReferenceNode\",\n          column: this.transformNode(node.column),\n          table: this.transformNode(node.table)\n        });\n      }\n      transformAnd(node) {\n        return requireAllProps({\n          kind: \"AndNode\",\n          left: this.transformNode(node.left),\n          right: this.transformNode(node.right)\n        });\n      }\n      transformOr(node) {\n        return requireAllProps({\n          kind: \"OrNode\",\n          left: this.transformNode(node.left),\n          right: this.transformNode(node.right)\n        });\n      }\n      transformValueList(node) {\n        return requireAllProps({\n          kind: \"ValueListNode\",\n          values: this.transformNodeList(node.values)\n        });\n      }\n      transformParens(node) {\n        return requireAllProps({\n          kind: \"ParensNode\",\n          node: this.transformNode(node.node)\n        });\n      }\n      transformJoin(node) {\n        return requireAllProps({\n          kind: \"JoinNode\",\n          joinType: node.joinType,\n          table: this.transformNode(node.table),\n          on: this.transformNode(node.on)\n        });\n      }\n      transformRaw(node) {\n        return requireAllProps({\n          kind: \"RawNode\",\n          sqlFragments: freeze([...node.sqlFragments]),\n          parameters: this.transformNodeList(node.parameters)\n        });\n      }\n      transformWhere(node) {\n        return requireAllProps({\n          kind: \"WhereNode\",\n          where: this.transformNode(node.where)\n        });\n      }\n      transformInsertQuery(node) {\n        return requireAllProps({\n          kind: \"InsertQueryNode\",\n          into: this.transformNode(node.into),\n          columns: this.transformNodeList(node.columns),\n          values: this.transformNode(node.values),\n          returning: this.transformNode(node.returning),\n          onConflict: this.transformNode(node.onConflict),\n          onDuplicateKey: this.transformNode(node.onDuplicateKey),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          with: this.transformNode(node.with),\n          ignore: node.ignore,\n          replace: node.replace,\n          explain: this.transformNode(node.explain),\n          defaultValues: node.defaultValues,\n          top: this.transformNode(node.top),\n          output: this.transformNode(node.output)\n        });\n      }\n      transformValues(node) {\n        return requireAllProps({\n          kind: \"ValuesNode\",\n          values: this.transformNodeList(node.values)\n        });\n      }\n      transformDeleteQuery(node) {\n        return requireAllProps({\n          kind: \"DeleteQueryNode\",\n          from: this.transformNode(node.from),\n          using: this.transformNode(node.using),\n          joins: this.transformNodeList(node.joins),\n          where: this.transformNode(node.where),\n          returning: this.transformNode(node.returning),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          with: this.transformNode(node.with),\n          orderBy: this.transformNode(node.orderBy),\n          limit: this.transformNode(node.limit),\n          explain: this.transformNode(node.explain),\n          top: this.transformNode(node.top),\n          output: this.transformNode(node.output)\n        });\n      }\n      transformReturning(node) {\n        return requireAllProps({\n          kind: \"ReturningNode\",\n          selections: this.transformNodeList(node.selections)\n        });\n      }\n      transformCreateTable(node) {\n        return requireAllProps({\n          kind: \"CreateTableNode\",\n          table: this.transformNode(node.table),\n          columns: this.transformNodeList(node.columns),\n          constraints: this.transformNodeList(node.constraints),\n          temporary: node.temporary,\n          ifNotExists: node.ifNotExists,\n          onCommit: node.onCommit,\n          frontModifiers: this.transformNodeList(node.frontModifiers),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          selectQuery: this.transformNode(node.selectQuery)\n        });\n      }\n      transformColumnDefinition(node) {\n        return requireAllProps({\n          kind: \"ColumnDefinitionNode\",\n          column: this.transformNode(node.column),\n          dataType: this.transformNode(node.dataType),\n          references: this.transformNode(node.references),\n          primaryKey: node.primaryKey,\n          autoIncrement: node.autoIncrement,\n          unique: node.unique,\n          notNull: node.notNull,\n          unsigned: node.unsigned,\n          defaultTo: this.transformNode(node.defaultTo),\n          check: this.transformNode(node.check),\n          generated: this.transformNode(node.generated),\n          frontModifiers: this.transformNodeList(node.frontModifiers),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          nullsNotDistinct: node.nullsNotDistinct,\n          identity: node.identity,\n          ifNotExists: node.ifNotExists\n        });\n      }\n      transformAddColumn(node) {\n        return requireAllProps({\n          kind: \"AddColumnNode\",\n          column: this.transformNode(node.column)\n        });\n      }\n      transformDropTable(node) {\n        return requireAllProps({\n          kind: \"DropTableNode\",\n          table: this.transformNode(node.table),\n          ifExists: node.ifExists,\n          cascade: node.cascade\n        });\n      }\n      transformOrderBy(node) {\n        return requireAllProps({\n          kind: \"OrderByNode\",\n          items: this.transformNodeList(node.items)\n        });\n      }\n      transformOrderByItem(node) {\n        return requireAllProps({\n          kind: \"OrderByItemNode\",\n          orderBy: this.transformNode(node.orderBy),\n          direction: this.transformNode(node.direction)\n        });\n      }\n      transformGroupBy(node) {\n        return requireAllProps({\n          kind: \"GroupByNode\",\n          items: this.transformNodeList(node.items)\n        });\n      }\n      transformGroupByItem(node) {\n        return requireAllProps({\n          kind: \"GroupByItemNode\",\n          groupBy: this.transformNode(node.groupBy)\n        });\n      }\n      transformUpdateQuery(node) {\n        return requireAllProps({\n          kind: \"UpdateQueryNode\",\n          table: this.transformNode(node.table),\n          from: this.transformNode(node.from),\n          joins: this.transformNodeList(node.joins),\n          where: this.transformNode(node.where),\n          updates: this.transformNodeList(node.updates),\n          returning: this.transformNode(node.returning),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          with: this.transformNode(node.with),\n          explain: this.transformNode(node.explain),\n          limit: this.transformNode(node.limit),\n          top: this.transformNode(node.top),\n          output: this.transformNode(node.output)\n        });\n      }\n      transformColumnUpdate(node) {\n        return requireAllProps({\n          kind: \"ColumnUpdateNode\",\n          column: this.transformNode(node.column),\n          value: this.transformNode(node.value)\n        });\n      }\n      transformLimit(node) {\n        return requireAllProps({\n          kind: \"LimitNode\",\n          limit: this.transformNode(node.limit)\n        });\n      }\n      transformOffset(node) {\n        return requireAllProps({\n          kind: \"OffsetNode\",\n          offset: this.transformNode(node.offset)\n        });\n      }\n      transformOnConflict(node) {\n        return requireAllProps({\n          kind: \"OnConflictNode\",\n          columns: this.transformNodeList(node.columns),\n          constraint: this.transformNode(node.constraint),\n          indexExpression: this.transformNode(node.indexExpression),\n          indexWhere: this.transformNode(node.indexWhere),\n          updates: this.transformNodeList(node.updates),\n          updateWhere: this.transformNode(node.updateWhere),\n          doNothing: node.doNothing\n        });\n      }\n      transformOnDuplicateKey(node) {\n        return requireAllProps({\n          kind: \"OnDuplicateKeyNode\",\n          updates: this.transformNodeList(node.updates)\n        });\n      }\n      transformCreateIndex(node) {\n        return requireAllProps({\n          kind: \"CreateIndexNode\",\n          name: this.transformNode(node.name),\n          table: this.transformNode(node.table),\n          columns: this.transformNodeList(node.columns),\n          unique: node.unique,\n          using: this.transformNode(node.using),\n          ifNotExists: node.ifNotExists,\n          where: this.transformNode(node.where),\n          nullsNotDistinct: node.nullsNotDistinct\n        });\n      }\n      transformList(node) {\n        return requireAllProps({\n          kind: \"ListNode\",\n          items: this.transformNodeList(node.items)\n        });\n      }\n      transformDropIndex(node) {\n        return requireAllProps({\n          kind: \"DropIndexNode\",\n          name: this.transformNode(node.name),\n          table: this.transformNode(node.table),\n          ifExists: node.ifExists,\n          cascade: node.cascade\n        });\n      }\n      transformPrimaryKeyConstraint(node) {\n        return requireAllProps({\n          kind: \"PrimaryKeyConstraintNode\",\n          columns: this.transformNodeList(node.columns),\n          name: this.transformNode(node.name)\n        });\n      }\n      transformUniqueConstraint(node) {\n        return requireAllProps({\n          kind: \"UniqueConstraintNode\",\n          columns: this.transformNodeList(node.columns),\n          name: this.transformNode(node.name),\n          nullsNotDistinct: node.nullsNotDistinct\n        });\n      }\n      transformForeignKeyConstraint(node) {\n        return requireAllProps({\n          kind: \"ForeignKeyConstraintNode\",\n          columns: this.transformNodeList(node.columns),\n          references: this.transformNode(node.references),\n          name: this.transformNode(node.name),\n          onDelete: node.onDelete,\n          onUpdate: node.onUpdate\n        });\n      }\n      transformSetOperation(node) {\n        return requireAllProps({\n          kind: \"SetOperationNode\",\n          operator: node.operator,\n          expression: this.transformNode(node.expression),\n          all: node.all\n        });\n      }\n      transformReferences(node) {\n        return requireAllProps({\n          kind: \"ReferencesNode\",\n          table: this.transformNode(node.table),\n          columns: this.transformNodeList(node.columns),\n          onDelete: node.onDelete,\n          onUpdate: node.onUpdate\n        });\n      }\n      transformCheckConstraint(node) {\n        return requireAllProps({\n          kind: \"CheckConstraintNode\",\n          expression: this.transformNode(node.expression),\n          name: this.transformNode(node.name)\n        });\n      }\n      transformWith(node) {\n        return requireAllProps({\n          kind: \"WithNode\",\n          expressions: this.transformNodeList(node.expressions),\n          recursive: node.recursive\n        });\n      }\n      transformCommonTableExpression(node) {\n        return requireAllProps({\n          kind: \"CommonTableExpressionNode\",\n          name: this.transformNode(node.name),\n          materialized: node.materialized,\n          expression: this.transformNode(node.expression)\n        });\n      }\n      transformCommonTableExpressionName(node) {\n        return requireAllProps({\n          kind: \"CommonTableExpressionNameNode\",\n          table: this.transformNode(node.table),\n          columns: this.transformNodeList(node.columns)\n        });\n      }\n      transformHaving(node) {\n        return requireAllProps({\n          kind: \"HavingNode\",\n          having: this.transformNode(node.having)\n        });\n      }\n      transformCreateSchema(node) {\n        return requireAllProps({\n          kind: \"CreateSchemaNode\",\n          schema: this.transformNode(node.schema),\n          ifNotExists: node.ifNotExists\n        });\n      }\n      transformDropSchema(node) {\n        return requireAllProps({\n          kind: \"DropSchemaNode\",\n          schema: this.transformNode(node.schema),\n          ifExists: node.ifExists,\n          cascade: node.cascade\n        });\n      }\n      transformAlterTable(node) {\n        return requireAllProps({\n          kind: \"AlterTableNode\",\n          table: this.transformNode(node.table),\n          renameTo: this.transformNode(node.renameTo),\n          setSchema: this.transformNode(node.setSchema),\n          columnAlterations: this.transformNodeList(node.columnAlterations),\n          addConstraint: this.transformNode(node.addConstraint),\n          dropConstraint: this.transformNode(node.dropConstraint),\n          addIndex: this.transformNode(node.addIndex),\n          dropIndex: this.transformNode(node.dropIndex)\n        });\n      }\n      transformDropColumn(node) {\n        return requireAllProps({\n          kind: \"DropColumnNode\",\n          column: this.transformNode(node.column)\n        });\n      }\n      transformRenameColumn(node) {\n        return requireAllProps({\n          kind: \"RenameColumnNode\",\n          column: this.transformNode(node.column),\n          renameTo: this.transformNode(node.renameTo)\n        });\n      }\n      transformAlterColumn(node) {\n        return requireAllProps({\n          kind: \"AlterColumnNode\",\n          column: this.transformNode(node.column),\n          dataType: this.transformNode(node.dataType),\n          dataTypeExpression: this.transformNode(node.dataTypeExpression),\n          setDefault: this.transformNode(node.setDefault),\n          dropDefault: node.dropDefault,\n          setNotNull: node.setNotNull,\n          dropNotNull: node.dropNotNull\n        });\n      }\n      transformModifyColumn(node) {\n        return requireAllProps({\n          kind: \"ModifyColumnNode\",\n          column: this.transformNode(node.column)\n        });\n      }\n      transformAddConstraint(node) {\n        return requireAllProps({\n          kind: \"AddConstraintNode\",\n          constraint: this.transformNode(node.constraint)\n        });\n      }\n      transformDropConstraint(node) {\n        return requireAllProps({\n          kind: \"DropConstraintNode\",\n          constraintName: this.transformNode(node.constraintName),\n          ifExists: node.ifExists,\n          modifier: node.modifier\n        });\n      }\n      transformCreateView(node) {\n        return requireAllProps({\n          kind: \"CreateViewNode\",\n          name: this.transformNode(node.name),\n          temporary: node.temporary,\n          orReplace: node.orReplace,\n          ifNotExists: node.ifNotExists,\n          materialized: node.materialized,\n          columns: this.transformNodeList(node.columns),\n          as: this.transformNode(node.as)\n        });\n      }\n      transformDropView(node) {\n        return requireAllProps({\n          kind: \"DropViewNode\",\n          name: this.transformNode(node.name),\n          ifExists: node.ifExists,\n          materialized: node.materialized,\n          cascade: node.cascade\n        });\n      }\n      transformGenerated(node) {\n        return requireAllProps({\n          kind: \"GeneratedNode\",\n          byDefault: node.byDefault,\n          always: node.always,\n          identity: node.identity,\n          stored: node.stored,\n          expression: this.transformNode(node.expression)\n        });\n      }\n      transformDefaultValue(node) {\n        return requireAllProps({\n          kind: \"DefaultValueNode\",\n          defaultValue: this.transformNode(node.defaultValue)\n        });\n      }\n      transformOn(node) {\n        return requireAllProps({\n          kind: \"OnNode\",\n          on: this.transformNode(node.on)\n        });\n      }\n      transformSelectModifier(node) {\n        return requireAllProps({\n          kind: \"SelectModifierNode\",\n          modifier: node.modifier,\n          rawModifier: this.transformNode(node.rawModifier),\n          of: this.transformNodeList(node.of)\n        });\n      }\n      transformCreateType(node) {\n        return requireAllProps({\n          kind: \"CreateTypeNode\",\n          name: this.transformNode(node.name),\n          enum: this.transformNode(node.enum)\n        });\n      }\n      transformDropType(node) {\n        return requireAllProps({\n          kind: \"DropTypeNode\",\n          name: this.transformNode(node.name),\n          ifExists: node.ifExists\n        });\n      }\n      transformExplain(node) {\n        return requireAllProps({\n          kind: \"ExplainNode\",\n          format: node.format,\n          options: this.transformNode(node.options)\n        });\n      }\n      transformSchemableIdentifier(node) {\n        return requireAllProps({\n          kind: \"SchemableIdentifierNode\",\n          schema: this.transformNode(node.schema),\n          identifier: this.transformNode(node.identifier)\n        });\n      }\n      transformAggregateFunction(node) {\n        return requireAllProps({\n          kind: \"AggregateFunctionNode\",\n          aggregated: this.transformNodeList(node.aggregated),\n          distinct: node.distinct,\n          orderBy: this.transformNode(node.orderBy),\n          filter: this.transformNode(node.filter),\n          func: node.func,\n          over: this.transformNode(node.over)\n        });\n      }\n      transformOver(node) {\n        return requireAllProps({\n          kind: \"OverNode\",\n          orderBy: this.transformNode(node.orderBy),\n          partitionBy: this.transformNode(node.partitionBy)\n        });\n      }\n      transformPartitionBy(node) {\n        return requireAllProps({\n          kind: \"PartitionByNode\",\n          items: this.transformNodeList(node.items)\n        });\n      }\n      transformPartitionByItem(node) {\n        return requireAllProps({\n          kind: \"PartitionByItemNode\",\n          partitionBy: this.transformNode(node.partitionBy)\n        });\n      }\n      transformBinaryOperation(node) {\n        return requireAllProps({\n          kind: \"BinaryOperationNode\",\n          leftOperand: this.transformNode(node.leftOperand),\n          operator: this.transformNode(node.operator),\n          rightOperand: this.transformNode(node.rightOperand)\n        });\n      }\n      transformUnaryOperation(node) {\n        return requireAllProps({\n          kind: \"UnaryOperationNode\",\n          operator: this.transformNode(node.operator),\n          operand: this.transformNode(node.operand)\n        });\n      }\n      transformUsing(node) {\n        return requireAllProps({\n          kind: \"UsingNode\",\n          tables: this.transformNodeList(node.tables)\n        });\n      }\n      transformFunction(node) {\n        return requireAllProps({\n          kind: \"FunctionNode\",\n          func: node.func,\n          arguments: this.transformNodeList(node.arguments)\n        });\n      }\n      transformCase(node) {\n        return requireAllProps({\n          kind: \"CaseNode\",\n          value: this.transformNode(node.value),\n          when: this.transformNodeList(node.when),\n          else: this.transformNode(node.else),\n          isStatement: node.isStatement\n        });\n      }\n      transformWhen(node) {\n        return requireAllProps({\n          kind: \"WhenNode\",\n          condition: this.transformNode(node.condition),\n          result: this.transformNode(node.result)\n        });\n      }\n      transformJSONReference(node) {\n        return requireAllProps({\n          kind: \"JSONReferenceNode\",\n          reference: this.transformNode(node.reference),\n          traversal: this.transformNode(node.traversal)\n        });\n      }\n      transformJSONPath(node) {\n        return requireAllProps({\n          kind: \"JSONPathNode\",\n          inOperator: this.transformNode(node.inOperator),\n          pathLegs: this.transformNodeList(node.pathLegs)\n        });\n      }\n      transformJSONPathLeg(node) {\n        return requireAllProps({\n          kind: \"JSONPathLegNode\",\n          type: node.type,\n          value: node.value\n        });\n      }\n      transformJSONOperatorChain(node) {\n        return requireAllProps({\n          kind: \"JSONOperatorChainNode\",\n          operator: this.transformNode(node.operator),\n          values: this.transformNodeList(node.values)\n        });\n      }\n      transformTuple(node) {\n        return requireAllProps({\n          kind: \"TupleNode\",\n          values: this.transformNodeList(node.values)\n        });\n      }\n      transformMergeQuery(node) {\n        return requireAllProps({\n          kind: \"MergeQueryNode\",\n          into: this.transformNode(node.into),\n          using: this.transformNode(node.using),\n          whens: this.transformNodeList(node.whens),\n          with: this.transformNode(node.with),\n          top: this.transformNode(node.top),\n          endModifiers: this.transformNodeList(node.endModifiers),\n          output: this.transformNode(node.output)\n        });\n      }\n      transformMatched(node) {\n        return requireAllProps({\n          kind: \"MatchedNode\",\n          not: node.not,\n          bySource: node.bySource\n        });\n      }\n      transformAddIndex(node) {\n        return requireAllProps({\n          kind: \"AddIndexNode\",\n          name: this.transformNode(node.name),\n          columns: this.transformNodeList(node.columns),\n          unique: node.unique,\n          using: this.transformNode(node.using),\n          ifNotExists: node.ifNotExists\n        });\n      }\n      transformCast(node) {\n        return requireAllProps({\n          kind: \"CastNode\",\n          expression: this.transformNode(node.expression),\n          dataType: this.transformNode(node.dataType)\n        });\n      }\n      transformFetch(node) {\n        return requireAllProps({\n          kind: \"FetchNode\",\n          rowCount: this.transformNode(node.rowCount),\n          modifier: node.modifier\n        });\n      }\n      transformTop(node) {\n        return requireAllProps({\n          kind: \"TopNode\",\n          expression: node.expression,\n          modifiers: node.modifiers\n        });\n      }\n      transformOutput(node) {\n        return requireAllProps({\n          kind: \"OutputNode\",\n          selections: this.transformNodeList(node.selections)\n        });\n      }\n      transformDataType(node) {\n        return node;\n      }\n      transformSelectAll(node) {\n        return node;\n      }\n      transformIdentifier(node) {\n        return node;\n      }\n      transformValue(node) {\n        return node;\n      }\n      transformPrimitiveValueList(node) {\n        return node;\n      }\n      transformOperator(node) {\n        return node;\n      }\n      transformDefaultInsertValue(node) {\n        return node;\n      }\n    };\n    ROOT_OPERATION_NODES = freeze({\n      AlterTableNode: true,\n      CreateIndexNode: true,\n      CreateSchemaNode: true,\n      CreateTableNode: true,\n      CreateTypeNode: true,\n      CreateViewNode: true,\n      DeleteQueryNode: true,\n      DropIndexNode: true,\n      DropSchemaNode: true,\n      DropTableNode: true,\n      DropTypeNode: true,\n      DropViewNode: true,\n      InsertQueryNode: true,\n      RawNode: true,\n      SelectQueryNode: true,\n      UpdateQueryNode: true,\n      MergeQueryNode: true\n    });\n    SCHEMALESS_FUNCTIONS = {\n      json_agg: true,\n      to_json: true\n    };\n    WithSchemaTransformer = class extends OperationNodeTransformer {\n      static {\n        __name(this, \"WithSchemaTransformer\");\n      }\n      #schema;\n      #schemableIds = /* @__PURE__ */ new Set();\n      #ctes = /* @__PURE__ */ new Set();\n      constructor(schema2) {\n        super();\n        this.#schema = schema2;\n      }\n      transformNodeImpl(node) {\n        if (!this.#isRootOperationNode(node)) {\n          return super.transformNodeImpl(node);\n        }\n        const ctes = this.#collectCTEs(node);\n        for (const cte of ctes) {\n          this.#ctes.add(cte);\n        }\n        const tables = this.#collectSchemableIds(node);\n        for (const table3 of tables) {\n          this.#schemableIds.add(table3);\n        }\n        const transformed = super.transformNodeImpl(node);\n        for (const table3 of tables) {\n          this.#schemableIds.delete(table3);\n        }\n        for (const cte of ctes) {\n          this.#ctes.delete(cte);\n        }\n        return transformed;\n      }\n      transformSchemableIdentifier(node) {\n        const transformed = super.transformSchemableIdentifier(node);\n        if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {\n          return transformed;\n        }\n        return {\n          ...transformed,\n          schema: IdentifierNode.create(this.#schema)\n        };\n      }\n      transformReferences(node) {\n        const transformed = super.transformReferences(node);\n        if (transformed.table.table.schema) {\n          return transformed;\n        }\n        return {\n          ...transformed,\n          table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)\n        };\n      }\n      transformAggregateFunction(node) {\n        return {\n          ...super.transformAggregateFunction({ ...node, aggregated: [] }),\n          aggregated: this.#transformTableArgsWithoutSchemas(node, \"aggregated\")\n        };\n      }\n      transformFunction(node) {\n        return {\n          ...super.transformFunction({ ...node, arguments: [] }),\n          arguments: this.#transformTableArgsWithoutSchemas(node, \"arguments\")\n        };\n      }\n      #transformTableArgsWithoutSchemas(node, argsKey) {\n        return SCHEMALESS_FUNCTIONS[node.func] ? node[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg) : {\n          ...arg,\n          table: this.transformIdentifier(arg.table.identifier)\n        }) : this.transformNodeList(node[argsKey]);\n      }\n      #isRootOperationNode(node) {\n        return node.kind in ROOT_OPERATION_NODES;\n      }\n      #collectSchemableIds(node) {\n        const schemableIds = /* @__PURE__ */ new Set();\n        if (\"name\" in node && node.name && SchemableIdentifierNode.is(node.name)) {\n          this.#collectSchemableId(node.name, schemableIds);\n        }\n        if (\"from\" in node && node.from) {\n          for (const from of node.from.froms) {\n            this.#collectSchemableIdsFromTableExpr(from, schemableIds);\n          }\n        }\n        if (\"into\" in node && node.into) {\n          this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);\n        }\n        if (\"table\" in node && node.table) {\n          this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);\n        }\n        if (\"joins\" in node && node.joins) {\n          for (const join of node.joins) {\n            this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);\n          }\n        }\n        if (\"using\" in node && node.using) {\n          this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);\n        }\n        return schemableIds;\n      }\n      #collectCTEs(node) {\n        const ctes = /* @__PURE__ */ new Set();\n        if (\"with\" in node && node.with) {\n          this.#collectCTEIds(node.with, ctes);\n        }\n        return ctes;\n      }\n      #collectSchemableIdsFromTableExpr(node, schemableIds) {\n        const table3 = TableNode.is(node) ? node : AliasNode.is(node) && TableNode.is(node.node) ? node.node : null;\n        if (table3) {\n          this.#collectSchemableId(table3.table, schemableIds);\n        }\n      }\n      #collectSchemableId(node, schemableIds) {\n        const id2 = node.identifier.name;\n        if (!this.#schemableIds.has(id2) && !this.#ctes.has(id2)) {\n          schemableIds.add(id2);\n        }\n      }\n      #collectCTEIds(node, ctes) {\n        for (const expr of node.expressions) {\n          const cteId = expr.name.table.table.identifier.name;\n          if (!this.#ctes.has(cteId)) {\n            ctes.add(cteId);\n          }\n        }\n      }\n    };\n    WithSchemaPlugin = class {\n      static {\n        __name(this, \"WithSchemaPlugin\");\n      }\n      #transformer;\n      constructor(schema2) {\n        this.#transformer = new WithSchemaTransformer(schema2);\n      }\n      transformQuery(args) {\n        return this.#transformer.transformNode(args.node);\n      }\n      async transformResult(args) {\n        return args.result;\n      }\n    };\n    MatchedNode = freeze({\n      is(node) {\n        return node.kind === \"MatchedNode\";\n      },\n      create(not, bySource = false) {\n        return freeze({\n          kind: \"MatchedNode\",\n          not,\n          bySource\n        });\n      }\n    });\n    __name(parseMergeWhen, \"parseMergeWhen\");\n    __name(parseMergeThen, \"parseMergeThen\");\n    Deferred = class {\n      static {\n        __name(this, \"Deferred\");\n      }\n      #promise;\n      #resolve;\n      #reject;\n      constructor() {\n        this.#promise = new Promise((resolve, reject) => {\n          this.#reject = reject;\n          this.#resolve = resolve;\n        });\n      }\n      get promise() {\n        return this.#promise;\n      }\n      resolve = /* @__PURE__ */ __name((value2) => {\n        if (this.#resolve) {\n          this.#resolve(value2);\n        }\n      }, \"resolve\");\n      reject = /* @__PURE__ */ __name((reason) => {\n        if (this.#reject) {\n          this.#reject(reason);\n        }\n      }, \"reject\");\n    };\n    LOGGED_MESSAGES = /* @__PURE__ */ new Set();\n    __name(logOnce, \"logOnce\");\n    NO_PLUGINS = freeze([]);\n    QueryExecutorBase = class {\n      static {\n        __name(this, \"QueryExecutorBase\");\n      }\n      #plugins;\n      constructor(plugins = NO_PLUGINS) {\n        this.#plugins = plugins;\n      }\n      get plugins() {\n        return this.#plugins;\n      }\n      transformQuery(node, queryId) {\n        for (const plugin of this.#plugins) {\n          const transformedNode = plugin.transformQuery({ node, queryId });\n          if (transformedNode.kind === node.kind) {\n            node = transformedNode;\n          } else {\n            throw new Error([\n              `KyselyPlugin.transformQuery must return a node`,\n              `of the same kind that was given to it.`,\n              `The plugin was given a ${node.kind}`,\n              `but it returned a ${transformedNode.kind}`\n            ].join(\" \"));\n          }\n        }\n        return node;\n      }\n      async executeQuery(compiledQuery, queryId) {\n        return await this.provideConnection(async (connection) => {\n          const result = await connection.executeQuery(compiledQuery);\n          const transformedResult = await this.#transformResult(result, queryId);\n          warnOfOutdatedDriverOrPlugins(result, transformedResult);\n          return transformedResult;\n        });\n      }\n      async *stream(compiledQuery, chunkSize, queryId) {\n        const connectionDefer = new Deferred();\n        const connectionReleaseDefer = new Deferred();\n        this.provideConnection(async (connection2) => {\n          connectionDefer.resolve(connection2);\n          return await connectionReleaseDefer.promise;\n        }).catch((ex) => connectionDefer.reject(ex));\n        const connection = await connectionDefer.promise;\n        try {\n          for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {\n            yield await this.#transformResult(result, queryId);\n          }\n        } finally {\n          connectionReleaseDefer.resolve();\n        }\n      }\n      async #transformResult(result, queryId) {\n        for (const plugin of this.#plugins) {\n          result = await plugin.transformResult({ result, queryId });\n        }\n        return result;\n      }\n    };\n    __name(warnOfOutdatedDriverOrPlugins, \"warnOfOutdatedDriverOrPlugins\");\n    NoopQueryExecutor = class _NoopQueryExecutor extends QueryExecutorBase {\n      static {\n        __name(this, \"NoopQueryExecutor\");\n      }\n      get adapter() {\n        throw new Error(\"this query cannot be compiled to SQL\");\n      }\n      compileQuery() {\n        throw new Error(\"this query cannot be compiled to SQL\");\n      }\n      provideConnection() {\n        throw new Error(\"this query cannot be executed\");\n      }\n      withConnectionProvider() {\n        throw new Error(\"this query cannot have a connection provider\");\n      }\n      withPlugin(plugin) {\n        return new _NoopQueryExecutor([...this.plugins, plugin]);\n      }\n      withPlugins(plugins) {\n        return new _NoopQueryExecutor([...this.plugins, ...plugins]);\n      }\n      withPluginAtFront(plugin) {\n        return new _NoopQueryExecutor([plugin, ...this.plugins]);\n      }\n      withoutPlugins() {\n        return new _NoopQueryExecutor([]);\n      }\n    };\n    NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();\n    MergeResult = class {\n      static {\n        __name(this, \"MergeResult\");\n      }\n      numChangedRows;\n      constructor(numChangedRows) {\n        this.numChangedRows = numChangedRows;\n      }\n    };\n    MergeQueryBuilder = class _MergeQueryBuilder {\n      static {\n        __name(this, \"MergeQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db\n       *   .mergeInto('person')\n       *   .using('pet', 'pet.owner_id', 'person.id')\n       *   .whenMatched()\n       *   .thenDelete()\n       *   .modifyEnd(sql.raw('-- this is a comment'))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\" using \"pet\" on \"pet\".\"owner_id\" = \"person\".\"id\" when matched then delete -- this is a comment\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _MergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())\n        });\n      }\n      /**\n       * Changes a `merge into` query to an `merge top into` query.\n       *\n       * `top` clause is only supported by some dialects like MS SQL Server.\n       *\n       * ### Examples\n       *\n       * Affect 5 matched rows at most:\n       *\n       * ```ts\n       * await db.mergeInto('person')\n       *   .top(5)\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenMatched()\n       *   .thenDelete()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * merge top(5) into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when matched then\n       *   delete\n       * ```\n       *\n       * Affect 50% of matched rows:\n       *\n       * ```ts\n       * await db.mergeInto('person')\n       *   .top(50, 'percent')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenMatched()\n       *   .thenDelete()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MS SQL Server):\n       *\n       * ```sql\n       * merge top(50) percent into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when matched then\n       *   delete\n       * ```\n       */\n      top(expression, modifiers) {\n        return new _MergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))\n        });\n      }\n      using(...args) {\n        return new WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin(\"Using\", args))\n        });\n      }\n      output(args) {\n        return new _MergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))\n        });\n      }\n      outputAll(table3) {\n        return new _MergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n    };\n    preventAwait(MergeQueryBuilder, \"don't await MergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.\");\n    WheneableMergeQueryBuilder = class _WheneableMergeQueryBuilder {\n      static {\n        __name(this, \"WheneableMergeQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db\n       *   .mergeInto('person')\n       *   .using('pet', 'pet.owner_id', 'person.id')\n       *   .whenMatched()\n       *   .thenDelete()\n       *   .modifyEnd(sql.raw('-- this is a comment'))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\" using \"pet\" on \"pet\".\"owner_id\" = \"person\".\"id\" when matched then delete -- this is a comment\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())\n        });\n      }\n      /**\n       * See {@link MergeQueryBuilder.top}.\n       */\n      top(expression, modifiers) {\n        return new _WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))\n        });\n      }\n      /**\n       * Adds a simple `when matched` clause to the query.\n       *\n       * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.\n       *\n       * For a simple `when not matched` clause, see {@link whenNotMatched}.\n       *\n       * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db.mergeInto('person')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenMatched()\n       *   .thenDelete()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when matched then\n       *   delete\n       * ```\n       */\n      whenMatched() {\n        return this.#whenMatched([]);\n      }\n      whenMatchedAnd(...args) {\n        return this.#whenMatched(args);\n      }\n      /**\n       * Adds the `when matched` clause to the query with an `and` condition. But unlike\n       * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.\n       *\n       * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation\n       * for that method for more examples.\n       */\n      whenMatchedAndRef(lhs, op, rhs) {\n        return this.#whenMatched([lhs, op, rhs], true);\n      }\n      #whenMatched(args, refRight) {\n        return new MatchedThenableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))\n        });\n      }\n      /**\n       * Adds a simple `when not matched` clause to the query.\n       *\n       * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.\n       *\n       * For a simple `when matched` clause, see {@link whenMatched}.\n       *\n       * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db.mergeInto('person')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenNotMatched()\n       *   .thenInsertValues({\n       *     first_name: 'John',\n       *     last_name: 'Doe',\n       *   })\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when not matched then\n       *   insert (\"first_name\", \"last_name\") values ($1, $2)\n       * ```\n       */\n      whenNotMatched() {\n        return this.#whenNotMatched([]);\n      }\n      whenNotMatchedAnd(...args) {\n        return this.#whenNotMatched(args);\n      }\n      /**\n       * Adds the `when not matched` clause to the query with an `and` condition. But unlike\n       * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.\n       *\n       * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.\n       *\n       * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation\n       * for that method for more examples.\n       */\n      whenNotMatchedAndRef(lhs, op, rhs) {\n        return this.#whenNotMatched([lhs, op, rhs], true);\n      }\n      /**\n       * Adds a simple `when not matched by source` clause to the query.\n       *\n       * Supported in MS SQL Server.\n       *\n       * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.\n       */\n      whenNotMatchedBySource() {\n        return this.#whenNotMatched([], false, true);\n      }\n      whenNotMatchedBySourceAnd(...args) {\n        return this.#whenNotMatched(args, false, true);\n      }\n      /**\n       * Adds the `when not matched by source` clause to the query with an `and` condition.\n       *\n       * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from\n       * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.\n       */\n      whenNotMatchedBySourceAndRef(lhs, op, rhs) {\n        return this.#whenNotMatched([lhs, op, rhs], true, true);\n      }\n      output(args) {\n        return new _WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))\n        });\n      }\n      outputAll(table3) {\n        return new _WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      #whenNotMatched(args, refRight = false, bySource = false) {\n        const props = {\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))\n        };\n        const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;\n        return new Builder(props);\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       *\n       * If you want to conditionally call a method on `this`, see\n       * the {@link $if} method.\n       *\n       * ### Examples\n       *\n       * The next example uses a helper function `log` to log a query:\n       *\n       * ```ts\n       * import type { Compilable } from 'kysely'\n       *\n       * function log<T extends Compilable>(qb: T): T {\n       *   console.log(qb.compile())\n       *   return qb\n       * }\n       *\n       * await db.updateTable('person')\n       *   .set({ first_name: 'John' })\n       *   .$call(log)\n       *   .execute()\n       * ```\n       */\n      $call(func) {\n        return func(this);\n      }\n      /**\n       * Call `func(this)` if `condition` is true.\n       *\n       * This method is especially handy with optional selects. Any `returning` or `returningAll`\n       * method calls add columns as optional fields to the output type when called inside\n       * the `func` callback. This is because we can't know if those selections were actually\n       * made before running the code.\n       *\n       * You can also call any other methods inside the callback.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import type { PersonUpdate } from 'type-editor' // imaginary module\n       *\n       * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {\n       *   return await db\n       *     .updateTable('person')\n       *     .set(updates)\n       *     .where('id', '=', id)\n       *     .returning(['id', 'first_name'])\n       *     .$if(returnLastName, (qb) => qb.returning('last_name'))\n       *     .executeTakeFirstOrThrow()\n       * }\n       * ```\n       *\n       * Any selections added inside the `if` callback will be added as optional fields to the\n       * output type since we can't know if the selections were actually made before running\n       * the code. In the example above the return type of the `updatePerson` function is:\n       *\n       * ```ts\n       * Promise<{\n       *   id: number\n       *   first_name: string\n       *   last_name?: string\n       * }>\n       * ```\n       */\n      $if(condition, func) {\n        if (condition) {\n          return func(this);\n        }\n        return new _WheneableMergeQueryBuilder({\n          ...this.#props\n        });\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      /**\n       * Executes the query and returns an array of rows.\n       *\n       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.\n       */\n      async execute() {\n        const compiledQuery = this.compile();\n        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);\n        if (compiledQuery.query.output && this.#props.executor.adapter.supportsOutput) {\n          return result.rows;\n        }\n        return [new MergeResult(result.numAffectedRows)];\n      }\n      /**\n       * Executes the query and returns the first result or undefined if\n       * the query returned no result.\n       */\n      async executeTakeFirst() {\n        const [result] = await this.execute();\n        return result;\n      }\n      /**\n       * Executes the query and returns the first result or throws if\n       * the query returned no result.\n       *\n       * By default an instance of {@link NoResultError} is thrown, but you can\n       * provide a custom error class, or callback as the only argument to throw a different\n       * error.\n       */\n      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {\n        const result = await this.executeTakeFirst();\n        if (result === void 0) {\n          const error4 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());\n          throw error4;\n        }\n        return result;\n      }\n    };\n    preventAwait(WheneableMergeQueryBuilder, \"don't await WheneableMergeQueryBuilder instances directly. To execute the query you need to call `execute`.\");\n    MatchedThenableMergeQueryBuilder = class {\n      static {\n        __name(this, \"MatchedThenableMergeQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Performs the `delete` action.\n       *\n       * To perform the `do nothing` action, see {@link thenDoNothing}.\n       *\n       * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db.mergeInto('person')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenMatched()\n       *   .thenDelete()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when matched then\n       *   delete\n       * ```\n       */\n      thenDelete() {\n        return new WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(\"delete\"))\n        });\n      }\n      /**\n       * Performs the `do nothing` action.\n       *\n       * This is supported in PostgreSQL.\n       *\n       * To perform the `delete` action, see {@link thenDelete}.\n       *\n       * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db.mergeInto('person')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenMatched()\n       *   .thenDoNothing()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when matched then\n       *   do nothing\n       * ```\n       */\n      thenDoNothing() {\n        return new WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(\"do nothing\"))\n        });\n      }\n      /**\n       * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.\n       * This is handy when multiple `set` invocations are needed.\n       *\n       * For a shorthand version of this method, see {@link thenUpdateSet}.\n       *\n       * To perform the `delete` action, see {@link thenDelete}.\n       *\n       * To perform the `do nothing` action, see {@link thenDoNothing}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * const result = await db.mergeInto('person')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenMatched()\n       *   .thenUpdate((ub) => ub\n       *     .set(sql`metadata['has_pets']`, 'Y')\n       *     .set({\n       *       updated_at: new Date().toISOString(),\n       *     })\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when matched then\n       *   update set metadata['has_pets'] = $1, \"updated_at\" = $2\n       * ```\n       */\n      thenUpdate(set2) {\n        return new WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set2(new UpdateQueryBuilder({\n            queryId: this.#props.queryId,\n            executor: NOOP_QUERY_EXECUTOR,\n            queryNode: UpdateQueryNode.createWithoutTable()\n          }))))\n        });\n      }\n      thenUpdateSet(...args) {\n        return this.thenUpdate((ub) => ub.set(...args));\n      }\n    };\n    preventAwait(MatchedThenableMergeQueryBuilder, \"don't await MatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.\");\n    NotMatchedThenableMergeQueryBuilder = class {\n      static {\n        __name(this, \"NotMatchedThenableMergeQueryBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Performs the `do nothing` action.\n       *\n       * This is supported in PostgreSQL.\n       *\n       * To perform the `insert` action, see {@link thenInsertValues}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db.mergeInto('person')\n       *   .using('pet', 'person.id', 'pet.owner_id')\n       *   .whenNotMatched()\n       *   .thenDoNothing()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * merge into \"person\"\n       * using \"pet\" on \"person\".\"id\" = \"pet\".\"owner_id\"\n       * when not matched then\n       *   do nothing\n       * ```\n       */\n      thenDoNothing() {\n        return new WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(\"do nothing\"))\n        });\n      }\n      thenInsertValues(insert) {\n        const [columns, values] = parseInsertExpression(insert);\n        return new WheneableMergeQueryBuilder({\n          ...this.#props,\n          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {\n            columns,\n            values\n          })))\n        });\n      }\n    };\n    preventAwait(NotMatchedThenableMergeQueryBuilder, \"don't await NotMatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.\");\n    QueryCreator = class _QueryCreator {\n      static {\n        __name(this, \"QueryCreator\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      selectFrom(from) {\n        return createSelectQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)\n        });\n      }\n      selectNoFrom(selection) {\n        return createSelectQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))\n        });\n      }\n      /**\n       * Creates an insert query.\n       *\n       * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}\n       * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of\n       * the inserted row if the db returned one.\n       *\n       * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see\n       * the {@link ReturningInterface.returning | returning} method for a way to return columns\n       * on supported databases like PostgreSQL.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db\n       *   .insertInto('person')\n       *   .values({\n       *     first_name: 'Jennifer',\n       *     last_name: 'Aniston'\n       *   })\n       *   .executeTakeFirst()\n       *\n       * console.log(result.insertId)\n       * ```\n       *\n       * Some databases like PostgreSQL support the `returning` method:\n       *\n       * ```ts\n       * const { id } = await db\n       *   .insertInto('person')\n       *   .values({\n       *     first_name: 'Jennifer',\n       *     last_name: 'Aniston'\n       *   })\n       *   .returning('id')\n       *   .executeTakeFirstOrThrow()\n       * ```\n       */\n      insertInto(table3) {\n        return new InsertQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: InsertQueryNode.create(parseTable(table3), this.#props.withNode)\n        });\n      }\n      /**\n       * Creates a replace query.\n       *\n       * A MySQL-only statement similar to {@link InsertQueryBuilder.onDuplicateKeyUpdate}\n       * that deletes and inserts values on collision instead of updating existing rows.\n       *\n       * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}\n       * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of\n       * the inserted row if the db returned one.\n       *\n       * See the {@link InsertQueryBuilder.values | values} method for more info and examples.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db\n       *   .replaceInto('person')\n       *   .values({\n       *     first_name: 'Jennifer',\n       *     last_name: 'Aniston'\n       *   })\n       *   .executeTakeFirst()\n       *\n       * console.log(result.insertId)\n       * ```\n       */\n      replaceInto(table3) {\n        return new InsertQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: InsertQueryNode.create(parseTable(table3), this.#props.withNode, true)\n        });\n      }\n      deleteFrom(tables) {\n        return new DeleteQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: DeleteQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)\n        });\n      }\n      updateTable(table3) {\n        return new UpdateQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: UpdateQueryNode.create(parseTableExpression(table3), this.#props.withNode)\n        });\n      }\n      mergeInto(targetTable) {\n        return new MergeQueryBuilder({\n          queryId: createQueryId(),\n          executor: this.#props.executor,\n          queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)\n        });\n      }\n      /**\n       * Creates a `with` query (Common Table Expression).\n       *\n       * ### Examples\n       *\n       * <!-- siteExample(\"cte\", \"Simple selects\", 10) -->\n       *\n       * Common table expressions (CTE) are a great way to modularize complex queries.\n       * Essentially they allow you to run multiple separate queries within a\n       * single roundtrip to the DB.\n       *\n       * Since CTEs are a part of the main query, query optimizers inside DB\n       * engines are able to optimize the overall query. For example, postgres\n       * is able to inline the CTEs inside the using queries if it decides it's\n       * faster.\n       *\n       * ```ts\n       * const result = await db\n       *   // Create a CTE called `jennifers` that selects all\n       *   // persons named 'Jennifer'.\n       *   .with('jennifers', (db) => db\n       *     .selectFrom('person')\n       *     .where('first_name', '=', 'Jennifer')\n       *     .select(['id', 'age'])\n       *   )\n       *   // Select all rows from the `jennifers` CTE and\n       *   // further filter it.\n       *   .with('adult_jennifers', (db) => db\n       *     .selectFrom('jennifers')\n       *     .where('age', '>', 18)\n       *     .select(['id', 'age'])\n       *   )\n       *   // Finally select all adult jennifers that are\n       *   // also younger than 60.\n       *   .selectFrom('adult_jennifers')\n       *   .where('age', '<', 60)\n       *   .selectAll()\n       *   .execute()\n       * ```\n       *\n       * <!-- siteExample(\"cte\", \"Inserts, updates and deletions\", 20) -->\n       *\n       * Some databases like postgres also allow you to run other queries than selects\n       * in CTEs. On these databases CTEs are extremely powerful:\n       *\n       * ```ts\n       * const result = await db\n       *   .with('new_person', (db) => db\n       *     .insertInto('person')\n       *     .values({\n       *       first_name: 'Jennifer',\n       *       age: 35,\n       *     })\n       *     .returning('id')\n       *   )\n       *   .with('new_pet', (db) => db\n       *     .insertInto('pet')\n       *     .values({\n       *       name: 'Doggo',\n       *       species: 'dog',\n       *       is_favorite: true,\n       *       // Use the id of the person we just inserted.\n       *       owner_id: db\n       *         .selectFrom('new_person')\n       *         .select('id')\n       *     })\n       *     .returning('id')\n       *   )\n       *   .selectFrom(['new_person', 'new_pet'])\n       *   .select([\n       *     'new_person.id as person_id',\n       *     'new_pet.id as pet_id'\n       *   ])\n       *   .execute()\n       * ```\n       *\n       * The CTE name can optionally specify column names in addition to\n       * a name. In that case Kysely requires the expression to retun\n       * rows with the same columns.\n       *\n       * ```ts\n       * await db\n       *   .with('jennifers(id, age)', (db) => db\n       *     .selectFrom('person')\n       *     .where('first_name', '=', 'Jennifer')\n       *     // This is ok since we return columns with the same\n       *     // names as specified by `jennifers(id, age)`.\n       *     .select(['id', 'age'])\n       *   )\n       *   .selectFrom('jennifers')\n       *   .selectAll()\n       *   .execute()\n       * ```\n       *\n       * The first argument can also be a callback. The callback is passed\n       * a `CTEBuilder` instance that can be used to configure the CTE:\n       *\n       * ```ts\n       * await db\n       *   .with(\n       *     (cte) => cte('jennifers').materialized(),\n       *     (db) => db\n       *       .selectFrom('person')\n       *       .where('first_name', '=', 'Jennifer')\n       *       .select(['id', 'age'])\n       *   )\n       *   .selectFrom('jennifers')\n       *   .selectAll()\n       *   .execute()\n       * ```\n       */\n      with(nameOrBuilder, expression) {\n        const cte = parseCommonTableExpression(nameOrBuilder, expression);\n        return new _QueryCreator({\n          ...this.#props,\n          withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)\n        });\n      }\n      /**\n       * Creates a recursive `with` query (Common Table Expression).\n       *\n       * Note that recursiveness is a property of the whole `with` statement.\n       * You cannot have recursive and non-recursive CTEs in a same `with` statement.\n       * Therefore the recursiveness is determined by the **first** `with` or\n       * `withRecusive` call you make.\n       *\n       * See the {@link with} method for examples and more documentation.\n       */\n      withRecursive(nameOrBuilder, expression) {\n        const cte = parseCommonTableExpression(nameOrBuilder, expression);\n        return new _QueryCreator({\n          ...this.#props,\n          withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })\n        });\n      }\n      /**\n       * Returns a copy of this query creator instance with the given plugin installed.\n       */\n      withPlugin(plugin) {\n        return new _QueryCreator({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      /**\n       * Returns a copy of this query creator instance without any plugins.\n       */\n      withoutPlugins() {\n        return new _QueryCreator({\n          ...this.#props,\n          executor: this.#props.executor.withoutPlugins()\n        });\n      }\n      /**\n       * Sets the schema to be used for all table references that don't explicitly\n       * specify a schema.\n       *\n       * This only affects the query created through the builder returned from\n       * this method and doesn't modify the `db` instance.\n       *\n       * See [this recipe](https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md)\n       * for a more detailed explanation.\n       *\n       * ### Examples\n       *\n       * ```\n       * await db\n       *   .withSchema('mammals')\n       *   .selectFrom('pet')\n       *   .selectAll()\n       *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select * from \"mammals\".\"pet\"\n       * inner join \"public\".\"person\"\n       * on \"public\".\"person\".\"id\" = \"mammals\".\"pet\".\"owner_id\"\n       * ```\n       *\n       * `withSchema` is smart enough to not add schema for aliases,\n       * common table expressions or other places where the schema\n       * doesn't belong to:\n       *\n       * ```\n       * await db\n       *   .withSchema('mammals')\n       *   .selectFrom('pet as p')\n       *   .select('p.name')\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select \"p\".\"name\" from \"mammals\".\"pet\" as \"p\"\n       * ```\n       */\n      withSchema(schema2) {\n        return new _QueryCreator({\n          ...this.#props,\n          executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))\n        });\n      }\n    };\n    __name(createQueryCreator, \"createQueryCreator\");\n    __name(createJoinBuilder, \"createJoinBuilder\");\n    __name(createOverBuilder, \"createOverBuilder\");\n    __name(parseJoin, \"parseJoin\");\n    __name(parseCallbackJoin, \"parseCallbackJoin\");\n    __name(parseSingleOnJoin, \"parseSingleOnJoin\");\n    OffsetNode = freeze({\n      is(node) {\n        return node.kind === \"OffsetNode\";\n      },\n      create(offset) {\n        return freeze({\n          kind: \"OffsetNode\",\n          offset\n        });\n      }\n    });\n    GroupByItemNode = freeze({\n      is(node) {\n        return node.kind === \"GroupByItemNode\";\n      },\n      create(groupBy) {\n        return freeze({\n          kind: \"GroupByItemNode\",\n          groupBy\n        });\n      }\n    });\n    __name(parseGroupBy, \"parseGroupBy\");\n    SetOperationNode = freeze({\n      is(node) {\n        return node.kind === \"SetOperationNode\";\n      },\n      create(operator, expression, all) {\n        return freeze({\n          kind: \"SetOperationNode\",\n          operator,\n          expression,\n          all\n        });\n      }\n    });\n    __name(parseSetOperations, \"parseSetOperations\");\n    ExpressionWrapper = class _ExpressionWrapper {\n      static {\n        __name(this, \"ExpressionWrapper\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      /** @private */\n      get expressionType() {\n        return void 0;\n      }\n      as(alias2) {\n        return new AliasedExpressionWrapper(this, alias2);\n      }\n      or(...args) {\n        return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));\n      }\n      and(...args) {\n        return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));\n      }\n      /**\n       * Change the output type of the expression.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `ExpressionWrapper` with a new output type.\n       */\n      $castTo() {\n        return new _ExpressionWrapper(this.#node);\n      }\n      /**\n       * Omit null from the expression's type.\n       *\n       * This function can be useful in cases where you know an expression can't be\n       * null, but Kysely is unable to infer it.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of `this` with a new output type.\n       */\n      $notNull() {\n        return new _ExpressionWrapper(this.#node);\n      }\n      toOperationNode() {\n        return this.#node;\n      }\n    };\n    AliasedExpressionWrapper = class {\n      static {\n        __name(this, \"AliasedExpressionWrapper\");\n      }\n      #expr;\n      #alias;\n      constructor(expr, alias2) {\n        this.#expr = expr;\n        this.#alias = alias2;\n      }\n      /** @private */\n      get expression() {\n        return this.#expr;\n      }\n      /** @private */\n      get alias() {\n        return this.#alias;\n      }\n      toOperationNode() {\n        return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));\n      }\n    };\n    OrWrapper = class _OrWrapper {\n      static {\n        __name(this, \"OrWrapper\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      /** @private */\n      get expressionType() {\n        return void 0;\n      }\n      as(alias2) {\n        return new AliasedExpressionWrapper(this, alias2);\n      }\n      or(...args) {\n        return new _OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));\n      }\n      /**\n       * Change the output type of the expression.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `OrWrapper` with a new output type.\n       */\n      $castTo() {\n        return new _OrWrapper(this.#node);\n      }\n      toOperationNode() {\n        return ParensNode.create(this.#node);\n      }\n    };\n    AndWrapper = class _AndWrapper {\n      static {\n        __name(this, \"AndWrapper\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      /** @private */\n      get expressionType() {\n        return void 0;\n      }\n      as(alias2) {\n        return new AliasedExpressionWrapper(this, alias2);\n      }\n      and(...args) {\n        return new _AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));\n      }\n      /**\n       * Change the output type of the expression.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `AndWrapper` with a new output type.\n       */\n      $castTo() {\n        return new _AndWrapper(this.#node);\n      }\n      toOperationNode() {\n        return ParensNode.create(this.#node);\n      }\n    };\n    FetchNode = {\n      is(node) {\n        return node.kind === \"FetchNode\";\n      },\n      create(rowCount, modifier) {\n        return {\n          kind: \"FetchNode\",\n          rowCount: ValueNode.create(rowCount),\n          modifier\n        };\n      }\n    };\n    __name(parseFetch, \"parseFetch\");\n    __name(isFetchModifier, \"isFetchModifier\");\n    SelectQueryBuilderImpl = class _SelectQueryBuilderImpl {\n      static {\n        __name(this, \"SelectQueryBuilderImpl\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      get expressionType() {\n        return void 0;\n      }\n      get isSelectQueryBuilder() {\n        return true;\n      }\n      where(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      whereRef(lhs, op, rhs) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      having(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      havingRef(lhs, op, rhs) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      select(selection) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))\n        });\n      }\n      distinctOn(selection) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))\n        });\n      }\n      modifyFront(modifier) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))\n        });\n      }\n      modifyEnd(modifier) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))\n        });\n      }\n      distinct() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create(\"Distinct\"))\n        });\n      }\n      forUpdate(of) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create(\"ForUpdate\", of ? asArray(of).map(parseTable) : void 0))\n        });\n      }\n      forShare(of) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create(\"ForShare\", of ? asArray(of).map(parseTable) : void 0))\n        });\n      }\n      forKeyShare(of) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create(\"ForKeyShare\", of ? asArray(of).map(parseTable) : void 0))\n        });\n      }\n      forNoKeyUpdate(of) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create(\"ForNoKeyUpdate\", of ? asArray(of).map(parseTable) : void 0))\n        });\n      }\n      skipLocked() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create(\"SkipLocked\"))\n        });\n      }\n      noWait() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create(\"NoWait\"))\n        });\n      }\n      selectAll(table3) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table3))\n        });\n      }\n      innerJoin(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"InnerJoin\", args))\n        });\n      }\n      leftJoin(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"LeftJoin\", args))\n        });\n      }\n      rightJoin(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"RightJoin\", args))\n        });\n      }\n      fullJoin(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"FullJoin\", args))\n        });\n      }\n      innerJoinLateral(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"LateralInnerJoin\", args))\n        });\n      }\n      leftJoinLateral(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin(\"LateralLeftJoin\", args))\n        });\n      }\n      orderBy(...args) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))\n        });\n      }\n      groupBy(groupBy) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))\n        });\n      }\n      limit(limit) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))\n        });\n      }\n      offset(offset) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset)))\n        });\n      }\n      fetch(rowCount, modifier = \"only\") {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))\n        });\n      }\n      top(expression, modifiers) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))\n        });\n      }\n      union(expression) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations(\"union\", expression, false))\n        });\n      }\n      unionAll(expression) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations(\"union\", expression, true))\n        });\n      }\n      intersect(expression) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations(\"intersect\", expression, false))\n        });\n      }\n      intersectAll(expression) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations(\"intersect\", expression, true))\n        });\n      }\n      except(expression) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations(\"except\", expression, false))\n        });\n      }\n      exceptAll(expression) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations(\"except\", expression, true))\n        });\n      }\n      as(alias2) {\n        return new AliasedSelectQueryBuilderImpl(this, alias2);\n      }\n      clearSelect() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)\n        });\n      }\n      clearWhere() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)\n        });\n      }\n      clearLimit() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)\n        });\n      }\n      clearOffset() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)\n        });\n      }\n      clearOrderBy() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithoutOrderBy(this.#props.queryNode)\n        });\n      }\n      clearGroupBy() {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)\n        });\n      }\n      $call(func) {\n        return func(this);\n      }\n      $if(condition, func) {\n        if (condition) {\n          return func(this);\n        }\n        return new _SelectQueryBuilderImpl({\n          ...this.#props\n        });\n      }\n      $castTo() {\n        return new _SelectQueryBuilderImpl(this.#props);\n      }\n      $narrowType() {\n        return new _SelectQueryBuilderImpl(this.#props);\n      }\n      $assertType() {\n        return new _SelectQueryBuilderImpl(this.#props);\n      }\n      $asTuple() {\n        return new ExpressionWrapper(this.toOperationNode());\n      }\n      withPlugin(plugin) {\n        return new _SelectQueryBuilderImpl({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        const compiledQuery = this.compile();\n        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);\n        return result.rows;\n      }\n      async executeTakeFirst() {\n        const [result] = await this.execute();\n        return result;\n      }\n      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {\n        const result = await this.executeTakeFirst();\n        if (result === void 0) {\n          const error4 = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());\n          throw error4;\n        }\n        return result;\n      }\n      async *stream(chunkSize = 100) {\n        const compiledQuery = this.compile();\n        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);\n        for await (const item of stream) {\n          yield* item.rows;\n        }\n      }\n      async explain(format2, options) {\n        const builder = new _SelectQueryBuilderImpl({\n          ...this.#props,\n          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format2, options)\n        });\n        return await builder.execute();\n      }\n    };\n    preventAwait(SelectQueryBuilderImpl, \"don't await SelectQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.\");\n    __name(createSelectQueryBuilder, \"createSelectQueryBuilder\");\n    AliasedSelectQueryBuilderImpl = class {\n      static {\n        __name(this, \"AliasedSelectQueryBuilderImpl\");\n      }\n      #queryBuilder;\n      #alias;\n      constructor(queryBuilder, alias2) {\n        this.#queryBuilder = queryBuilder;\n        this.#alias = alias2;\n      }\n      get expression() {\n        return this.#queryBuilder;\n      }\n      get alias() {\n        return this.#alias;\n      }\n      get isAliasedSelectQueryBuilder() {\n        return true;\n      }\n      toOperationNode() {\n        return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));\n      }\n    };\n    preventAwait(AliasedSelectQueryBuilderImpl, \"don't await AliasedSelectQueryBuilder instances directly. AliasedSelectQueryBuilder should never be executed directly since it's always a part of another query.\");\n    AggregateFunctionNode = freeze({\n      is(node) {\n        return node.kind === \"AggregateFunctionNode\";\n      },\n      create(aggregateFunction, aggregated = []) {\n        return freeze({\n          kind: \"AggregateFunctionNode\",\n          func: aggregateFunction,\n          aggregated\n        });\n      },\n      cloneWithDistinct(aggregateFunctionNode) {\n        return freeze({\n          ...aggregateFunctionNode,\n          distinct: true\n        });\n      },\n      cloneWithOrderBy(aggregateFunctionNode, orderItems) {\n        return freeze({\n          ...aggregateFunctionNode,\n          orderBy: aggregateFunctionNode.orderBy ? OrderByNode.cloneWithItems(aggregateFunctionNode.orderBy, orderItems) : OrderByNode.create(orderItems)\n        });\n      },\n      cloneWithFilter(aggregateFunctionNode, filter) {\n        return freeze({\n          ...aggregateFunctionNode,\n          filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, \"And\", filter) : WhereNode.create(filter)\n        });\n      },\n      cloneWithOrFilter(aggregateFunctionNode, filter) {\n        return freeze({\n          ...aggregateFunctionNode,\n          filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, \"Or\", filter) : WhereNode.create(filter)\n        });\n      },\n      cloneWithOver(aggregateFunctionNode, over) {\n        return freeze({\n          ...aggregateFunctionNode,\n          over\n        });\n      }\n    });\n    FunctionNode = freeze({\n      is(node) {\n        return node.kind === \"FunctionNode\";\n      },\n      create(func, args) {\n        return freeze({\n          kind: \"FunctionNode\",\n          func,\n          arguments: args\n        });\n      }\n    });\n    AggregateFunctionBuilder = class _AggregateFunctionBuilder {\n      static {\n        __name(this, \"AggregateFunctionBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /** @private */\n      get expressionType() {\n        return void 0;\n      }\n      /**\n       * Returns an aliased version of the function.\n       *\n       * In addition to slapping `as \"the_alias\"` to the end of the SQL,\n       * this method also provides strict typing:\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .select(\n       *     (eb) => eb.fn.count<number>('id').as('person_count')\n       *   )\n       *   .executeTakeFirstOrThrow()\n       *\n       * // `person_count: number` field exists in the result type.\n       * console.log(result.person_count)\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select count(\"id\") as \"person_count\"\n       * from \"person\"\n       * ```\n       */\n      as(alias2) {\n        return new AliasedAggregateFunctionBuilder(this, alias2);\n      }\n      /**\n       * Adds a `distinct` clause inside the function.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .select((eb) =>\n       *     eb.fn.count<number>('first_name').distinct().as('first_name_count')\n       *   )\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select count(distinct \"first_name\") as \"first_name_count\"\n       * from \"person\"\n       * ```\n       */\n      distinct() {\n        return new _AggregateFunctionBuilder({\n          ...this.#props,\n          aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)\n        });\n      }\n      /**\n       * Adds an `order by` clause inside the aggregate function.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .innerJoin('pet', 'pet.owner_id', 'person.id')\n       *   .select((eb) =>\n       *     eb.fn.jsonAgg('pet').orderBy('pet.name').as('person_pets')\n       *   )\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select json_agg(\"pet\" order by \"pet\".\"name\") as \"person_pets\"\n       * from \"person\"\n       * inner join \"pet\" ON \"pet\".\"owner_id\" = \"person\".\"id\"\n       * ```\n       */\n      orderBy(orderBy, direction) {\n        return new _AggregateFunctionBuilder({\n          ...this.#props,\n          aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(this.#props.aggregateFunctionNode, parseOrderBy([orderBy, direction]))\n        });\n      }\n      filterWhere(...args) {\n        return new _AggregateFunctionBuilder({\n          ...this.#props,\n          aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))\n        });\n      }\n      /**\n       * Adds a `filter` clause with a nested `where` clause after the function, where\n       * both sides of the operator are references to columns.\n       *\n       * Similar to {@link WhereInterface}'s `whereRef` method.\n       *\n       * ### Examples\n       *\n       * Count people with same first and last names versus general public:\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .select((eb) => [\n       *     eb.fn\n       *       .count<number>('id')\n       *       .filterWhereRef('first_name', '=', 'last_name')\n       *       .as('repeat_name_count'),\n       *     eb.fn.count<number>('id').as('total_count'),\n       *   ])\n       *   .executeTakeFirstOrThrow()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select\n       *   count(\"id\") filter(where \"first_name\" = \"last_name\") as \"repeat_name_count\",\n       *   count(\"id\") as \"total_count\"\n       * from \"person\"\n       * ```\n       */\n      filterWhereRef(lhs, op, rhs) {\n        return new _AggregateFunctionBuilder({\n          ...this.#props,\n          aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))\n        });\n      }\n      /**\n       * Adds an `over` clause (window functions) after the function.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .select(\n       *     (eb) => eb.fn.avg<number>('age').over().as('average_age')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select avg(\"age\") over() as \"average_age\"\n       * from \"person\"\n       * ```\n       *\n       * Also supports passing a callback that returns an over builder,\n       * allowing to add partition by and sort by clauses inside over.\n       *\n       * ```ts\n       * const result = await db\n       *   .selectFrom('person')\n       *   .select(\n       *     (eb) => eb.fn.avg<number>('age').over(\n       *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')\n       *     ).as('average_age')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select avg(\"age\") over(partition by \"last_name\" order by \"first_name\" asc) as \"average_age\"\n       * from \"person\"\n       * ```\n       */\n      over(over) {\n        const builder = createOverBuilder();\n        return new _AggregateFunctionBuilder({\n          ...this.#props,\n          aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      /**\n       * Casts the expression to the given type.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `AggregateFunctionBuilder` with a new output type.\n       */\n      $castTo() {\n        return new _AggregateFunctionBuilder(this.#props);\n      }\n      /**\n       * Omit null from the expression's type.\n       *\n       * This function can be useful in cases where you know an expression can't be\n       * null, but Kysely is unable to infer it.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of `this` with a new output type.\n       */\n      $notNull() {\n        return new _AggregateFunctionBuilder(this.#props);\n      }\n      toOperationNode() {\n        return this.#props.aggregateFunctionNode;\n      }\n    };\n    preventAwait(AggregateFunctionBuilder, \"don't await AggregateFunctionBuilder instances. They are never executed directly and are always just a part of a query.\");\n    AliasedAggregateFunctionBuilder = class {\n      static {\n        __name(this, \"AliasedAggregateFunctionBuilder\");\n      }\n      #aggregateFunctionBuilder;\n      #alias;\n      constructor(aggregateFunctionBuilder, alias2) {\n        this.#aggregateFunctionBuilder = aggregateFunctionBuilder;\n        this.#alias = alias2;\n      }\n      /** @private */\n      get expression() {\n        return this.#aggregateFunctionBuilder;\n      }\n      /** @private */\n      get alias() {\n        return this.#alias;\n      }\n      toOperationNode() {\n        return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));\n      }\n    };\n    __name(createFunctionModule, \"createFunctionModule\");\n    UnaryOperationNode = freeze({\n      is(node) {\n        return node.kind === \"UnaryOperationNode\";\n      },\n      create(operator, operand) {\n        return freeze({\n          kind: \"UnaryOperationNode\",\n          operator,\n          operand\n        });\n      }\n    });\n    __name(parseUnaryOperation, \"parseUnaryOperation\");\n    CaseNode = freeze({\n      is(node) {\n        return node.kind === \"CaseNode\";\n      },\n      create(value2) {\n        return freeze({\n          kind: \"CaseNode\",\n          value: value2\n        });\n      },\n      cloneWithWhen(caseNode, when) {\n        return freeze({\n          ...caseNode,\n          when: freeze(caseNode.when ? [...caseNode.when, when] : [when])\n        });\n      },\n      cloneWithThen(caseNode, then) {\n        return freeze({\n          ...caseNode,\n          when: caseNode.when ? freeze([\n            ...caseNode.when.slice(0, -1),\n            WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)\n          ]) : void 0\n        });\n      },\n      cloneWith(caseNode, props) {\n        return freeze({\n          ...caseNode,\n          ...props\n        });\n      }\n    });\n    CaseBuilder = class {\n      static {\n        __name(this, \"CaseBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      when(...args) {\n        return new CaseThenBuilder({\n          ...this.#props,\n          node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))\n        });\n      }\n    };\n    CaseThenBuilder = class {\n      static {\n        __name(this, \"CaseThenBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      then(valueExpression) {\n        return new CaseWhenBuilder({\n          ...this.#props,\n          node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))\n        });\n      }\n    };\n    CaseWhenBuilder = class {\n      static {\n        __name(this, \"CaseWhenBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      when(...args) {\n        return new CaseThenBuilder({\n          ...this.#props,\n          node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))\n        });\n      }\n      else(valueExpression) {\n        return new CaseEndBuilder({\n          ...this.#props,\n          node: CaseNode.cloneWith(this.#props.node, {\n            else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)\n          })\n        });\n      }\n      end() {\n        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));\n      }\n      endCase() {\n        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));\n      }\n    };\n    CaseEndBuilder = class {\n      static {\n        __name(this, \"CaseEndBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      end() {\n        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));\n      }\n      endCase() {\n        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));\n      }\n    };\n    JSONPathLegNode = freeze({\n      is(node) {\n        return node.kind === \"JSONPathLegNode\";\n      },\n      create(type2, value2) {\n        return freeze({\n          kind: \"JSONPathLegNode\",\n          type: type2,\n          value: value2\n        });\n      }\n    });\n    JSONPathBuilder = class {\n      static {\n        __name(this, \"JSONPathBuilder\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      /**\n       * Access an element of a JSON array in a specific location.\n       *\n       * Since there's no guarantee an element exists in the given array location, the\n       * resulting type is always nullable. If you're sure the element exists, you\n       * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.\n       *\n       * See also {@link key} to access properties of JSON objects.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.selectFrom('person')\n       *   .select(eb =>\n       *     eb.ref('nicknames', '->').at(0).as('primary_nickname')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select \"nicknames\"->0 as \"primary_nickname\" from \"person\"\n       *```\n       *\n       * Combined with {@link key}:\n       *\n       * ```ts\n       * db.selectFrom('person').select(eb =>\n       *   eb.ref('experience', '->').at(0).key('role').as('first_role')\n       * )\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select \"experience\"->0->'role' as \"first_role\" from \"person\"\n       * ```\n       *\n       * You can use `'last'` to access the last element of the array in MySQL:\n       *\n       * ```ts\n       * db.selectFrom('person').select(eb =>\n       *   eb.ref('nicknames', '->$').at('last').as('last_nickname')\n       * )\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * select `nicknames`->'$[last]' as `last_nickname` from `person`\n       * ```\n       *\n       * Or `'#-1'` in SQLite:\n       *\n       * ```ts\n       * db.selectFrom('person').select(eb =>\n       *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')\n       * )\n       * ```\n       *\n       * The generated SQL (SQLite):\n       *\n       * ```sql\n       * select \"nicknames\"->>'$[#-1]' as `last_nickname` from `person`\n       * ```\n       */\n      at(index) {\n        return this.#createBuilderWithPathLeg(\"ArrayLocation\", index);\n      }\n      /**\n       * Access a property of a JSON object.\n       *\n       * If a field is optional, the resulting type will be nullable.\n       *\n       * See also {@link at} to access elements of JSON arrays.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * db.selectFrom('person').select(eb =>\n       *   eb.ref('address', '->').key('city').as('city')\n       * )\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select \"address\"->'city' as \"city\" from \"person\"\n       * ```\n       *\n       * Going deeper:\n       *\n       * ```ts\n       * db.selectFrom('person').select(eb =>\n       *   eb.ref('profile', '->$').key('website').key('url').as('website_url')\n       * )\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * select `profile`->'$.website.url' as `website_url` from `person`\n       * ```\n       *\n       * Combined with {@link at}:\n       *\n       * ```ts\n       * db.selectFrom('person').select(eb =>\n       *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')\n       * )\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select \"profile\"->'addresses'->0->'city' as \"city\" from \"person\"\n       * ```\n       */\n      key(key) {\n        return this.#createBuilderWithPathLeg(\"Member\", key);\n      }\n      #createBuilderWithPathLeg(legType, value2) {\n        if (JSONReferenceNode.is(this.#node)) {\n          return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value2)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value2))));\n        }\n        return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value2)));\n      }\n    };\n    TraversedJSONPathBuilder = class _TraversedJSONPathBuilder extends JSONPathBuilder {\n      static {\n        __name(this, \"TraversedJSONPathBuilder\");\n      }\n      #node;\n      constructor(node) {\n        super(node);\n        this.#node = node;\n      }\n      /** @private */\n      get expressionType() {\n        return void 0;\n      }\n      as(alias2) {\n        return new AliasedJSONPathBuilder(this, alias2);\n      }\n      /**\n       * Change the output type of the json path.\n       *\n       * This method call doesn't change the SQL in any way. This methods simply\n       * returns a copy of this `JSONPathBuilder` with a new output type.\n       */\n      $castTo() {\n        return new _TraversedJSONPathBuilder(this.#node);\n      }\n      $notNull() {\n        return new _TraversedJSONPathBuilder(this.#node);\n      }\n      toOperationNode() {\n        return this.#node;\n      }\n    };\n    AliasedJSONPathBuilder = class {\n      static {\n        __name(this, \"AliasedJSONPathBuilder\");\n      }\n      #jsonPath;\n      #alias;\n      constructor(jsonPath, alias2) {\n        this.#jsonPath = jsonPath;\n        this.#alias = alias2;\n      }\n      /** @private */\n      get expression() {\n        return this.#jsonPath;\n      }\n      /** @private */\n      get alias() {\n        return this.#alias;\n      }\n      toOperationNode() {\n        return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));\n      }\n    };\n    TupleNode = freeze({\n      is(node) {\n        return node.kind === \"TupleNode\";\n      },\n      create(values) {\n        return freeze({\n          kind: \"TupleNode\",\n          values: freeze(values)\n        });\n      }\n    });\n    SIMPLE_COLUMN_DATA_TYPES = [\n      \"varchar\",\n      \"char\",\n      \"text\",\n      \"integer\",\n      \"int2\",\n      \"int4\",\n      \"int8\",\n      \"smallint\",\n      \"bigint\",\n      \"boolean\",\n      \"real\",\n      \"double precision\",\n      \"float4\",\n      \"float8\",\n      \"decimal\",\n      \"numeric\",\n      \"binary\",\n      \"bytea\",\n      \"date\",\n      \"datetime\",\n      \"time\",\n      \"timetz\",\n      \"timestamp\",\n      \"timestamptz\",\n      \"serial\",\n      \"bigserial\",\n      \"uuid\",\n      \"json\",\n      \"jsonb\",\n      \"blob\",\n      \"varbinary\",\n      \"int4range\",\n      \"int4multirange\",\n      \"int8range\",\n      \"int8multirange\",\n      \"numrange\",\n      \"nummultirange\",\n      \"tsrange\",\n      \"tsmultirange\",\n      \"tstzrange\",\n      \"tstzmultirange\",\n      \"daterange\",\n      \"datemultirange\"\n    ];\n    COLUMN_DATA_TYPE_REGEX = [\n      /^varchar\\(\\d+\\)$/,\n      /^char\\(\\d+\\)$/,\n      /^decimal\\(\\d+, \\d+\\)$/,\n      /^numeric\\(\\d+, \\d+\\)$/,\n      /^binary\\(\\d+\\)$/,\n      /^datetime\\(\\d+\\)$/,\n      /^time\\(\\d+\\)$/,\n      /^timetz\\(\\d+\\)$/,\n      /^timestamp\\(\\d+\\)$/,\n      /^timestamptz\\(\\d+\\)$/,\n      /^varbinary\\(\\d+\\)$/\n    ];\n    DataTypeNode = freeze({\n      is(node) {\n        return node.kind === \"DataTypeNode\";\n      },\n      create(dataType) {\n        return freeze({\n          kind: \"DataTypeNode\",\n          dataType\n        });\n      }\n    });\n    __name(isColumnDataType, \"isColumnDataType\");\n    __name(parseDataTypeExpression, \"parseDataTypeExpression\");\n    CastNode = freeze({\n      is(node) {\n        return node.kind === \"CastNode\";\n      },\n      create(expression, dataType) {\n        return freeze({\n          kind: \"CastNode\",\n          expression,\n          dataType\n        });\n      }\n    });\n    __name(createExpressionBuilder, \"createExpressionBuilder\");\n    __name(expressionBuilder, \"expressionBuilder\");\n    __name(parseExpression, \"parseExpression\");\n    __name(parseAliasedExpression, \"parseAliasedExpression\");\n    __name(isExpressionOrFactory, \"isExpressionOrFactory\");\n    __name(parseTableExpressionOrList, \"parseTableExpressionOrList\");\n    __name(parseTableExpression, \"parseTableExpression\");\n    __name(parseAliasedTable, \"parseAliasedTable\");\n    __name(parseTable, \"parseTable\");\n    __name(trim$1, \"trim$1\");\n    AddColumnNode = freeze({\n      is(node) {\n        return node.kind === \"AddColumnNode\";\n      },\n      create(column) {\n        return freeze({\n          kind: \"AddColumnNode\",\n          column\n        });\n      }\n    });\n    ColumnDefinitionNode = freeze({\n      is(node) {\n        return node.kind === \"ColumnDefinitionNode\";\n      },\n      create(column, dataType) {\n        return freeze({\n          kind: \"ColumnDefinitionNode\",\n          column: ColumnNode.create(column),\n          dataType\n        });\n      },\n      cloneWithFrontModifier(node, modifier) {\n        return freeze({\n          ...node,\n          frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]\n        });\n      },\n      cloneWithEndModifier(node, modifier) {\n        return freeze({\n          ...node,\n          endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      }\n    });\n    DropColumnNode = freeze({\n      is(node) {\n        return node.kind === \"DropColumnNode\";\n      },\n      create(column) {\n        return freeze({\n          kind: \"DropColumnNode\",\n          column: ColumnNode.create(column)\n        });\n      }\n    });\n    RenameColumnNode = freeze({\n      is(node) {\n        return node.kind === \"RenameColumnNode\";\n      },\n      create(column, newColumn) {\n        return freeze({\n          kind: \"RenameColumnNode\",\n          column: ColumnNode.create(column),\n          renameTo: ColumnNode.create(newColumn)\n        });\n      }\n    });\n    CheckConstraintNode = freeze({\n      is(node) {\n        return node.kind === \"CheckConstraintNode\";\n      },\n      create(expression, constraintName) {\n        return freeze({\n          kind: \"CheckConstraintNode\",\n          expression,\n          name: constraintName ? IdentifierNode.create(constraintName) : void 0\n        });\n      }\n    });\n    ON_MODIFY_FOREIGN_ACTIONS = [\n      \"no action\",\n      \"restrict\",\n      \"cascade\",\n      \"set null\",\n      \"set default\"\n    ];\n    ReferencesNode = freeze({\n      is(node) {\n        return node.kind === \"ReferencesNode\";\n      },\n      create(table3, columns) {\n        return freeze({\n          kind: \"ReferencesNode\",\n          table: table3,\n          columns: freeze([...columns])\n        });\n      },\n      cloneWithOnDelete(references, onDelete) {\n        return freeze({\n          ...references,\n          onDelete\n        });\n      },\n      cloneWithOnUpdate(references, onUpdate) {\n        return freeze({\n          ...references,\n          onUpdate\n        });\n      }\n    });\n    __name(parseDefaultValueExpression, \"parseDefaultValueExpression\");\n    GeneratedNode = freeze({\n      is(node) {\n        return node.kind === \"GeneratedNode\";\n      },\n      create(params) {\n        return freeze({\n          kind: \"GeneratedNode\",\n          ...params\n        });\n      },\n      createWithExpression(expression) {\n        return freeze({\n          kind: \"GeneratedNode\",\n          always: true,\n          expression\n        });\n      },\n      cloneWith(node, params) {\n        return freeze({\n          ...node,\n          ...params\n        });\n      }\n    });\n    DefaultValueNode = freeze({\n      is(node) {\n        return node.kind === \"DefaultValueNode\";\n      },\n      create(defaultValue) {\n        return freeze({\n          kind: \"DefaultValueNode\",\n          defaultValue\n        });\n      }\n    });\n    __name(parseOnModifyForeignAction, \"parseOnModifyForeignAction\");\n    ColumnDefinitionBuilder = class _ColumnDefinitionBuilder {\n      static {\n        __name(this, \"ColumnDefinitionBuilder\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      /**\n       * Adds `auto_increment` or `autoincrement` to the column definition\n       * depending on the dialect.\n       *\n       * Some dialects like PostgreSQL don't support this. On PostgreSQL\n       * you can use the `serial` or `bigserial` data type instead.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.autoIncrement().primaryKey())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `id` integer primary key auto_increment\n       * )\n       * ```\n       */\n      autoIncrement() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));\n      }\n      /**\n       * Makes the column an identity column.\n       *\n       * This only works on some dialects like MS SQL Server (MSSQL).\n       *\n       * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.identity().primaryKey())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MSSQL):\n       *\n       * ```sql\n       * create table \"person\" (\n       *   \"id\" integer identity primary key\n       * )\n       * ```\n       */\n      identity() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));\n      }\n      /**\n       * Makes the column the primary key.\n       *\n       * If you want to specify a composite primary key use the\n       * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.primaryKey())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `id` integer primary key\n       * )\n       */\n      primaryKey() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));\n      }\n      /**\n       * Adds a foreign key constraint for the column.\n       *\n       * If your database engine doesn't support foreign key constraints in the\n       * column definition (like MySQL 5) you need to call the table level\n       * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('owner_id', 'integer', (col) => col.references('person.id'))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create table \"pet\" (\n       *   \"owner_id\" integer references \"person\" (\"id\")\n       * )\n       * ```\n       */\n      references(ref) {\n        const references = parseStringReference(ref);\n        if (!references.table || SelectAllNode.is(references.column)) {\n          throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);\n        }\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          references: ReferencesNode.create(references.table, [\n            references.column\n          ])\n        }));\n      }\n      /**\n       * Adds an `on delete` constraint for the foreign key column.\n       *\n       * If your database engine doesn't support foreign key constraints in the\n       * column definition (like MySQL 5) you need to call the table level\n       * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn(\n       *     'owner_id',\n       *     'integer',\n       *     (col) => col.references('person.id').onDelete('cascade')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create table \"pet\" (\n       *   \"owner_id\" integer references \"person\" (\"id\") on delete cascade\n       * )\n       * ```\n       */\n      onDelete(onDelete) {\n        if (!this.#node.references) {\n          throw new Error(\"on delete constraint can only be added for foreign keys\");\n        }\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))\n        }));\n      }\n      /**\n       * Adds an `on update` constraint for the foreign key column.\n       *\n       * If your database engine doesn't support foreign key constraints in the\n       * column definition (like MySQL 5) you need to call the table level\n       * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn(\n       *     'owner_id',\n       *     'integer',\n       *     (col) => col.references('person.id').onUpdate('cascade')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create table \"pet\" (\n       *   \"owner_id\" integer references \"person\" (\"id\") on update cascade\n       * )\n       * ```\n       */\n      onUpdate(onUpdate) {\n        if (!this.#node.references) {\n          throw new Error(\"on update constraint can only be added for foreign keys\");\n        }\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))\n        }));\n      }\n      /**\n       * Adds a unique constraint for the column.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('email', 'varchar(255)', col => col.unique())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `email` varchar(255) unique\n       * )\n       * ```\n       */\n      unique() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));\n      }\n      /**\n       * Adds a `not null` constraint for the column.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('first_name', 'varchar(255)', col => col.notNull())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `first_name` varchar(255) not null\n       * )\n       * ```\n       */\n      notNull() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));\n      }\n      /**\n       * Adds a `unsigned` modifier for the column.\n       *\n       * This only works on some dialects like MySQL.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('age', 'integer', col => col.unsigned())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `age` integer unsigned\n       * )\n       * ```\n       */\n      unsigned() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));\n      }\n      /**\n       * Adds a default value constraint for the column.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `pet` (\n       *   `number_of_legs` integer default 4\n       * )\n       * ```\n       *\n       * Values passed to `defaultTo` are interpreted as value literals by default. You can define\n       * an arbitrary SQL expression using the {@link sql} template tag:\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn(\n       *     'created_at',\n       *     'timestamp',\n       *     (col) => col.defaultTo(sql`CURRENT_TIMESTAMP`)\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `pet` (\n       *   `created_at` timestamp default CURRENT_TIMESTAMP\n       * )\n       * ```\n       */\n      defaultTo(value2) {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value2))\n        }));\n      }\n      /**\n       * Adds a check constraint for the column.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('number_of_legs', 'integer', (col) =>\n       *     col.check(sql`number_of_legs < 5`)\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `pet` (\n       *   `number_of_legs` integer check (number_of_legs < 5)\n       * )\n       * ```\n       */\n      check(expression) {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          check: CheckConstraintNode.create(expression.toOperationNode())\n        }));\n      }\n      /**\n       * Makes the column a generated column using a `generated always as` statement.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('full_name', 'varchar(255)',\n       *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name))\n       * )\n       * ```\n       */\n      generatedAlwaysAs(expression) {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          generated: GeneratedNode.createWithExpression(expression.toOperationNode())\n        }));\n      }\n      /**\n       * Adds the `generated always as identity` specifier.\n       *\n       * This only works on some dialects like PostgreSQL.\n       *\n       * For MS SQL Server (MSSQL)'s identity column use {@link identity}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.generatedAlwaysAsIdentity().primaryKey())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create table \"person\" (\n       *   \"id\" integer generated always as identity primary key\n       * )\n       * ```\n       */\n      generatedAlwaysAsIdentity() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          generated: GeneratedNode.create({ identity: true, always: true })\n        }));\n      }\n      /**\n       * Adds the `generated by default as identity` specifier on supported dialects.\n       *\n       * This only works on some dialects like PostgreSQL.\n       *\n       * For MS SQL Server (MSSQL)'s identity column use {@link identity}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.generatedByDefaultAsIdentity().primaryKey())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create table \"person\" (\n       *   \"id\" integer generated by default as identity primary key\n       * )\n       * ```\n       */\n      generatedByDefaultAsIdentity() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          generated: GeneratedNode.create({ identity: true, byDefault: true })\n        }));\n      }\n      /**\n       * Makes a generated column stored instead of virtual. This method can only\n       * be used with {@link generatedAlwaysAs}\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('full_name', 'varchar(255)', (col) => col\n       *     .generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)\n       *     .stored()\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name)) stored\n       * )\n       * ```\n       */\n      stored() {\n        if (!this.#node.generated) {\n          throw new Error(\"stored() can only be called after generatedAlwaysAs\");\n        }\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {\n          generated: GeneratedNode.cloneWith(this.#node.generated, {\n            stored: true\n          })\n        }));\n      }\n      /**\n       * This can be used to add any additional SQL right after the column's data type.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.primaryKey())\n       *   .addColumn(\n       *     'first_name',\n       *     'varchar(36)',\n       *     (col) => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull()\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `id` integer primary key,\n       *   `first_name` varchar(36) collate utf8mb4_general_ci not null\n       * )\n       * ```\n       */\n      modifyFront(modifier) {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));\n      }\n      /**\n       * Adds `nulls not distinct` specifier.\n       * Should be used with `unique` constraint.\n       *\n       * This only works on some dialects like PostgreSQL.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.primaryKey())\n       *   .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create table \"person\" (\n       *   \"id\" integer primary key,\n       *   \"first_name\" varchar(30) unique nulls not distinct\n       * )\n       * ```\n       */\n      nullsNotDistinct() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));\n      }\n      /**\n       * Adds `if not exists` specifier. This only works for PostgreSQL.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .alterTable('person')\n       *   .addColumn('email', 'varchar(255)', col => col.unique().ifNotExists())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * alter table \"person\" add column if not exists \"email\" varchar(255) unique\n       * ```\n       */\n      ifNotExists() {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the column definition.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.primaryKey())\n       *   .addColumn(\n       *     'age',\n       *     'integer',\n       *     col => col.unsigned()\n       *       .notNull()\n       *       .modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`)\n       *   )\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `id` integer primary key,\n       *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'\n       * )\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#node;\n      }\n    };\n    preventAwait(ColumnDefinitionBuilder, \"don't await ColumnDefinitionBuilder instances directly.\");\n    ModifyColumnNode = freeze({\n      is(node) {\n        return node.kind === \"ModifyColumnNode\";\n      },\n      create(column) {\n        return freeze({\n          kind: \"ModifyColumnNode\",\n          column\n        });\n      }\n    });\n    ForeignKeyConstraintNode = freeze({\n      is(node) {\n        return node.kind === \"ForeignKeyConstraintNode\";\n      },\n      create(sourceColumns, targetTable, targetColumns, constraintName) {\n        return freeze({\n          kind: \"ForeignKeyConstraintNode\",\n          columns: sourceColumns,\n          references: ReferencesNode.create(targetTable, targetColumns),\n          name: constraintName ? IdentifierNode.create(constraintName) : void 0\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      }\n    });\n    ForeignKeyConstraintBuilder = class _ForeignKeyConstraintBuilder {\n      static {\n        __name(this, \"ForeignKeyConstraintBuilder\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      onDelete(onDelete) {\n        return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {\n          onDelete: parseOnModifyForeignAction(onDelete)\n        }));\n      }\n      onUpdate(onUpdate) {\n        return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {\n          onUpdate: parseOnModifyForeignAction(onUpdate)\n        }));\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#node;\n      }\n    };\n    preventAwait(ForeignKeyConstraintBuilder, \"don't await ForeignKeyConstraintBuilder instances directly.\");\n    AddConstraintNode = freeze({\n      is(node) {\n        return node.kind === \"AddConstraintNode\";\n      },\n      create(constraint) {\n        return freeze({\n          kind: \"AddConstraintNode\",\n          constraint\n        });\n      }\n    });\n    UniqueConstraintNode = freeze({\n      is(node) {\n        return node.kind === \"UniqueConstraintNode\";\n      },\n      create(columns, constraintName, nullsNotDistinct) {\n        return freeze({\n          kind: \"UniqueConstraintNode\",\n          columns: freeze(columns.map(ColumnNode.create)),\n          name: constraintName ? IdentifierNode.create(constraintName) : void 0,\n          nullsNotDistinct\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      }\n    });\n    DropConstraintNode = freeze({\n      is(node) {\n        return node.kind === \"DropConstraintNode\";\n      },\n      create(constraintName) {\n        return freeze({\n          kind: \"DropConstraintNode\",\n          constraintName: IdentifierNode.create(constraintName)\n        });\n      },\n      cloneWith(dropConstraint, props) {\n        return freeze({\n          ...dropConstraint,\n          ...props\n        });\n      }\n    });\n    AlterColumnNode = freeze({\n      is(node) {\n        return node.kind === \"AlterColumnNode\";\n      },\n      create(column, prop, value2) {\n        return freeze({\n          kind: \"AlterColumnNode\",\n          column: ColumnNode.create(column),\n          [prop]: value2\n        });\n      }\n    });\n    AlterColumnBuilder = class {\n      static {\n        __name(this, \"AlterColumnBuilder\");\n      }\n      #column;\n      constructor(column) {\n        this.#column = column;\n      }\n      setDataType(dataType) {\n        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, \"dataType\", parseDataTypeExpression(dataType)));\n      }\n      setDefault(value2) {\n        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, \"setDefault\", parseDefaultValueExpression(value2)));\n      }\n      dropDefault() {\n        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, \"dropDefault\", true));\n      }\n      setNotNull() {\n        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, \"setNotNull\", true));\n      }\n      dropNotNull() {\n        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, \"dropNotNull\", true));\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n    };\n    preventAwait(AlterColumnBuilder, \"don't await AlterColumnBuilder instances\");\n    AlteredColumnBuilder = class {\n      static {\n        __name(this, \"AlteredColumnBuilder\");\n      }\n      #alterColumnNode;\n      constructor(alterColumnNode) {\n        this.#alterColumnNode = alterColumnNode;\n      }\n      toOperationNode() {\n        return this.#alterColumnNode;\n      }\n    };\n    preventAwait(AlteredColumnBuilder, \"don't await AlteredColumnBuilder instances\");\n    AlterTableExecutor = class {\n      static {\n        __name(this, \"AlterTableExecutor\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(AlterTableExecutor, \"don't await AlterTableExecutor instances directly. To execute the query you need to call `execute`\");\n    AlterTableAddForeignKeyConstraintBuilder = class _AlterTableAddForeignKeyConstraintBuilder {\n      static {\n        __name(this, \"AlterTableAddForeignKeyConstraintBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      onDelete(onDelete) {\n        return new _AlterTableAddForeignKeyConstraintBuilder({\n          ...this.#props,\n          constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)\n        });\n      }\n      onUpdate(onUpdate) {\n        return new _AlterTableAddForeignKeyConstraintBuilder({\n          ...this.#props,\n          constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {\n          addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())\n        }), this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(AlterTableAddForeignKeyConstraintBuilder, \"don't await AlterTableAddForeignKeyConstraintBuilder instances directly. To execute the query you need to call `execute`\");\n    AlterTableDropConstraintBuilder = class _AlterTableDropConstraintBuilder {\n      static {\n        __name(this, \"AlterTableDropConstraintBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      ifExists() {\n        return new _AlterTableDropConstraintBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {\n              ifExists: true\n            })\n          })\n        });\n      }\n      cascade() {\n        return new _AlterTableDropConstraintBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {\n              modifier: \"cascade\"\n            })\n          })\n        });\n      }\n      restrict() {\n        return new _AlterTableDropConstraintBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {\n              modifier: \"restrict\"\n            })\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(AlterTableDropConstraintBuilder, \"don't await AlterTableDropConstraintBuilder instances directly. To execute the query you need to call `execute`\");\n    PrimaryConstraintNode = freeze({\n      is(node) {\n        return node.kind === \"PrimaryKeyConstraintNode\";\n      },\n      create(columns, constraintName) {\n        return freeze({\n          kind: \"PrimaryKeyConstraintNode\",\n          columns: freeze(columns.map(ColumnNode.create)),\n          name: constraintName ? IdentifierNode.create(constraintName) : void 0\n        });\n      }\n    });\n    AddIndexNode = freeze({\n      is(node) {\n        return node.kind === \"AddIndexNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"AddIndexNode\",\n          name: IdentifierNode.create(name)\n        });\n      },\n      cloneWith(node, props) {\n        return freeze({\n          ...node,\n          ...props\n        });\n      },\n      cloneWithColumns(node, columns) {\n        return freeze({\n          ...node,\n          columns: [...node.columns || [], ...columns]\n        });\n      }\n    });\n    AlterTableAddIndexBuilder = class _AlterTableAddIndexBuilder {\n      static {\n        __name(this, \"AlterTableAddIndexBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Makes the index unique.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .alterTable('person')\n       *   .addIndex('person_first_name_index')\n       *   .unique()\n       *   .column('email')\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * alter table `person` add unique index `person_first_name_index` (`email`)\n       * ```\n       */\n      unique() {\n        return new _AlterTableAddIndexBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {\n              unique: true\n            })\n          })\n        });\n      }\n      /**\n       * Adds a column to the index.\n       *\n       * Also see {@link columns} for adding multiple columns at once or {@link expression}\n       * for specifying an arbitrary expression.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .alterTable('person')\n       *   .addIndex('person_first_name_and_age_index')\n       *   .column('first_name')\n       *   .column('age desc')\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)\n       * ```\n       */\n      column(column) {\n        return new _AlterTableAddIndexBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [\n              parseOrderedColumnName(column)\n            ])\n          })\n        });\n      }\n      /**\n       * Specifies a list of columns for the index.\n       *\n       * Also see {@link column} for adding a single column or {@link expression} for\n       * specifying an arbitrary expression.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .alterTable('person')\n       *   .addIndex('person_first_name_and_age_index')\n       *   .columns(['first_name', 'age desc'])\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)\n       * ```\n       */\n      columns(columns) {\n        return new _AlterTableAddIndexBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))\n          })\n        });\n      }\n      /**\n       * Specifies an arbitrary expression for the index.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .alterTable('person')\n       *   .addIndex('person_first_name_index')\n       *   .expression(sql<boolean>`(first_name < 'Sami')`)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))\n       * ```\n       */\n      expression(expression) {\n        return new _AlterTableAddIndexBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [\n              expression.toOperationNode()\n            ])\n          })\n        });\n      }\n      using(indexType) {\n        return new _AlterTableAddIndexBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {\n              using: RawNode.createWithSql(indexType)\n            })\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(AlterTableAddIndexBuilder, \"don't await AlterTableAddIndexBuilder instances directly. To execute the query you need to call `execute`\");\n    UniqueConstraintNodeBuilder = class _UniqueConstraintNodeBuilder {\n      static {\n        __name(this, \"UniqueConstraintNodeBuilder\");\n      }\n      #node;\n      constructor(node) {\n        this.#node = node;\n      }\n      toOperationNode() {\n        return this.#node;\n      }\n      /**\n       * Adds `nulls not distinct` to the unique constraint definition\n       *\n       * Supported by PostgreSQL dialect only\n       */\n      nullsNotDistinct() {\n        return new _UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));\n      }\n    };\n    preventAwait(UniqueConstraintNodeBuilder, \"don't await UniqueConstraintNodeBuilder instances directly.\");\n    AlterTableBuilder = class {\n      static {\n        __name(this, \"AlterTableBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      renameTo(newTableName) {\n        return new AlterTableExecutor({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            renameTo: parseTable(newTableName)\n          })\n        });\n      }\n      setSchema(newSchema) {\n        return new AlterTableExecutor({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            setSchema: IdentifierNode.create(newSchema)\n          })\n        });\n      }\n      alterColumn(column, alteration) {\n        const builder = alteration(new AlterColumnBuilder(column));\n        return new AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())\n        });\n      }\n      dropColumn(column) {\n        return new AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))\n        });\n      }\n      renameColumn(column, newColumn) {\n        return new AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))\n        });\n      }\n      addColumn(columnName, dataType, build2 = noop2) {\n        const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));\n        return new AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))\n        });\n      }\n      modifyColumn(columnName, dataType, build2 = noop2) {\n        const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));\n        return new AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))\n        });\n      }\n      /**\n       * See {@link CreateTableBuilder.addUniqueConstraint}\n       */\n      addUniqueConstraint(constraintName, columns, build2 = noop2) {\n        const uniqueConstraintBuilder = build2(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));\n        return new AlterTableExecutor({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())\n          })\n        });\n      }\n      /**\n       * See {@link CreateTableBuilder.addCheckConstraint}\n       */\n      addCheckConstraint(constraintName, checkExpression) {\n        return new AlterTableExecutor({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addConstraint: AddConstraintNode.create(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))\n          })\n        });\n      }\n      /**\n       * See {@link CreateTableBuilder.addForeignKeyConstraint}\n       *\n       * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns\n       * the constraint builder and doesn't take a callback as the last argument. This\n       * is because you can only add one column per `ALTER TABLE` query.\n       */\n      addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns) {\n        return new AlterTableAddForeignKeyConstraintBuilder({\n          ...this.#props,\n          constraintBuilder: new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName))\n        });\n      }\n      /**\n       * See {@link CreateTableBuilder.addPrimaryKeyConstraint}\n       */\n      addPrimaryKeyConstraint(constraintName, columns) {\n        return new AlterTableExecutor({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addConstraint: AddConstraintNode.create(PrimaryConstraintNode.create(columns, constraintName))\n          })\n        });\n      }\n      dropConstraint(constraintName) {\n        return new AlterTableDropConstraintBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            dropConstraint: DropConstraintNode.create(constraintName)\n          })\n        });\n      }\n      /**\n       * This can be used to add index to table.\n       *\n       *  ### Examples\n       *\n       * ```ts\n       * db.schema.alterTable('person')\n       *   .addIndex('person_email_index')\n       *   .column('email')\n       *   .unique()\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * alter table `person` add unique index `person_email_index` (`email`)\n       * ```\n       */\n      addIndex(indexName) {\n        return new AlterTableAddIndexBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            addIndex: AddIndexNode.create(indexName)\n          })\n        });\n      }\n      /**\n       * This can be used to drop index from table.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * db.schema.alterTable('person')\n       *   .dropIndex('person_email_index')\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * alter table `person` drop index `test_first_name_index`\n       * ```\n       */\n      dropIndex(indexName) {\n        return new AlterTableExecutor({\n          ...this.#props,\n          node: AlterTableNode.cloneWithTableProps(this.#props.node, {\n            dropIndex: DropIndexNode.create(indexName)\n          })\n        });\n      }\n      /**\n       * Calls the given function passing `this` as the only argument.\n       *\n       * See {@link CreateTableBuilder.$call}\n       */\n      $call(func) {\n        return func(this);\n      }\n    };\n    preventAwait(AlterTableBuilder, \"don't await AlterTableBuilder instances\");\n    AlterTableColumnAlteringBuilder = class _AlterTableColumnAlteringBuilder {\n      static {\n        __name(this, \"AlterTableColumnAlteringBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      alterColumn(column, alteration) {\n        const builder = alteration(new AlterColumnBuilder(column));\n        return new _AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())\n        });\n      }\n      dropColumn(column) {\n        return new _AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))\n        });\n      }\n      renameColumn(column, newColumn) {\n        return new _AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))\n        });\n      }\n      addColumn(columnName, dataType, build2 = noop2) {\n        const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));\n        return new _AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))\n        });\n      }\n      modifyColumn(columnName, dataType, build2 = noop2) {\n        const builder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));\n        return new _AlterTableColumnAlteringBuilder({\n          ...this.#props,\n          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))\n        });\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(AlterTableColumnAlteringBuilder, \"don't await AlterTableColumnAlteringBuilder instances directly. To execute the query you need to call `execute`\");\n    ImmediateValueTransformer = class extends OperationNodeTransformer {\n      static {\n        __name(this, \"ImmediateValueTransformer\");\n      }\n      transformValue(node) {\n        return {\n          ...super.transformValue(node),\n          immediate: true\n        };\n      }\n    };\n    CreateIndexBuilder = class _CreateIndexBuilder {\n      static {\n        __name(this, \"CreateIndexBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Adds the \"if not exists\" modifier.\n       *\n       * If the index already exists, no error is thrown if this method has been called.\n       */\n      ifNotExists() {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWith(this.#props.node, {\n            ifNotExists: true\n          })\n        });\n      }\n      /**\n       * Makes the index unique.\n       */\n      unique() {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWith(this.#props.node, {\n            unique: true\n          })\n        });\n      }\n      /**\n       * Adds `nulls not distinct` specifier to index.\n       * This only works on some dialects like PostgreSQL.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * db.schema.createIndex('person_first_name_index')\n       *  .on('person')\n       *  .column('first_name')\n       *  .nullsNotDistinct()\n       *  .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create index \"person_first_name_index\"\n       * on \"test\" (\"first_name\")\n       * nulls not distinct;\n       * ```\n       */\n      nullsNotDistinct() {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWith(this.#props.node, {\n            nullsNotDistinct: true\n          })\n        });\n      }\n      /**\n       * Specifies the table for the index.\n       */\n      on(table3) {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWith(this.#props.node, {\n            table: parseTable(table3)\n          })\n        });\n      }\n      /**\n       * Adds a column to the index.\n       *\n       * Also see {@link columns} for adding multiple columns at once or {@link expression}\n       * for specifying an arbitrary expression.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *         .createIndex('person_first_name_and_age_index')\n       *         .on('person')\n       *         .column('first_name')\n       *         .column('age desc')\n       *         .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create index \"person_first_name_and_age_index\" on \"person\" (\"first_name\", \"age\" desc)\n       * ```\n       */\n      column(column) {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWithColumns(this.#props.node, [\n            parseOrderedColumnName(column)\n          ])\n        });\n      }\n      /**\n       * Specifies a list of columns for the index.\n       *\n       * Also see {@link column} for adding a single column or {@link expression} for\n       * specifying an arbitrary expression.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *         .createIndex('person_first_name_and_age_index')\n       *         .on('person')\n       *         .columns(['first_name', 'age desc'])\n       *         .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create index \"person_first_name_and_age_index\" on \"person\" (\"first_name\", \"age\" desc)\n       * ```\n       */\n      columns(columns) {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))\n        });\n      }\n      /**\n       * Specifies an arbitrary expression for the index.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createIndex('person_first_name_index')\n       *   .on('person')\n       *   .expression(sql`first_name COLLATE \"fi_FI\"`)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create index \"person_first_name_index\" on \"person\" (first_name COLLATE \"fi_FI\")\n       * ```\n       */\n      expression(expression) {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWithColumns(this.#props.node, [\n            expression.toOperationNode()\n          ])\n        });\n      }\n      using(indexType) {\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: CreateIndexNode.cloneWith(this.#props.node, {\n            using: RawNode.createWithSql(indexType)\n          })\n        });\n      }\n      where(...args) {\n        const transformer = new ImmediateValueTransformer();\n        return new _CreateIndexBuilder({\n          ...this.#props,\n          node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args)))\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(CreateIndexBuilder, \"don't await CreateIndexBuilder instances directly. To execute the query you need to call `execute`\");\n    CreateSchemaBuilder = class _CreateSchemaBuilder {\n      static {\n        __name(this, \"CreateSchemaBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      ifNotExists() {\n        return new _CreateSchemaBuilder({\n          ...this.#props,\n          node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(CreateSchemaBuilder, \"don't await CreateSchemaBuilder instances directly. To execute the query you need to call `execute`\");\n    __name(parseOnCommitAction, \"parseOnCommitAction\");\n    CreateTableBuilder = class _CreateTableBuilder {\n      static {\n        __name(this, \"CreateTableBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Adds the \"temporary\" modifier.\n       *\n       * Use this to create a temporary table.\n       */\n      temporary() {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWith(this.#props.node, {\n            temporary: true\n          })\n        });\n      }\n      /**\n       * Adds an \"on commit\" statement.\n       *\n       * This can be used in conjunction with temporary tables on supported databases\n       * like PostgreSQL.\n       */\n      onCommit(onCommit) {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWith(this.#props.node, {\n            onCommit: parseOnCommitAction(onCommit)\n          })\n        });\n      }\n      /**\n       * Adds the \"if not exists\" modifier.\n       *\n       * If the table already exists, no error is thrown if this method has been called.\n       */\n      ifNotExists() {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWith(this.#props.node, {\n            ifNotExists: true\n          })\n        });\n      }\n      /**\n       * Adds a column to the table.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())\n       *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())\n       *   .addColumn('last_name', 'varchar(255)')\n       *   .addColumn('bank_balance', 'numeric(8, 2)')\n       *   // You can specify any data type using the `sql` tag if the types\n       *   // don't include it.\n       *   .addColumn('data', sql`any_type_here`)\n       *   .addColumn('parent_id', 'integer', (col) =>\n       *     col.references('person.id').onDelete('cascade')\n       *   )\n       * ```\n       *\n       * With this method, it's once again good to remember that Kysely just builds the\n       * query and doesn't provide the same API for all databases. For example, some\n       * databases like older MySQL don't support the `references` statement in the\n       * column definition. Instead foreign key constraints need to be defined in the\n       * `create table` query. See the next example:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', (col) => col.primaryKey())\n       *   .addColumn('parent_id', 'integer')\n       *   .addForeignKeyConstraint(\n       *     'person_parent_id_fk',\n       *     ['parent_id'],\n       *     'person',\n       *     ['id'],\n       *     (cb) => cb.onDelete('cascade')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * Another good example is that PostgreSQL doesn't support the `auto_increment`\n       * keyword and you need to define an autoincrementing column for example using\n       * `serial`:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'serial', (col) => col.primaryKey())\n       *   .execute()\n       * ```\n       */\n      addColumn(columnName, dataType, build2 = noop2) {\n        const columnBuilder = build2(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())\n        });\n      }\n      /**\n       * Adds a primary key constraint for one or more columns.\n       *\n       * The constraint name can be anything you want, but it must be unique\n       * across the whole database.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('first_name', 'varchar(64)')\n       *   .addColumn('last_name', 'varchar(64)')\n       *   .addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])\n       *   .execute()\n       * ```\n       */\n      addPrimaryKeyConstraint(constraintName, columns) {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithConstraint(this.#props.node, PrimaryConstraintNode.create(columns, constraintName))\n        });\n      }\n      /**\n       * Adds a unique constraint for one or more columns.\n       *\n       * The constraint name can be anything you want, but it must be unique\n       * across the whole database.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('first_name', 'varchar(64)')\n       *   .addColumn('last_name', 'varchar(64)')\n       *   .addUniqueConstraint(\n       *     'first_name_last_name_unique',\n       *     ['first_name', 'last_name']\n       *   )\n       *   .execute()\n       * ```\n       *\n       * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('first_name', 'varchar(64)')\n       *   .addColumn('last_name', 'varchar(64)')\n       *   .addUniqueConstraint(\n       *     'first_name_last_name_unique',\n       *     ['first_name', 'last_name'],\n       *     (cb) => cb.nullsNotDistinct()\n       *   )\n       *   .execute()\n       * ```\n       */\n      addUniqueConstraint(constraintName, columns, build2 = noop2) {\n        const uniqueConstraintBuilder = build2(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())\n        });\n      }\n      /**\n       * Adds a check constraint.\n       *\n       * The constraint name can be anything you want, but it must be unique\n       * across the whole database.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('animal')\n       *   .addColumn('number_of_legs', 'integer')\n       *   .addCheckConstraint('check_legs', sql`number_of_legs < 5`)\n       *   .execute()\n       * ```\n       */\n      addCheckConstraint(constraintName, checkExpression) {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithConstraint(this.#props.node, CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))\n        });\n      }\n      /**\n       * Adds a foreign key constraint.\n       *\n       * The constraint name can be anything you want, but it must be unique\n       * across the whole database.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('owner_id', 'integer')\n       *   .addForeignKeyConstraint(\n       *     'owner_id_foreign',\n       *     ['owner_id'],\n       *     'person',\n       *     ['id'],\n       *   )\n       *   .execute()\n       * ```\n       *\n       * Add constraint for multiple columns:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('owner_id1', 'integer')\n       *   .addColumn('owner_id2', 'integer')\n       *   .addForeignKeyConstraint(\n       *     'owner_id_foreign',\n       *     ['owner_id1', 'owner_id2'],\n       *     'person',\n       *     ['id1', 'id2'],\n       *     (cb) => cb.onDelete('cascade')\n       *   )\n       *   .execute()\n       * ```\n       */\n      addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build2 = noop2) {\n        const builder = build2(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())\n        });\n      }\n      /**\n       * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.\n       *\n       * Also see {@link temporary}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .modifyFront(sql`global temporary`)\n       *   .addColumn('id', 'integer', col => col.primaryKey())\n       *   .addColumn('first_name', 'varchar(64)', col => col.notNull())\n       *   .addColumn('last_name', 'varchar(64)', col => col.notNull())\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (Postgres):\n       *\n       * ```sql\n       * create global temporary table \"person\" (\n       *   \"id\" integer primary key,\n       *   \"first_name\" varchar(64) not null,\n       *   \"last_name\" varchar(64) not null\n       * )\n       * ```\n       */\n      modifyFront(modifier) {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())\n        });\n      }\n      /**\n       * This can be used to add any additional SQL to the end of the query.\n       *\n       * Also see {@link onCommit}.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * import { sql } from 'kysely'\n       *\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.primaryKey())\n       *   .addColumn('first_name', 'varchar(64)', col => col.notNull())\n       *   .addColumn('last_name', 'varchar(64)', col => col.notNull())\n       *   .modifyEnd(sql`collate utf8_unicode_ci`)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (MySQL):\n       *\n       * ```sql\n       * create table `person` (\n       *   `id` integer primary key,\n       *   `first_name` varchar(64) not null,\n       *   `last_name` varchar(64) not null\n       * ) collate utf8_unicode_ci\n       * ```\n       */\n      modifyEnd(modifier) {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())\n        });\n      }\n      /**\n       * Allows to create table from `select` query.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('copy')\n       *   .temporary()\n       *   .as(db.selectFrom('person').select(['first_name', 'last_name']))\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * create temporary table \"copy\" as\n       * select \"first_name\", \"last_name\" from \"person\"\n       * ```\n       */\n      as(expression) {\n        return new _CreateTableBuilder({\n          ...this.#props,\n          node: CreateTableNode.cloneWith(this.#props.node, {\n            selectQuery: parseExpression(expression)\n          })\n        });\n      }\n      /**\n       * Calls the given function passing `this` as the only argument.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('test')\n       *   .$call((builder) => builder.addColumn('id', 'integer'))\n       *   .execute()\n       * ```\n       *\n       * This is useful for creating reusable functions that can be called with a builder.\n       *\n       * ```ts\n       * import { type CreateTableBuilder, sql } from 'kysely'\n       *\n       * const addDefaultColumns = (ctb: CreateTableBuilder<any, any>) => {\n       *   return ctb\n       *     .addColumn('id', 'integer', (col) => col.notNull())\n       *     .addColumn('created_at', 'date', (col) =>\n       *       col.notNull().defaultTo(sql`now()`)\n       *     )\n       *     .addColumn('updated_at', 'date', (col) =>\n       *       col.notNull().defaultTo(sql`now()`)\n       *     )\n       * }\n       *\n       * await db.schema\n       *   .createTable('test')\n       *   .$call(addDefaultColumns)\n       *   .execute()\n       * ```\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(CreateTableBuilder, \"don't await CreateTableBuilder instances directly. To execute the query you need to call `execute`\");\n    DropIndexBuilder = class _DropIndexBuilder {\n      static {\n        __name(this, \"DropIndexBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Specifies the table the index was created for. This is not needed\n       * in all dialects.\n       */\n      on(table3) {\n        return new _DropIndexBuilder({\n          ...this.#props,\n          node: DropIndexNode.cloneWith(this.#props.node, {\n            table: parseTable(table3)\n          })\n        });\n      }\n      ifExists() {\n        return new _DropIndexBuilder({\n          ...this.#props,\n          node: DropIndexNode.cloneWith(this.#props.node, {\n            ifExists: true\n          })\n        });\n      }\n      cascade() {\n        return new _DropIndexBuilder({\n          ...this.#props,\n          node: DropIndexNode.cloneWith(this.#props.node, {\n            cascade: true\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(DropIndexBuilder, \"don't await DropIndexBuilder instances directly. To execute the query you need to call `execute`\");\n    DropSchemaBuilder = class _DropSchemaBuilder {\n      static {\n        __name(this, \"DropSchemaBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      ifExists() {\n        return new _DropSchemaBuilder({\n          ...this.#props,\n          node: DropSchemaNode.cloneWith(this.#props.node, {\n            ifExists: true\n          })\n        });\n      }\n      cascade() {\n        return new _DropSchemaBuilder({\n          ...this.#props,\n          node: DropSchemaNode.cloneWith(this.#props.node, {\n            cascade: true\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(DropSchemaBuilder, \"don't await DropSchemaBuilder instances directly. To execute the query you need to call `execute`\");\n    DropTableBuilder = class _DropTableBuilder {\n      static {\n        __name(this, \"DropTableBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      ifExists() {\n        return new _DropTableBuilder({\n          ...this.#props,\n          node: DropTableNode.cloneWith(this.#props.node, {\n            ifExists: true\n          })\n        });\n      }\n      cascade() {\n        return new _DropTableBuilder({\n          ...this.#props,\n          node: DropTableNode.cloneWith(this.#props.node, {\n            cascade: true\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(DropTableBuilder, \"don't await DropTableBuilder instances directly. To execute the query you need to call `execute`\");\n    CreateViewNode = freeze({\n      is(node) {\n        return node.kind === \"CreateViewNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"CreateViewNode\",\n          name: SchemableIdentifierNode.create(name)\n        });\n      },\n      cloneWith(createView, params) {\n        return freeze({\n          ...createView,\n          ...params\n        });\n      }\n    });\n    ImmediateValuePlugin = class {\n      static {\n        __name(this, \"ImmediateValuePlugin\");\n      }\n      #transformer = new ImmediateValueTransformer();\n      transformQuery(args) {\n        return this.#transformer.transformNode(args.node);\n      }\n      transformResult(args) {\n        return Promise.resolve(args.result);\n      }\n    };\n    CreateViewBuilder = class _CreateViewBuilder {\n      static {\n        __name(this, \"CreateViewBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      /**\n       * Adds the \"temporary\" modifier.\n       *\n       * Use this to create a temporary view.\n       */\n      temporary() {\n        return new _CreateViewBuilder({\n          ...this.#props,\n          node: CreateViewNode.cloneWith(this.#props.node, {\n            temporary: true\n          })\n        });\n      }\n      materialized() {\n        return new _CreateViewBuilder({\n          ...this.#props,\n          node: CreateViewNode.cloneWith(this.#props.node, {\n            materialized: true\n          })\n        });\n      }\n      /**\n       * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.\n       */\n      ifNotExists() {\n        return new _CreateViewBuilder({\n          ...this.#props,\n          node: CreateViewNode.cloneWith(this.#props.node, {\n            ifNotExists: true\n          })\n        });\n      }\n      orReplace() {\n        return new _CreateViewBuilder({\n          ...this.#props,\n          node: CreateViewNode.cloneWith(this.#props.node, {\n            orReplace: true\n          })\n        });\n      }\n      columns(columns) {\n        return new _CreateViewBuilder({\n          ...this.#props,\n          node: CreateViewNode.cloneWith(this.#props.node, {\n            columns: columns.map(parseColumnName)\n          })\n        });\n      }\n      /**\n       * Sets the select query or a `values` statement that creates the view.\n       *\n       * WARNING!\n       * Some dialects don't support parameterized queries in DDL statements and therefore\n       * the query or raw {@link sql } expression passed here is interpolated into a single\n       * string opening an SQL injection vulnerability. DO NOT pass unchecked user input\n       * into the query or raw expression passed to this method!\n       */\n      as(query) {\n        const queryNode = query.withPlugin(new ImmediateValuePlugin()).toOperationNode();\n        return new _CreateViewBuilder({\n          ...this.#props,\n          node: CreateViewNode.cloneWith(this.#props.node, {\n            as: queryNode\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(CreateViewBuilder, \"don't await CreateViewBuilder instances directly. To execute the query you need to call `execute`\");\n    DropViewNode = freeze({\n      is(node) {\n        return node.kind === \"DropViewNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"DropViewNode\",\n          name: SchemableIdentifierNode.create(name)\n        });\n      },\n      cloneWith(dropView, params) {\n        return freeze({\n          ...dropView,\n          ...params\n        });\n      }\n    });\n    DropViewBuilder = class _DropViewBuilder {\n      static {\n        __name(this, \"DropViewBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      materialized() {\n        return new _DropViewBuilder({\n          ...this.#props,\n          node: DropViewNode.cloneWith(this.#props.node, {\n            materialized: true\n          })\n        });\n      }\n      ifExists() {\n        return new _DropViewBuilder({\n          ...this.#props,\n          node: DropViewNode.cloneWith(this.#props.node, {\n            ifExists: true\n          })\n        });\n      }\n      cascade() {\n        return new _DropViewBuilder({\n          ...this.#props,\n          node: DropViewNode.cloneWith(this.#props.node, {\n            cascade: true\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(DropViewBuilder, \"don't await DropViewBuilder instances directly. To execute the query you need to call `execute`\");\n    CreateTypeNode = freeze({\n      is(node) {\n        return node.kind === \"CreateTypeNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"CreateTypeNode\",\n          name\n        });\n      },\n      cloneWithEnum(createType, values) {\n        return freeze({\n          ...createType,\n          enum: ValueListNode.create(values.map((value2) => ValueNode.createImmediate(value2)))\n        });\n      }\n    });\n    CreateTypeBuilder = class _CreateTypeBuilder {\n      static {\n        __name(this, \"CreateTypeBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      /**\n       * Creates an anum type.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])\n       * ```\n       */\n      asEnum(values) {\n        return new _CreateTypeBuilder({\n          ...this.#props,\n          node: CreateTypeNode.cloneWithEnum(this.#props.node, values)\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(CreateTypeBuilder, \"don't await CreateTypeBuilder instances directly. To execute the query you need to call `execute`\");\n    DropTypeNode = freeze({\n      is(node) {\n        return node.kind === \"DropTypeNode\";\n      },\n      create(name) {\n        return freeze({\n          kind: \"DropTypeNode\",\n          name\n        });\n      },\n      cloneWith(dropType, params) {\n        return freeze({\n          ...dropType,\n          ...params\n        });\n      }\n    });\n    DropTypeBuilder = class _DropTypeBuilder {\n      static {\n        __name(this, \"DropTypeBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      ifExists() {\n        return new _DropTypeBuilder({\n          ...this.#props,\n          node: DropTypeNode.cloneWith(this.#props.node, {\n            ifExists: true\n          })\n        });\n      }\n      /**\n       * Simply calls the provided function passing `this` as the only argument. `$call` returns\n       * what the provided function returns.\n       */\n      $call(func) {\n        return func(this);\n      }\n      toOperationNode() {\n        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);\n      }\n      compile() {\n        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);\n      }\n      async execute() {\n        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);\n      }\n    };\n    preventAwait(DropTypeBuilder, \"don't await DropTypeBuilder instances directly. To execute the query you need to call `execute`\");\n    __name(parseSchemableIdentifier, \"parseSchemableIdentifier\");\n    __name(trim, \"trim\");\n    SchemaModule = class _SchemaModule {\n      static {\n        __name(this, \"SchemaModule\");\n      }\n      #executor;\n      constructor(executor) {\n        this.#executor = executor;\n      }\n      /**\n       * Create a new table.\n       *\n       * ### Examples\n       *\n       * This example creates a new table with columns `id`, `first_name`,\n       * `last_name` and `gender`:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('person')\n       *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())\n       *   .addColumn('first_name', 'varchar', col => col.notNull())\n       *   .addColumn('last_name', 'varchar', col => col.notNull())\n       *   .addColumn('gender', 'varchar')\n       *   .execute()\n       * ```\n       *\n       * This example creates a table with a foreign key. Not all database\n       * engines support column-level foreign key constraint definitions.\n       * For example if you are using MySQL 5.X see the next example after\n       * this one.\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())\n       *   .addColumn('owner_id', 'integer', col => col\n       *     .references('person.id')\n       *     .onDelete('cascade')\n       *   )\n       *   .execute()\n       * ```\n       *\n       * This example adds a foreign key constraint for a columns just\n       * like the previous example, but using a table-level statement.\n       * On MySQL 5.X you need to define foreign key constraints like\n       * this:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('pet')\n       *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())\n       *   .addColumn('owner_id', 'integer')\n       *   .addForeignKeyConstraint(\n       *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],\n       *     (constraint) => constraint.onDelete('cascade')\n       *   )\n       *   .execute()\n       * ```\n       */\n      createTable(table3) {\n        return new CreateTableBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: CreateTableNode.create(parseTable(table3))\n        });\n      }\n      /**\n       * Drop a table.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .dropTable('person')\n       *   .execute()\n       * ```\n       */\n      dropTable(table3) {\n        return new DropTableBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: DropTableNode.create(parseTable(table3))\n        });\n      }\n      /**\n       * Create a new index.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createIndex('person_full_name_unique_index')\n       *   .on('person')\n       *   .columns(['first_name', 'last_name'])\n       *   .execute()\n       * ```\n       */\n      createIndex(indexName) {\n        return new CreateIndexBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: CreateIndexNode.create(indexName)\n        });\n      }\n      /**\n       * Drop an index.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .dropIndex('person_full_name_unique_index')\n       *   .execute()\n       * ```\n       */\n      dropIndex(indexName) {\n        return new DropIndexBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: DropIndexNode.create(indexName)\n        });\n      }\n      /**\n       * Create a new schema.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createSchema('some_schema')\n       *   .execute()\n       * ```\n       */\n      createSchema(schema2) {\n        return new CreateSchemaBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: CreateSchemaNode.create(schema2)\n        });\n      }\n      /**\n       * Drop a schema.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .dropSchema('some_schema')\n       *   .execute()\n       * ```\n       */\n      dropSchema(schema2) {\n        return new DropSchemaBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: DropSchemaNode.create(schema2)\n        });\n      }\n      /**\n       * Alter a table.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .alterTable('person')\n       *   .alterColumn('first_name', (ac) => ac.setDataType('text'))\n       *   .execute()\n       * ```\n       */\n      alterTable(table3) {\n        return new AlterTableBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: AlterTableNode.create(parseTable(table3))\n        });\n      }\n      /**\n       * Create a new view.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createView('dogs')\n       *   .orReplace()\n       *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))\n       *   .execute()\n       * ```\n       */\n      createView(viewName) {\n        return new CreateViewBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: CreateViewNode.create(viewName)\n        });\n      }\n      /**\n       * Drop a view.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .dropView('dogs')\n       *   .ifExists()\n       *   .execute()\n       * ```\n       */\n      dropView(viewName) {\n        return new DropViewBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: DropViewNode.create(viewName)\n        });\n      }\n      /**\n       * Create a new type.\n       *\n       * Only some dialects like PostgreSQL have user-defined types.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .createType('species')\n       *   .asEnum(['dog', 'cat', 'frog'])\n       *   .execute()\n       * ```\n       */\n      createType(typeName) {\n        return new CreateTypeBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: CreateTypeNode.create(parseSchemableIdentifier(typeName))\n        });\n      }\n      /**\n       * Drop a type.\n       *\n       * Only some dialects like PostgreSQL have user-defined types.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db.schema\n       *   .dropType('species')\n       *   .ifExists()\n       *   .execute()\n       * ```\n       */\n      dropType(typeName) {\n        return new DropTypeBuilder({\n          queryId: createQueryId(),\n          executor: this.#executor,\n          node: DropTypeNode.create(parseSchemableIdentifier(typeName))\n        });\n      }\n      /**\n       * Returns a copy of this schema module with the given plugin installed.\n       */\n      withPlugin(plugin) {\n        return new _SchemaModule(this.#executor.withPlugin(plugin));\n      }\n      /**\n       * Returns a copy of this schema module  without any plugins.\n       */\n      withoutPlugins() {\n        return new _SchemaModule(this.#executor.withoutPlugins());\n      }\n      /**\n       * See {@link QueryCreator.withSchema}\n       */\n      withSchema(schema2) {\n        return new _SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema2)));\n      }\n    };\n    DynamicModule = class {\n      static {\n        __name(this, \"DynamicModule\");\n      }\n      /**\n       * Creates a dynamic reference to a column that is not know at compile time.\n       *\n       * Kysely is built in a way that by default you can't refer to tables or columns\n       * that are not actually visible in the current query and context. This is all\n       * done by TypeScript at compile time, which means that you need to know the\n       * columns and tables at compile time. This is not always the case of course.\n       *\n       * This method is meant to be used in those cases where the column names\n       * come from the user input or are not otherwise known at compile time.\n       *\n       * WARNING! Unlike values, column names are not escaped by the database engine\n       * or Kysely and if you pass in unchecked column names using this method, you\n       * create an SQL injection vulnerability. Always __always__ validate the user\n       * input before passing it to this method.\n       *\n       * There are couple of examples below for some use cases, but you can pass\n       * `ref` to other methods as well. If the types allow you to pass a `ref`\n       * value to some place, it should work.\n       *\n       * ### Examples\n       *\n       * Filter by a column not know at compile time:\n       *\n       * ```ts\n       * async function someQuery(filterColumn: string, filterValue: string) {\n       *   const { ref } = db.dynamic\n       *\n       *   return await db\n       *     .selectFrom('person')\n       *     .selectAll()\n       *     .where(ref(filterColumn), '=', filterValue)\n       *     .execute()\n       * }\n       *\n       * someQuery('first_name', 'Arnold')\n       * someQuery('person.last_name', 'Aniston')\n       * ```\n       *\n       * Order by a column not know at compile time:\n       *\n       * ```ts\n       * async function someQuery(orderBy: string) {\n       *   const { ref } = db.dynamic\n       *\n       *   return await db\n       *     .selectFrom('person')\n       *     .select('person.first_name as fn')\n       *     .orderBy(ref(orderBy))\n       *     .execute()\n       * }\n       *\n       * someQuery('fn')\n       * ```\n       *\n       * In this example we add selections dynamically:\n       *\n       * ```ts\n       * const { ref } = db.dynamic\n       *\n       * // Some column name provided by the user. Value not known at compile time.\n       * const columnFromUserInput: PossibleColumns = 'birthdate';\n       *\n       * // A type that lists all possible values `columnFromUserInput` can have.\n       * // You can use `keyof Person` if any column of an interface is allowed.\n       * type PossibleColumns = 'last_name' | 'first_name' | 'birthdate'\n       *\n       * const [person] = await db.selectFrom('person')\n       *   .select([\n       *     ref<PossibleColumns>(columnFromUserInput),\n       *     'id'\n       *   ])\n       *   .execute()\n       *\n       * // The resulting type contains all `PossibleColumns` as optional fields\n       * // because we cannot know which field was actually selected before\n       * // running the code.\n       * const lastName: string | null | undefined = person?.last_name\n       * const firstName: string | undefined = person?.first_name\n       * const birthDate: Date | null | undefined = person?.birthdate\n       *\n       * // The result type also contains the compile time selection `id`.\n       * person?.id\n       * ```\n       */\n      ref(reference) {\n        return new DynamicReferenceBuilder(reference);\n      }\n    };\n    DefaultConnectionProvider = class {\n      static {\n        __name(this, \"DefaultConnectionProvider\");\n      }\n      #driver;\n      constructor(driver) {\n        this.#driver = driver;\n      }\n      async provideConnection(consumer) {\n        const connection = await this.#driver.acquireConnection();\n        try {\n          return await consumer(connection);\n        } finally {\n          await this.#driver.releaseConnection(connection);\n        }\n      }\n    };\n    DefaultQueryExecutor = class _DefaultQueryExecutor extends QueryExecutorBase {\n      static {\n        __name(this, \"DefaultQueryExecutor\");\n      }\n      #compiler;\n      #adapter;\n      #connectionProvider;\n      constructor(compiler, adapter, connectionProvider, plugins = []) {\n        super(plugins);\n        this.#compiler = compiler;\n        this.#adapter = adapter;\n        this.#connectionProvider = connectionProvider;\n      }\n      get adapter() {\n        return this.#adapter;\n      }\n      compileQuery(node) {\n        return this.#compiler.compileQuery(node);\n      }\n      provideConnection(consumer) {\n        return this.#connectionProvider.provideConnection(consumer);\n      }\n      withPlugins(plugins) {\n        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);\n      }\n      withPlugin(plugin) {\n        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin]);\n      }\n      withPluginAtFront(plugin) {\n        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin, ...this.plugins]);\n      }\n      withConnectionProvider(connectionProvider) {\n        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);\n      }\n      withoutPlugins() {\n        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);\n      }\n    };\n    __name(performanceNow, \"performanceNow\");\n    RuntimeDriver = class {\n      static {\n        __name(this, \"RuntimeDriver\");\n      }\n      #driver;\n      #log;\n      #initPromise;\n      #initDone;\n      #destroyPromise;\n      #connections = /* @__PURE__ */ new WeakSet();\n      constructor(driver, log4) {\n        this.#initDone = false;\n        this.#driver = driver;\n        this.#log = log4;\n      }\n      async init() {\n        if (this.#destroyPromise) {\n          throw new Error(\"driver has already been destroyed\");\n        }\n        if (!this.#initPromise) {\n          this.#initPromise = this.#driver.init().then(() => {\n            this.#initDone = true;\n          }).catch((err) => {\n            this.#initPromise = void 0;\n            return Promise.reject(err);\n          });\n        }\n        await this.#initPromise;\n      }\n      async acquireConnection() {\n        if (this.#destroyPromise) {\n          throw new Error(\"driver has already been destroyed\");\n        }\n        if (!this.#initDone) {\n          await this.init();\n        }\n        const connection = await this.#driver.acquireConnection();\n        if (!this.#connections.has(connection)) {\n          if (this.#needsLogging()) {\n            this.#addLogging(connection);\n          }\n          this.#connections.add(connection);\n        }\n        return connection;\n      }\n      async releaseConnection(connection) {\n        await this.#driver.releaseConnection(connection);\n      }\n      beginTransaction(connection, settings) {\n        return this.#driver.beginTransaction(connection, settings);\n      }\n      commitTransaction(connection) {\n        return this.#driver.commitTransaction(connection);\n      }\n      rollbackTransaction(connection) {\n        return this.#driver.rollbackTransaction(connection);\n      }\n      async destroy() {\n        if (!this.#initPromise) {\n          return;\n        }\n        await this.#initPromise;\n        if (!this.#destroyPromise) {\n          this.#destroyPromise = this.#driver.destroy().catch((err) => {\n            this.#destroyPromise = void 0;\n            return Promise.reject(err);\n          });\n        }\n        await this.#destroyPromise;\n      }\n      #needsLogging() {\n        return this.#log.isLevelEnabled(\"query\") || this.#log.isLevelEnabled(\"error\");\n      }\n      // This method monkey patches the database connection's executeQuery method\n      // by adding logging code around it. Monkey patching is not pretty, but it's\n      // the best option in this case.\n      #addLogging(connection) {\n        const executeQuery = connection.executeQuery;\n        connection.executeQuery = async (compiledQuery) => {\n          let caughtError;\n          const startTime = performanceNow();\n          try {\n            return await executeQuery.call(connection, compiledQuery);\n          } catch (error4) {\n            caughtError = error4;\n            await this.#logError(error4, compiledQuery, startTime);\n            throw error4;\n          } finally {\n            if (!caughtError) {\n              await this.#logQuery(compiledQuery, startTime);\n            }\n          }\n        };\n      }\n      async #logError(error4, compiledQuery, startTime) {\n        await this.#log.error(() => ({\n          level: \"error\",\n          error: error4,\n          query: compiledQuery,\n          queryDurationMillis: this.#calculateDurationMillis(startTime)\n        }));\n      }\n      async #logQuery(compiledQuery, startTime) {\n        await this.#log.query(() => ({\n          level: \"query\",\n          query: compiledQuery,\n          queryDurationMillis: this.#calculateDurationMillis(startTime)\n        }));\n      }\n      #calculateDurationMillis(startTime) {\n        return performanceNow() - startTime;\n      }\n    };\n    ignoreError = /* @__PURE__ */ __name(() => {\n    }, \"ignoreError\");\n    SingleConnectionProvider = class {\n      static {\n        __name(this, \"SingleConnectionProvider\");\n      }\n      #connection;\n      #runningPromise;\n      constructor(connection) {\n        this.#connection = connection;\n      }\n      async provideConnection(consumer) {\n        while (this.#runningPromise) {\n          await this.#runningPromise.catch(ignoreError);\n        }\n        this.#runningPromise = this.#run(consumer).finally(() => {\n          this.#runningPromise = void 0;\n        });\n        return this.#runningPromise;\n      }\n      // Run the runner in an async function to make sure it doesn't\n      // throw synchronous errors.\n      async #run(runner) {\n        return await runner(this.#connection);\n      }\n    };\n    TRANSACTION_ISOLATION_LEVELS = [\n      \"read uncommitted\",\n      \"read committed\",\n      \"repeatable read\",\n      \"serializable\",\n      \"snapshot\"\n    ];\n    freeze([\"query\", \"error\"]);\n    Log = class {\n      static {\n        __name(this, \"Log\");\n      }\n      #levels;\n      #logger;\n      constructor(config3) {\n        if (isFunction(config3)) {\n          this.#logger = config3;\n          this.#levels = freeze({\n            query: true,\n            error: true\n          });\n        } else {\n          this.#logger = defaultLogger;\n          this.#levels = freeze({\n            query: config3.includes(\"query\"),\n            error: config3.includes(\"error\")\n          });\n        }\n      }\n      isLevelEnabled(level) {\n        return this.#levels[level];\n      }\n      async query(getEvent) {\n        if (this.#levels.query) {\n          await this.#logger(getEvent());\n        }\n      }\n      async error(getEvent) {\n        if (this.#levels.error) {\n          await this.#logger(getEvent());\n        }\n      }\n    };\n    __name(defaultLogger, \"defaultLogger\");\n    __name(isCompilable, \"isCompilable\");\n    Kysely = class _Kysely extends QueryCreator {\n      static {\n        __name(this, \"Kysely\");\n      }\n      #props;\n      constructor(args) {\n        let superProps;\n        let props;\n        if (isKyselyProps(args)) {\n          superProps = { executor: args.executor };\n          props = { ...args };\n        } else {\n          const dialect = args.dialect;\n          const driver = dialect.createDriver();\n          const compiler = dialect.createQueryCompiler();\n          const adapter = dialect.createAdapter();\n          const log4 = new Log(args.log ?? []);\n          const runtimeDriver = new RuntimeDriver(driver, log4);\n          const connectionProvider = new DefaultConnectionProvider(runtimeDriver);\n          const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);\n          superProps = { executor };\n          props = {\n            config: args,\n            executor,\n            dialect,\n            driver: runtimeDriver\n          };\n        }\n        super(superProps);\n        this.#props = freeze(props);\n      }\n      /**\n       * Returns the {@link SchemaModule} module for building database schema.\n       */\n      get schema() {\n        return new SchemaModule(this.#props.executor);\n      }\n      /**\n       * Returns a the {@link DynamicModule} module.\n       *\n       * The {@link DynamicModule} module can be used to bypass strict typing and\n       * passing in dynamic values for the queries.\n       */\n      get dynamic() {\n        return new DynamicModule();\n      }\n      /**\n       * Returns a {@link DatabaseIntrospector | database introspector}.\n       */\n      get introspection() {\n        return this.#props.dialect.createIntrospector(this.withoutPlugins());\n      }\n      case(value2) {\n        return new CaseBuilder({\n          node: CaseNode.create(isUndefined(value2) ? void 0 : parseExpression(value2))\n        });\n      }\n      /**\n       * Returns a {@link FunctionModule} that can be used to write somewhat type-safe function\n       * calls.\n       *\n       * ```ts\n       * const { count } = db.fn\n       *\n       * await db.selectFrom('person')\n       *   .innerJoin('pet', 'pet.owner_id', 'person.id')\n       *   .select([\n       *     'id',\n       *     count('pet.id').as('person_count'),\n       *   ])\n       *   .groupBy('person.id')\n       *   .having(count('pet.id'), '>', 10)\n       *   .execute()\n       * ```\n       *\n       * The generated SQL (PostgreSQL):\n       *\n       * ```sql\n       * select \"person\".\"id\", count(\"pet\".\"id\") as \"person_count\"\n       * from \"person\"\n       * inner join \"pet\" on \"pet\".\"owner_id\" = \"person\".\"id\"\n       * group by \"person\".\"id\"\n       * having count(\"pet\".\"id\") > $1\n       * ```\n       *\n       * Why \"somewhat\" type-safe? Because the function calls are not bound to the\n       * current query context. They allow you to reference columns and tables that\n       * are not in the current query. E.g. remove the `innerJoin` from the previous\n       * query and TypeScript won't even complain.\n       *\n       * If you want to make the function calls fully type-safe, you can use the\n       * {@link ExpressionBuilder.fn} getter for a query context-aware, stricter {@link FunctionModule}.\n       *\n       * ```ts\n       * await db.selectFrom('person')\n       *   .innerJoin('pet', 'pet.owner_id', 'person.id')\n       *   .select((eb) => [\n       *     'person.id',\n       *     eb.fn.count('pet.id').as('pet_count')\n       *   ])\n       *   .groupBy('person.id')\n       *   .having((eb) => eb.fn.count('pet.id'), '>', 10)\n       *   .execute()\n       * ```\n       */\n      get fn() {\n        return createFunctionModule();\n      }\n      /**\n       * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.\n       *\n       * The returned {@link TransactionBuilder} can be used to configure the transaction. The\n       * {@link TransactionBuilder.execute} method can then be called to run the transaction.\n       * {@link TransactionBuilder.execute} takes a function that is run inside the\n       * transaction. If the function throws an exception,\n       * 1. the exception is caught,\n       * 2. the transaction is rolled back, and\n       * 3. the exception is thrown again.\n       * Otherwise the transaction is committed.\n       *\n       * The callback function passed to the {@link TransactionBuilder.execute | execute}\n       * method gets the transaction object as its only argument. The transaction is\n       * of type {@link Transaction} which inherits {@link Kysely}. Any query\n       * started through the transaction object is executed inside the transaction.\n       *\n       * ### Examples\n       *\n       * <!-- siteExample(\"transactions\", \"Simple transaction\", 10) -->\n       *\n       * This example inserts two rows in a transaction. If an exception is thrown inside\n       * the callback passed to the `execute` method,\n       * 1. the exception is caught,\n       * 2. the transaction is rolled back, and\n       * 3. the exception is thrown again.\n       * Otherwise the transaction is committed.\n       *\n       * ```ts\n       * const catto = await db.transaction().execute(async (trx) => {\n       *   const jennifer = await trx.insertInto('person')\n       *     .values({\n       *       first_name: 'Jennifer',\n       *       last_name: 'Aniston',\n       *       age: 40,\n       *     })\n       *     .returning('id')\n       *     .executeTakeFirstOrThrow()\n       *\n       *   return await trx.insertInto('pet')\n       *     .values({\n       *       owner_id: jennifer.id,\n       *       name: 'Catto',\n       *       species: 'cat',\n       *       is_favorite: false,\n       *     })\n       *     .returningAll()\n       *     .executeTakeFirst()\n       * })\n       * ```\n       *\n       * Setting the isolation level:\n       *\n       * ```ts\n       * import type { Kysely } from 'kysely'\n       *\n       * await db\n       *   .transaction()\n       *   .setIsolationLevel('serializable')\n       *   .execute(async (trx) => {\n       *     await doStuff(trx)\n       *   })\n       *\n       * async function doStuff(kysely: typeof db) {\n       *   // ...\n       * }\n       * ```\n       */\n      transaction() {\n        return new TransactionBuilder({ ...this.#props });\n      }\n      /**\n       * Provides a kysely instance bound to a single database connection.\n       *\n       * ### Examples\n       *\n       * ```ts\n       * await db\n       *   .connection()\n       *   .execute(async (db) => {\n       *     // `db` is an instance of `Kysely` that's bound to a single\n       *     // database connection. All queries executed through `db` use\n       *     // the same connection.\n       *     await doStuff(db)\n       *   })\n       *\n       * async function doStuff(kysely: typeof db) {\n       *   // ...\n       * }\n       * ```\n       */\n      connection() {\n        return new ConnectionBuilder({ ...this.#props });\n      }\n      /**\n       * Returns a copy of this Kysely instance with the given plugin installed.\n       */\n      withPlugin(plugin) {\n        return new _Kysely({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      /**\n       * Returns a copy of this Kysely instance without any plugins.\n       */\n      withoutPlugins() {\n        return new _Kysely({\n          ...this.#props,\n          executor: this.#props.executor.withoutPlugins()\n        });\n      }\n      /**\n       * @override\n       */\n      withSchema(schema2) {\n        return new _Kysely({\n          ...this.#props,\n          executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))\n        });\n      }\n      /**\n       * Returns a copy of this Kysely instance with tables added to its\n       * database type.\n       *\n       * This method only modifies the types and doesn't affect any of the\n       * executed queries in any way.\n       *\n       * ### Examples\n       *\n       * The following example adds and uses a temporary table:\n       *\n       * ```ts\n       * await db.schema\n       *   .createTable('temp_table')\n       *   .temporary()\n       *   .addColumn('some_column', 'integer')\n       *   .execute()\n       *\n       * const tempDb = db.withTables<{\n       *   temp_table: {\n       *     some_column: number\n       *   }\n       * }>()\n       *\n       * await tempDb\n       *   .insertInto('temp_table')\n       *   .values({ some_column: 100 })\n       *   .execute()\n       * ```\n       */\n      withTables() {\n        return new _Kysely({ ...this.#props });\n      }\n      /**\n       * Releases all resources and disconnects from the database.\n       *\n       * You need to call this when you are done using the `Kysely` instance.\n       */\n      async destroy() {\n        await this.#props.driver.destroy();\n      }\n      /**\n       * Returns true if this `Kysely` instance is a transaction.\n       *\n       * You can also use `db instanceof Transaction`.\n       */\n      get isTransaction() {\n        return false;\n      }\n      /**\n       * @internal\n       * @private\n       */\n      getExecutor() {\n        return this.#props.executor;\n      }\n      /**\n       * Executes a given compiled query or query builder.\n       *\n       * See {@link https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.\n       */\n      executeQuery(query, queryId = createQueryId()) {\n        const compiledQuery = isCompilable(query) ? query.compile() : query;\n        return this.getExecutor().executeQuery(compiledQuery, queryId);\n      }\n    };\n    Transaction = class _Transaction extends Kysely {\n      static {\n        __name(this, \"Transaction\");\n      }\n      #props;\n      constructor(props) {\n        super(props);\n        this.#props = props;\n      }\n      // The return type is `true` instead of `boolean` to make Kysely<DB>\n      // unassignable to Transaction<DB> while allowing assignment the\n      // other way around.\n      get isTransaction() {\n        return true;\n      }\n      transaction() {\n        throw new Error(\"calling the transaction method for a Transaction is not supported\");\n      }\n      connection() {\n        throw new Error(\"calling the connection method for a Transaction is not supported\");\n      }\n      async destroy() {\n        throw new Error(\"calling the destroy method for a Transaction is not supported\");\n      }\n      withPlugin(plugin) {\n        return new _Transaction({\n          ...this.#props,\n          executor: this.#props.executor.withPlugin(plugin)\n        });\n      }\n      withoutPlugins() {\n        return new _Transaction({\n          ...this.#props,\n          executor: this.#props.executor.withoutPlugins()\n        });\n      }\n      withSchema(schema2) {\n        return new _Transaction({\n          ...this.#props,\n          executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema2))\n        });\n      }\n      withTables() {\n        return new _Transaction({ ...this.#props });\n      }\n    };\n    __name(isKyselyProps, \"isKyselyProps\");\n    ConnectionBuilder = class {\n      static {\n        __name(this, \"ConnectionBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      async execute(callback) {\n        return this.#props.executor.provideConnection(async (connection) => {\n          const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));\n          const db = new Kysely({\n            ...this.#props,\n            executor\n          });\n          return await callback(db);\n        });\n      }\n    };\n    preventAwait(ConnectionBuilder, \"don't await ConnectionBuilder instances directly. To execute the query you need to call the `execute` method\");\n    TransactionBuilder = class _TransactionBuilder {\n      static {\n        __name(this, \"TransactionBuilder\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      setIsolationLevel(isolationLevel) {\n        return new _TransactionBuilder({\n          ...this.#props,\n          isolationLevel\n        });\n      }\n      async execute(callback) {\n        const { isolationLevel, ...kyselyProps } = this.#props;\n        const settings = { isolationLevel };\n        validateTransactionSettings(settings);\n        return this.#props.executor.provideConnection(async (connection) => {\n          const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));\n          const transaction = new Transaction({\n            ...kyselyProps,\n            executor\n          });\n          try {\n            await this.#props.driver.beginTransaction(connection, settings);\n            const result = await callback(transaction);\n            await this.#props.driver.commitTransaction(connection);\n            return result;\n          } catch (error4) {\n            await this.#props.driver.rollbackTransaction(connection);\n            throw error4;\n          }\n        });\n      }\n    };\n    preventAwait(TransactionBuilder, \"don't await TransactionBuilder instances directly. To execute the transaction you need to call the `execute` method\");\n    __name(validateTransactionSettings, \"validateTransactionSettings\");\n    RawBuilderImpl = class _RawBuilderImpl {\n      static {\n        __name(this, \"RawBuilderImpl\");\n      }\n      #props;\n      constructor(props) {\n        this.#props = freeze(props);\n      }\n      get expressionType() {\n        return void 0;\n      }\n      get isRawBuilder() {\n        return true;\n      }\n      as(alias2) {\n        return new AliasedRawBuilderImpl(this, alias2);\n      }\n      $castTo() {\n        return new _RawBuilderImpl({ ...this.#props });\n      }\n      $notNull() {\n        return new _RawBuilderImpl(this.#props);\n      }\n      withPlugin(plugin) {\n        return new _RawBuilderImpl({\n          ...this.#props,\n          plugins: this.#props.plugins !== void 0 ? freeze([...this.#props.plugins, plugin]) : freeze([plugin])\n        });\n      }\n      toOperationNode() {\n        return this.#toOperationNode(this.#getExecutor());\n      }\n      compile(executorProvider) {\n        return this.#compile(this.#getExecutor(executorProvider));\n      }\n      async execute(executorProvider) {\n        const executor = this.#getExecutor(executorProvider);\n        return executor.executeQuery(this.#compile(executor), this.#props.queryId);\n      }\n      #getExecutor(executorProvider) {\n        const executor = executorProvider !== void 0 ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;\n        return this.#props.plugins !== void 0 ? executor.withPlugins(this.#props.plugins) : executor;\n      }\n      #toOperationNode(executor) {\n        return executor.transformQuery(this.#props.rawNode, this.#props.queryId);\n      }\n      #compile(executor) {\n        return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);\n      }\n    };\n    __name(createRawBuilder, \"createRawBuilder\");\n    preventAwait(RawBuilderImpl, \"don't await RawBuilder instances directly. To execute the query you need to call `execute`\");\n    AliasedRawBuilderImpl = class {\n      static {\n        __name(this, \"AliasedRawBuilderImpl\");\n      }\n      #rawBuilder;\n      #alias;\n      constructor(rawBuilder, alias2) {\n        this.#rawBuilder = rawBuilder;\n        this.#alias = alias2;\n      }\n      get expression() {\n        return this.#rawBuilder;\n      }\n      get alias() {\n        return this.#alias;\n      }\n      get rawBuilder() {\n        return this.#rawBuilder;\n      }\n      toOperationNode() {\n        return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));\n      }\n    };\n    preventAwait(AliasedRawBuilderImpl, \"don't await AliasedRawBuilder instances directly. AliasedRawBuilder should never be executed directly since it's always a part of another query.\");\n    sql = Object.assign((sqlFragments, ...parameters) => {\n      return createRawBuilder({\n        queryId: createQueryId(),\n        rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? [])\n      });\n    }, {\n      ref(columnReference) {\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.createWithChild(parseStringReference(columnReference))\n        });\n      },\n      val(value2) {\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.createWithChild(parseValueExpression(value2))\n        });\n      },\n      value(value2) {\n        return this.val(value2);\n      },\n      table(tableReference) {\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.createWithChild(parseTable(tableReference))\n        });\n      },\n      id(...ids) {\n        const fragments = new Array(ids.length + 1).fill(\".\");\n        fragments[0] = \"\";\n        fragments[fragments.length - 1] = \"\";\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))\n        });\n      },\n      lit(value2) {\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.createWithChild(ValueNode.createImmediate(value2))\n        });\n      },\n      literal(value2) {\n        return this.lit(value2);\n      },\n      raw(sql2) {\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.createWithSql(sql2)\n        });\n      },\n      join(array2, separator = sql`, `) {\n        const nodes = new Array(2 * array2.length - 1);\n        const sep = separator.toOperationNode();\n        for (let i = 0; i < array2.length; ++i) {\n          nodes[2 * i] = parseParameter(array2[i]);\n          if (i !== array2.length - 1) {\n            nodes[2 * i + 1] = sep;\n          }\n        }\n        return createRawBuilder({\n          queryId: createQueryId(),\n          rawNode: RawNode.createWithChildren(nodes)\n        });\n      }\n    });\n    __name(parseParameter, \"parseParameter\");\n    OperationNodeVisitor = class {\n      static {\n        __name(this, \"OperationNodeVisitor\");\n      }\n      nodeStack = [];\n      get parentNode() {\n        return this.nodeStack[this.nodeStack.length - 2];\n      }\n      #visitors = freeze({\n        AliasNode: this.visitAlias.bind(this),\n        ColumnNode: this.visitColumn.bind(this),\n        IdentifierNode: this.visitIdentifier.bind(this),\n        SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),\n        RawNode: this.visitRaw.bind(this),\n        ReferenceNode: this.visitReference.bind(this),\n        SelectQueryNode: this.visitSelectQuery.bind(this),\n        SelectionNode: this.visitSelection.bind(this),\n        TableNode: this.visitTable.bind(this),\n        FromNode: this.visitFrom.bind(this),\n        SelectAllNode: this.visitSelectAll.bind(this),\n        AndNode: this.visitAnd.bind(this),\n        OrNode: this.visitOr.bind(this),\n        ValueNode: this.visitValue.bind(this),\n        ValueListNode: this.visitValueList.bind(this),\n        PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),\n        ParensNode: this.visitParens.bind(this),\n        JoinNode: this.visitJoin.bind(this),\n        OperatorNode: this.visitOperator.bind(this),\n        WhereNode: this.visitWhere.bind(this),\n        InsertQueryNode: this.visitInsertQuery.bind(this),\n        DeleteQueryNode: this.visitDeleteQuery.bind(this),\n        ReturningNode: this.visitReturning.bind(this),\n        CreateTableNode: this.visitCreateTable.bind(this),\n        AddColumnNode: this.visitAddColumn.bind(this),\n        ColumnDefinitionNode: this.visitColumnDefinition.bind(this),\n        DropTableNode: this.visitDropTable.bind(this),\n        DataTypeNode: this.visitDataType.bind(this),\n        OrderByNode: this.visitOrderBy.bind(this),\n        OrderByItemNode: this.visitOrderByItem.bind(this),\n        GroupByNode: this.visitGroupBy.bind(this),\n        GroupByItemNode: this.visitGroupByItem.bind(this),\n        UpdateQueryNode: this.visitUpdateQuery.bind(this),\n        ColumnUpdateNode: this.visitColumnUpdate.bind(this),\n        LimitNode: this.visitLimit.bind(this),\n        OffsetNode: this.visitOffset.bind(this),\n        OnConflictNode: this.visitOnConflict.bind(this),\n        OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),\n        CreateIndexNode: this.visitCreateIndex.bind(this),\n        DropIndexNode: this.visitDropIndex.bind(this),\n        ListNode: this.visitList.bind(this),\n        PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),\n        UniqueConstraintNode: this.visitUniqueConstraint.bind(this),\n        ReferencesNode: this.visitReferences.bind(this),\n        CheckConstraintNode: this.visitCheckConstraint.bind(this),\n        WithNode: this.visitWith.bind(this),\n        CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),\n        CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),\n        HavingNode: this.visitHaving.bind(this),\n        CreateSchemaNode: this.visitCreateSchema.bind(this),\n        DropSchemaNode: this.visitDropSchema.bind(this),\n        AlterTableNode: this.visitAlterTable.bind(this),\n        DropColumnNode: this.visitDropColumn.bind(this),\n        RenameColumnNode: this.visitRenameColumn.bind(this),\n        AlterColumnNode: this.visitAlterColumn.bind(this),\n        ModifyColumnNode: this.visitModifyColumn.bind(this),\n        AddConstraintNode: this.visitAddConstraint.bind(this),\n        DropConstraintNode: this.visitDropConstraint.bind(this),\n        ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),\n        CreateViewNode: this.visitCreateView.bind(this),\n        DropViewNode: this.visitDropView.bind(this),\n        GeneratedNode: this.visitGenerated.bind(this),\n        DefaultValueNode: this.visitDefaultValue.bind(this),\n        OnNode: this.visitOn.bind(this),\n        ValuesNode: this.visitValues.bind(this),\n        SelectModifierNode: this.visitSelectModifier.bind(this),\n        CreateTypeNode: this.visitCreateType.bind(this),\n        DropTypeNode: this.visitDropType.bind(this),\n        ExplainNode: this.visitExplain.bind(this),\n        DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),\n        AggregateFunctionNode: this.visitAggregateFunction.bind(this),\n        OverNode: this.visitOver.bind(this),\n        PartitionByNode: this.visitPartitionBy.bind(this),\n        PartitionByItemNode: this.visitPartitionByItem.bind(this),\n        SetOperationNode: this.visitSetOperation.bind(this),\n        BinaryOperationNode: this.visitBinaryOperation.bind(this),\n        UnaryOperationNode: this.visitUnaryOperation.bind(this),\n        UsingNode: this.visitUsing.bind(this),\n        FunctionNode: this.visitFunction.bind(this),\n        CaseNode: this.visitCase.bind(this),\n        WhenNode: this.visitWhen.bind(this),\n        JSONReferenceNode: this.visitJSONReference.bind(this),\n        JSONPathNode: this.visitJSONPath.bind(this),\n        JSONPathLegNode: this.visitJSONPathLeg.bind(this),\n        JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),\n        TupleNode: this.visitTuple.bind(this),\n        MergeQueryNode: this.visitMergeQuery.bind(this),\n        MatchedNode: this.visitMatched.bind(this),\n        AddIndexNode: this.visitAddIndex.bind(this),\n        CastNode: this.visitCast.bind(this),\n        FetchNode: this.visitFetch.bind(this),\n        TopNode: this.visitTop.bind(this),\n        OutputNode: this.visitOutput.bind(this)\n      });\n      visitNode = /* @__PURE__ */ __name((node) => {\n        this.nodeStack.push(node);\n        this.#visitors[node.kind](node);\n        this.nodeStack.pop();\n      }, \"visitNode\");\n    };\n    DefaultQueryCompiler = class extends OperationNodeVisitor {\n      static {\n        __name(this, \"DefaultQueryCompiler\");\n      }\n      #sql = \"\";\n      #parameters = [];\n      get numParameters() {\n        return this.#parameters.length;\n      }\n      compileQuery(node) {\n        this.#sql = \"\";\n        this.#parameters = [];\n        this.nodeStack.splice(0, this.nodeStack.length);\n        this.visitNode(node);\n        return freeze({\n          query: node,\n          sql: this.getSql(),\n          parameters: [...this.#parameters]\n        });\n      }\n      getSql() {\n        return this.#sql;\n      }\n      visitSelectQuery(node) {\n        const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);\n        if (this.parentNode === void 0 && node.explain) {\n          this.visitNode(node.explain);\n          this.append(\" \");\n        }\n        if (wrapInParens) {\n          this.append(\"(\");\n        }\n        if (node.with) {\n          this.visitNode(node.with);\n          this.append(\" \");\n        }\n        this.append(\"select\");\n        if (node.distinctOn) {\n          this.append(\" \");\n          this.compileDistinctOn(node.distinctOn);\n        }\n        if (node.frontModifiers?.length) {\n          this.append(\" \");\n          this.compileList(node.frontModifiers, \" \");\n        }\n        if (node.top) {\n          this.append(\" \");\n          this.visitNode(node.top);\n        }\n        if (node.selections) {\n          this.append(\" \");\n          this.compileList(node.selections);\n        }\n        if (node.from) {\n          this.append(\" \");\n          this.visitNode(node.from);\n        }\n        if (node.joins) {\n          this.append(\" \");\n          this.compileList(node.joins, \" \");\n        }\n        if (node.where) {\n          this.append(\" \");\n          this.visitNode(node.where);\n        }\n        if (node.groupBy) {\n          this.append(\" \");\n          this.visitNode(node.groupBy);\n        }\n        if (node.having) {\n          this.append(\" \");\n          this.visitNode(node.having);\n        }\n        if (node.setOperations) {\n          this.append(\" \");\n          this.compileList(node.setOperations, \" \");\n        }\n        if (node.orderBy) {\n          this.append(\" \");\n          this.visitNode(node.orderBy);\n        }\n        if (node.limit) {\n          this.append(\" \");\n          this.visitNode(node.limit);\n        }\n        if (node.offset) {\n          this.append(\" \");\n          this.visitNode(node.offset);\n        }\n        if (node.fetch) {\n          this.append(\" \");\n          this.visitNode(node.fetch);\n        }\n        if (node.endModifiers?.length) {\n          this.append(\" \");\n          this.compileList(this.sortSelectModifiers([...node.endModifiers]), \" \");\n        }\n        if (wrapInParens) {\n          this.append(\")\");\n        }\n      }\n      visitFrom(node) {\n        this.append(\"from \");\n        this.compileList(node.froms);\n      }\n      visitSelection(node) {\n        this.visitNode(node.selection);\n      }\n      visitColumn(node) {\n        this.visitNode(node.column);\n      }\n      compileDistinctOn(expressions) {\n        this.append(\"distinct on (\");\n        this.compileList(expressions);\n        this.append(\")\");\n      }\n      compileList(nodes, separator = \", \") {\n        const lastIndex = nodes.length - 1;\n        for (let i = 0; i <= lastIndex; i++) {\n          this.visitNode(nodes[i]);\n          if (i < lastIndex) {\n            this.append(separator);\n          }\n        }\n      }\n      visitWhere(node) {\n        this.append(\"where \");\n        this.visitNode(node.where);\n      }\n      visitHaving(node) {\n        this.append(\"having \");\n        this.visitNode(node.having);\n      }\n      visitInsertQuery(node) {\n        const rootQueryNode = this.nodeStack.find(QueryNode.is);\n        const isSubQuery = rootQueryNode !== node;\n        if (!isSubQuery && node.explain) {\n          this.visitNode(node.explain);\n          this.append(\" \");\n        }\n        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {\n          this.append(\"(\");\n        }\n        if (node.with) {\n          this.visitNode(node.with);\n          this.append(\" \");\n        }\n        this.append(node.replace ? \"replace\" : \"insert\");\n        if (node.ignore) {\n          this.append(\" ignore\");\n        }\n        if (node.top) {\n          this.append(\" \");\n          this.visitNode(node.top);\n        }\n        if (node.into) {\n          this.append(\" into \");\n          this.visitNode(node.into);\n        }\n        if (node.columns) {\n          this.append(\" (\");\n          this.compileList(node.columns);\n          this.append(\")\");\n        }\n        if (node.output) {\n          this.append(\" \");\n          this.visitNode(node.output);\n        }\n        if (node.values) {\n          this.append(\" \");\n          this.visitNode(node.values);\n        }\n        if (node.defaultValues) {\n          this.append(\" \");\n          this.append(\"default values\");\n        }\n        if (node.onConflict) {\n          this.append(\" \");\n          this.visitNode(node.onConflict);\n        }\n        if (node.onDuplicateKey) {\n          this.append(\" \");\n          this.visitNode(node.onDuplicateKey);\n        }\n        if (node.returning) {\n          this.append(\" \");\n          this.visitNode(node.returning);\n        }\n        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {\n          this.append(\")\");\n        }\n        if (node.endModifiers?.length) {\n          this.append(\" \");\n          this.compileList(node.endModifiers, \" \");\n        }\n      }\n      visitValues(node) {\n        this.append(\"values \");\n        this.compileList(node.values);\n      }\n      visitDeleteQuery(node) {\n        const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;\n        if (!isSubQuery && node.explain) {\n          this.visitNode(node.explain);\n          this.append(\" \");\n        }\n        if (isSubQuery) {\n          this.append(\"(\");\n        }\n        if (node.with) {\n          this.visitNode(node.with);\n          this.append(\" \");\n        }\n        this.append(\"delete \");\n        if (node.top) {\n          this.visitNode(node.top);\n          this.append(\" \");\n        }\n        this.visitNode(node.from);\n        if (node.output) {\n          this.append(\" \");\n          this.visitNode(node.output);\n        }\n        if (node.using) {\n          this.append(\" \");\n          this.visitNode(node.using);\n        }\n        if (node.joins) {\n          this.append(\" \");\n          this.compileList(node.joins, \" \");\n        }\n        if (node.where) {\n          this.append(\" \");\n          this.visitNode(node.where);\n        }\n        if (node.orderBy) {\n          this.append(\" \");\n          this.visitNode(node.orderBy);\n        }\n        if (node.limit) {\n          this.append(\" \");\n          this.visitNode(node.limit);\n        }\n        if (node.returning) {\n          this.append(\" \");\n          this.visitNode(node.returning);\n        }\n        if (isSubQuery) {\n          this.append(\")\");\n        }\n        if (node.endModifiers?.length) {\n          this.append(\" \");\n          this.compileList(node.endModifiers, \" \");\n        }\n      }\n      visitReturning(node) {\n        this.append(\"returning \");\n        this.compileList(node.selections);\n      }\n      visitAlias(node) {\n        this.visitNode(node.node);\n        this.append(\" as \");\n        this.visitNode(node.alias);\n      }\n      visitReference(node) {\n        if (node.table) {\n          this.visitNode(node.table);\n          this.append(\".\");\n        }\n        this.visitNode(node.column);\n      }\n      visitSelectAll(_3) {\n        this.append(\"*\");\n      }\n      visitIdentifier(node) {\n        this.append(this.getLeftIdentifierWrapper());\n        this.compileUnwrappedIdentifier(node);\n        this.append(this.getRightIdentifierWrapper());\n      }\n      compileUnwrappedIdentifier(node) {\n        if (!isString2(node.name)) {\n          throw new Error(\"a non-string identifier was passed to compileUnwrappedIdentifier.\");\n        }\n        this.append(this.sanitizeIdentifier(node.name));\n      }\n      visitAnd(node) {\n        this.visitNode(node.left);\n        this.append(\" and \");\n        this.visitNode(node.right);\n      }\n      visitOr(node) {\n        this.visitNode(node.left);\n        this.append(\" or \");\n        this.visitNode(node.right);\n      }\n      visitValue(node) {\n        if (node.immediate) {\n          this.appendImmediateValue(node.value);\n        } else {\n          this.appendValue(node.value);\n        }\n      }\n      visitValueList(node) {\n        this.append(\"(\");\n        this.compileList(node.values);\n        this.append(\")\");\n      }\n      visitTuple(node) {\n        this.append(\"(\");\n        this.compileList(node.values);\n        this.append(\")\");\n      }\n      visitPrimitiveValueList(node) {\n        this.append(\"(\");\n        const { values } = node;\n        for (let i = 0; i < values.length; ++i) {\n          this.appendValue(values[i]);\n          if (i !== values.length - 1) {\n            this.append(\", \");\n          }\n        }\n        this.append(\")\");\n      }\n      visitParens(node) {\n        this.append(\"(\");\n        this.visitNode(node.node);\n        this.append(\")\");\n      }\n      visitJoin(node) {\n        this.append(JOIN_TYPE_SQL[node.joinType]);\n        this.append(\" \");\n        this.visitNode(node.table);\n        if (node.on) {\n          this.append(\" \");\n          this.visitNode(node.on);\n        }\n      }\n      visitOn(node) {\n        this.append(\"on \");\n        this.visitNode(node.on);\n      }\n      visitRaw(node) {\n        const { sqlFragments, parameters: params } = node;\n        for (let i = 0; i < sqlFragments.length; ++i) {\n          this.append(sqlFragments[i]);\n          if (params.length > i) {\n            this.visitNode(params[i]);\n          }\n        }\n      }\n      visitOperator(node) {\n        this.append(node.operator);\n      }\n      visitTable(node) {\n        this.visitNode(node.table);\n      }\n      visitSchemableIdentifier(node) {\n        if (node.schema) {\n          this.visitNode(node.schema);\n          this.append(\".\");\n        }\n        this.visitNode(node.identifier);\n      }\n      visitCreateTable(node) {\n        this.append(\"create \");\n        if (node.frontModifiers && node.frontModifiers.length > 0) {\n          this.compileList(node.frontModifiers, \" \");\n          this.append(\" \");\n        }\n        if (node.temporary) {\n          this.append(\"temporary \");\n        }\n        this.append(\"table \");\n        if (node.ifNotExists) {\n          this.append(\"if not exists \");\n        }\n        this.visitNode(node.table);\n        if (node.selectQuery) {\n          this.append(\" as \");\n          this.visitNode(node.selectQuery);\n        } else {\n          this.append(\" (\");\n          this.compileList([...node.columns, ...node.constraints ?? []]);\n          this.append(\")\");\n          if (node.onCommit) {\n            this.append(\" on commit \");\n            this.append(node.onCommit);\n          }\n          if (node.endModifiers && node.endModifiers.length > 0) {\n            this.append(\" \");\n            this.compileList(node.endModifiers, \" \");\n          }\n        }\n      }\n      visitColumnDefinition(node) {\n        if (node.ifNotExists) {\n          this.append(\"if not exists \");\n        }\n        this.visitNode(node.column);\n        this.append(\" \");\n        this.visitNode(node.dataType);\n        if (node.unsigned) {\n          this.append(\" unsigned\");\n        }\n        if (node.frontModifiers && node.frontModifiers.length > 0) {\n          this.append(\" \");\n          this.compileList(node.frontModifiers, \" \");\n        }\n        if (node.generated) {\n          this.append(\" \");\n          this.visitNode(node.generated);\n        }\n        if (node.identity) {\n          this.append(\" identity\");\n        }\n        if (node.defaultTo) {\n          this.append(\" \");\n          this.visitNode(node.defaultTo);\n        }\n        if (node.notNull) {\n          this.append(\" not null\");\n        }\n        if (node.unique) {\n          this.append(\" unique\");\n        }\n        if (node.nullsNotDistinct) {\n          this.append(\" nulls not distinct\");\n        }\n        if (node.primaryKey) {\n          this.append(\" primary key\");\n        }\n        if (node.autoIncrement) {\n          this.append(\" \");\n          this.append(this.getAutoIncrement());\n        }\n        if (node.references) {\n          this.append(\" \");\n          this.visitNode(node.references);\n        }\n        if (node.check) {\n          this.append(\" \");\n          this.visitNode(node.check);\n        }\n        if (node.endModifiers && node.endModifiers.length > 0) {\n          this.append(\" \");\n          this.compileList(node.endModifiers, \" \");\n        }\n      }\n      getAutoIncrement() {\n        return \"auto_increment\";\n      }\n      visitReferences(node) {\n        this.append(\"references \");\n        this.visitNode(node.table);\n        this.append(\" (\");\n        this.compileList(node.columns);\n        this.append(\")\");\n        if (node.onDelete) {\n          this.append(\" on delete \");\n          this.append(node.onDelete);\n        }\n        if (node.onUpdate) {\n          this.append(\" on update \");\n          this.append(node.onUpdate);\n        }\n      }\n      visitDropTable(node) {\n        this.append(\"drop table \");\n        if (node.ifExists) {\n          this.append(\"if exists \");\n        }\n        this.visitNode(node.table);\n        if (node.cascade) {\n          this.append(\" cascade\");\n        }\n      }\n      visitDataType(node) {\n        this.append(node.dataType);\n      }\n      visitOrderBy(node) {\n        this.append(\"order by \");\n        this.compileList(node.items);\n      }\n      visitOrderByItem(node) {\n        this.visitNode(node.orderBy);\n        if (node.direction) {\n          this.append(\" \");\n          this.visitNode(node.direction);\n        }\n      }\n      visitGroupBy(node) {\n        this.append(\"group by \");\n        this.compileList(node.items);\n      }\n      visitGroupByItem(node) {\n        this.visitNode(node.groupBy);\n      }\n      visitUpdateQuery(node) {\n        const rootQueryNode = this.nodeStack.find(QueryNode.is);\n        const isSubQuery = rootQueryNode !== node;\n        if (!isSubQuery && node.explain) {\n          this.visitNode(node.explain);\n          this.append(\" \");\n        }\n        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {\n          this.append(\"(\");\n        }\n        if (node.with) {\n          this.visitNode(node.with);\n          this.append(\" \");\n        }\n        this.append(\"update \");\n        if (node.top) {\n          this.visitNode(node.top);\n          this.append(\" \");\n        }\n        if (node.table) {\n          this.visitNode(node.table);\n          this.append(\" \");\n        }\n        this.append(\"set \");\n        if (node.updates) {\n          this.compileList(node.updates);\n        }\n        if (node.output) {\n          this.append(\" \");\n          this.visitNode(node.output);\n        }\n        if (node.from) {\n          this.append(\" \");\n          this.visitNode(node.from);\n        }\n        if (node.joins) {\n          this.append(\" \");\n          this.compileList(node.joins, \" \");\n        }\n        if (node.where) {\n          this.append(\" \");\n          this.visitNode(node.where);\n        }\n        if (node.limit) {\n          this.append(\" \");\n          this.visitNode(node.limit);\n        }\n        if (node.returning) {\n          this.append(\" \");\n          this.visitNode(node.returning);\n        }\n        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {\n          this.append(\")\");\n        }\n        if (node.endModifiers?.length) {\n          this.append(\" \");\n          this.compileList(node.endModifiers, \" \");\n        }\n      }\n      visitColumnUpdate(node) {\n        this.visitNode(node.column);\n        this.append(\" = \");\n        this.visitNode(node.value);\n      }\n      visitLimit(node) {\n        this.append(\"limit \");\n        this.visitNode(node.limit);\n      }\n      visitOffset(node) {\n        this.append(\"offset \");\n        this.visitNode(node.offset);\n      }\n      visitOnConflict(node) {\n        this.append(\"on conflict\");\n        if (node.columns) {\n          this.append(\" (\");\n          this.compileList(node.columns);\n          this.append(\")\");\n        } else if (node.constraint) {\n          this.append(\" on constraint \");\n          this.visitNode(node.constraint);\n        } else if (node.indexExpression) {\n          this.append(\" (\");\n          this.visitNode(node.indexExpression);\n          this.append(\")\");\n        }\n        if (node.indexWhere) {\n          this.append(\" \");\n          this.visitNode(node.indexWhere);\n        }\n        if (node.doNothing === true) {\n          this.append(\" do nothing\");\n        } else if (node.updates) {\n          this.append(\" do update set \");\n          this.compileList(node.updates);\n          if (node.updateWhere) {\n            this.append(\" \");\n            this.visitNode(node.updateWhere);\n          }\n        }\n      }\n      visitOnDuplicateKey(node) {\n        this.append(\"on duplicate key update \");\n        this.compileList(node.updates);\n      }\n      visitCreateIndex(node) {\n        this.append(\"create \");\n        if (node.unique) {\n          this.append(\"unique \");\n        }\n        this.append(\"index \");\n        if (node.ifNotExists) {\n          this.append(\"if not exists \");\n        }\n        this.visitNode(node.name);\n        if (node.table) {\n          this.append(\" on \");\n          this.visitNode(node.table);\n        }\n        if (node.using) {\n          this.append(\" using \");\n          this.visitNode(node.using);\n        }\n        if (node.columns) {\n          this.append(\" (\");\n          this.compileList(node.columns);\n          this.append(\")\");\n        }\n        if (node.nullsNotDistinct) {\n          this.append(\" nulls not distinct\");\n        }\n        if (node.where) {\n          this.append(\" \");\n          this.visitNode(node.where);\n        }\n      }\n      visitDropIndex(node) {\n        this.append(\"drop index \");\n        if (node.ifExists) {\n          this.append(\"if exists \");\n        }\n        this.visitNode(node.name);\n        if (node.table) {\n          this.append(\" on \");\n          this.visitNode(node.table);\n        }\n        if (node.cascade) {\n          this.append(\" cascade\");\n        }\n      }\n      visitCreateSchema(node) {\n        this.append(\"create schema \");\n        if (node.ifNotExists) {\n          this.append(\"if not exists \");\n        }\n        this.visitNode(node.schema);\n      }\n      visitDropSchema(node) {\n        this.append(\"drop schema \");\n        if (node.ifExists) {\n          this.append(\"if exists \");\n        }\n        this.visitNode(node.schema);\n        if (node.cascade) {\n          this.append(\" cascade\");\n        }\n      }\n      visitPrimaryKeyConstraint(node) {\n        if (node.name) {\n          this.append(\"constraint \");\n          this.visitNode(node.name);\n          this.append(\" \");\n        }\n        this.append(\"primary key (\");\n        this.compileList(node.columns);\n        this.append(\")\");\n      }\n      visitUniqueConstraint(node) {\n        if (node.name) {\n          this.append(\"constraint \");\n          this.visitNode(node.name);\n          this.append(\" \");\n        }\n        this.append(\"unique\");\n        if (node.nullsNotDistinct) {\n          this.append(\" nulls not distinct\");\n        }\n        this.append(\" (\");\n        this.compileList(node.columns);\n        this.append(\")\");\n      }\n      visitCheckConstraint(node) {\n        if (node.name) {\n          this.append(\"constraint \");\n          this.visitNode(node.name);\n          this.append(\" \");\n        }\n        this.append(\"check (\");\n        this.visitNode(node.expression);\n        this.append(\")\");\n      }\n      visitForeignKeyConstraint(node) {\n        if (node.name) {\n          this.append(\"constraint \");\n          this.visitNode(node.name);\n          this.append(\" \");\n        }\n        this.append(\"foreign key (\");\n        this.compileList(node.columns);\n        this.append(\") \");\n        this.visitNode(node.references);\n        if (node.onDelete) {\n          this.append(\" on delete \");\n          this.append(node.onDelete);\n        }\n        if (node.onUpdate) {\n          this.append(\" on update \");\n          this.append(node.onUpdate);\n        }\n      }\n      visitList(node) {\n        this.compileList(node.items);\n      }\n      visitWith(node) {\n        this.append(\"with \");\n        if (node.recursive) {\n          this.append(\"recursive \");\n        }\n        this.compileList(node.expressions);\n      }\n      visitCommonTableExpression(node) {\n        this.visitNode(node.name);\n        this.append(\" as \");\n        if (isBoolean(node.materialized)) {\n          if (!node.materialized) {\n            this.append(\"not \");\n          }\n          this.append(\"materialized \");\n        }\n        this.visitNode(node.expression);\n      }\n      visitCommonTableExpressionName(node) {\n        this.visitNode(node.table);\n        if (node.columns) {\n          this.append(\"(\");\n          this.compileList(node.columns);\n          this.append(\")\");\n        }\n      }\n      visitAlterTable(node) {\n        this.append(\"alter table \");\n        this.visitNode(node.table);\n        this.append(\" \");\n        if (node.renameTo) {\n          this.append(\"rename to \");\n          this.visitNode(node.renameTo);\n        }\n        if (node.setSchema) {\n          this.append(\"set schema \");\n          this.visitNode(node.setSchema);\n        }\n        if (node.addConstraint) {\n          this.visitNode(node.addConstraint);\n        }\n        if (node.dropConstraint) {\n          this.visitNode(node.dropConstraint);\n        }\n        if (node.columnAlterations) {\n          this.compileColumnAlterations(node.columnAlterations);\n        }\n        if (node.addIndex) {\n          this.visitNode(node.addIndex);\n        }\n        if (node.dropIndex) {\n          this.visitNode(node.dropIndex);\n        }\n      }\n      visitAddColumn(node) {\n        this.append(\"add column \");\n        this.visitNode(node.column);\n      }\n      visitRenameColumn(node) {\n        this.append(\"rename column \");\n        this.visitNode(node.column);\n        this.append(\" to \");\n        this.visitNode(node.renameTo);\n      }\n      visitDropColumn(node) {\n        this.append(\"drop column \");\n        this.visitNode(node.column);\n      }\n      visitAlterColumn(node) {\n        this.append(\"alter column \");\n        this.visitNode(node.column);\n        this.append(\" \");\n        if (node.dataType) {\n          if (this.announcesNewColumnDataType()) {\n            this.append(\"type \");\n          }\n          this.visitNode(node.dataType);\n          if (node.dataTypeExpression) {\n            this.append(\"using \");\n            this.visitNode(node.dataTypeExpression);\n          }\n        }\n        if (node.setDefault) {\n          this.append(\"set default \");\n          this.visitNode(node.setDefault);\n        }\n        if (node.dropDefault) {\n          this.append(\"drop default\");\n        }\n        if (node.setNotNull) {\n          this.append(\"set not null\");\n        }\n        if (node.dropNotNull) {\n          this.append(\"drop not null\");\n        }\n      }\n      visitModifyColumn(node) {\n        this.append(\"modify column \");\n        this.visitNode(node.column);\n      }\n      visitAddConstraint(node) {\n        this.append(\"add \");\n        this.visitNode(node.constraint);\n      }\n      visitDropConstraint(node) {\n        this.append(\"drop constraint \");\n        if (node.ifExists) {\n          this.append(\"if exists \");\n        }\n        this.visitNode(node.constraintName);\n        if (node.modifier === \"cascade\") {\n          this.append(\" cascade\");\n        } else if (node.modifier === \"restrict\") {\n          this.append(\" restrict\");\n        }\n      }\n      visitSetOperation(node) {\n        this.append(node.operator);\n        this.append(\" \");\n        if (node.all) {\n          this.append(\"all \");\n        }\n        this.visitNode(node.expression);\n      }\n      visitCreateView(node) {\n        this.append(\"create \");\n        if (node.orReplace) {\n          this.append(\"or replace \");\n        }\n        if (node.materialized) {\n          this.append(\"materialized \");\n        }\n        if (node.temporary) {\n          this.append(\"temporary \");\n        }\n        this.append(\"view \");\n        if (node.ifNotExists) {\n          this.append(\"if not exists \");\n        }\n        this.visitNode(node.name);\n        this.append(\" \");\n        if (node.columns) {\n          this.append(\"(\");\n          this.compileList(node.columns);\n          this.append(\") \");\n        }\n        if (node.as) {\n          this.append(\"as \");\n          this.visitNode(node.as);\n        }\n      }\n      visitDropView(node) {\n        this.append(\"drop \");\n        if (node.materialized) {\n          this.append(\"materialized \");\n        }\n        this.append(\"view \");\n        if (node.ifExists) {\n          this.append(\"if exists \");\n        }\n        this.visitNode(node.name);\n        if (node.cascade) {\n          this.append(\" cascade\");\n        }\n      }\n      visitGenerated(node) {\n        this.append(\"generated \");\n        if (node.always) {\n          this.append(\"always \");\n        }\n        if (node.byDefault) {\n          this.append(\"by default \");\n        }\n        this.append(\"as \");\n        if (node.identity) {\n          this.append(\"identity\");\n        }\n        if (node.expression) {\n          this.append(\"(\");\n          this.visitNode(node.expression);\n          this.append(\")\");\n        }\n        if (node.stored) {\n          this.append(\" stored\");\n        }\n      }\n      visitDefaultValue(node) {\n        this.append(\"default \");\n        this.visitNode(node.defaultValue);\n      }\n      visitSelectModifier(node) {\n        if (node.rawModifier) {\n          this.visitNode(node.rawModifier);\n        } else {\n          this.append(SELECT_MODIFIER_SQL[node.modifier]);\n        }\n        if (node.of) {\n          this.append(\" of \");\n          this.compileList(node.of, \", \");\n        }\n      }\n      visitCreateType(node) {\n        this.append(\"create type \");\n        this.visitNode(node.name);\n        if (node.enum) {\n          this.append(\" as enum \");\n          this.visitNode(node.enum);\n        }\n      }\n      visitDropType(node) {\n        this.append(\"drop type \");\n        if (node.ifExists) {\n          this.append(\"if exists \");\n        }\n        this.visitNode(node.name);\n      }\n      visitExplain(node) {\n        this.append(\"explain\");\n        if (node.options || node.format) {\n          this.append(\" \");\n          this.append(this.getLeftExplainOptionsWrapper());\n          if (node.options) {\n            this.visitNode(node.options);\n            if (node.format) {\n              this.append(this.getExplainOptionsDelimiter());\n            }\n          }\n          if (node.format) {\n            this.append(\"format\");\n            this.append(this.getExplainOptionAssignment());\n            this.append(node.format);\n          }\n          this.append(this.getRightExplainOptionsWrapper());\n        }\n      }\n      visitDefaultInsertValue(_3) {\n        this.append(\"default\");\n      }\n      visitAggregateFunction(node) {\n        this.append(node.func);\n        this.append(\"(\");\n        if (node.distinct) {\n          this.append(\"distinct \");\n        }\n        this.compileList(node.aggregated);\n        if (node.orderBy) {\n          this.append(\" \");\n          this.visitNode(node.orderBy);\n        }\n        this.append(\")\");\n        if (node.filter) {\n          this.append(\" filter(\");\n          this.visitNode(node.filter);\n          this.append(\")\");\n        }\n        if (node.over) {\n          this.append(\" \");\n          this.visitNode(node.over);\n        }\n      }\n      visitOver(node) {\n        this.append(\"over(\");\n        if (node.partitionBy) {\n          this.visitNode(node.partitionBy);\n          if (node.orderBy) {\n            this.append(\" \");\n          }\n        }\n        if (node.orderBy) {\n          this.visitNode(node.orderBy);\n        }\n        this.append(\")\");\n      }\n      visitPartitionBy(node) {\n        this.append(\"partition by \");\n        this.compileList(node.items);\n      }\n      visitPartitionByItem(node) {\n        this.visitNode(node.partitionBy);\n      }\n      visitBinaryOperation(node) {\n        this.visitNode(node.leftOperand);\n        this.append(\" \");\n        this.visitNode(node.operator);\n        this.append(\" \");\n        this.visitNode(node.rightOperand);\n      }\n      visitUnaryOperation(node) {\n        this.visitNode(node.operator);\n        if (!this.isMinusOperator(node.operator)) {\n          this.append(\" \");\n        }\n        this.visitNode(node.operand);\n      }\n      isMinusOperator(node) {\n        return OperatorNode.is(node) && node.operator === \"-\";\n      }\n      visitUsing(node) {\n        this.append(\"using \");\n        this.compileList(node.tables);\n      }\n      visitFunction(node) {\n        this.append(node.func);\n        this.append(\"(\");\n        this.compileList(node.arguments);\n        this.append(\")\");\n      }\n      visitCase(node) {\n        this.append(\"case\");\n        if (node.value) {\n          this.append(\" \");\n          this.visitNode(node.value);\n        }\n        if (node.when) {\n          this.append(\" \");\n          this.compileList(node.when, \" \");\n        }\n        if (node.else) {\n          this.append(\" else \");\n          this.visitNode(node.else);\n        }\n        this.append(\" end\");\n        if (node.isStatement) {\n          this.append(\" case\");\n        }\n      }\n      visitWhen(node) {\n        this.append(\"when \");\n        this.visitNode(node.condition);\n        if (node.result) {\n          this.append(\" then \");\n          this.visitNode(node.result);\n        }\n      }\n      visitJSONReference(node) {\n        this.visitNode(node.reference);\n        this.visitNode(node.traversal);\n      }\n      visitJSONPath(node) {\n        if (node.inOperator) {\n          this.visitNode(node.inOperator);\n        }\n        this.append(\"'$\");\n        for (const pathLeg of node.pathLegs) {\n          this.visitNode(pathLeg);\n        }\n        this.append(\"'\");\n      }\n      visitJSONPathLeg(node) {\n        const isArrayLocation = node.type === \"ArrayLocation\";\n        this.append(isArrayLocation ? \"[\" : \".\");\n        this.append(String(node.value));\n        if (isArrayLocation) {\n          this.append(\"]\");\n        }\n      }\n      visitJSONOperatorChain(node) {\n        for (let i = 0, len = node.values.length; i < len; i++) {\n          if (i === len - 1) {\n            this.visitNode(node.operator);\n          } else {\n            this.append(\"->\");\n          }\n          this.visitNode(node.values[i]);\n        }\n      }\n      visitMergeQuery(node) {\n        if (node.with) {\n          this.visitNode(node.with);\n          this.append(\" \");\n        }\n        this.append(\"merge \");\n        if (node.top) {\n          this.visitNode(node.top);\n          this.append(\" \");\n        }\n        this.append(\"into \");\n        this.visitNode(node.into);\n        if (node.using) {\n          this.append(\" \");\n          this.visitNode(node.using);\n        }\n        if (node.whens) {\n          this.append(\" \");\n          this.compileList(node.whens, \" \");\n        }\n        if (node.output) {\n          this.append(\" \");\n          this.visitNode(node.output);\n        }\n        if (node.endModifiers?.length) {\n          this.append(\" \");\n          this.compileList(node.endModifiers, \" \");\n        }\n      }\n      visitMatched(node) {\n        if (node.not) {\n          this.append(\"not \");\n        }\n        this.append(\"matched\");\n        if (node.bySource) {\n          this.append(\" by source\");\n        }\n      }\n      visitAddIndex(node) {\n        this.append(\"add \");\n        if (node.unique) {\n          this.append(\"unique \");\n        }\n        this.append(\"index \");\n        this.visitNode(node.name);\n        if (node.columns) {\n          this.append(\" (\");\n          this.compileList(node.columns);\n          this.append(\")\");\n        }\n        if (node.using) {\n          this.append(\" using \");\n          this.visitNode(node.using);\n        }\n      }\n      visitCast(node) {\n        this.append(\"cast(\");\n        this.visitNode(node.expression);\n        this.append(\" as \");\n        this.visitNode(node.dataType);\n        this.append(\")\");\n      }\n      visitFetch(node) {\n        this.append(\"fetch next \");\n        this.visitNode(node.rowCount);\n        this.append(` rows ${node.modifier}`);\n      }\n      visitOutput(node) {\n        this.append(\"output \");\n        this.compileList(node.selections);\n      }\n      visitTop(node) {\n        this.append(`top(${node.expression})`);\n        if (node.modifiers) {\n          this.append(` ${node.modifiers}`);\n        }\n      }\n      append(str) {\n        this.#sql += str;\n      }\n      appendValue(parameter) {\n        this.addParameter(parameter);\n        this.append(this.getCurrentParameterPlaceholder());\n      }\n      getLeftIdentifierWrapper() {\n        return '\"';\n      }\n      getRightIdentifierWrapper() {\n        return '\"';\n      }\n      getCurrentParameterPlaceholder() {\n        return \"$\" + this.numParameters;\n      }\n      getLeftExplainOptionsWrapper() {\n        return \"(\";\n      }\n      getExplainOptionAssignment() {\n        return \" \";\n      }\n      getExplainOptionsDelimiter() {\n        return \", \";\n      }\n      getRightExplainOptionsWrapper() {\n        return \")\";\n      }\n      sanitizeIdentifier(identifier) {\n        const leftWrap = this.getLeftIdentifierWrapper();\n        const rightWrap = this.getRightIdentifierWrapper();\n        let sanitized = \"\";\n        for (const c of identifier) {\n          sanitized += c;\n          if (c === leftWrap) {\n            sanitized += leftWrap;\n          } else if (c === rightWrap) {\n            sanitized += rightWrap;\n          }\n        }\n        return sanitized;\n      }\n      addParameter(parameter) {\n        this.#parameters.push(parameter);\n      }\n      appendImmediateValue(value2) {\n        if (isString2(value2)) {\n          this.append(`'${value2}'`);\n        } else if (isNumber(value2) || isBoolean(value2)) {\n          this.append(value2.toString());\n        } else if (isNull(value2)) {\n          this.append(\"null\");\n        } else if (isDate(value2)) {\n          this.appendImmediateValue(value2.toISOString());\n        } else if (isBigInt(value2)) {\n          this.appendImmediateValue(value2.toString());\n        } else {\n          throw new Error(`invalid immediate value ${value2}`);\n        }\n      }\n      sortSelectModifiers(arr) {\n        arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);\n        return freeze(arr);\n      }\n      compileColumnAlterations(columnAlterations) {\n        this.compileList(columnAlterations);\n      }\n      /**\n       * controls whether the dialect adds a \"type\" keyword before a column's new data\n       * type in an ALTER TABLE statement.\n       */\n      announcesNewColumnDataType() {\n        return true;\n      }\n    };\n    SELECT_MODIFIER_SQL = freeze({\n      ForKeyShare: \"for key share\",\n      ForNoKeyUpdate: \"for no key update\",\n      ForUpdate: \"for update\",\n      ForShare: \"for share\",\n      NoWait: \"nowait\",\n      SkipLocked: \"skip locked\",\n      Distinct: \"distinct\"\n    });\n    SELECT_MODIFIER_PRIORITY = freeze({\n      ForKeyShare: 1,\n      ForNoKeyUpdate: 1,\n      ForUpdate: 1,\n      ForShare: 1,\n      NoWait: 2,\n      SkipLocked: 2,\n      Distinct: 0\n    });\n    JOIN_TYPE_SQL = freeze({\n      InnerJoin: \"inner join\",\n      LeftJoin: \"left join\",\n      RightJoin: \"right join\",\n      FullJoin: \"full join\",\n      LateralInnerJoin: \"inner join lateral\",\n      LateralLeftJoin: \"left join lateral\",\n      Using: \"using\"\n    });\n    DialectAdapterBase = class {\n      static {\n        __name(this, \"DialectAdapterBase\");\n      }\n      get supportsCreateIfNotExists() {\n        return true;\n      }\n      get supportsTransactionalDdl() {\n        return false;\n      }\n      get supportsReturning() {\n        return false;\n      }\n      get supportsOutput() {\n        return false;\n      }\n    };\n    ID_WRAP_REGEX = /\"/g;\n    SqliteQueryCompiler = class extends DefaultQueryCompiler {\n      static {\n        __name(this, \"SqliteQueryCompiler\");\n      }\n      getCurrentParameterPlaceholder() {\n        return \"?\";\n      }\n      getLeftExplainOptionsWrapper() {\n        return \"\";\n      }\n      getRightExplainOptionsWrapper() {\n        return \"\";\n      }\n      getLeftIdentifierWrapper() {\n        return '\"';\n      }\n      getRightIdentifierWrapper() {\n        return '\"';\n      }\n      getAutoIncrement() {\n        return \"autoincrement\";\n      }\n      sanitizeIdentifier(identifier) {\n        return identifier.replace(ID_WRAP_REGEX, '\"\"');\n      }\n      visitDefaultInsertValue(_3) {\n        this.append(\"null\");\n      }\n    };\n    DEFAULT_MIGRATION_TABLE = \"kysely_migration\";\n    DEFAULT_MIGRATION_LOCK_TABLE = \"kysely_migration_lock\";\n    freeze({ __noMigrations__: true });\n    SqliteIntrospector = class {\n      static {\n        __name(this, \"SqliteIntrospector\");\n      }\n      #db;\n      constructor(db) {\n        this.#db = db;\n      }\n      async getSchemas() {\n        return [];\n      }\n      async getTables(options = { withInternalKyselyTables: false }) {\n        return await this.#getTableMetadata(options);\n      }\n      async getMetadata(options) {\n        return {\n          tables: await this.getTables(options)\n        };\n      }\n      #tablesQuery(qb, options) {\n        let tablesQuery = qb.selectFrom(\"sqlite_master\").where(\"type\", \"in\", [\"table\", \"view\"]).where(\"name\", \"not like\", \"sqlite_%\").select([\"name\", \"sql\", \"type\"]).orderBy(\"name\");\n        if (!options.withInternalKyselyTables) {\n          tablesQuery = tablesQuery.where(\"name\", \"!=\", DEFAULT_MIGRATION_TABLE).where(\"name\", \"!=\", DEFAULT_MIGRATION_LOCK_TABLE);\n        }\n        return tablesQuery;\n      }\n      async #getTableMetadata(options) {\n        const tablesResult = await this.#tablesQuery(this.#db, options).execute();\n        const tableMetadata = await this.#db.with(\"table_list\", (qb) => this.#tablesQuery(qb, options)).selectFrom([\n          \"table_list as tl\",\n          sql`pragma_table_info(tl.name)`.as(\"p\")\n        ]).select([\n          \"tl.name as table\",\n          \"p.cid\",\n          \"p.name\",\n          \"p.type\",\n          \"p.notnull\",\n          \"p.dflt_value\",\n          \"p.pk\"\n        ]).orderBy([\"tl.name\", \"p.cid\"]).execute();\n        const columnsByTable = {};\n        for (const row of tableMetadata) {\n          columnsByTable[row.table] ??= [];\n          columnsByTable[row.table].push(row);\n        }\n        return tablesResult.map(({ name, sql: sql2, type: type2 }) => {\n          let autoIncrementCol = sql2?.split(/[\\(\\),]/)?.find((it2) => it2.toLowerCase().includes(\"autoincrement\"))?.trimStart()?.split(/\\s+/)?.[0]?.replace(/[\"`]/g, \"\");\n          const columns = columnsByTable[name] ?? [];\n          if (!autoIncrementCol) {\n            const pkCols = columns.filter((r2) => r2.pk > 0);\n            if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === \"integer\") {\n              autoIncrementCol = pkCols[0].name;\n            }\n          }\n          return {\n            name,\n            isView: type2 === \"view\",\n            columns: columns.map((col) => ({\n              name: col.name,\n              dataType: col.type,\n              isNullable: !col.notnull,\n              isAutoIncrementing: col.name === autoIncrementCol,\n              hasDefaultValue: col.dflt_value != null,\n              comment: void 0\n            }))\n          };\n        });\n      }\n    };\n    SqliteAdapter = class extends DialectAdapterBase {\n      static {\n        __name(this, \"SqliteAdapter\");\n      }\n      get supportsTransactionalDdl() {\n        return false;\n      }\n      get supportsReturning() {\n        return true;\n      }\n      async acquireMigrationLock(_db, _opt) {\n      }\n      async releaseMigrationLock(_db, _opt) {\n      }\n    };\n    ParseJSONResultsPlugin = class {\n      static {\n        __name(this, \"ParseJSONResultsPlugin\");\n      }\n      opt;\n      #objectStrategy;\n      constructor(opt = {}) {\n        this.opt = opt;\n        this.#objectStrategy = opt.objectStrategy || \"in-place\";\n      }\n      // noop\n      transformQuery(args) {\n        return args.node;\n      }\n      async transformResult(args) {\n        return {\n          ...args.result,\n          rows: parseArray(args.result.rows, this.#objectStrategy)\n        };\n      }\n    };\n    __name(parseArray, \"parseArray\");\n    __name(parse2, \"parse\");\n    __name(parseString, \"parseString\");\n    __name(maybeJson, \"maybeJson\");\n    __name(parseObject, \"parseObject\");\n    LibsqlError = class extends Error {\n      static {\n        __name(this, \"LibsqlError\");\n      }\n      /** Machine-readable error code. */\n      code;\n      /** Raw numeric error code */\n      rawCode;\n      constructor(message, code, rawCode, cause) {\n        if (code !== void 0) {\n          message = `${code}: ${message}`;\n        }\n        super(message, { cause });\n        this.code = code;\n        this.rawCode = rawCode;\n        this.name = \"LibsqlError\";\n      }\n    };\n    __name(parseUri, \"parseUri\");\n    URI_RE = (() => {\n      const SCHEME = \"(?<scheme>[A-Za-z][A-Za-z.+-]*)\";\n      const AUTHORITY = \"(?<authority>[^/?#]*)\";\n      const PATH = \"(?<path>[^?#]*)\";\n      const QUERY = \"(?<query>[^#]*)\";\n      const FRAGMENT = \"(?<fragment>.*)\";\n      return new RegExp(`^${SCHEME}:(//${AUTHORITY})?${PATH}(\\\\?${QUERY})?(#${FRAGMENT})?$`, \"su\");\n    })();\n    __name(parseAuthority, \"parseAuthority\");\n    AUTHORITY_RE = (() => {\n      return new RegExp(`^((?<username>[^:]*)(:(?<password>.*))?@)?((?<host>[^:\\\\[\\\\]]*)|(\\\\[(?<host_br>[^\\\\[\\\\]]*)\\\\]))(:(?<port>[0-9]*))?$`, \"su\");\n    })();\n    __name(parseQuery, \"parseQuery\");\n    __name(percentDecode, \"percentDecode\");\n    __name(encodeBaseUrl, \"encodeBaseUrl\");\n    __name(encodeHost, \"encodeHost\");\n    __name(encodePort, \"encodePort\");\n    __name(encodeUserinfo, \"encodeUserinfo\");\n    version2 = \"3.7.7\";\n    VERSION = version2;\n    _hasBuffer = typeof Buffer === \"function\";\n    _TD = typeof TextDecoder === \"function\" ? new TextDecoder() : void 0;\n    _TE = typeof TextEncoder === \"function\" ? new TextEncoder() : void 0;\n    b64ch = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    b64chs = Array.prototype.slice.call(b64ch);\n    b64tab = ((a2) => {\n      let tab = {};\n      a2.forEach((c, i) => tab[c] = i);\n      return tab;\n    })(b64chs);\n    b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    _fromCC = String.fromCharCode.bind(String);\n    _U8Afrom = typeof Uint8Array.from === \"function\" ? Uint8Array.from.bind(Uint8Array) : (it2) => new Uint8Array(Array.prototype.slice.call(it2, 0));\n    _mkUriSafe = /* @__PURE__ */ __name((src) => src.replace(/=/g, \"\").replace(/[+\\/]/g, (m0) => m0 == \"+\" ? \"-\" : \"_\"), \"_mkUriSafe\");\n    _tidyB64 = /* @__PURE__ */ __name((s2) => s2.replace(/[^A-Za-z0-9\\+\\/]/g, \"\"), \"_tidyB64\");\n    btoaPolyfill = /* @__PURE__ */ __name((bin) => {\n      let u32, c0, c1, c2, asc = \"\";\n      const pad = bin.length % 3;\n      for (let i = 0; i < bin.length; ) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)\n          throw new TypeError(\"invalid character found\");\n        u32 = c0 << 16 | c1 << 8 | c2;\n        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];\n      }\n      return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n    }, \"btoaPolyfill\");\n    _btoa = typeof btoa === \"function\" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, \"binary\").toString(\"base64\") : btoaPolyfill;\n    _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString(\"base64\") : (u8a) => {\n      const maxargs = 4096;\n      let strs = [];\n      for (let i = 0, l2 = u8a.length; i < l2; i += maxargs) {\n        strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n      }\n      return _btoa(strs.join(\"\"));\n    };\n    fromUint8Array = /* @__PURE__ */ __name((u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a), \"fromUint8Array\");\n    cb_utob = /* @__PURE__ */ __name((c) => {\n      if (c.length < 2) {\n        var cc2 = c.charCodeAt(0);\n        return cc2 < 128 ? c : cc2 < 2048 ? _fromCC(192 | cc2 >>> 6) + _fromCC(128 | cc2 & 63) : _fromCC(224 | cc2 >>> 12 & 15) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);\n      } else {\n        var cc2 = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);\n        return _fromCC(240 | cc2 >>> 18 & 7) + _fromCC(128 | cc2 >>> 12 & 63) + _fromCC(128 | cc2 >>> 6 & 63) + _fromCC(128 | cc2 & 63);\n      }\n    }, \"cb_utob\");\n    re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    utob = /* @__PURE__ */ __name((u3) => u3.replace(re_utob, cb_utob), \"utob\");\n    _encode = _hasBuffer ? (s2) => Buffer.from(s2, \"utf8\").toString(\"base64\") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));\n    encode = /* @__PURE__ */ __name((src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src), \"encode\");\n    encodeURI$1 = /* @__PURE__ */ __name((src) => encode(src, true), \"encodeURI$1\");\n    re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n    cb_btou = /* @__PURE__ */ __name((cccc) => {\n      switch (cccc.length) {\n        case 4:\n          var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;\n          return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);\n        case 3:\n          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));\n        default:\n          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));\n      }\n    }, \"cb_btou\");\n    btou = /* @__PURE__ */ __name((b3) => b3.replace(re_btou, cb_btou), \"btou\");\n    atobPolyfill = /* @__PURE__ */ __name((asc) => {\n      asc = asc.replace(/\\s+/g, \"\");\n      if (!b64re.test(asc))\n        throw new TypeError(\"malformed base64.\");\n      asc += \"==\".slice(2 - (asc.length & 3));\n      let u24, bin = \"\", r1, r2;\n      for (let i = 0; i < asc.length; ) {\n        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n      }\n      return bin;\n    }, \"atobPolyfill\");\n    _atob = typeof atob === \"function\" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, \"base64\").toString(\"binary\") : atobPolyfill;\n    _toUint8Array = _hasBuffer ? (a2) => _U8Afrom(Buffer.from(a2, \"base64\")) : (a2) => _U8Afrom(_atob(a2).split(\"\").map((c) => c.charCodeAt(0)));\n    toUint8Array = /* @__PURE__ */ __name((a2) => _toUint8Array(_unURI(a2)), \"toUint8Array\");\n    _decode = _hasBuffer ? (a2) => Buffer.from(a2, \"base64\").toString(\"utf8\") : _TD ? (a2) => _TD.decode(_toUint8Array(a2)) : (a2) => btou(_atob(a2));\n    _unURI = /* @__PURE__ */ __name((a2) => _tidyB64(a2.replace(/[-_]/g, (m0) => m0 == \"-\" ? \"+\" : \"/\")), \"_unURI\");\n    decode$2 = /* @__PURE__ */ __name((src) => _decode(_unURI(src)), \"decode$2\");\n    isValid = /* @__PURE__ */ __name((src) => {\n      if (typeof src !== \"string\")\n        return false;\n      const s2 = src.replace(/\\s+/g, \"\").replace(/={0,2}$/, \"\");\n      return !/[^\\s0-9a-zA-Z\\+/]/.test(s2) || !/[^\\s0-9a-zA-Z\\-_]/.test(s2);\n    }, \"isValid\");\n    _noEnum = /* @__PURE__ */ __name((v3) => {\n      return {\n        value: v3,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      };\n    }, \"_noEnum\");\n    extendString = /* @__PURE__ */ __name(function() {\n      const _add = /* @__PURE__ */ __name((name, body) => Object.defineProperty(String.prototype, name, _noEnum(body)), \"_add\");\n      _add(\"fromBase64\", function() {\n        return decode$2(this);\n      });\n      _add(\"toBase64\", function(urlsafe) {\n        return encode(this, urlsafe);\n      });\n      _add(\"toBase64URI\", function() {\n        return encode(this, true);\n      });\n      _add(\"toBase64URL\", function() {\n        return encode(this, true);\n      });\n      _add(\"toUint8Array\", function() {\n        return toUint8Array(this);\n      });\n    }, \"extendString\");\n    extendUint8Array = /* @__PURE__ */ __name(function() {\n      const _add = /* @__PURE__ */ __name((name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)), \"_add\");\n      _add(\"toBase64\", function(urlsafe) {\n        return fromUint8Array(this, urlsafe);\n      });\n      _add(\"toBase64URI\", function() {\n        return fromUint8Array(this, true);\n      });\n      _add(\"toBase64URL\", function() {\n        return fromUint8Array(this, true);\n      });\n    }, \"extendUint8Array\");\n    extendBuiltins = /* @__PURE__ */ __name(() => {\n      extendString();\n      extendUint8Array();\n    }, \"extendBuiltins\");\n    gBase64 = {\n      version: version2,\n      VERSION,\n      atob: _atob,\n      atobPolyfill,\n      btoa: _btoa,\n      btoaPolyfill,\n      fromBase64: decode$2,\n      toBase64: encode,\n      encode,\n      encodeURI: encodeURI$1,\n      encodeURL: encodeURI$1,\n      utob,\n      btou,\n      decode: decode$2,\n      isValid,\n      fromUint8Array,\n      toUint8Array,\n      extendString,\n      extendUint8Array,\n      extendBuiltins\n    };\n    supportedUrlLink = \"https://github.com/libsql/libsql-client-ts#supported-urls\";\n    __name(transactionModeToBegin, \"transactionModeToBegin\");\n    ResultSetImpl = class {\n      static {\n        __name(this, \"ResultSetImpl\");\n      }\n      columns;\n      columnTypes;\n      rows;\n      rowsAffected;\n      lastInsertRowid;\n      constructor(columns, columnTypes, rows, rowsAffected, lastInsertRowid) {\n        this.columns = columns;\n        this.columnTypes = columnTypes;\n        this.rows = rows;\n        this.rowsAffected = rowsAffected;\n        this.lastInsertRowid = lastInsertRowid;\n      }\n      toJSON() {\n        return {\n          columns: this.columns,\n          columnTypes: this.columnTypes,\n          rows: this.rows.map(rowToJson),\n          rowsAffected: this.rowsAffected,\n          lastInsertRowid: this.lastInsertRowid !== void 0 ? \"\" + this.lastInsertRowid : null\n        };\n      }\n    };\n    __name(rowToJson, \"rowToJson\");\n    __name(valueToJson, \"valueToJson\");\n    inMemoryMode = \":memory:\";\n    __name(expandConfig, \"expandConfig\");\n    if (typeof WebSocket !== \"undefined\") {\n      _WebSocket = WebSocket;\n    } else if (typeof global !== \"undefined\") {\n      _WebSocket = global.WebSocket;\n    } else if (typeof window !== \"undefined\") {\n      _WebSocket = window.WebSocket;\n    } else if (typeof self !== \"undefined\") {\n      _WebSocket = self.WebSocket;\n    }\n    Client = class {\n      static {\n        __name(this, \"Client\");\n      }\n      /** @private */\n      constructor() {\n        this.intMode = \"number\";\n      }\n      /** Representation of integers returned from the database. See {@link IntMode}.\n       *\n       * This value is inherited by {@link Stream} objects created with {@link openStream}, but you can\n       * override the integer mode for every stream by setting {@link Stream.intMode} on the stream.\n       */\n      intMode;\n    };\n    ClientError = class extends Error {\n      static {\n        __name(this, \"ClientError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"ClientError\";\n      }\n    };\n    ProtoError = class extends ClientError {\n      static {\n        __name(this, \"ProtoError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"ProtoError\";\n      }\n    };\n    ResponseError = class extends ClientError {\n      static {\n        __name(this, \"ResponseError\");\n      }\n      code;\n      /** @internal */\n      proto;\n      /** @private */\n      constructor(message, protoError) {\n        super(message);\n        this.name = \"ResponseError\";\n        this.code = protoError.code;\n        this.proto = protoError;\n        this.stack = void 0;\n      }\n    };\n    ClosedError = class extends ClientError {\n      static {\n        __name(this, \"ClosedError\");\n      }\n      /** @private */\n      constructor(message, cause) {\n        if (cause !== void 0) {\n          super(`${message}: ${cause}`);\n          this.cause = cause;\n        } else {\n          super(message);\n        }\n        this.name = \"ClosedError\";\n      }\n    };\n    WebSocketUnsupportedError = class extends ClientError {\n      static {\n        __name(this, \"WebSocketUnsupportedError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"WebSocketUnsupportedError\";\n      }\n    };\n    WebSocketError = class extends ClientError {\n      static {\n        __name(this, \"WebSocketError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"WebSocketError\";\n      }\n    };\n    HttpServerError = class extends ClientError {\n      static {\n        __name(this, \"HttpServerError\");\n      }\n      status;\n      /** @private */\n      constructor(message, status) {\n        super(message);\n        this.status = status;\n        this.name = \"HttpServerError\";\n      }\n    };\n    ProtocolVersionError = class extends ClientError {\n      static {\n        __name(this, \"ProtocolVersionError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"ProtocolVersionError\";\n      }\n    };\n    InternalError = class extends ClientError {\n      static {\n        __name(this, \"InternalError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"InternalError\";\n      }\n    };\n    MisuseError = class extends ClientError {\n      static {\n        __name(this, \"MisuseError\");\n      }\n      /** @private */\n      constructor(message) {\n        super(message);\n        this.name = \"MisuseError\";\n      }\n    };\n    __name(string, \"string\");\n    __name(stringOpt, \"stringOpt\");\n    __name(number, \"number\");\n    __name(boolean, \"boolean\");\n    __name(array, \"array\");\n    __name(object, \"object\");\n    __name(arrayObjectsMap, \"arrayObjectsMap\");\n    __name(typeError, \"typeError\");\n    __name(readJsonObject, \"readJsonObject\");\n    ObjectWriter = class {\n      static {\n        __name(this, \"ObjectWriter\");\n      }\n      #output;\n      #isFirst;\n      constructor(output) {\n        this.#output = output;\n        this.#isFirst = false;\n      }\n      begin() {\n        this.#output.push(\"{\");\n        this.#isFirst = true;\n      }\n      end() {\n        this.#output.push(\"}\");\n        this.#isFirst = false;\n      }\n      #key(name) {\n        if (this.#isFirst) {\n          this.#output.push('\"');\n          this.#isFirst = false;\n        } else {\n          this.#output.push(',\"');\n        }\n        this.#output.push(name);\n        this.#output.push('\":');\n      }\n      string(name, value2) {\n        this.#key(name);\n        this.#output.push(JSON.stringify(value2));\n      }\n      stringRaw(name, value2) {\n        this.#key(name);\n        this.#output.push('\"');\n        this.#output.push(value2);\n        this.#output.push('\"');\n      }\n      number(name, value2) {\n        this.#key(name);\n        this.#output.push(\"\" + value2);\n      }\n      boolean(name, value2) {\n        this.#key(name);\n        this.#output.push(value2 ? \"true\" : \"false\");\n      }\n      object(name, value2, valueFun) {\n        this.#key(name);\n        this.begin();\n        valueFun(this, value2);\n        this.end();\n      }\n      arrayObjects(name, values, valueFun) {\n        this.#key(name);\n        this.#output.push(\"[\");\n        for (let i = 0; i < values.length; ++i) {\n          if (i !== 0) {\n            this.#output.push(\",\");\n          }\n          this.begin();\n          valueFun(this, values[i]);\n          this.end();\n        }\n        this.#output.push(\"]\");\n      }\n    };\n    __name(writeJsonObject, \"writeJsonObject\");\n    VARINT = 0;\n    FIXED_64 = 1;\n    LENGTH_DELIMITED = 2;\n    FIXED_32 = 5;\n    MessageReader = class {\n      static {\n        __name(this, \"MessageReader\");\n      }\n      #array;\n      #view;\n      #pos;\n      constructor(array2) {\n        this.#array = array2;\n        this.#view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);\n        this.#pos = 0;\n      }\n      varint() {\n        let value2 = 0;\n        for (let shift = 0; ; shift += 7) {\n          const byte = this.#array[this.#pos++];\n          value2 |= (byte & 127) << shift;\n          if (!(byte & 128)) {\n            break;\n          }\n        }\n        return value2;\n      }\n      varintBig() {\n        let value2 = 0n;\n        for (let shift = 0n; ; shift += 7n) {\n          const byte = this.#array[this.#pos++];\n          value2 |= BigInt(byte & 127) << shift;\n          if (!(byte & 128)) {\n            break;\n          }\n        }\n        return value2;\n      }\n      bytes(length) {\n        const array2 = new Uint8Array(this.#array.buffer, this.#array.byteOffset + this.#pos, length);\n        this.#pos += length;\n        return array2;\n      }\n      double() {\n        const value2 = this.#view.getFloat64(this.#pos, true);\n        this.#pos += 8;\n        return value2;\n      }\n      skipVarint() {\n        for (; ; ) {\n          const byte = this.#array[this.#pos++];\n          if (!(byte & 128)) {\n            break;\n          }\n        }\n      }\n      skip(count3) {\n        this.#pos += count3;\n      }\n      eof() {\n        return this.#pos >= this.#array.byteLength;\n      }\n    };\n    FieldReader = class {\n      static {\n        __name(this, \"FieldReader\");\n      }\n      #reader;\n      #wireType;\n      constructor(reader) {\n        this.#reader = reader;\n        this.#wireType = -1;\n      }\n      setup(wireType) {\n        this.#wireType = wireType;\n      }\n      #expect(expectedWireType) {\n        if (this.#wireType !== expectedWireType) {\n          throw new ProtoError(`Expected wire type ${expectedWireType}, got ${this.#wireType}`);\n        }\n        this.#wireType = -1;\n      }\n      bytes() {\n        this.#expect(LENGTH_DELIMITED);\n        const length = this.#reader.varint();\n        return this.#reader.bytes(length);\n      }\n      string() {\n        return new TextDecoder().decode(this.bytes());\n      }\n      message(def) {\n        return readProtobufMessage(this.bytes(), def);\n      }\n      int32() {\n        this.#expect(VARINT);\n        return this.#reader.varint();\n      }\n      uint32() {\n        return this.int32();\n      }\n      bool() {\n        return this.int32() !== 0;\n      }\n      uint64() {\n        this.#expect(VARINT);\n        return this.#reader.varintBig();\n      }\n      sint64() {\n        const value2 = this.uint64();\n        return value2 >> 1n ^ -(value2 & 1n);\n      }\n      double() {\n        this.#expect(FIXED_64);\n        return this.#reader.double();\n      }\n      maybeSkip() {\n        if (this.#wireType < 0) {\n          return;\n        } else if (this.#wireType === VARINT) {\n          this.#reader.skipVarint();\n        } else if (this.#wireType === FIXED_64) {\n          this.#reader.skip(8);\n        } else if (this.#wireType === LENGTH_DELIMITED) {\n          const length = this.#reader.varint();\n          this.#reader.skip(length);\n        } else if (this.#wireType === FIXED_32) {\n          this.#reader.skip(4);\n        } else {\n          throw new ProtoError(`Unexpected wire type ${this.#wireType}`);\n        }\n        this.#wireType = -1;\n      }\n    };\n    __name(readProtobufMessage, \"readProtobufMessage\");\n    MessageWriter = class _MessageWriter {\n      static {\n        __name(this, \"MessageWriter\");\n      }\n      #buf;\n      #array;\n      #view;\n      #pos;\n      constructor() {\n        this.#buf = new ArrayBuffer(256);\n        this.#array = new Uint8Array(this.#buf);\n        this.#view = new DataView(this.#buf);\n        this.#pos = 0;\n      }\n      #ensure(extra) {\n        if (this.#pos + extra <= this.#buf.byteLength) {\n          return;\n        }\n        let newCap = this.#buf.byteLength;\n        while (newCap < this.#pos + extra) {\n          newCap *= 2;\n        }\n        const newBuf = new ArrayBuffer(newCap);\n        const newArray = new Uint8Array(newBuf);\n        const newView = new DataView(newBuf);\n        newArray.set(new Uint8Array(this.#buf, 0, this.#pos));\n        this.#buf = newBuf;\n        this.#array = newArray;\n        this.#view = newView;\n      }\n      #varint(value2) {\n        this.#ensure(5);\n        value2 = 0 | value2;\n        do {\n          let byte = value2 & 127;\n          value2 >>>= 7;\n          byte |= value2 ? 128 : 0;\n          this.#array[this.#pos++] = byte;\n        } while (value2);\n      }\n      #varintBig(value2) {\n        this.#ensure(10);\n        value2 = value2 & 0xffffffffffffffffn;\n        do {\n          let byte = Number(value2 & 0x7fn);\n          value2 >>= 7n;\n          byte |= value2 ? 128 : 0;\n          this.#array[this.#pos++] = byte;\n        } while (value2);\n      }\n      #tag(tag, wireType) {\n        this.#varint(tag << 3 | wireType);\n      }\n      bytes(tag, value2) {\n        this.#tag(tag, LENGTH_DELIMITED);\n        this.#varint(value2.byteLength);\n        this.#ensure(value2.byteLength);\n        this.#array.set(value2, this.#pos);\n        this.#pos += value2.byteLength;\n      }\n      string(tag, value2) {\n        this.bytes(tag, new TextEncoder().encode(value2));\n      }\n      message(tag, value2, fun) {\n        const writer = new _MessageWriter();\n        fun(writer, value2);\n        this.bytes(tag, writer.data());\n      }\n      int32(tag, value2) {\n        this.#tag(tag, VARINT);\n        this.#varint(value2);\n      }\n      uint32(tag, value2) {\n        this.int32(tag, value2);\n      }\n      bool(tag, value2) {\n        this.int32(tag, value2 ? 1 : 0);\n      }\n      sint64(tag, value2) {\n        this.#tag(tag, VARINT);\n        this.#varintBig(value2 << 1n ^ value2 >> 63n);\n      }\n      double(tag, value2) {\n        this.#tag(tag, FIXED_64);\n        this.#ensure(8);\n        this.#view.setFloat64(this.#pos, value2, true);\n        this.#pos += 8;\n      }\n      data() {\n        return new Uint8Array(this.#buf, 0, this.#pos);\n      }\n    };\n    __name(writeProtobufMessage, \"writeProtobufMessage\");\n    IdAlloc = class {\n      static {\n        __name(this, \"IdAlloc\");\n      }\n      // Set of all allocated ids\n      #usedIds;\n      // Set of all free ids lower than `#usedIds.size`\n      #freeIds;\n      constructor() {\n        this.#usedIds = /* @__PURE__ */ new Set();\n        this.#freeIds = /* @__PURE__ */ new Set();\n      }\n      // Returns an id that was free, and marks it as used.\n      alloc() {\n        for (const freeId2 of this.#freeIds) {\n          this.#freeIds.delete(freeId2);\n          this.#usedIds.add(freeId2);\n          if (!this.#usedIds.has(this.#usedIds.size - 1)) {\n            this.#freeIds.add(this.#usedIds.size - 1);\n          }\n          return freeId2;\n        }\n        const freeId = this.#usedIds.size;\n        this.#usedIds.add(freeId);\n        return freeId;\n      }\n      free(id2) {\n        if (!this.#usedIds.delete(id2)) {\n          throw new InternalError(\"Freeing an id that is not allocated\");\n        }\n        this.#freeIds.delete(this.#usedIds.size);\n        if (id2 < this.#usedIds.size) {\n          this.#freeIds.add(id2);\n        }\n      }\n    };\n    __name(impossible, \"impossible\");\n    __name(valueToProto, \"valueToProto\");\n    minInteger = -9223372036854775808n;\n    maxInteger = 9223372036854775807n;\n    __name(valueFromProto, \"valueFromProto\");\n    __name(stmtResultFromProto, \"stmtResultFromProto\");\n    __name(rowsResultFromProto, \"rowsResultFromProto\");\n    __name(rowResultFromProto, \"rowResultFromProto\");\n    __name(valueResultFromProto, \"valueResultFromProto\");\n    __name(rowFromProto, \"rowFromProto\");\n    __name(errorFromProto, \"errorFromProto\");\n    Sql = class {\n      static {\n        __name(this, \"Sql\");\n      }\n      #owner;\n      #sqlId;\n      #closed;\n      /** @private */\n      constructor(owner, sqlId) {\n        this.#owner = owner;\n        this.#sqlId = sqlId;\n        this.#closed = void 0;\n      }\n      /** @private */\n      _getSqlId(owner) {\n        if (this.#owner !== owner) {\n          throw new MisuseError(\"Attempted to use SQL text opened with other object\");\n        } else if (this.#closed !== void 0) {\n          throw new ClosedError(\"SQL text is closed\", this.#closed);\n        }\n        return this.#sqlId;\n      }\n      /** Remove the SQL text from the server, releasing resouces. */\n      close() {\n        this._setClosed(new ClientError(\"SQL text was manually closed\"));\n      }\n      /** @private */\n      _setClosed(error4) {\n        if (this.#closed === void 0) {\n          this.#closed = error4;\n          this.#owner._closeSql(this.#sqlId);\n        }\n      }\n      /** True if the SQL text is closed (removed from the server). */\n      get closed() {\n        return this.#closed !== void 0;\n      }\n    };\n    __name(sqlToProto, \"sqlToProto\");\n    Queue = class {\n      static {\n        __name(this, \"Queue\");\n      }\n      #pushStack;\n      #shiftStack;\n      constructor() {\n        this.#pushStack = [];\n        this.#shiftStack = [];\n      }\n      get length() {\n        return this.#pushStack.length + this.#shiftStack.length;\n      }\n      push(elem) {\n        this.#pushStack.push(elem);\n      }\n      shift() {\n        if (this.#shiftStack.length === 0 && this.#pushStack.length > 0) {\n          this.#shiftStack = this.#pushStack.reverse();\n          this.#pushStack = [];\n        }\n        return this.#shiftStack.pop();\n      }\n      first() {\n        return this.#shiftStack.length !== 0 ? this.#shiftStack[this.#shiftStack.length - 1] : this.#pushStack[0];\n      }\n    };\n    Stmt$2 = class Stmt {\n      static {\n        __name(this, \"Stmt\");\n      }\n      /** The SQL statement text. */\n      sql;\n      /** @private */\n      _args;\n      /** @private */\n      _namedArgs;\n      /** Initialize the statement with given SQL text. */\n      constructor(sql2) {\n        this.sql = sql2;\n        this._args = [];\n        this._namedArgs = /* @__PURE__ */ new Map();\n      }\n      /** Binds positional parameters from the given `values`. All previous positional bindings are cleared. */\n      bindIndexes(values) {\n        this._args.length = 0;\n        for (const value2 of values) {\n          this._args.push(valueToProto(value2));\n        }\n        return this;\n      }\n      /** Binds a parameter by a 1-based index. */\n      bindIndex(index, value2) {\n        if (index !== (index | 0) || index <= 0) {\n          throw new RangeError(\"Index of a positional argument must be positive integer\");\n        }\n        while (this._args.length < index) {\n          this._args.push(null);\n        }\n        this._args[index - 1] = valueToProto(value2);\n        return this;\n      }\n      /** Binds a parameter by name. */\n      bindName(name, value2) {\n        this._namedArgs.set(name, valueToProto(value2));\n        return this;\n      }\n      /** Clears all bindings. */\n      unbindAll() {\n        this._args.length = 0;\n        this._namedArgs.clear();\n        return this;\n      }\n    };\n    __name(stmtToProto, \"stmtToProto\");\n    Batch$2 = class Batch {\n      static {\n        __name(this, \"Batch\");\n      }\n      /** @private */\n      _stream;\n      #useCursor;\n      /** @private */\n      _steps;\n      #executed;\n      /** @private */\n      constructor(stream, useCursor) {\n        this._stream = stream;\n        this.#useCursor = useCursor;\n        this._steps = [];\n        this.#executed = false;\n      }\n      /** Return a builder for adding a step to the batch. */\n      step() {\n        return new BatchStep$2(this);\n      }\n      /** Execute the batch. */\n      execute() {\n        if (this.#executed) {\n          throw new MisuseError(\"This batch has already been executed\");\n        }\n        this.#executed = true;\n        const batch = {\n          steps: this._steps.map((step) => step.proto)\n        };\n        if (this.#useCursor) {\n          return executeCursor(this._stream, this._steps, batch);\n        } else {\n          return executeRegular(this._stream, this._steps, batch);\n        }\n      }\n    };\n    __name(executeRegular, \"executeRegular\");\n    __name(executeCursor, \"executeCursor\");\n    BatchStep$2 = class BatchStep {\n      static {\n        __name(this, \"BatchStep\");\n      }\n      /** @private */\n      _batch;\n      #conds;\n      /** @private */\n      _index;\n      /** @private */\n      constructor(batch) {\n        this._batch = batch;\n        this.#conds = [];\n        this._index = void 0;\n      }\n      /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple\n       * times, we join the conditions with a logical AND. */\n      condition(cond) {\n        this.#conds.push(cond._proto);\n        return this;\n      }\n      /** Add a statement that returns rows. */\n      query(stmt) {\n        return this.#add(stmt, true, rowsResultFromProto);\n      }\n      /** Add a statement that returns at most a single row. */\n      queryRow(stmt) {\n        return this.#add(stmt, true, rowResultFromProto);\n      }\n      /** Add a statement that returns at most a single value. */\n      queryValue(stmt) {\n        return this.#add(stmt, true, valueResultFromProto);\n      }\n      /** Add a statement without returning rows. */\n      run(stmt) {\n        return this.#add(stmt, false, stmtResultFromProto);\n      }\n      #add(inStmt, wantRows, fromProto) {\n        if (this._index !== void 0) {\n          throw new MisuseError(\"This BatchStep has already been added to the batch\");\n        }\n        const stmt = stmtToProto(this._batch._stream._sqlOwner(), inStmt, wantRows);\n        let condition;\n        if (this.#conds.length === 0) {\n          condition = void 0;\n        } else if (this.#conds.length === 1) {\n          condition = this.#conds[0];\n        } else {\n          condition = { type: \"and\", conds: this.#conds.slice() };\n        }\n        const proto = { stmt, condition };\n        return new Promise((outputCallback, errorCallback) => {\n          const callback = /* @__PURE__ */ __name((stepResult, stepError) => {\n            if (stepResult !== void 0 && stepError !== void 0) {\n              errorCallback(new ProtoError(\"Server returned both result and error\"));\n            } else if (stepError !== void 0) {\n              errorCallback(errorFromProto(stepError));\n            } else if (stepResult !== void 0) {\n              outputCallback(fromProto(stepResult, this._batch._stream.intMode));\n            } else {\n              outputCallback(void 0);\n            }\n          }, \"callback\");\n          this._index = this._batch._steps.length;\n          this._batch._steps.push({ proto, callback });\n        });\n      }\n    };\n    BatchCond$2 = class BatchCond {\n      static {\n        __name(this, \"BatchCond\");\n      }\n      /** @private */\n      _batch;\n      /** @private */\n      _proto;\n      /** @private */\n      constructor(batch, proto) {\n        this._batch = batch;\n        this._proto = proto;\n      }\n      /** Create a condition that evaluates to true when the given step executes successfully.\n       *\n       * If the given step fails error or is skipped because its condition evaluated to false, this\n       * condition evaluates to false.\n       */\n      static ok(step) {\n        return new BatchCond(step._batch, { type: \"ok\", step: stepIndex(step) });\n      }\n      /** Create a condition that evaluates to true when the given step fails.\n       *\n       * If the given step succeeds or is skipped because its condition evaluated to false, this condition\n       * evaluates to false.\n       */\n      static error(step) {\n        return new BatchCond(step._batch, { type: \"error\", step: stepIndex(step) });\n      }\n      /** Create a condition that is a logical negation of another condition.\n       */\n      static not(cond) {\n        return new BatchCond(cond._batch, { type: \"not\", cond: cond._proto });\n      }\n      /** Create a condition that is a logical AND of other conditions.\n       */\n      static and(batch, conds) {\n        for (const cond of conds) {\n          checkCondBatch(batch, cond);\n        }\n        return new BatchCond(batch, { type: \"and\", conds: conds.map((e) => e._proto) });\n      }\n      /** Create a condition that is a logical OR of other conditions.\n       */\n      static or(batch, conds) {\n        for (const cond of conds) {\n          checkCondBatch(batch, cond);\n        }\n        return new BatchCond(batch, { type: \"or\", conds: conds.map((e) => e._proto) });\n      }\n      /** Create a condition that evaluates to true when the SQL connection is in autocommit mode (not inside an\n       * explicit transaction). This requires protocol version 3 or higher.\n       */\n      static isAutocommit(batch) {\n        batch._stream.client()._ensureVersion(3, \"BatchCond.isAutocommit()\");\n        return new BatchCond(batch, { type: \"is_autocommit\" });\n      }\n    };\n    __name(stepIndex, \"stepIndex\");\n    __name(checkCondBatch, \"checkCondBatch\");\n    __name(describeResultFromProto, \"describeResultFromProto\");\n    Stream = class {\n      static {\n        __name(this, \"Stream\");\n      }\n      /** @private */\n      constructor(intMode) {\n        this.intMode = intMode;\n      }\n      /** Execute a statement and return rows. */\n      query(stmt) {\n        return this.#execute(stmt, true, rowsResultFromProto);\n      }\n      /** Execute a statement and return at most a single row. */\n      queryRow(stmt) {\n        return this.#execute(stmt, true, rowResultFromProto);\n      }\n      /** Execute a statement and return at most a single value. */\n      queryValue(stmt) {\n        return this.#execute(stmt, true, valueResultFromProto);\n      }\n      /** Execute a statement without returning rows. */\n      run(stmt) {\n        return this.#execute(stmt, false, stmtResultFromProto);\n      }\n      #execute(inStmt, wantRows, fromProto) {\n        const stmt = stmtToProto(this._sqlOwner(), inStmt, wantRows);\n        return this._execute(stmt).then((r2) => fromProto(r2, this.intMode));\n      }\n      /** Return a builder for creating and executing a batch.\n       *\n       * If `useCursor` is true, the batch will be executed using a Hrana cursor, which will stream results from\n       * the server to the client, which consumes less memory on the server. This requires protocol version 3 or\n       * higher.\n       */\n      batch(useCursor = false) {\n        return new Batch$2(this, useCursor);\n      }\n      /** Parse and analyze a statement. This requires protocol version 2 or higher. */\n      describe(inSql) {\n        const protoSql = sqlToProto(this._sqlOwner(), inSql);\n        return this._describe(protoSql).then(describeResultFromProto);\n      }\n      /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.\n       * */\n      sequence(inSql) {\n        const protoSql = sqlToProto(this._sqlOwner(), inSql);\n        return this._sequence(protoSql);\n      }\n      /** Representation of integers returned from the database. See {@link IntMode}.\n       *\n       * This value affects the results of all operations on this stream.\n       */\n      intMode;\n    };\n    Cursor = class {\n      static {\n        __name(this, \"Cursor\");\n      }\n    };\n    fetchChunkSize = 1e3;\n    fetchQueueSize = 10;\n    WsCursor = class extends Cursor {\n      static {\n        __name(this, \"WsCursor\");\n      }\n      #client;\n      #stream;\n      #cursorId;\n      #entryQueue;\n      #fetchQueue;\n      #closed;\n      #done;\n      /** @private */\n      constructor(client, stream, cursorId) {\n        super();\n        this.#client = client;\n        this.#stream = stream;\n        this.#cursorId = cursorId;\n        this.#entryQueue = new Queue();\n        this.#fetchQueue = new Queue();\n        this.#closed = void 0;\n        this.#done = false;\n      }\n      /** Fetch the next entry from the cursor. */\n      async next() {\n        for (; ; ) {\n          if (this.#closed !== void 0) {\n            throw new ClosedError(\"Cursor is closed\", this.#closed);\n          }\n          while (!this.#done && this.#fetchQueue.length < fetchQueueSize) {\n            this.#fetchQueue.push(this.#fetch());\n          }\n          const entry = this.#entryQueue.shift();\n          if (this.#done || entry !== void 0) {\n            return entry;\n          }\n          await this.#fetchQueue.shift().then((response) => {\n            if (response === void 0) {\n              return;\n            }\n            for (const entry2 of response.entries) {\n              this.#entryQueue.push(entry2);\n            }\n            this.#done ||= response.done;\n          });\n        }\n      }\n      #fetch() {\n        return this.#stream._sendCursorRequest(this, {\n          type: \"fetch_cursor\",\n          cursorId: this.#cursorId,\n          maxCount: fetchChunkSize\n        }).then((resp) => resp, (error4) => {\n          this._setClosed(error4);\n          return void 0;\n        });\n      }\n      /** @private */\n      _setClosed(error4) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#closed = error4;\n        this.#stream._sendCursorRequest(this, {\n          type: \"close_cursor\",\n          cursorId: this.#cursorId\n        }).catch(() => void 0);\n        this.#stream._cursorClosed(this);\n      }\n      /** Close the cursor. */\n      close() {\n        this._setClosed(new ClientError(\"Cursor was manually closed\"));\n      }\n      /** True if the cursor is closed. */\n      get closed() {\n        return this.#closed !== void 0;\n      }\n    };\n    WsStream = class _WsStream extends Stream {\n      static {\n        __name(this, \"WsStream\");\n      }\n      #client;\n      #streamId;\n      #queue;\n      #cursor;\n      #closing;\n      #closed;\n      /** @private */\n      static open(client) {\n        const streamId = client._streamIdAlloc.alloc();\n        const stream = new _WsStream(client, streamId);\n        const responseCallback = /* @__PURE__ */ __name(() => void 0, \"responseCallback\");\n        const errorCallback = /* @__PURE__ */ __name((e) => stream.#setClosed(e), \"errorCallback\");\n        const request = { type: \"open_stream\", streamId };\n        client._sendRequest(request, { responseCallback, errorCallback });\n        return stream;\n      }\n      /** @private */\n      constructor(client, streamId) {\n        super(client.intMode);\n        this.#client = client;\n        this.#streamId = streamId;\n        this.#queue = new Queue();\n        this.#cursor = void 0;\n        this.#closing = false;\n        this.#closed = void 0;\n      }\n      /** Get the {@link WsClient} object that this stream belongs to. */\n      client() {\n        return this.#client;\n      }\n      /** @private */\n      _sqlOwner() {\n        return this.#client;\n      }\n      /** @private */\n      _execute(stmt) {\n        return this.#sendStreamRequest({\n          type: \"execute\",\n          streamId: this.#streamId,\n          stmt\n        }).then((response) => {\n          return response.result;\n        });\n      }\n      /** @private */\n      _batch(batch) {\n        return this.#sendStreamRequest({\n          type: \"batch\",\n          streamId: this.#streamId,\n          batch\n        }).then((response) => {\n          return response.result;\n        });\n      }\n      /** @private */\n      _describe(protoSql) {\n        this.#client._ensureVersion(2, \"describe()\");\n        return this.#sendStreamRequest({\n          type: \"describe\",\n          streamId: this.#streamId,\n          sql: protoSql.sql,\n          sqlId: protoSql.sqlId\n        }).then((response) => {\n          return response.result;\n        });\n      }\n      /** @private */\n      _sequence(protoSql) {\n        this.#client._ensureVersion(2, \"sequence()\");\n        return this.#sendStreamRequest({\n          type: \"sequence\",\n          streamId: this.#streamId,\n          sql: protoSql.sql,\n          sqlId: protoSql.sqlId\n        }).then((_response) => {\n          return void 0;\n        });\n      }\n      /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an\n       * explicit transaction). This requires protocol version 3 or higher.\n       */\n      getAutocommit() {\n        this.#client._ensureVersion(3, \"getAutocommit()\");\n        return this.#sendStreamRequest({\n          type: \"get_autocommit\",\n          streamId: this.#streamId\n        }).then((response) => {\n          return response.isAutocommit;\n        });\n      }\n      #sendStreamRequest(request) {\n        return new Promise((responseCallback, errorCallback) => {\n          this.#pushToQueue({ type: \"request\", request, responseCallback, errorCallback });\n        });\n      }\n      /** @private */\n      _openCursor(batch) {\n        this.#client._ensureVersion(3, \"cursor\");\n        return new Promise((cursorCallback, errorCallback) => {\n          this.#pushToQueue({ type: \"cursor\", batch, cursorCallback, errorCallback });\n        });\n      }\n      /** @private */\n      _sendCursorRequest(cursor, request) {\n        if (cursor !== this.#cursor) {\n          throw new InternalError(\"Cursor not associated with the stream attempted to execute a request\");\n        }\n        return new Promise((responseCallback, errorCallback) => {\n          if (this.#closed !== void 0) {\n            errorCallback(new ClosedError(\"Stream is closed\", this.#closed));\n          } else {\n            this.#client._sendRequest(request, { responseCallback, errorCallback });\n          }\n        });\n      }\n      /** @private */\n      _cursorClosed(cursor) {\n        if (cursor !== this.#cursor) {\n          throw new InternalError(\"Cursor was closed, but it was not associated with the stream\");\n        }\n        this.#cursor = void 0;\n        this.#flushQueue();\n      }\n      #pushToQueue(entry) {\n        if (this.#closed !== void 0) {\n          entry.errorCallback(new ClosedError(\"Stream is closed\", this.#closed));\n        } else if (this.#closing) {\n          entry.errorCallback(new ClosedError(\"Stream is closing\", void 0));\n        } else {\n          this.#queue.push(entry);\n          this.#flushQueue();\n        }\n      }\n      #flushQueue() {\n        for (; ; ) {\n          const entry = this.#queue.first();\n          if (entry === void 0 && this.#cursor === void 0 && this.#closing) {\n            this.#setClosed(new ClientError(\"Stream was gracefully closed\"));\n            break;\n          } else if (entry?.type === \"request\" && this.#cursor === void 0) {\n            const { request, responseCallback, errorCallback } = entry;\n            this.#queue.shift();\n            this.#client._sendRequest(request, { responseCallback, errorCallback });\n          } else if (entry?.type === \"cursor\" && this.#cursor === void 0) {\n            const { batch, cursorCallback } = entry;\n            this.#queue.shift();\n            const cursorId = this.#client._cursorIdAlloc.alloc();\n            const cursor = new WsCursor(this.#client, this, cursorId);\n            const request = {\n              type: \"open_cursor\",\n              streamId: this.#streamId,\n              cursorId,\n              batch\n            };\n            const responseCallback = /* @__PURE__ */ __name(() => void 0, \"responseCallback\");\n            const errorCallback = /* @__PURE__ */ __name((e) => cursor._setClosed(e), \"errorCallback\");\n            this.#client._sendRequest(request, { responseCallback, errorCallback });\n            this.#cursor = cursor;\n            cursorCallback(cursor);\n          } else {\n            break;\n          }\n        }\n      }\n      #setClosed(error4) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#closed = error4;\n        if (this.#cursor !== void 0) {\n          this.#cursor._setClosed(error4);\n        }\n        for (; ; ) {\n          const entry = this.#queue.shift();\n          if (entry !== void 0) {\n            entry.errorCallback(error4);\n          } else {\n            break;\n          }\n        }\n        const request = { type: \"close_stream\", streamId: this.#streamId };\n        const responseCallback = /* @__PURE__ */ __name(() => this.#client._streamIdAlloc.free(this.#streamId), \"responseCallback\");\n        const errorCallback = /* @__PURE__ */ __name(() => void 0, \"errorCallback\");\n        this.#client._sendRequest(request, { responseCallback, errorCallback });\n      }\n      /** Immediately close the stream. */\n      close() {\n        this.#setClosed(new ClientError(\"Stream was manually closed\"));\n      }\n      /** Gracefully close the stream. */\n      closeGracefully() {\n        this.#closing = true;\n        this.#flushQueue();\n      }\n      /** True if the stream is closed or closing. */\n      get closed() {\n        return this.#closed !== void 0 || this.#closing;\n      }\n    };\n    __name(Stmt$1, \"Stmt$1\");\n    __name(NamedArg$1, \"NamedArg$1\");\n    __name(Batch$1, \"Batch$1\");\n    __name(BatchStep$1, \"BatchStep$1\");\n    __name(BatchCond$1, \"BatchCond$1\");\n    __name(Value$3, \"Value$3\");\n    __name(ClientMsg$1, \"ClientMsg$1\");\n    __name(Request$2, \"Request$2\");\n    __name(Stmt2, \"Stmt\");\n    __name(NamedArg, \"NamedArg\");\n    __name(Batch2, \"Batch\");\n    __name(BatchStep2, \"BatchStep\");\n    __name(BatchCond2, \"BatchCond\");\n    __name(BatchCondList, \"BatchCondList\");\n    __name(Value$2, \"Value$2\");\n    __name(Empty, \"Empty\");\n    __name(ClientMsg, \"ClientMsg\");\n    __name(HelloMsg, \"HelloMsg\");\n    __name(RequestMsg, \"RequestMsg\");\n    __name(OpenStreamReq, \"OpenStreamReq\");\n    __name(CloseStreamReq$1, \"CloseStreamReq$1\");\n    __name(ExecuteReq, \"ExecuteReq\");\n    __name(BatchReq, \"BatchReq\");\n    __name(OpenCursorReq, \"OpenCursorReq\");\n    __name(CloseCursorReq, \"CloseCursorReq\");\n    __name(FetchCursorReq, \"FetchCursorReq\");\n    __name(SequenceReq, \"SequenceReq\");\n    __name(DescribeReq, \"DescribeReq\");\n    __name(StoreSqlReq, \"StoreSqlReq\");\n    __name(CloseSqlReq, \"CloseSqlReq\");\n    __name(GetAutocommitReq, \"GetAutocommitReq\");\n    __name(Error$2, \"Error$2\");\n    __name(StmtResult$1, \"StmtResult$1\");\n    __name(Col$1, \"Col$1\");\n    __name(BatchResult$1, \"BatchResult$1\");\n    __name(CursorEntry$1, \"CursorEntry$1\");\n    __name(DescribeResult$1, \"DescribeResult$1\");\n    __name(DescribeParam$1, \"DescribeParam$1\");\n    __name(DescribeCol$1, \"DescribeCol$1\");\n    __name(Value$1, \"Value$1\");\n    __name(ServerMsg$1, \"ServerMsg$1\");\n    __name(Response$1, \"Response$1\");\n    Error$1 = {\n      default() {\n        return { message: \"\", code: void 0 };\n      },\n      1(r2, msg) {\n        msg.message = r2.string();\n      },\n      2(r2, msg) {\n        msg.code = r2.string();\n      }\n    };\n    StmtResult = {\n      default() {\n        return {\n          cols: [],\n          rows: [],\n          affectedRowCount: 0,\n          lastInsertRowid: void 0\n        };\n      },\n      1(r2, msg) {\n        msg.cols.push(r2.message(Col));\n      },\n      2(r2, msg) {\n        msg.rows.push(r2.message(Row));\n      },\n      3(r2, msg) {\n        msg.affectedRowCount = Number(r2.uint64());\n      },\n      4(r2, msg) {\n        msg.lastInsertRowid = r2.sint64();\n      }\n    };\n    Col = {\n      default() {\n        return { name: void 0, decltype: void 0 };\n      },\n      1(r2, msg) {\n        msg.name = r2.string();\n      },\n      2(r2, msg) {\n        msg.decltype = r2.string();\n      }\n    };\n    Row = {\n      default() {\n        return [];\n      },\n      1(r2, msg) {\n        msg.push(r2.message(Value));\n      }\n    };\n    BatchResult = {\n      default() {\n        return { stepResults: /* @__PURE__ */ new Map(), stepErrors: /* @__PURE__ */ new Map() };\n      },\n      1(r2, msg) {\n        const [key, value2] = r2.message(BatchResultStepResult);\n        msg.stepResults.set(key, value2);\n      },\n      2(r2, msg) {\n        const [key, value2] = r2.message(BatchResultStepError);\n        msg.stepErrors.set(key, value2);\n      }\n    };\n    BatchResultStepResult = {\n      default() {\n        return [0, StmtResult.default()];\n      },\n      1(r2, msg) {\n        msg[0] = r2.uint32();\n      },\n      2(r2, msg) {\n        msg[1] = r2.message(StmtResult);\n      }\n    };\n    BatchResultStepError = {\n      default() {\n        return [0, Error$1.default()];\n      },\n      1(r2, msg) {\n        msg[0] = r2.uint32();\n      },\n      2(r2, msg) {\n        msg[1] = r2.message(Error$1);\n      }\n    };\n    CursorEntry = {\n      default() {\n        return { type: \"none\" };\n      },\n      1(r2) {\n        return r2.message(StepBeginEntry);\n      },\n      2(r2) {\n        return r2.message(StepEndEntry);\n      },\n      3(r2) {\n        return r2.message(StepErrorEntry);\n      },\n      4(r2) {\n        return { type: \"row\", row: r2.message(Row) };\n      },\n      5(r2) {\n        return { type: \"error\", error: r2.message(Error$1) };\n      }\n    };\n    StepBeginEntry = {\n      default() {\n        return { type: \"step_begin\", step: 0, cols: [] };\n      },\n      1(r2, msg) {\n        msg.step = r2.uint32();\n      },\n      2(r2, msg) {\n        msg.cols.push(r2.message(Col));\n      }\n    };\n    StepEndEntry = {\n      default() {\n        return {\n          type: \"step_end\",\n          affectedRowCount: 0,\n          lastInsertRowid: void 0\n        };\n      },\n      1(r2, msg) {\n        msg.affectedRowCount = r2.uint32();\n      },\n      2(r2, msg) {\n        msg.lastInsertRowid = r2.uint64();\n      }\n    };\n    StepErrorEntry = {\n      default() {\n        return {\n          type: \"step_error\",\n          step: 0,\n          error: Error$1.default()\n        };\n      },\n      1(r2, msg) {\n        msg.step = r2.uint32();\n      },\n      2(r2, msg) {\n        msg.error = r2.message(Error$1);\n      }\n    };\n    DescribeResult = {\n      default() {\n        return {\n          params: [],\n          cols: [],\n          isExplain: false,\n          isReadonly: false\n        };\n      },\n      1(r2, msg) {\n        msg.params.push(r2.message(DescribeParam));\n      },\n      2(r2, msg) {\n        msg.cols.push(r2.message(DescribeCol));\n      },\n      3(r2, msg) {\n        msg.isExplain = r2.bool();\n      },\n      4(r2, msg) {\n        msg.isReadonly = r2.bool();\n      }\n    };\n    DescribeParam = {\n      default() {\n        return { name: void 0 };\n      },\n      1(r2, msg) {\n        msg.name = r2.string();\n      }\n    };\n    DescribeCol = {\n      default() {\n        return { name: \"\", decltype: void 0 };\n      },\n      1(r2, msg) {\n        msg.name = r2.string();\n      },\n      2(r2, msg) {\n        msg.decltype = r2.string();\n      }\n    };\n    Value = {\n      default() {\n        return void 0;\n      },\n      1(r2) {\n        return null;\n      },\n      2(r2) {\n        return r2.sint64();\n      },\n      3(r2) {\n        return r2.double();\n      },\n      4(r2) {\n        return r2.string();\n      },\n      5(r2) {\n        return r2.bytes();\n      }\n    };\n    ServerMsg = {\n      default() {\n        return { type: \"none\" };\n      },\n      1(r2) {\n        return { type: \"hello_ok\" };\n      },\n      2(r2) {\n        return r2.message(HelloErrorMsg);\n      },\n      3(r2) {\n        return r2.message(ResponseOkMsg);\n      },\n      4(r2) {\n        return r2.message(ResponseErrorMsg);\n      }\n    };\n    HelloErrorMsg = {\n      default() {\n        return { type: \"hello_error\", error: Error$1.default() };\n      },\n      1(r2, msg) {\n        msg.error = r2.message(Error$1);\n      }\n    };\n    ResponseErrorMsg = {\n      default() {\n        return { type: \"response_error\", requestId: 0, error: Error$1.default() };\n      },\n      1(r2, msg) {\n        msg.requestId = r2.int32();\n      },\n      2(r2, msg) {\n        msg.error = r2.message(Error$1);\n      }\n    };\n    ResponseOkMsg = {\n      default() {\n        return {\n          type: \"response_ok\",\n          requestId: 0,\n          response: { type: \"none\" }\n        };\n      },\n      1(r2, msg) {\n        msg.requestId = r2.int32();\n      },\n      2(r2, msg) {\n        msg.response = { type: \"open_stream\" };\n      },\n      3(r2, msg) {\n        msg.response = { type: \"close_stream\" };\n      },\n      4(r2, msg) {\n        msg.response = r2.message(ExecuteResp);\n      },\n      5(r2, msg) {\n        msg.response = r2.message(BatchResp);\n      },\n      6(r2, msg) {\n        msg.response = { type: \"open_cursor\" };\n      },\n      7(r2, msg) {\n        msg.response = { type: \"close_cursor\" };\n      },\n      8(r2, msg) {\n        msg.response = r2.message(FetchCursorResp);\n      },\n      9(r2, msg) {\n        msg.response = { type: \"sequence\" };\n      },\n      10(r2, msg) {\n        msg.response = r2.message(DescribeResp);\n      },\n      11(r2, msg) {\n        msg.response = { type: \"store_sql\" };\n      },\n      12(r2, msg) {\n        msg.response = { type: \"close_sql\" };\n      },\n      13(r2, msg) {\n        msg.response = r2.message(GetAutocommitResp);\n      }\n    };\n    ExecuteResp = {\n      default() {\n        return { type: \"execute\", result: StmtResult.default() };\n      },\n      1(r2, msg) {\n        msg.result = r2.message(StmtResult);\n      }\n    };\n    BatchResp = {\n      default() {\n        return { type: \"batch\", result: BatchResult.default() };\n      },\n      1(r2, msg) {\n        msg.result = r2.message(BatchResult);\n      }\n    };\n    FetchCursorResp = {\n      default() {\n        return { type: \"fetch_cursor\", entries: [], done: false };\n      },\n      1(r2, msg) {\n        msg.entries.push(r2.message(CursorEntry));\n      },\n      2(r2, msg) {\n        msg.done = r2.bool();\n      }\n    };\n    DescribeResp = {\n      default() {\n        return { type: \"describe\", result: DescribeResult.default() };\n      },\n      1(r2, msg) {\n        msg.result = r2.message(DescribeResult);\n      }\n    };\n    GetAutocommitResp = {\n      default() {\n        return { type: \"get_autocommit\", isAutocommit: false };\n      },\n      1(r2, msg) {\n        msg.isAutocommit = r2.bool();\n      }\n    };\n    subprotocolsV2 = /* @__PURE__ */ new Map([\n      [\"hrana2\", { version: 2, encoding: \"json\" }],\n      [\"hrana1\", { version: 1, encoding: \"json\" }]\n    ]);\n    subprotocolsV3 = /* @__PURE__ */ new Map([\n      [\"hrana3-protobuf\", { version: 3, encoding: \"protobuf\" }],\n      [\"hrana3\", { version: 3, encoding: \"json\" }],\n      [\"hrana2\", { version: 2, encoding: \"json\" }],\n      [\"hrana1\", { version: 1, encoding: \"json\" }]\n    ]);\n    WsClient$1 = class WsClient extends Client {\n      static {\n        __name(this, \"WsClient\");\n      }\n      #socket;\n      // List of callbacks that we queue until the socket transitions from the CONNECTING to the OPEN state.\n      #openCallbacks;\n      // Have we already transitioned from CONNECTING to OPEN and fired the callbacks in #openCallbacks?\n      #opened;\n      // Stores the error that caused us to close the client (and the socket). If we are not closed, this is\n      // `undefined`.\n      #closed;\n      // Have we received a response to our \"hello\" from the server?\n      #recvdHello;\n      // Subprotocol negotiated with the server. It is only available after the socket transitions to the OPEN\n      // state.\n      #subprotocol;\n      // Has the `getVersion()` function been called? This is only used to validate that the API is used\n      // correctly.\n      #getVersionCalled;\n      // A map from request id to the responses that we expect to receive from the server.\n      #responseMap;\n      // An allocator of request ids.\n      #requestIdAlloc;\n      // An allocator of stream ids.\n      /** @private */\n      _streamIdAlloc;\n      // An allocator of cursor ids.\n      /** @private */\n      _cursorIdAlloc;\n      // An allocator of SQL text ids.\n      #sqlIdAlloc;\n      /** @private */\n      constructor(socket, jwt2) {\n        super();\n        this.#socket = socket;\n        this.#openCallbacks = [];\n        this.#opened = false;\n        this.#closed = void 0;\n        this.#recvdHello = false;\n        this.#subprotocol = void 0;\n        this.#getVersionCalled = false;\n        this.#responseMap = /* @__PURE__ */ new Map();\n        this.#requestIdAlloc = new IdAlloc();\n        this._streamIdAlloc = new IdAlloc();\n        this._cursorIdAlloc = new IdAlloc();\n        this.#sqlIdAlloc = new IdAlloc();\n        this.#socket.binaryType = \"arraybuffer\";\n        this.#socket.addEventListener(\"open\", () => this.#onSocketOpen());\n        this.#socket.addEventListener(\"close\", (event) => this.#onSocketClose(event));\n        this.#socket.addEventListener(\"error\", (event) => this.#onSocketError(event));\n        this.#socket.addEventListener(\"message\", (event) => this.#onSocketMessage(event));\n        this.#send({ type: \"hello\", jwt: jwt2 });\n      }\n      // Send (or enqueue to send) a message to the server.\n      #send(msg) {\n        if (this.#closed !== void 0) {\n          throw new InternalError(\"Trying to send a message on a closed client\");\n        }\n        if (this.#opened) {\n          this.#sendToSocket(msg);\n        } else {\n          const openCallback = /* @__PURE__ */ __name(() => this.#sendToSocket(msg), \"openCallback\");\n          const errorCallback = /* @__PURE__ */ __name(() => void 0, \"errorCallback\");\n          this.#openCallbacks.push({ openCallback, errorCallback });\n        }\n      }\n      // The socket transitioned from CONNECTING to OPEN\n      #onSocketOpen() {\n        const protocol = this.#socket.protocol;\n        if (protocol === void 0) {\n          this.#setClosed(new ClientError(\"The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem.\"));\n          return;\n        } else if (protocol === \"\") {\n          this.#subprotocol = { version: 1, encoding: \"json\" };\n        } else {\n          this.#subprotocol = subprotocolsV3.get(protocol);\n          if (this.#subprotocol === void 0) {\n            this.#setClosed(new ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));\n            return;\n          }\n        }\n        for (const callbacks of this.#openCallbacks) {\n          callbacks.openCallback();\n        }\n        this.#openCallbacks.length = 0;\n        this.#opened = true;\n      }\n      #sendToSocket(msg) {\n        const encoding = this.#subprotocol.encoding;\n        if (encoding === \"json\") {\n          const jsonMsg = writeJsonObject(msg, ClientMsg$1);\n          this.#socket.send(jsonMsg);\n        } else if (encoding === \"protobuf\") {\n          const protobufMsg = writeProtobufMessage(msg, ClientMsg);\n          this.#socket.send(protobufMsg);\n        } else {\n          throw impossible(encoding, \"Impossible encoding\");\n        }\n      }\n      /** Get the protocol version negotiated with the server, possibly waiting until the socket is open. */\n      getVersion() {\n        return new Promise((versionCallback, errorCallback) => {\n          this.#getVersionCalled = true;\n          if (this.#closed !== void 0) {\n            errorCallback(this.#closed);\n          } else if (!this.#opened) {\n            const openCallback = /* @__PURE__ */ __name(() => versionCallback(this.#subprotocol.version), \"openCallback\");\n            this.#openCallbacks.push({ openCallback, errorCallback });\n          } else {\n            versionCallback(this.#subprotocol.version);\n          }\n        });\n      }\n      // Make sure that the negotiated version is at least `minVersion`.\n      /** @private */\n      _ensureVersion(minVersion, feature) {\n        if (this.#subprotocol === void 0 || !this.#getVersionCalled) {\n          throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);\n        } else if (this.#subprotocol.version < minVersion) {\n          throw new ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, but the WebSocket server only supports version ${this.#subprotocol.version}`);\n        }\n      }\n      // Send a request to the server and invoke a callback when we get the response.\n      /** @private */\n      _sendRequest(request, callbacks) {\n        if (this.#closed !== void 0) {\n          callbacks.errorCallback(new ClosedError(\"Client is closed\", this.#closed));\n          return;\n        }\n        const requestId = this.#requestIdAlloc.alloc();\n        this.#responseMap.set(requestId, { ...callbacks, type: request.type });\n        this.#send({ type: \"request\", requestId, request });\n      }\n      // The socket encountered an error.\n      #onSocketError(event) {\n        const eventMessage = event.message;\n        const message = eventMessage ?? \"WebSocket was closed due to an error\";\n        this.#setClosed(new WebSocketError(message));\n      }\n      // The socket was closed.\n      #onSocketClose(event) {\n        let message = `WebSocket was closed with code ${event.code}`;\n        if (event.reason) {\n          message += `: ${event.reason}`;\n        }\n        this.#setClosed(new WebSocketError(message));\n      }\n      // Close the client with the given error.\n      #setClosed(error4) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#closed = error4;\n        for (const callbacks of this.#openCallbacks) {\n          callbacks.errorCallback(error4);\n        }\n        this.#openCallbacks.length = 0;\n        for (const [requestId, responseState] of this.#responseMap.entries()) {\n          responseState.errorCallback(error4);\n          this.#requestIdAlloc.free(requestId);\n        }\n        this.#responseMap.clear();\n        this.#socket.close();\n      }\n      // We received a message from the socket.\n      #onSocketMessage(event) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        try {\n          let msg;\n          const encoding = this.#subprotocol.encoding;\n          if (encoding === \"json\") {\n            if (typeof event.data !== \"string\") {\n              this.#socket.close(3003, \"Only text messages are accepted with JSON encoding\");\n              this.#setClosed(new ProtoError(\"Received non-text message from server with JSON encoding\"));\n              return;\n            }\n            msg = readJsonObject(JSON.parse(event.data), ServerMsg$1);\n          } else if (encoding === \"protobuf\") {\n            if (!(event.data instanceof ArrayBuffer)) {\n              this.#socket.close(3003, \"Only binary messages are accepted with Protobuf encoding\");\n              this.#setClosed(new ProtoError(\"Received non-binary message from server with Protobuf encoding\"));\n              return;\n            }\n            msg = readProtobufMessage(new Uint8Array(event.data), ServerMsg);\n          } else {\n            throw impossible(encoding, \"Impossible encoding\");\n          }\n          this.#handleMsg(msg);\n        } catch (e) {\n          this.#socket.close(3007, \"Could not handle message\");\n          this.#setClosed(e);\n        }\n      }\n      // Handle a message from the server.\n      #handleMsg(msg) {\n        if (msg.type === \"none\") {\n          throw new ProtoError(\"Received an unrecognized ServerMsg\");\n        } else if (msg.type === \"hello_ok\" || msg.type === \"hello_error\") {\n          if (this.#recvdHello) {\n            throw new ProtoError(\"Received a duplicated hello response\");\n          }\n          this.#recvdHello = true;\n          if (msg.type === \"hello_error\") {\n            throw errorFromProto(msg.error);\n          }\n          return;\n        } else if (!this.#recvdHello) {\n          throw new ProtoError(\"Received a non-hello message before a hello response\");\n        }\n        if (msg.type === \"response_ok\") {\n          const requestId = msg.requestId;\n          const responseState = this.#responseMap.get(requestId);\n          this.#responseMap.delete(requestId);\n          if (responseState === void 0) {\n            throw new ProtoError(\"Received unexpected OK response\");\n          }\n          this.#requestIdAlloc.free(requestId);\n          try {\n            if (responseState.type !== msg.response.type) {\n              console.dir({ responseState, msg });\n              throw new ProtoError(\"Received unexpected type of response\");\n            }\n            responseState.responseCallback(msg.response);\n          } catch (e) {\n            responseState.errorCallback(e);\n            throw e;\n          }\n        } else if (msg.type === \"response_error\") {\n          const requestId = msg.requestId;\n          const responseState = this.#responseMap.get(requestId);\n          this.#responseMap.delete(requestId);\n          if (responseState === void 0) {\n            throw new ProtoError(\"Received unexpected error response\");\n          }\n          this.#requestIdAlloc.free(requestId);\n          responseState.errorCallback(errorFromProto(msg.error));\n        } else {\n          throw impossible(msg, \"Impossible ServerMsg type\");\n        }\n      }\n      /** Open a {@link WsStream}, a stream for executing SQL statements. */\n      openStream() {\n        return WsStream.open(this);\n      }\n      /** Cache a SQL text on the server. This requires protocol version 2 or higher. */\n      storeSql(sql2) {\n        this._ensureVersion(2, \"storeSql()\");\n        const sqlId = this.#sqlIdAlloc.alloc();\n        const sqlObj = new Sql(this, sqlId);\n        const responseCallback = /* @__PURE__ */ __name(() => void 0, \"responseCallback\");\n        const errorCallback = /* @__PURE__ */ __name((e) => sqlObj._setClosed(e), \"errorCallback\");\n        const request = { type: \"store_sql\", sqlId, sql: sql2 };\n        this._sendRequest(request, { responseCallback, errorCallback });\n        return sqlObj;\n      }\n      /** @private */\n      _closeSql(sqlId) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        const responseCallback = /* @__PURE__ */ __name(() => this.#sqlIdAlloc.free(sqlId), \"responseCallback\");\n        const errorCallback = /* @__PURE__ */ __name((e) => this.#setClosed(e), \"errorCallback\");\n        const request = { type: \"close_sql\", sqlId };\n        this._sendRequest(request, { responseCallback, errorCallback });\n      }\n      /** Close the client and the WebSocket. */\n      close() {\n        this.#setClosed(new ClientError(\"Client was manually closed\"));\n      }\n      /** True if the client is closed. */\n      get closed() {\n        return this.#closed !== void 0;\n      }\n    };\n    _fetch = fetch;\n    _Request = Request;\n    _Headers = Headers;\n    if (typeof queueMicrotask !== \"undefined\") {\n      _queueMicrotask = queueMicrotask;\n    } else {\n      const resolved = Promise.resolve();\n      _queueMicrotask = /* @__PURE__ */ __name((callback) => {\n        resolved.then(callback);\n      }, \"_queueMicrotask\");\n    }\n    ByteQueue = class {\n      static {\n        __name(this, \"ByteQueue\");\n      }\n      #array;\n      #shiftPos;\n      #pushPos;\n      constructor(initialCap) {\n        this.#array = new Uint8Array(new ArrayBuffer(initialCap));\n        this.#shiftPos = 0;\n        this.#pushPos = 0;\n      }\n      get length() {\n        return this.#pushPos - this.#shiftPos;\n      }\n      data() {\n        return this.#array.slice(this.#shiftPos, this.#pushPos);\n      }\n      push(chunk) {\n        this.#ensurePush(chunk.byteLength);\n        this.#array.set(chunk, this.#pushPos);\n        this.#pushPos += chunk.byteLength;\n      }\n      #ensurePush(pushLength) {\n        if (this.#pushPos + pushLength <= this.#array.byteLength) {\n          return;\n        }\n        const filledLength = this.#pushPos - this.#shiftPos;\n        if (filledLength + pushLength <= this.#array.byteLength && 2 * this.#pushPos >= this.#array.byteLength) {\n          this.#array.copyWithin(0, this.#shiftPos, this.#pushPos);\n        } else {\n          let newCap = this.#array.byteLength;\n          do {\n            newCap *= 2;\n          } while (filledLength + pushLength > newCap);\n          const newArray = new Uint8Array(new ArrayBuffer(newCap));\n          newArray.set(this.#array.slice(this.#shiftPos, this.#pushPos), 0);\n          this.#array = newArray;\n        }\n        this.#pushPos = filledLength;\n        this.#shiftPos = 0;\n      }\n      shift(length) {\n        this.#shiftPos += length;\n      }\n    };\n    __name(PipelineRespBody$1, \"PipelineRespBody$1\");\n    __name(StreamResult$1, \"StreamResult$1\");\n    __name(StreamResponse$1, \"StreamResponse$1\");\n    __name(CursorRespBody$1, \"CursorRespBody$1\");\n    PipelineRespBody = {\n      default() {\n        return { baton: void 0, baseUrl: void 0, results: [] };\n      },\n      1(r2, msg) {\n        msg.baton = r2.string();\n      },\n      2(r2, msg) {\n        msg.baseUrl = r2.string();\n      },\n      3(r2, msg) {\n        msg.results.push(r2.message(StreamResult));\n      }\n    };\n    StreamResult = {\n      default() {\n        return { type: \"none\" };\n      },\n      1(r2) {\n        return { type: \"ok\", response: r2.message(StreamResponse) };\n      },\n      2(r2) {\n        return { type: \"error\", error: r2.message(Error$1) };\n      }\n    };\n    StreamResponse = {\n      default() {\n        return { type: \"none\" };\n      },\n      1(r2) {\n        return { type: \"close\" };\n      },\n      2(r2) {\n        return r2.message(ExecuteStreamResp);\n      },\n      3(r2) {\n        return r2.message(BatchStreamResp);\n      },\n      4(r2) {\n        return { type: \"sequence\" };\n      },\n      5(r2) {\n        return r2.message(DescribeStreamResp);\n      },\n      6(r2) {\n        return { type: \"store_sql\" };\n      },\n      7(r2) {\n        return { type: \"close_sql\" };\n      },\n      8(r2) {\n        return r2.message(GetAutocommitStreamResp);\n      }\n    };\n    ExecuteStreamResp = {\n      default() {\n        return { type: \"execute\", result: StmtResult.default() };\n      },\n      1(r2, msg) {\n        msg.result = r2.message(StmtResult);\n      }\n    };\n    BatchStreamResp = {\n      default() {\n        return { type: \"batch\", result: BatchResult.default() };\n      },\n      1(r2, msg) {\n        msg.result = r2.message(BatchResult);\n      }\n    };\n    DescribeStreamResp = {\n      default() {\n        return { type: \"describe\", result: DescribeResult.default() };\n      },\n      1(r2, msg) {\n        msg.result = r2.message(DescribeResult);\n      }\n    };\n    GetAutocommitStreamResp = {\n      default() {\n        return { type: \"get_autocommit\", isAutocommit: false };\n      },\n      1(r2, msg) {\n        msg.isAutocommit = r2.bool();\n      }\n    };\n    CursorRespBody = {\n      default() {\n        return { baton: void 0, baseUrl: void 0 };\n      },\n      1(r2, msg) {\n        msg.baton = r2.string();\n      },\n      2(r2, msg) {\n        msg.baseUrl = r2.string();\n      }\n    };\n    HttpCursor = class extends Cursor {\n      static {\n        __name(this, \"HttpCursor\");\n      }\n      #stream;\n      #encoding;\n      #reader;\n      #queue;\n      #closed;\n      #done;\n      /** @private */\n      constructor(stream, encoding) {\n        super();\n        this.#stream = stream;\n        this.#encoding = encoding;\n        this.#reader = void 0;\n        this.#queue = new ByteQueue(16 * 1024);\n        this.#closed = void 0;\n        this.#done = false;\n      }\n      async open(response) {\n        if (response.body === null) {\n          throw new ProtoError(\"No response body for cursor request\");\n        }\n        this.#reader = response.body.getReader();\n        const respBody = await this.#nextItem(CursorRespBody$1, CursorRespBody);\n        if (respBody === void 0) {\n          throw new ProtoError(\"Empty response to cursor request\");\n        }\n        return respBody;\n      }\n      /** Fetch the next entry from the cursor. */\n      next() {\n        return this.#nextItem(CursorEntry$1, CursorEntry);\n      }\n      /** Close the cursor. */\n      close() {\n        this._setClosed(new ClientError(\"Cursor was manually closed\"));\n      }\n      /** @private */\n      _setClosed(error4) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#closed = error4;\n        this.#stream._cursorClosed(this);\n        if (this.#reader !== void 0) {\n          this.#reader.cancel();\n        }\n      }\n      /** True if the cursor is closed. */\n      get closed() {\n        return this.#closed !== void 0;\n      }\n      async #nextItem(jsonFun, protobufDef) {\n        for (; ; ) {\n          if (this.#done) {\n            return void 0;\n          } else if (this.#closed !== void 0) {\n            throw new ClosedError(\"Cursor is closed\", this.#closed);\n          }\n          if (this.#encoding === \"json\") {\n            const jsonData = this.#parseItemJson();\n            if (jsonData !== void 0) {\n              const jsonText = new TextDecoder().decode(jsonData);\n              const jsonValue = JSON.parse(jsonText);\n              return readJsonObject(jsonValue, jsonFun);\n            }\n          } else if (this.#encoding === \"protobuf\") {\n            const protobufData = this.#parseItemProtobuf();\n            if (protobufData !== void 0) {\n              return readProtobufMessage(protobufData, protobufDef);\n            }\n          } else {\n            throw impossible(this.#encoding, \"Impossible encoding\");\n          }\n          if (this.#reader === void 0) {\n            throw new InternalError(\"Attempted to read from HTTP cursor before it was opened\");\n          }\n          const { value: value2, done } = await this.#reader.read();\n          if (done && this.#queue.length === 0) {\n            this.#done = true;\n          } else if (done) {\n            throw new ProtoError(\"Unexpected end of cursor stream\");\n          } else {\n            this.#queue.push(value2);\n          }\n        }\n      }\n      #parseItemJson() {\n        const data = this.#queue.data();\n        const newlineByte = 10;\n        const newlinePos = data.indexOf(newlineByte);\n        if (newlinePos < 0) {\n          return void 0;\n        }\n        const jsonData = data.slice(0, newlinePos);\n        this.#queue.shift(newlinePos + 1);\n        return jsonData;\n      }\n      #parseItemProtobuf() {\n        const data = this.#queue.data();\n        let varintValue = 0;\n        let varintLength = 0;\n        for (; ; ) {\n          if (varintLength >= data.byteLength) {\n            return void 0;\n          }\n          const byte = data[varintLength];\n          varintValue |= (byte & 127) << 7 * varintLength;\n          varintLength += 1;\n          if (!(byte & 128)) {\n            break;\n          }\n        }\n        if (data.byteLength < varintLength + varintValue) {\n          return void 0;\n        }\n        const protobufData = data.slice(varintLength, varintLength + varintValue);\n        this.#queue.shift(varintLength + varintValue);\n        return protobufData;\n      }\n    };\n    __name(PipelineReqBody$1, \"PipelineReqBody$1\");\n    __name(StreamRequest$1, \"StreamRequest$1\");\n    __name(CursorReqBody$1, \"CursorReqBody$1\");\n    __name(PipelineReqBody, \"PipelineReqBody\");\n    __name(StreamRequest, \"StreamRequest\");\n    __name(CloseStreamReq, \"CloseStreamReq\");\n    __name(ExecuteStreamReq, \"ExecuteStreamReq\");\n    __name(BatchStreamReq, \"BatchStreamReq\");\n    __name(SequenceStreamReq, \"SequenceStreamReq\");\n    __name(DescribeStreamReq, \"DescribeStreamReq\");\n    __name(StoreSqlStreamReq, \"StoreSqlStreamReq\");\n    __name(CloseSqlStreamReq, \"CloseSqlStreamReq\");\n    __name(GetAutocommitStreamReq, \"GetAutocommitStreamReq\");\n    __name(CursorReqBody, \"CursorReqBody\");\n    HttpStream = class extends Stream {\n      static {\n        __name(this, \"HttpStream\");\n      }\n      #client;\n      #baseUrl;\n      #jwt;\n      #fetch;\n      #baton;\n      #queue;\n      #flushing;\n      #cursor;\n      #closing;\n      #closeQueued;\n      #closed;\n      #sqlIdAlloc;\n      /** @private */\n      constructor(client, baseUrl, jwt2, customFetch2) {\n        super(client.intMode);\n        this.#client = client;\n        this.#baseUrl = baseUrl.toString();\n        this.#jwt = jwt2;\n        this.#fetch = customFetch2;\n        this.#baton = void 0;\n        this.#queue = new Queue();\n        this.#flushing = false;\n        this.#closing = false;\n        this.#closeQueued = false;\n        this.#closed = void 0;\n        this.#sqlIdAlloc = new IdAlloc();\n      }\n      /** Get the {@link HttpClient} object that this stream belongs to. */\n      client() {\n        return this.#client;\n      }\n      /** @private */\n      _sqlOwner() {\n        return this;\n      }\n      /** Cache a SQL text on the server. */\n      storeSql(sql2) {\n        const sqlId = this.#sqlIdAlloc.alloc();\n        this.#sendStreamRequest({ type: \"store_sql\", sqlId, sql: sql2 }).then(() => void 0, (error4) => this._setClosed(error4));\n        return new Sql(this, sqlId);\n      }\n      /** @private */\n      _closeSql(sqlId) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#sendStreamRequest({ type: \"close_sql\", sqlId }).then(() => this.#sqlIdAlloc.free(sqlId), (error4) => this._setClosed(error4));\n      }\n      /** @private */\n      _execute(stmt) {\n        return this.#sendStreamRequest({ type: \"execute\", stmt }).then((response) => {\n          return response.result;\n        });\n      }\n      /** @private */\n      _batch(batch) {\n        return this.#sendStreamRequest({ type: \"batch\", batch }).then((response) => {\n          return response.result;\n        });\n      }\n      /** @private */\n      _describe(protoSql) {\n        return this.#sendStreamRequest({\n          type: \"describe\",\n          sql: protoSql.sql,\n          sqlId: protoSql.sqlId\n        }).then((response) => {\n          return response.result;\n        });\n      }\n      /** @private */\n      _sequence(protoSql) {\n        return this.#sendStreamRequest({\n          type: \"sequence\",\n          sql: protoSql.sql,\n          sqlId: protoSql.sqlId\n        }).then((_response) => {\n          return void 0;\n        });\n      }\n      /** Check whether the SQL connection underlying this stream is in autocommit state (i.e., outside of an\n       * explicit transaction). This requires protocol version 3 or higher.\n       */\n      getAutocommit() {\n        this.#client._ensureVersion(3, \"getAutocommit()\");\n        return this.#sendStreamRequest({\n          type: \"get_autocommit\"\n        }).then((response) => {\n          return response.isAutocommit;\n        });\n      }\n      #sendStreamRequest(request) {\n        return new Promise((responseCallback, errorCallback) => {\n          this.#pushToQueue({ type: \"pipeline\", request, responseCallback, errorCallback });\n        });\n      }\n      /** @private */\n      _openCursor(batch) {\n        return new Promise((cursorCallback, errorCallback) => {\n          this.#pushToQueue({ type: \"cursor\", batch, cursorCallback, errorCallback });\n        });\n      }\n      /** @private */\n      _cursorClosed(cursor) {\n        if (cursor !== this.#cursor) {\n          throw new InternalError(\"Cursor was closed, but it was not associated with the stream\");\n        }\n        this.#cursor = void 0;\n        _queueMicrotask(() => this.#flushQueue());\n      }\n      /** Immediately close the stream. */\n      close() {\n        this._setClosed(new ClientError(\"Stream was manually closed\"));\n      }\n      /** Gracefully close the stream. */\n      closeGracefully() {\n        this.#closing = true;\n        _queueMicrotask(() => this.#flushQueue());\n      }\n      /** True if the stream is closed. */\n      get closed() {\n        return this.#closed !== void 0 || this.#closing;\n      }\n      /** @private */\n      _setClosed(error4) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#closed = error4;\n        if (this.#cursor !== void 0) {\n          this.#cursor._setClosed(error4);\n        }\n        this.#client._streamClosed(this);\n        for (; ; ) {\n          const entry = this.#queue.shift();\n          if (entry !== void 0) {\n            entry.errorCallback(error4);\n          } else {\n            break;\n          }\n        }\n        if ((this.#baton !== void 0 || this.#flushing) && !this.#closeQueued) {\n          this.#queue.push({\n            type: \"pipeline\",\n            request: { type: \"close\" },\n            responseCallback: /* @__PURE__ */ __name(() => void 0, \"responseCallback\"),\n            errorCallback: /* @__PURE__ */ __name(() => void 0, \"errorCallback\")\n          });\n          this.#closeQueued = true;\n          _queueMicrotask(() => this.#flushQueue());\n        }\n      }\n      #pushToQueue(entry) {\n        if (this.#closed !== void 0) {\n          throw new ClosedError(\"Stream is closed\", this.#closed);\n        } else if (this.#closing) {\n          throw new ClosedError(\"Stream is closing\", void 0);\n        } else {\n          this.#queue.push(entry);\n          _queueMicrotask(() => this.#flushQueue());\n        }\n      }\n      #flushQueue() {\n        if (this.#flushing || this.#cursor !== void 0) {\n          return;\n        }\n        if (this.#closing && this.#queue.length === 0) {\n          this._setClosed(new ClientError(\"Stream was gracefully closed\"));\n          return;\n        }\n        const endpoint = this.#client._endpoint;\n        if (endpoint === void 0) {\n          this.#client._endpointPromise.then(() => this.#flushQueue(), (error4) => this._setClosed(error4));\n          return;\n        }\n        const firstEntry = this.#queue.shift();\n        if (firstEntry === void 0) {\n          return;\n        } else if (firstEntry.type === \"pipeline\") {\n          const pipeline = [firstEntry];\n          for (; ; ) {\n            const entry = this.#queue.first();\n            if (entry !== void 0 && entry.type === \"pipeline\") {\n              pipeline.push(entry);\n              this.#queue.shift();\n            } else if (entry === void 0 && this.#closing && !this.#closeQueued) {\n              pipeline.push({\n                type: \"pipeline\",\n                request: { type: \"close\" },\n                responseCallback: /* @__PURE__ */ __name(() => void 0, \"responseCallback\"),\n                errorCallback: /* @__PURE__ */ __name(() => void 0, \"errorCallback\")\n              });\n              this.#closeQueued = true;\n              break;\n            } else {\n              break;\n            }\n          }\n          this.#flushPipeline(endpoint, pipeline);\n        } else if (firstEntry.type === \"cursor\") {\n          this.#flushCursor(endpoint, firstEntry);\n        } else {\n          throw impossible(firstEntry, \"Impossible type of QueueEntry\");\n        }\n      }\n      #flushPipeline(endpoint, pipeline) {\n        this.#flush(() => this.#createPipelineRequest(pipeline, endpoint), (resp) => decodePipelineResponse(resp, endpoint.encoding), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (respBody) => handlePipelineResponse(pipeline, respBody), (error4) => pipeline.forEach((entry) => entry.errorCallback(error4)));\n      }\n      #flushCursor(endpoint, entry) {\n        const cursor = new HttpCursor(this, endpoint.encoding);\n        this.#cursor = cursor;\n        this.#flush(() => this.#createCursorRequest(entry, endpoint), (resp) => cursor.open(resp), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (_respBody) => entry.cursorCallback(cursor), (error4) => entry.errorCallback(error4));\n      }\n      #flush(createRequest2, decodeResponse, getBaton, getBaseUrl, handleResponse, handleError) {\n        let promise;\n        try {\n          const request = createRequest2();\n          const fetch2 = this.#fetch;\n          promise = fetch2(request);\n        } catch (error4) {\n          promise = Promise.reject(error4);\n        }\n        this.#flushing = true;\n        promise.then((resp) => {\n          if (!resp.ok) {\n            return errorFromResponse(resp).then((error4) => {\n              throw error4;\n            });\n          }\n          return decodeResponse(resp);\n        }).then((r2) => {\n          this.#baton = getBaton(r2);\n          this.#baseUrl = getBaseUrl(r2) ?? this.#baseUrl;\n          handleResponse(r2);\n        }).catch((error4) => {\n          this._setClosed(error4);\n          handleError(error4);\n        }).finally(() => {\n          this.#flushing = false;\n          this.#flushQueue();\n        });\n      }\n      #createPipelineRequest(pipeline, endpoint) {\n        return this.#createRequest(new URL(endpoint.pipelinePath, this.#baseUrl), {\n          baton: this.#baton,\n          requests: pipeline.map((entry) => entry.request)\n        }, endpoint.encoding, PipelineReqBody$1, PipelineReqBody);\n      }\n      #createCursorRequest(entry, endpoint) {\n        if (endpoint.cursorPath === void 0) {\n          throw new ProtocolVersionError(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${endpoint.version}.`);\n        }\n        return this.#createRequest(new URL(endpoint.cursorPath, this.#baseUrl), {\n          baton: this.#baton,\n          batch: entry.batch\n        }, endpoint.encoding, CursorReqBody$1, CursorReqBody);\n      }\n      #createRequest(url, reqBody, encoding, jsonFun, protobufFun) {\n        let bodyData;\n        let contentType;\n        if (encoding === \"json\") {\n          bodyData = writeJsonObject(reqBody, jsonFun);\n          contentType = \"application/json\";\n        } else if (encoding === \"protobuf\") {\n          bodyData = writeProtobufMessage(reqBody, protobufFun);\n          contentType = \"application/x-protobuf\";\n        } else {\n          throw impossible(encoding, \"Impossible encoding\");\n        }\n        const headers = new _Headers();\n        headers.set(\"content-type\", contentType);\n        if (this.#jwt !== void 0) {\n          headers.set(\"authorization\", `Bearer ${this.#jwt}`);\n        }\n        return new _Request(url.toString(), { method: \"POST\", headers, body: bodyData });\n      }\n    };\n    __name(handlePipelineResponse, \"handlePipelineResponse\");\n    __name(decodePipelineResponse, \"decodePipelineResponse\");\n    __name(errorFromResponse, \"errorFromResponse\");\n    checkEndpoints = [\n      {\n        versionPath: \"v3-protobuf\",\n        pipelinePath: \"v3-protobuf/pipeline\",\n        cursorPath: \"v3-protobuf/cursor\",\n        version: 3,\n        encoding: \"protobuf\"\n      }\n      /*\n      {\n          versionPath: \"v3\",\n          pipelinePath: \"v3/pipeline\",\n          cursorPath: \"v3/cursor\",\n          version: 3,\n          encoding: \"json\",\n      },\n      */\n    ];\n    fallbackEndpoint = {\n      versionPath: \"v2\",\n      pipelinePath: \"v2/pipeline\",\n      cursorPath: void 0,\n      version: 2,\n      encoding: \"json\"\n    };\n    HttpClient$1 = class HttpClient extends Client {\n      static {\n        __name(this, \"HttpClient\");\n      }\n      #url;\n      #jwt;\n      #fetch;\n      #closed;\n      #streams;\n      /** @private */\n      _endpointPromise;\n      /** @private */\n      _endpoint;\n      /** @private */\n      constructor(url, jwt2, customFetch2, protocolVersion = 2) {\n        super();\n        this.#url = url;\n        this.#jwt = jwt2;\n        this.#fetch = customFetch2 ?? _fetch;\n        this.#closed = void 0;\n        this.#streams = /* @__PURE__ */ new Set();\n        if (protocolVersion == 3) {\n          this._endpointPromise = findEndpoint(this.#fetch, this.#url);\n          this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error4) => this.#setClosed(error4));\n        } else {\n          this._endpointPromise = Promise.resolve(fallbackEndpoint);\n          this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error4) => this.#setClosed(error4));\n        }\n      }\n      /** Get the protocol version supported by the server. */\n      async getVersion() {\n        if (this._endpoint !== void 0) {\n          return this._endpoint.version;\n        }\n        return (await this._endpointPromise).version;\n      }\n      // Make sure that the negotiated version is at least `minVersion`.\n      /** @private */\n      _ensureVersion(minVersion, feature) {\n        if (minVersion <= fallbackEndpoint.version) {\n          return;\n        } else if (this._endpoint === void 0) {\n          throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);\n        } else if (this._endpoint.version < minVersion) {\n          throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the HTTP server only supports version ${this._endpoint.version}.`);\n        }\n      }\n      /** Open a {@link HttpStream}, a stream for executing SQL statements. */\n      openStream() {\n        if (this.#closed !== void 0) {\n          throw new ClosedError(\"Client is closed\", this.#closed);\n        }\n        const stream = new HttpStream(this, this.#url, this.#jwt, this.#fetch);\n        this.#streams.add(stream);\n        return stream;\n      }\n      /** @private */\n      _streamClosed(stream) {\n        this.#streams.delete(stream);\n      }\n      /** Close the client and all its streams. */\n      close() {\n        this.#setClosed(new ClientError(\"Client was manually closed\"));\n      }\n      /** True if the client is closed. */\n      get closed() {\n        return this.#closed !== void 0;\n      }\n      #setClosed(error4) {\n        if (this.#closed !== void 0) {\n          return;\n        }\n        this.#closed = error4;\n        for (const stream of Array.from(this.#streams)) {\n          stream._setClosed(new ClosedError(\"Client was closed\", error4));\n        }\n      }\n    };\n    __name(findEndpoint, \"findEndpoint\");\n    __name(openWs, \"openWs\");\n    __name(openHttp, \"openHttp\");\n    HranaTransaction = class {\n      static {\n        __name(this, \"HranaTransaction\");\n      }\n      #mode;\n      #version;\n      // Promise that is resolved when the BEGIN statement completes, or `undefined` if we haven't executed the\n      // BEGIN statement yet.\n      #started;\n      /** @private */\n      constructor(mode, version3) {\n        this.#mode = mode;\n        this.#version = version3;\n        this.#started = void 0;\n      }\n      execute(stmt) {\n        return this.batch([stmt]).then((results) => results[0]);\n      }\n      async batch(stmts) {\n        const stream = this._getStream();\n        if (stream.closed) {\n          throw new LibsqlError(\"Cannot execute statements because the transaction is closed\", \"TRANSACTION_CLOSED\");\n        }\n        try {\n          const hranaStmts = stmts.map(stmtToHrana);\n          let rowsPromises;\n          if (this.#started === void 0) {\n            this._getSqlCache().apply(hranaStmts);\n            const batch = stream.batch(this.#version >= 3);\n            const beginStep = batch.step();\n            const beginPromise = beginStep.run(transactionModeToBegin(this.#mode));\n            let lastStep = beginStep;\n            rowsPromises = hranaStmts.map((hranaStmt) => {\n              const stmtStep = batch.step().condition(BatchCond$2.ok(lastStep));\n              if (this.#version >= 3) {\n                stmtStep.condition(BatchCond$2.not(BatchCond$2.isAutocommit(batch)));\n              }\n              const rowsPromise = stmtStep.query(hranaStmt);\n              rowsPromise.catch(() => void 0);\n              lastStep = stmtStep;\n              return rowsPromise;\n            });\n            this.#started = batch.execute().then(() => beginPromise).then(() => void 0);\n            try {\n              await this.#started;\n            } catch (e) {\n              this.close();\n              throw e;\n            }\n          } else {\n            if (this.#version < 3) {\n              await this.#started;\n            } else {\n            }\n            this._getSqlCache().apply(hranaStmts);\n            const batch = stream.batch(this.#version >= 3);\n            let lastStep = void 0;\n            rowsPromises = hranaStmts.map((hranaStmt) => {\n              const stmtStep = batch.step();\n              if (lastStep !== void 0) {\n                stmtStep.condition(BatchCond$2.ok(lastStep));\n              }\n              if (this.#version >= 3) {\n                stmtStep.condition(BatchCond$2.not(BatchCond$2.isAutocommit(batch)));\n              }\n              const rowsPromise = stmtStep.query(hranaStmt);\n              rowsPromise.catch(() => void 0);\n              lastStep = stmtStep;\n              return rowsPromise;\n            });\n            await batch.execute();\n          }\n          const resultSets = [];\n          for (const rowsPromise of rowsPromises) {\n            const rows = await rowsPromise;\n            if (rows === void 0) {\n              throw new LibsqlError(\"Statement in a transaction was not executed, probably because the transaction has been rolled back\", \"TRANSACTION_CLOSED\");\n            }\n            resultSets.push(resultSetFromHrana(rows));\n          }\n          return resultSets;\n        } catch (e) {\n          throw mapHranaError(e);\n        }\n      }\n      async executeMultiple(sql2) {\n        const stream = this._getStream();\n        if (stream.closed) {\n          throw new LibsqlError(\"Cannot execute statements because the transaction is closed\", \"TRANSACTION_CLOSED\");\n        }\n        try {\n          if (this.#started === void 0) {\n            this.#started = stream.run(transactionModeToBegin(this.#mode)).then(() => void 0);\n            try {\n              await this.#started;\n            } catch (e) {\n              this.close();\n              throw e;\n            }\n          } else {\n            await this.#started;\n          }\n          await stream.sequence(sql2);\n        } catch (e) {\n          throw mapHranaError(e);\n        }\n      }\n      async rollback() {\n        try {\n          const stream = this._getStream();\n          if (stream.closed) {\n            return;\n          }\n          if (this.#started !== void 0) {\n          } else {\n            return;\n          }\n          const promise = stream.run(\"ROLLBACK\").catch((e) => {\n            throw mapHranaError(e);\n          });\n          stream.closeGracefully();\n          await promise;\n        } catch (e) {\n          throw mapHranaError(e);\n        } finally {\n          this.close();\n        }\n      }\n      async commit() {\n        try {\n          const stream = this._getStream();\n          if (stream.closed) {\n            throw new LibsqlError(\"Cannot commit the transaction because it is already closed\", \"TRANSACTION_CLOSED\");\n          }\n          if (this.#started !== void 0) {\n            await this.#started;\n          } else {\n            return;\n          }\n          const promise = stream.run(\"COMMIT\").catch((e) => {\n            throw mapHranaError(e);\n          });\n          stream.closeGracefully();\n          await promise;\n        } catch (e) {\n          throw mapHranaError(e);\n        } finally {\n          this.close();\n        }\n      }\n    };\n    __name(executeHranaBatch, \"executeHranaBatch\");\n    __name(stmtToHrana, \"stmtToHrana\");\n    __name(resultSetFromHrana, \"resultSetFromHrana\");\n    __name(mapHranaError, \"mapHranaError\");\n    __name(mapHranaErrorCode, \"mapHranaErrorCode\");\n    SqlCache = class {\n      static {\n        __name(this, \"SqlCache\");\n      }\n      #owner;\n      #sqls;\n      capacity;\n      constructor(owner, capacity) {\n        this.#owner = owner;\n        this.#sqls = new Lru();\n        this.capacity = capacity;\n      }\n      // Replaces SQL strings with cached `hrana.Sql` objects in the statements in `hranaStmts`. After this\n      // function returns, we guarantee that all `hranaStmts` refer to valid (not closed) `hrana.Sql` objects,\n      // but _we may invalidate any other `hrana.Sql` objects_ (by closing them, thus removing them from the\n      // server).\n      //\n      // In practice, this means that after calling this function, you can use the statements only up to the\n      // first `await`, because concurrent code may also use the cache and invalidate those statements.\n      apply(hranaStmts) {\n        if (this.capacity <= 0) {\n          return;\n        }\n        const usedSqlObjs = /* @__PURE__ */ new Set();\n        for (const hranaStmt of hranaStmts) {\n          if (typeof hranaStmt.sql !== \"string\") {\n            continue;\n          }\n          const sqlText = hranaStmt.sql;\n          if (sqlText.length >= 5e3) {\n            continue;\n          }\n          let sqlObj = this.#sqls.get(sqlText);\n          if (sqlObj === void 0) {\n            while (this.#sqls.size + 1 > this.capacity) {\n              const [evictSqlText, evictSqlObj] = this.#sqls.peekLru();\n              if (usedSqlObjs.has(evictSqlObj)) {\n                break;\n              }\n              evictSqlObj.close();\n              this.#sqls.delete(evictSqlText);\n            }\n            if (this.#sqls.size + 1 <= this.capacity) {\n              sqlObj = this.#owner.storeSql(sqlText);\n              this.#sqls.set(sqlText, sqlObj);\n            }\n          }\n          if (sqlObj !== void 0) {\n            hranaStmt.sql = sqlObj;\n            usedSqlObjs.add(sqlObj);\n          }\n        }\n      }\n    };\n    Lru = class {\n      static {\n        __name(this, \"Lru\");\n      }\n      // This maps keys to the cache values. The entries are ordered by their last use (entires that were used\n      // most recently are at the end).\n      #cache;\n      constructor() {\n        this.#cache = /* @__PURE__ */ new Map();\n      }\n      get(key) {\n        const value2 = this.#cache.get(key);\n        if (value2 !== void 0) {\n          this.#cache.delete(key);\n          this.#cache.set(key, value2);\n        }\n        return value2;\n      }\n      set(key, value2) {\n        this.#cache.set(key, value2);\n      }\n      peekLru() {\n        for (const entry of this.#cache.entries()) {\n          return entry;\n        }\n        return void 0;\n      }\n      delete(key) {\n        this.#cache.delete(key);\n      }\n      get size() {\n        return this.#cache.size;\n      }\n    };\n    __name(requirePromiseLimit, \"requirePromiseLimit\");\n    promiseLimitExports = requirePromiseLimit();\n    promiseLimit = /* @__PURE__ */ getDefaultExportFromCjs(promiseLimitExports);\n    __name(_createClient$2, \"_createClient$2\");\n    maxConnAgeMillis = 60 * 1e3;\n    sqlCacheCapacity$1 = 100;\n    WsClient2 = class {\n      static {\n        __name(this, \"WsClient\");\n      }\n      #url;\n      #authToken;\n      #intMode;\n      // State of the current connection. The `hrana.WsClient` inside may be closed at any moment due to an\n      // asynchronous error.\n      #connState;\n      // If defined, this is a connection that will be used in the future, once it is ready.\n      #futureConnState;\n      closed;\n      protocol;\n      #isSchemaDatabase;\n      #promiseLimitFunction;\n      /** @private */\n      constructor(client, url, authToken, intMode, concurrency) {\n        this.#url = url;\n        this.#authToken = authToken;\n        this.#intMode = intMode;\n        this.#connState = this.#openConn(client);\n        this.#futureConnState = void 0;\n        this.closed = false;\n        this.protocol = \"ws\";\n        this.#promiseLimitFunction = promiseLimit(concurrency);\n      }\n      async limit(fn2) {\n        return this.#promiseLimitFunction(fn2);\n      }\n      async execute(stmtOrSql, args) {\n        let stmt;\n        if (typeof stmtOrSql === \"string\") {\n          stmt = {\n            sql: stmtOrSql,\n            args: args || []\n          };\n        } else {\n          stmt = stmtOrSql;\n        }\n        return this.limit(async () => {\n          const streamState = await this.#openStream();\n          try {\n            const hranaStmt = stmtToHrana(stmt);\n            streamState.conn.sqlCache.apply([hranaStmt]);\n            const hranaRowsPromise = streamState.stream.query(hranaStmt);\n            streamState.stream.closeGracefully();\n            const hranaRowsResult = await hranaRowsPromise;\n            return resultSetFromHrana(hranaRowsResult);\n          } catch (e) {\n            throw mapHranaError(e);\n          } finally {\n            this._closeStream(streamState);\n          }\n        });\n      }\n      async batch(stmts, mode = \"deferred\") {\n        return this.limit(async () => {\n          const streamState = await this.#openStream();\n          try {\n            const normalizedStmts = stmts.map((stmt) => {\n              if (Array.isArray(stmt)) {\n                return {\n                  sql: stmt[0],\n                  args: stmt[1] || []\n                };\n              }\n              return stmt;\n            });\n            const hranaStmts = normalizedStmts.map(stmtToHrana);\n            const version3 = await streamState.conn.client.getVersion();\n            streamState.conn.sqlCache.apply(hranaStmts);\n            const batch = streamState.stream.batch(version3 >= 3);\n            const resultsPromise = executeHranaBatch(mode, version3, batch, hranaStmts);\n            const results = await resultsPromise;\n            return results;\n          } catch (e) {\n            throw mapHranaError(e);\n          } finally {\n            this._closeStream(streamState);\n          }\n        });\n      }\n      async migrate(stmts) {\n        return this.limit(async () => {\n          const streamState = await this.#openStream();\n          try {\n            const hranaStmts = stmts.map(stmtToHrana);\n            const version3 = await streamState.conn.client.getVersion();\n            const batch = streamState.stream.batch(version3 >= 3);\n            const resultsPromise = executeHranaBatch(\"deferred\", version3, batch, hranaStmts, true);\n            const results = await resultsPromise;\n            return results;\n          } catch (e) {\n            throw mapHranaError(e);\n          } finally {\n            this._closeStream(streamState);\n          }\n        });\n      }\n      async transaction(mode = \"write\") {\n        return this.limit(async () => {\n          const streamState = await this.#openStream();\n          try {\n            const version3 = await streamState.conn.client.getVersion();\n            return new WsTransaction(this, streamState, mode, version3);\n          } catch (e) {\n            this._closeStream(streamState);\n            throw mapHranaError(e);\n          }\n        });\n      }\n      async executeMultiple(sql2) {\n        return this.limit(async () => {\n          const streamState = await this.#openStream();\n          try {\n            const promise = streamState.stream.sequence(sql2);\n            streamState.stream.closeGracefully();\n            await promise;\n          } catch (e) {\n            throw mapHranaError(e);\n          } finally {\n            this._closeStream(streamState);\n          }\n        });\n      }\n      sync() {\n        throw new LibsqlError(\"sync not supported in ws mode\", \"SYNC_NOT_SUPPORTED\");\n      }\n      async #openStream() {\n        if (this.closed) {\n          throw new LibsqlError(\"The client is closed\", \"CLIENT_CLOSED\");\n        }\n        const now = /* @__PURE__ */ new Date();\n        const ageMillis = now.valueOf() - this.#connState.openTime.valueOf();\n        if (ageMillis > maxConnAgeMillis && this.#futureConnState === void 0) {\n          const futureConnState = this.#openConn();\n          this.#futureConnState = futureConnState;\n          futureConnState.client.getVersion().then((_version) => {\n            if (this.#connState !== futureConnState) {\n              if (this.#connState.streamStates.size === 0) {\n                this.#connState.client.close();\n              }\n            }\n            this.#connState = futureConnState;\n            this.#futureConnState = void 0;\n          }, (_e2) => {\n            this.#futureConnState = void 0;\n          });\n        }\n        if (this.#connState.client.closed) {\n          try {\n            if (this.#futureConnState !== void 0) {\n              this.#connState = this.#futureConnState;\n            } else {\n              this.#connState = this.#openConn();\n            }\n          } catch (e) {\n            throw mapHranaError(e);\n          }\n        }\n        const connState = this.#connState;\n        try {\n          if (connState.useSqlCache === void 0) {\n            connState.useSqlCache = await connState.client.getVersion() >= 2;\n            if (connState.useSqlCache) {\n              connState.sqlCache.capacity = sqlCacheCapacity$1;\n            }\n          }\n          const stream = connState.client.openStream();\n          stream.intMode = this.#intMode;\n          const streamState = { conn: connState, stream };\n          connState.streamStates.add(streamState);\n          return streamState;\n        } catch (e) {\n          throw mapHranaError(e);\n        }\n      }\n      #openConn(client) {\n        try {\n          client ??= openWs(this.#url, this.#authToken);\n          return {\n            client,\n            useSqlCache: void 0,\n            sqlCache: new SqlCache(client, 0),\n            openTime: /* @__PURE__ */ new Date(),\n            streamStates: /* @__PURE__ */ new Set()\n          };\n        } catch (e) {\n          throw mapHranaError(e);\n        }\n      }\n      _closeStream(streamState) {\n        streamState.stream.close();\n        const connState = streamState.conn;\n        connState.streamStates.delete(streamState);\n        if (connState.streamStates.size === 0 && connState !== this.#connState) {\n          connState.client.close();\n        }\n      }\n      close() {\n        this.#connState.client.close();\n        this.closed = true;\n      }\n    };\n    WsTransaction = class extends HranaTransaction {\n      static {\n        __name(this, \"WsTransaction\");\n      }\n      #client;\n      #streamState;\n      /** @private */\n      constructor(client, state, mode, version3) {\n        super(mode, version3);\n        this.#client = client;\n        this.#streamState = state;\n      }\n      /** @private */\n      _getStream() {\n        return this.#streamState.stream;\n      }\n      /** @private */\n      _getSqlCache() {\n        return this.#streamState.conn.sqlCache;\n      }\n      close() {\n        this.#client._closeStream(this.#streamState);\n      }\n      get closed() {\n        return this.#streamState.stream.closed;\n      }\n    };\n    __name(_createClient$1, \"_createClient$1\");\n    sqlCacheCapacity = 30;\n    HttpClient2 = class {\n      static {\n        __name(this, \"HttpClient\");\n      }\n      #client;\n      protocol;\n      #authToken;\n      #promiseLimitFunction;\n      /** @private */\n      constructor(url, authToken, intMode, customFetch2, concurrency) {\n        this.#client = openHttp(url, authToken, customFetch2);\n        this.#client.intMode = intMode;\n        this.protocol = \"http\";\n        this.#authToken = authToken;\n        this.#promiseLimitFunction = promiseLimit(concurrency);\n      }\n      async limit(fn2) {\n        return this.#promiseLimitFunction(fn2);\n      }\n      async execute(stmtOrSql, args) {\n        let stmt;\n        if (typeof stmtOrSql === \"string\") {\n          stmt = {\n            sql: stmtOrSql,\n            args: args || []\n          };\n        } else {\n          stmt = stmtOrSql;\n        }\n        return this.limit(async () => {\n          try {\n            const hranaStmt = stmtToHrana(stmt);\n            let rowsPromise;\n            const stream = this.#client.openStream();\n            try {\n              rowsPromise = stream.query(hranaStmt);\n            } finally {\n              stream.closeGracefully();\n            }\n            const rowsResult = await rowsPromise;\n            return resultSetFromHrana(rowsResult);\n          } catch (e) {\n            throw mapHranaError(e);\n          }\n        });\n      }\n      async batch(stmts, mode = \"deferred\") {\n        return this.limit(async () => {\n          try {\n            const normalizedStmts = stmts.map((stmt) => {\n              if (Array.isArray(stmt)) {\n                return {\n                  sql: stmt[0],\n                  args: stmt[1] || []\n                };\n              }\n              return stmt;\n            });\n            const hranaStmts = normalizedStmts.map(stmtToHrana);\n            const version3 = await this.#client.getVersion();\n            let resultsPromise;\n            const stream = this.#client.openStream();\n            try {\n              const sqlCache = new SqlCache(stream, sqlCacheCapacity);\n              sqlCache.apply(hranaStmts);\n              const batch = stream.batch(false);\n              resultsPromise = executeHranaBatch(mode, version3, batch, hranaStmts);\n            } finally {\n              stream.closeGracefully();\n            }\n            const results = await resultsPromise;\n            return results;\n          } catch (e) {\n            throw mapHranaError(e);\n          }\n        });\n      }\n      async migrate(stmts) {\n        return this.limit(async () => {\n          try {\n            const hranaStmts = stmts.map(stmtToHrana);\n            const version3 = await this.#client.getVersion();\n            let resultsPromise;\n            const stream = this.#client.openStream();\n            try {\n              const batch = stream.batch(false);\n              resultsPromise = executeHranaBatch(\"deferred\", version3, batch, hranaStmts, true);\n            } finally {\n              stream.closeGracefully();\n            }\n            const results = await resultsPromise;\n            return results;\n          } catch (e) {\n            throw mapHranaError(e);\n          }\n        });\n      }\n      async transaction(mode = \"write\") {\n        return this.limit(async () => {\n          try {\n            const version3 = await this.#client.getVersion();\n            return new HttpTransaction(this.#client.openStream(), mode, version3);\n          } catch (e) {\n            throw mapHranaError(e);\n          }\n        });\n      }\n      async executeMultiple(sql2) {\n        return this.limit(async () => {\n          try {\n            let promise;\n            const stream = this.#client.openStream();\n            try {\n              promise = stream.sequence(sql2);\n            } finally {\n              stream.closeGracefully();\n            }\n            await promise;\n          } catch (e) {\n            throw mapHranaError(e);\n          }\n        });\n      }\n      sync() {\n        throw new LibsqlError(\"sync not supported in http mode\", \"SYNC_NOT_SUPPORTED\");\n      }\n      close() {\n        this.#client.close();\n      }\n      get closed() {\n        return this.#client.closed;\n      }\n    };\n    HttpTransaction = class extends HranaTransaction {\n      static {\n        __name(this, \"HttpTransaction\");\n      }\n      #stream;\n      #sqlCache;\n      /** @private */\n      constructor(stream, mode, version3) {\n        super(mode, version3);\n        this.#stream = stream;\n        this.#sqlCache = new SqlCache(stream, sqlCacheCapacity);\n      }\n      /** @private */\n      _getStream() {\n        return this.#stream;\n      }\n      /** @private */\n      _getSqlCache() {\n        return this.#sqlCache;\n      }\n      close() {\n        this.#stream.close();\n      }\n      get closed() {\n        return this.#stream.closed;\n      }\n    };\n    __name(createClient, \"createClient\");\n    __name(_createClient, \"_createClient\");\n    __name(getJsonObjectArgs, \"getJsonObjectArgs\");\n    __name(colName, \"colName\");\n    __name(colRef, \"colRef\");\n    __name(jsonArrayFrom, \"jsonArrayFrom\");\n    __name(jsonObjectFrom, \"jsonObjectFrom\");\n    __name(jsonBuildObject, \"jsonBuildObject\");\n    __name(getSqliteJsonObjectArgs, \"getSqliteJsonObjectArgs\");\n    decodeBase64Url$1 = /* @__PURE__ */ __name((str) => {\n      return decodeBase642(str.replace(/_|-/g, (m2) => ({ _: \"/\", \"-\": \"+\" })[m2] ?? m2));\n    }, \"decodeBase64Url$1\");\n    encodeBase64Url$1 = /* @__PURE__ */ __name((buf2) => encodeBase642(buf2).replace(/\\/|\\+/g, (m2) => ({ \"/\": \"_\", \"+\": \"-\" })[m2] ?? m2), \"encodeBase64Url$1\");\n    encodeBase642 = /* @__PURE__ */ __name((buf2) => {\n      let binary2 = \"\";\n      const bytes = new Uint8Array(buf2);\n      for (let i = 0, len = bytes.length; i < len; i++) {\n        binary2 += String.fromCharCode(bytes[i]);\n      }\n      return btoa(binary2);\n    }, \"encodeBase64\");\n    decodeBase642 = /* @__PURE__ */ __name((str) => {\n      const binary2 = atob(str);\n      const bytes = new Uint8Array(new ArrayBuffer(binary2.length));\n      const half = binary2.length / 2;\n      for (let i = 0, j3 = binary2.length - 1; i <= half; i++, j3--) {\n        bytes[i] = binary2.charCodeAt(i);\n        bytes[j3] = binary2.charCodeAt(j3);\n      }\n      return bytes;\n    }, \"decodeBase64\");\n    AlgorithmTypes = /* @__PURE__ */ ((AlgorithmTypes2) => {\n      AlgorithmTypes2[\"HS256\"] = \"HS256\";\n      AlgorithmTypes2[\"HS384\"] = \"HS384\";\n      AlgorithmTypes2[\"HS512\"] = \"HS512\";\n      AlgorithmTypes2[\"RS256\"] = \"RS256\";\n      AlgorithmTypes2[\"RS384\"] = \"RS384\";\n      AlgorithmTypes2[\"RS512\"] = \"RS512\";\n      AlgorithmTypes2[\"PS256\"] = \"PS256\";\n      AlgorithmTypes2[\"PS384\"] = \"PS384\";\n      AlgorithmTypes2[\"PS512\"] = \"PS512\";\n      AlgorithmTypes2[\"ES256\"] = \"ES256\";\n      AlgorithmTypes2[\"ES384\"] = \"ES384\";\n      AlgorithmTypes2[\"ES512\"] = \"ES512\";\n      AlgorithmTypes2[\"EdDSA\"] = \"EdDSA\";\n      return AlgorithmTypes2;\n    })(AlgorithmTypes || {});\n    JwtAlgorithmNotImplemented = class extends Error {\n      static {\n        __name(this, \"JwtAlgorithmNotImplemented\");\n      }\n      constructor(alg) {\n        super(`${alg} is not an implemented algorithm`);\n        this.name = \"JwtAlgorithmNotImplemented\";\n      }\n    };\n    JwtTokenInvalid = class extends Error {\n      static {\n        __name(this, \"JwtTokenInvalid\");\n      }\n      constructor(token) {\n        super(`invalid JWT token: ${token}`);\n        this.name = \"JwtTokenInvalid\";\n      }\n    };\n    JwtTokenNotBefore = class extends Error {\n      static {\n        __name(this, \"JwtTokenNotBefore\");\n      }\n      constructor(token) {\n        super(`token (${token}) is being used before it's valid`);\n        this.name = \"JwtTokenNotBefore\";\n      }\n    };\n    JwtTokenExpired = class extends Error {\n      static {\n        __name(this, \"JwtTokenExpired\");\n      }\n      constructor(token) {\n        super(`token (${token}) expired`);\n        this.name = \"JwtTokenExpired\";\n      }\n    };\n    JwtTokenIssuedAt = class extends Error {\n      static {\n        __name(this, \"JwtTokenIssuedAt\");\n      }\n      constructor(currentTimestamp, iat) {\n        super(`Incorrect \"iat\" claim must be a older than \"${currentTimestamp}\" (iat: \"${iat}\")`);\n        this.name = \"JwtTokenIssuedAt\";\n      }\n    };\n    JwtHeaderInvalid = class extends Error {\n      static {\n        __name(this, \"JwtHeaderInvalid\");\n      }\n      constructor(header) {\n        super(`jwt header is invalid: ${JSON.stringify(header)}`);\n        this.name = \"JwtHeaderInvalid\";\n      }\n    };\n    JwtTokenSignatureMismatched = class extends Error {\n      static {\n        __name(this, \"JwtTokenSignatureMismatched\");\n      }\n      constructor(token) {\n        super(`token(${token}) signature mismatched`);\n        this.name = \"JwtTokenSignatureMismatched\";\n      }\n    };\n    CryptoKeyUsage = /* @__PURE__ */ ((CryptoKeyUsage2) => {\n      CryptoKeyUsage2[\"Encrypt\"] = \"encrypt\";\n      CryptoKeyUsage2[\"Decrypt\"] = \"decrypt\";\n      CryptoKeyUsage2[\"Sign\"] = \"sign\";\n      CryptoKeyUsage2[\"Verify\"] = \"verify\";\n      CryptoKeyUsage2[\"DeriveKey\"] = \"deriveKey\";\n      CryptoKeyUsage2[\"DeriveBits\"] = \"deriveBits\";\n      CryptoKeyUsage2[\"WrapKey\"] = \"wrapKey\";\n      CryptoKeyUsage2[\"UnwrapKey\"] = \"unwrapKey\";\n      return CryptoKeyUsage2;\n    })(CryptoKeyUsage || {});\n    utf8Encoder = new TextEncoder();\n    utf8Decoder = new TextDecoder();\n    __name(signing, \"signing\");\n    __name(verifying, \"verifying\");\n    __name(pemToBinary, \"pemToBinary\");\n    __name(importPrivateKey, \"importPrivateKey\");\n    __name(importPublicKey, \"importPublicKey\");\n    __name(exportPublicJwkFrom, \"exportPublicJwkFrom\");\n    __name(getKeyAlgorithm, \"getKeyAlgorithm\");\n    __name(isCryptoKey$1, \"isCryptoKey$1\");\n    encodeJwtPart = /* @__PURE__ */ __name((part) => encodeBase64Url$1(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, \"\"), \"encodeJwtPart\");\n    encodeSignaturePart = /* @__PURE__ */ __name((buf2) => encodeBase64Url$1(buf2).replace(/=/g, \"\"), \"encodeSignaturePart\");\n    decodeJwtPart = /* @__PURE__ */ __name((part) => JSON.parse(utf8Decoder.decode(decodeBase64Url$1(part))), \"decodeJwtPart\");\n    __name(isTokenHeader, \"isTokenHeader\");\n    sign$1 = /* @__PURE__ */ __name(async (payload, privateKey, alg = \"HS256\") => {\n      const encodedPayload = encodeJwtPart(payload);\n      let encodedHeader;\n      if (typeof privateKey === \"object\" && \"alg\" in privateKey) {\n        alg = privateKey.alg;\n        encodedHeader = encodeJwtPart({ alg, typ: \"JWT\", kid: privateKey.kid });\n      } else {\n        encodedHeader = encodeJwtPart({ alg, typ: \"JWT\" });\n      }\n      const partialToken = `${encodedHeader}.${encodedPayload}`;\n      const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken));\n      const signature = encodeSignaturePart(signaturePart);\n      return `${partialToken}.${signature}`;\n    }, \"sign$1\");\n    verify$1 = /* @__PURE__ */ __name(async (token, publicKey, alg = \"HS256\") => {\n      const tokenParts = token.split(\".\");\n      if (tokenParts.length !== 3) {\n        throw new JwtTokenInvalid(token);\n      }\n      const { header, payload } = decode$1(token);\n      if (!isTokenHeader(header)) {\n        throw new JwtHeaderInvalid(header);\n      }\n      const now = Date.now() / 1e3 | 0;\n      if (payload.nbf && payload.nbf > now) {\n        throw new JwtTokenNotBefore(token);\n      }\n      if (payload.exp && payload.exp <= now) {\n        throw new JwtTokenExpired(token);\n      }\n      if (payload.iat && now < payload.iat) {\n        throw new JwtTokenIssuedAt(now, payload.iat);\n      }\n      const headerPayload = token.substring(0, token.lastIndexOf(\".\"));\n      const verified = await verifying(\n        publicKey,\n        alg,\n        decodeBase64Url$1(tokenParts[2]),\n        utf8Encoder.encode(headerPayload)\n      );\n      if (!verified) {\n        throw new JwtTokenSignatureMismatched(token);\n      }\n      return payload;\n    }, \"verify$1\");\n    decode$1 = /* @__PURE__ */ __name((token) => {\n      try {\n        const [h3, p2] = token.split(\".\");\n        const header = decodeJwtPart(h3);\n        const payload = decodeJwtPart(p2);\n        return {\n          header,\n          payload\n        };\n      } catch {\n        throw new JwtTokenInvalid(token);\n      }\n    }, \"decode$1\");\n    Jwt = { sign: sign$1, verify: verify$1, decode: decode$1 };\n    parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {\n      const { all = false, dot = false } = options;\n      const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;\n      const contentType = headers.get(\"Content-Type\");\n      if (contentType?.startsWith(\"multipart/form-data\") || contentType?.startsWith(\"application/x-www-form-urlencoded\")) {\n        return parseFormData(request, { all, dot });\n      }\n      return {};\n    }, \"parseBody\");\n    __name(parseFormData, \"parseFormData\");\n    __name(convertFormDataToBodyData, \"convertFormDataToBodyData\");\n    handleParsingAllValues = /* @__PURE__ */ __name((form2, key, value2) => {\n      if (form2[key] !== void 0) {\n        if (Array.isArray(form2[key])) {\n          form2[key].push(value2);\n        } else {\n          form2[key] = [form2[key], value2];\n        }\n      } else {\n        form2[key] = value2;\n      }\n    }, \"handleParsingAllValues\");\n    handleParsingNestedValues = /* @__PURE__ */ __name((form2, key, value2) => {\n      let nestedForm = form2;\n      const keys2 = key.split(\".\");\n      keys2.forEach((key2, index) => {\n        if (index === keys2.length - 1) {\n          nestedForm[key2] = value2;\n        } else {\n          if (!nestedForm[key2] || typeof nestedForm[key2] !== \"object\" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {\n            nestedForm[key2] = /* @__PURE__ */ Object.create(null);\n          }\n          nestedForm = nestedForm[key2];\n        }\n      });\n    }, \"handleParsingNestedValues\");\n    tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), \"tryDecodeURIComponent\");\n    HonoRequest = class {\n      static {\n        __name(this, \"HonoRequest\");\n      }\n      raw;\n      #validatedData;\n      #matchResult;\n      routeIndex = 0;\n      path;\n      bodyCache = {};\n      constructor(request, path = \"/\", matchResult = [[]]) {\n        this.raw = request;\n        this.path = path;\n        this.#matchResult = matchResult;\n        this.#validatedData = {};\n      }\n      param(key) {\n        return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();\n      }\n      #getDecodedParam(key) {\n        const paramKey = this.#matchResult[0][this.routeIndex][1][key];\n        const param = this.#getParamValue(paramKey);\n        return param ? /\\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;\n      }\n      #getAllDecodedParams() {\n        const decoded = {};\n        const keys2 = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n        for (const key of keys2) {\n          const value2 = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);\n          if (value2 && typeof value2 === \"string\") {\n            decoded[key] = /\\%/.test(value2) ? tryDecodeURIComponent(value2) : value2;\n          }\n        }\n        return decoded;\n      }\n      #getParamValue(paramKey) {\n        return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;\n      }\n      query(key) {\n        return getQueryParam(this.url, key);\n      }\n      queries(key) {\n        return getQueryParams(this.url, key);\n      }\n      header(name) {\n        if (name) {\n          return this.raw.headers.get(name) ?? void 0;\n        }\n        const headerData = {};\n        this.raw.headers.forEach((value2, key) => {\n          headerData[key] = value2;\n        });\n        return headerData;\n      }\n      async parseBody(options) {\n        return this.bodyCache.parsedBody ??= await parseBody(this, options);\n      }\n      #cachedBody = /* @__PURE__ */ __name((key) => {\n        const { bodyCache, raw: raw2 } = this;\n        const cachedBody = bodyCache[key];\n        if (cachedBody) {\n          return cachedBody;\n        }\n        const anyCachedKey = Object.keys(bodyCache)[0];\n        if (anyCachedKey) {\n          return bodyCache[anyCachedKey].then((body) => {\n            if (anyCachedKey === \"json\") {\n              body = JSON.stringify(body);\n            }\n            return new Response(body)[key]();\n          });\n        }\n        return bodyCache[key] = raw2[key]();\n      }, \"#cachedBody\");\n      json() {\n        return this.#cachedBody(\"json\");\n      }\n      text() {\n        return this.#cachedBody(\"text\");\n      }\n      arrayBuffer() {\n        return this.#cachedBody(\"arrayBuffer\");\n      }\n      blob() {\n        return this.#cachedBody(\"blob\");\n      }\n      formData() {\n        return this.#cachedBody(\"formData\");\n      }\n      addValidatedData(target, data) {\n        this.#validatedData[target] = data;\n      }\n      valid(target) {\n        return this.#validatedData[target];\n      }\n      get url() {\n        return this.raw.url;\n      }\n      get method() {\n        return this.raw.method;\n      }\n      get matchedRoutes() {\n        return this.#matchResult[0].map(([[, route]]) => route);\n      }\n      get routePath() {\n        return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;\n      }\n    };\n    HtmlEscapedCallbackPhase = {\n      Stringify: 1\n    };\n    raw = /* @__PURE__ */ __name((value2, callbacks) => {\n      const escapedString = new String(value2);\n      escapedString.isEscaped = true;\n      escapedString.callbacks = callbacks;\n      return escapedString;\n    }, \"raw\");\n    escapeRe = /[&<>'\"]/;\n    stringBufferToString = /* @__PURE__ */ __name(async (buffer, callbacks) => {\n      let str = \"\";\n      callbacks ||= [];\n      const resolvedBuffer = await Promise.all(buffer);\n      for (let i = resolvedBuffer.length - 1; ; i--) {\n        str += resolvedBuffer[i];\n        i--;\n        if (i < 0) {\n          break;\n        }\n        let r2 = resolvedBuffer[i];\n        if (typeof r2 === \"object\") {\n          callbacks.push(...r2.callbacks || []);\n        }\n        const isEscaped = r2.isEscaped;\n        r2 = await (typeof r2 === \"object\" ? r2.toString() : r2);\n        if (typeof r2 === \"object\") {\n          callbacks.push(...r2.callbacks || []);\n        }\n        if (r2.isEscaped ?? isEscaped) {\n          str += r2;\n        } else {\n          const buf2 = [str];\n          escapeToBuffer(r2, buf2);\n          str = buf2[0];\n        }\n      }\n      return raw(str, callbacks);\n    }, \"stringBufferToString\");\n    escapeToBuffer = /* @__PURE__ */ __name((str, buffer) => {\n      const match = str.search(escapeRe);\n      if (match === -1) {\n        buffer[0] += str;\n        return;\n      }\n      let escape2;\n      let index;\n      let lastIndex = 0;\n      for (index = match; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n          case 34:\n            escape2 = \"&quot;\";\n            break;\n          case 39:\n            escape2 = \"&#39;\";\n            break;\n          case 38:\n            escape2 = \"&amp;\";\n            break;\n          case 60:\n            escape2 = \"&lt;\";\n            break;\n          case 62:\n            escape2 = \"&gt;\";\n            break;\n          default:\n            continue;\n        }\n        buffer[0] += str.substring(lastIndex, index) + escape2;\n        lastIndex = index + 1;\n      }\n      buffer[0] += str.substring(lastIndex, index);\n    }, \"escapeToBuffer\");\n    resolveCallbackSync = /* @__PURE__ */ __name((str) => {\n      const callbacks = str.callbacks;\n      if (!callbacks?.length) {\n        return str;\n      }\n      const buffer = [str];\n      const context2 = {};\n      callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context: context2 }));\n      return buffer[0];\n    }, \"resolveCallbackSync\");\n    resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context2, buffer) => {\n      if (typeof str === \"object\" && !(str instanceof String)) {\n        if (!(str instanceof Promise)) {\n          str = str.toString();\n        }\n        if (str instanceof Promise) {\n          str = await str;\n        }\n      }\n      const callbacks = str.callbacks;\n      if (!callbacks?.length) {\n        return Promise.resolve(str);\n      }\n      if (buffer) {\n        buffer[0] += str;\n      } else {\n        buffer = [str];\n      }\n      const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context: context2 }))).then(\n        (res) => Promise.all(\n          res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context2, buffer))\n        ).then(() => buffer[0])\n      );\n      {\n        return resStr;\n      }\n    }, \"resolveCallback\");\n    TEXT_PLAIN = \"text/plain; charset=UTF-8\";\n    setHeaders = /* @__PURE__ */ __name((headers, map2 = {}) => {\n      for (const key of Object.keys(map2)) {\n        headers.set(key, map2[key]);\n      }\n      return headers;\n    }, \"setHeaders\");\n    Context = class {\n      static {\n        __name(this, \"Context\");\n      }\n      #rawRequest;\n      #req;\n      env = {};\n      #var;\n      finalized = false;\n      error;\n      #status = 200;\n      #executionCtx;\n      #headers;\n      #preparedHeaders;\n      #res;\n      #isFresh = true;\n      #layout;\n      #renderer;\n      #notFoundHandler;\n      #matchResult;\n      #path;\n      constructor(req, options) {\n        this.#rawRequest = req;\n        if (options) {\n          this.#executionCtx = options.executionCtx;\n          this.env = options.env;\n          this.#notFoundHandler = options.notFoundHandler;\n          this.#path = options.path;\n          this.#matchResult = options.matchResult;\n        }\n      }\n      get req() {\n        this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);\n        return this.#req;\n      }\n      get event() {\n        if (this.#executionCtx && \"respondWith\" in this.#executionCtx) {\n          return this.#executionCtx;\n        } else {\n          throw Error(\"This context has no FetchEvent\");\n        }\n      }\n      get executionCtx() {\n        if (this.#executionCtx) {\n          return this.#executionCtx;\n        } else {\n          throw Error(\"This context has no ExecutionContext\");\n        }\n      }\n      get res() {\n        this.#isFresh = false;\n        return this.#res ||= new Response(\"404 Not Found\", { status: 404 });\n      }\n      set res(_res) {\n        this.#isFresh = false;\n        if (this.#res && _res) {\n          _res = new Response(_res.body, _res);\n          for (const [k2, v3] of this.#res.headers.entries()) {\n            if (k2 === \"content-type\") {\n              continue;\n            }\n            if (k2 === \"set-cookie\") {\n              const cookies = this.#res.headers.getSetCookie();\n              _res.headers.delete(\"set-cookie\");\n              for (const cookie of cookies) {\n                _res.headers.append(\"set-cookie\", cookie);\n              }\n            } else {\n              _res.headers.set(k2, v3);\n            }\n          }\n        }\n        this.#res = _res;\n        this.finalized = true;\n      }\n      render = /* @__PURE__ */ __name((...args) => {\n        this.#renderer ??= (content) => this.html(content);\n        return this.#renderer(...args);\n      }, \"render\");\n      setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, \"setLayout\");\n      getLayout = /* @__PURE__ */ __name(() => this.#layout, \"getLayout\");\n      setRenderer = /* @__PURE__ */ __name((renderer2) => {\n        this.#renderer = renderer2;\n      }, \"setRenderer\");\n      header = /* @__PURE__ */ __name((name, value2, options) => {\n        if (this.finalized) {\n          this.#res = new Response(this.#res.body, this.#res);\n        }\n        if (value2 === void 0) {\n          if (this.#headers) {\n            this.#headers.delete(name);\n          } else if (this.#preparedHeaders) {\n            delete this.#preparedHeaders[name.toLocaleLowerCase()];\n          }\n          if (this.finalized) {\n            this.res.headers.delete(name);\n          }\n          return;\n        }\n        if (options?.append) {\n          if (!this.#headers) {\n            this.#isFresh = false;\n            this.#headers = new Headers(this.#preparedHeaders);\n            this.#preparedHeaders = {};\n          }\n          this.#headers.append(name, value2);\n        } else {\n          if (this.#headers) {\n            this.#headers.set(name, value2);\n          } else {\n            this.#preparedHeaders ??= {};\n            this.#preparedHeaders[name.toLowerCase()] = value2;\n          }\n        }\n        if (this.finalized) {\n          if (options?.append) {\n            this.res.headers.append(name, value2);\n          } else {\n            this.res.headers.set(name, value2);\n          }\n        }\n      }, \"header\");\n      status = /* @__PURE__ */ __name((status) => {\n        this.#isFresh = false;\n        this.#status = status;\n      }, \"status\");\n      set = /* @__PURE__ */ __name((key, value2) => {\n        this.#var ??= /* @__PURE__ */ new Map();\n        this.#var.set(key, value2);\n      }, \"set\");\n      get = /* @__PURE__ */ __name((key) => {\n        return this.#var ? this.#var.get(key) : void 0;\n      }, \"get\");\n      get var() {\n        if (!this.#var) {\n          return {};\n        }\n        return Object.fromEntries(this.#var);\n      }\n      #newResponse(data, arg, headers) {\n        if (this.#isFresh && !headers && !arg && this.#status === 200) {\n          return new Response(data, {\n            headers: this.#preparedHeaders\n          });\n        }\n        if (arg && typeof arg !== \"number\") {\n          const header = new Headers(arg.headers);\n          if (this.#headers) {\n            this.#headers.forEach((v3, k2) => {\n              if (k2 === \"set-cookie\") {\n                header.append(k2, v3);\n              } else {\n                header.set(k2, v3);\n              }\n            });\n          }\n          const headers2 = setHeaders(header, this.#preparedHeaders);\n          return new Response(data, {\n            headers: headers2,\n            status: arg.status ?? this.#status\n          });\n        }\n        const status = typeof arg === \"number\" ? arg : this.#status;\n        this.#preparedHeaders ??= {};\n        this.#headers ??= new Headers();\n        setHeaders(this.#headers, this.#preparedHeaders);\n        if (this.#res) {\n          this.#res.headers.forEach((v3, k2) => {\n            if (k2 === \"set-cookie\") {\n              this.#headers?.append(k2, v3);\n            } else {\n              this.#headers?.set(k2, v3);\n            }\n          });\n          setHeaders(this.#headers, this.#preparedHeaders);\n        }\n        headers ??= {};\n        for (const [k2, v3] of Object.entries(headers)) {\n          if (typeof v3 === \"string\") {\n            this.#headers.set(k2, v3);\n          } else {\n            this.#headers.delete(k2);\n            for (const v22 of v3) {\n              this.#headers.append(k2, v22);\n            }\n          }\n        }\n        return new Response(data, {\n          status,\n          headers: this.#headers\n        });\n      }\n      newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), \"newResponse\");\n      body = /* @__PURE__ */ __name((data, arg, headers) => {\n        return typeof arg === \"number\" ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg);\n      }, \"body\");\n      text = /* @__PURE__ */ __name((text, arg, headers) => {\n        if (!this.#preparedHeaders) {\n          if (this.#isFresh && !headers && !arg) {\n            return new Response(text);\n          }\n          this.#preparedHeaders = {};\n        }\n        this.#preparedHeaders[\"content-type\"] = TEXT_PLAIN;\n        if (typeof arg === \"number\") {\n          return this.#newResponse(text, arg, headers);\n        }\n        return this.#newResponse(text, arg);\n      }, \"text\");\n      json = /* @__PURE__ */ __name((object2, arg, headers) => {\n        const body = JSON.stringify(object2);\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[\"content-type\"] = \"application/json\";\n        return typeof arg === \"number\" ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg);\n      }, \"json\");\n      html = /* @__PURE__ */ __name((html2, arg, headers) => {\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[\"content-type\"] = \"text/html; charset=UTF-8\";\n        if (typeof html2 === \"object\") {\n          return resolveCallback(html2, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html22) => {\n            return typeof arg === \"number\" ? this.#newResponse(html22, arg, headers) : this.#newResponse(html22, arg);\n          });\n        }\n        return typeof arg === \"number\" ? this.#newResponse(html2, arg, headers) : this.#newResponse(html2, arg);\n      }, \"html\");\n      redirect = /* @__PURE__ */ __name((location2, status) => {\n        this.#headers ??= new Headers();\n        this.#headers.set(\"Location\", String(location2));\n        return this.newResponse(null, status ?? 302);\n      }, \"redirect\");\n      notFound = /* @__PURE__ */ __name(() => {\n        this.#notFoundHandler ??= () => new Response();\n        return this.#notFoundHandler(this);\n      }, \"notFound\");\n    };\n    verify2 = Jwt.verify;\n    decode = Jwt.decode;\n    sign2 = Jwt.sign;\n    compose = /* @__PURE__ */ __name((middleware2, onError, onNotFound) => {\n      return (context2, next) => {\n        let index = -1;\n        return dispatch(0);\n        async function dispatch(i) {\n          if (i <= index) {\n            throw new Error(\"next() called multiple times\");\n          }\n          index = i;\n          let res;\n          let isError = false;\n          let handler;\n          if (middleware2[i]) {\n            handler = middleware2[i][0][0];\n            context2.req.routeIndex = i;\n          } else {\n            handler = i === middleware2.length && next || void 0;\n          }\n          if (handler) {\n            try {\n              res = await handler(context2, () => dispatch(i + 1));\n            } catch (err) {\n              if (err instanceof Error && onError) {\n                context2.error = err;\n                res = await onError(err, context2);\n                isError = true;\n              } else {\n                throw err;\n              }\n            }\n          } else {\n            if (context2.finalized === false && onNotFound) {\n              res = await onNotFound(context2);\n            }\n          }\n          if (res && (context2.finalized === false || isError)) {\n            context2.res = res;\n          }\n          return context2;\n        }\n        __name(dispatch, \"dispatch\");\n      };\n    }, \"compose\");\n    METHOD_NAME_ALL = \"ALL\";\n    METHOD_NAME_ALL_LOWERCASE = \"all\";\n    METHODS = [\"get\", \"post\", \"put\", \"delete\", \"options\", \"patch\"];\n    MESSAGE_MATCHER_IS_ALREADY_BUILT = \"Can not add a route since the matcher is already built.\";\n    UnsupportedPathError = class extends Error {\n      static {\n        __name(this, \"UnsupportedPathError\");\n      }\n    };\n    COMPOSED_HANDLER = \"__COMPOSED_HANDLER\";\n    notFoundHandler = /* @__PURE__ */ __name((c) => {\n      return c.text(\"404 Not Found\", 404);\n    }, \"notFoundHandler\");\n    errorHandler = /* @__PURE__ */ __name((err, c) => {\n      if (\"getResponse\" in err) {\n        const res = err.getResponse();\n        return c.newResponse(res.body, res);\n      }\n      console.error(err);\n      return c.text(\"Internal Server Error\", 500);\n    }, \"errorHandler\");\n    Hono$1 = class Hono {\n      static {\n        __name(this, \"Hono\");\n      }\n      get;\n      post;\n      put;\n      delete;\n      options;\n      patch;\n      all;\n      on;\n      use;\n      router;\n      getPath;\n      _basePath = \"/\";\n      #path = \"/\";\n      routes = [];\n      constructor(options = {}) {\n        const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];\n        allMethods.forEach((method) => {\n          this[method] = (args1, ...args) => {\n            if (typeof args1 === \"string\") {\n              this.#path = args1;\n            } else {\n              this.#addRoute(method, this.#path, args1);\n            }\n            args.forEach((handler) => {\n              this.#addRoute(method, this.#path, handler);\n            });\n            return this;\n          };\n        });\n        this.on = (method, path, ...handlers) => {\n          for (const p2 of [path].flat()) {\n            this.#path = p2;\n            for (const m2 of [method].flat()) {\n              handlers.map((handler) => {\n                this.#addRoute(m2.toUpperCase(), this.#path, handler);\n              });\n            }\n          }\n          return this;\n        };\n        this.use = (arg1, ...handlers) => {\n          if (typeof arg1 === \"string\") {\n            this.#path = arg1;\n          } else {\n            this.#path = \"*\";\n            handlers.unshift(arg1);\n          }\n          handlers.forEach((handler) => {\n            this.#addRoute(METHOD_NAME_ALL, this.#path, handler);\n          });\n          return this;\n        };\n        const { strict, ...optionsWithoutStrict } = options;\n        Object.assign(this, optionsWithoutStrict);\n        this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;\n      }\n      #clone() {\n        const clone = new Hono$1({\n          router: this.router,\n          getPath: this.getPath\n        });\n        clone.errorHandler = this.errorHandler;\n        clone.#notFoundHandler = this.#notFoundHandler;\n        clone.routes = this.routes;\n        return clone;\n      }\n      #notFoundHandler = notFoundHandler;\n      errorHandler = errorHandler;\n      route(path, app) {\n        const subApp = this.basePath(path);\n        app.routes.map((r2) => {\n          let handler;\n          if (app.errorHandler === errorHandler) {\n            handler = r2.handler;\n          } else {\n            handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app.errorHandler)(c, () => r2.handler(c, next))).res, \"handler\");\n            handler[COMPOSED_HANDLER] = r2.handler;\n          }\n          subApp.#addRoute(r2.method, r2.path, handler);\n        });\n        return this;\n      }\n      basePath(path) {\n        const subApp = this.#clone();\n        subApp._basePath = mergePath(this._basePath, path);\n        return subApp;\n      }\n      onError = /* @__PURE__ */ __name((handler) => {\n        this.errorHandler = handler;\n        return this;\n      }, \"onError\");\n      notFound = /* @__PURE__ */ __name((handler) => {\n        this.#notFoundHandler = handler;\n        return this;\n      }, \"notFound\");\n      mount(path, applicationHandler, options) {\n        let replaceRequest;\n        let optionHandler;\n        if (options) {\n          if (typeof options === \"function\") {\n            optionHandler = options;\n          } else {\n            optionHandler = options.optionHandler;\n            if (options.replaceRequest === false) {\n              replaceRequest = /* @__PURE__ */ __name((request) => request, \"replaceRequest\");\n            } else {\n              replaceRequest = options.replaceRequest;\n            }\n          }\n        }\n        const getOptions = optionHandler ? (c) => {\n          const options2 = optionHandler(c);\n          return Array.isArray(options2) ? options2 : [options2];\n        } : (c) => {\n          let executionContext = void 0;\n          try {\n            executionContext = c.executionCtx;\n          } catch {\n          }\n          return [c.env, executionContext];\n        };\n        replaceRequest ||= (() => {\n          const mergedPath = mergePath(this._basePath, path);\n          const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n          return (request) => {\n            const url = new URL(request.url);\n            url.pathname = url.pathname.slice(pathPrefixLength) || \"/\";\n            return new Request(url, request);\n          };\n        })();\n        const handler = /* @__PURE__ */ __name(async (c, next) => {\n          const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));\n          if (res) {\n            return res;\n          }\n          await next();\n        }, \"handler\");\n        this.#addRoute(METHOD_NAME_ALL, mergePath(path, \"*\"), handler);\n        return this;\n      }\n      #addRoute(method, path, handler) {\n        method = method.toUpperCase();\n        path = mergePath(this._basePath, path);\n        const r2 = { path, method, handler };\n        this.router.add(method, path, [handler, r2]);\n        this.routes.push(r2);\n      }\n      #handleError(err, c) {\n        if (err instanceof Error) {\n          return this.errorHandler(err, c);\n        }\n        throw err;\n      }\n      #dispatch(request, executionCtx, env2, method) {\n        if (method === \"HEAD\") {\n          return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, \"GET\")))();\n        }\n        const path = this.getPath(request, { env: env2 });\n        const matchResult = this.router.match(method, path);\n        const c = new Context(request, {\n          path,\n          matchResult,\n          env: env2,\n          executionCtx,\n          notFoundHandler: this.#notFoundHandler\n        });\n        if (matchResult[0].length === 1) {\n          let res;\n          try {\n            res = matchResult[0][0][0][0](c, async () => {\n              c.res = await this.#notFoundHandler(c);\n            });\n          } catch (err) {\n            return this.#handleError(err, c);\n          }\n          return res instanceof Promise ? res.then(\n            (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))\n          ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);\n        }\n        const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);\n        return (async () => {\n          try {\n            const context2 = await composed(c);\n            if (!context2.finalized) {\n              throw new Error(\n                \"Context is not finalized. Did you forget to return a Response object or `await next()`?\"\n              );\n            }\n            return context2.res;\n          } catch (err) {\n            return this.#handleError(err, c);\n          }\n        })();\n      }\n      fetch = /* @__PURE__ */ __name((request, ...rest) => {\n        return this.#dispatch(request, rest[1], rest[0], request.method);\n      }, \"fetch\");\n      request = /* @__PURE__ */ __name((input2, requestInit, Env, executionCtx) => {\n        if (input2 instanceof Request) {\n          return this.fetch(requestInit ? new Request(input2, requestInit) : input2, Env, executionCtx);\n        }\n        input2 = input2.toString();\n        return this.fetch(\n          new Request(\n            /^https?:\\/\\//.test(input2) ? input2 : `http://localhost${mergePath(\"/\", input2)}`,\n            requestInit\n          ),\n          Env,\n          executionCtx\n        );\n      }, \"request\");\n      fire = /* @__PURE__ */ __name(() => {\n        addEventListener(\"fetch\", (event) => {\n          event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));\n        });\n      }, \"fire\");\n    };\n    LABEL_REG_EXP_STR = \"[^/]+\";\n    ONLY_WILDCARD_REG_EXP_STR = \".*\";\n    TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\n    PATH_ERROR = Symbol();\n    regExpMetaChars = new Set(\".\\\\+*[^]$()\");\n    __name(compareKey, \"compareKey\");\n    Node$1 = class Node {\n      static {\n        __name(this, \"Node\");\n      }\n      #index;\n      #varIndex;\n      #children = /* @__PURE__ */ Object.create(null);\n      insert(tokens, index, paramMap, context2, pathErrorCheckOnly) {\n        if (tokens.length === 0) {\n          if (this.#index !== void 0) {\n            throw PATH_ERROR;\n          }\n          if (pathErrorCheckOnly) {\n            return;\n          }\n          this.#index = index;\n          return;\n        }\n        const [token, ...restTokens] = tokens;\n        const pattern = token === \"*\" ? restTokens.length === 0 ? [\"\", \"\", ONLY_WILDCARD_REG_EXP_STR] : [\"\", \"\", LABEL_REG_EXP_STR] : token === \"/*\" ? [\"\", \"\", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n        let node;\n        if (pattern) {\n          const name = pattern[1];\n          let regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n          if (name && pattern[2]) {\n            regexpStr = regexpStr.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, \"(?:\");\n            if (/\\((?!\\?:)/.test(regexpStr)) {\n              throw PATH_ERROR;\n            }\n          }\n          node = this.#children[regexpStr];\n          if (!node) {\n            if (Object.keys(this.#children).some(\n              (k2) => k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR\n            )) {\n              throw PATH_ERROR;\n            }\n            if (pathErrorCheckOnly) {\n              return;\n            }\n            node = this.#children[regexpStr] = new Node$1();\n            if (name !== \"\") {\n              node.#varIndex = context2.varIndex++;\n            }\n          }\n          if (!pathErrorCheckOnly && name !== \"\") {\n            paramMap.push([name, node.#varIndex]);\n          }\n        } else {\n          node = this.#children[token];\n          if (!node) {\n            if (Object.keys(this.#children).some(\n              (k2) => k2.length > 1 && k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR\n            )) {\n              throw PATH_ERROR;\n            }\n            if (pathErrorCheckOnly) {\n              return;\n            }\n            node = this.#children[token] = new Node$1();\n          }\n        }\n        node.insert(restTokens, index, paramMap, context2, pathErrorCheckOnly);\n      }\n      buildRegExpStr() {\n        const childKeys = Object.keys(this.#children).sort(compareKey);\n        const strList = childKeys.map((k2) => {\n          const c = this.#children[k2];\n          return (typeof c.#varIndex === \"number\" ? `(${k2})@${c.#varIndex}` : regExpMetaChars.has(k2) ? `\\\\${k2}` : k2) + c.buildRegExpStr();\n        });\n        if (typeof this.#index === \"number\") {\n          strList.unshift(`#${this.#index}`);\n        }\n        if (strList.length === 0) {\n          return \"\";\n        }\n        if (strList.length === 1) {\n          return strList[0];\n        }\n        return \"(?:\" + strList.join(\"|\") + \")\";\n      }\n    };\n    Trie = class {\n      static {\n        __name(this, \"Trie\");\n      }\n      #context = { varIndex: 0 };\n      #root = new Node$1();\n      insert(path, index, pathErrorCheckOnly) {\n        const paramAssoc = [];\n        const groups = [];\n        for (let i = 0; ; ) {\n          let replaced = false;\n          path = path.replace(/\\{[^}]+\\}/g, (m2) => {\n            const mark = `@\\\\${i}`;\n            groups[i] = [mark, m2];\n            i++;\n            replaced = true;\n            return mark;\n          });\n          if (!replaced) {\n            break;\n          }\n        }\n        const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n        for (let i = groups.length - 1; i >= 0; i--) {\n          const [mark] = groups[i];\n          for (let j3 = tokens.length - 1; j3 >= 0; j3--) {\n            if (tokens[j3].indexOf(mark) !== -1) {\n              tokens[j3] = tokens[j3].replace(mark, groups[i][1]);\n              break;\n            }\n          }\n        }\n        this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);\n        return paramAssoc;\n      }\n      buildRegExp() {\n        let regexp = this.#root.buildRegExpStr();\n        if (regexp === \"\") {\n          return [/^$/, [], []];\n        }\n        let captureIndex = 0;\n        const indexReplacementMap = [];\n        const paramReplacementMap = [];\n        regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_3, handlerIndex, paramIndex) => {\n          if (handlerIndex !== void 0) {\n            indexReplacementMap[++captureIndex] = Number(handlerIndex);\n            return \"$()\";\n          }\n          if (paramIndex !== void 0) {\n            paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n            return \"\";\n          }\n          return \"\";\n        });\n        return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];\n      }\n    };\n    emptyParam = [];\n    nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];\n    wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n    __name(buildWildcardRegExp, \"buildWildcardRegExp\");\n    __name(clearWildcardRegExpCache, \"clearWildcardRegExpCache\");\n    __name(buildMatcherFromPreprocessedRoutes, \"buildMatcherFromPreprocessedRoutes\");\n    __name(findMiddleware, \"findMiddleware\");\n    RegExpRouter = class {\n      static {\n        __name(this, \"RegExpRouter\");\n      }\n      name = \"RegExpRouter\";\n      #middleware;\n      #routes;\n      constructor() {\n        this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n        this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n      }\n      add(method, path, handler) {\n        const middleware2 = this.#middleware;\n        const routes = this.#routes;\n        if (!middleware2 || !routes) {\n          throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n        }\n        if (!middleware2[method]) {\n          [middleware2, routes].forEach((handlerMap) => {\n            handlerMap[method] = /* @__PURE__ */ Object.create(null);\n            Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p2) => {\n              handlerMap[method][p2] = [...handlerMap[METHOD_NAME_ALL][p2]];\n            });\n          });\n        }\n        if (path === \"/*\") {\n          path = \"*\";\n        }\n        const paramCount = (path.match(/\\/:/g) || []).length;\n        if (/\\*$/.test(path)) {\n          const re2 = buildWildcardRegExp(path);\n          if (method === METHOD_NAME_ALL) {\n            Object.keys(middleware2).forEach((m2) => {\n              middleware2[m2][path] ||= findMiddleware(middleware2[m2], path) || findMiddleware(middleware2[METHOD_NAME_ALL], path) || [];\n            });\n          } else {\n            middleware2[method][path] ||= findMiddleware(middleware2[method], path) || findMiddleware(middleware2[METHOD_NAME_ALL], path) || [];\n          }\n          Object.keys(middleware2).forEach((m2) => {\n            if (method === METHOD_NAME_ALL || method === m2) {\n              Object.keys(middleware2[m2]).forEach((p2) => {\n                re2.test(p2) && middleware2[m2][p2].push([handler, paramCount]);\n              });\n            }\n          });\n          Object.keys(routes).forEach((m2) => {\n            if (method === METHOD_NAME_ALL || method === m2) {\n              Object.keys(routes[m2]).forEach(\n                (p2) => re2.test(p2) && routes[m2][p2].push([handler, paramCount])\n              );\n            }\n          });\n          return;\n        }\n        const paths = checkOptionalParameter(path) || [path];\n        for (let i = 0, len = paths.length; i < len; i++) {\n          const path2 = paths[i];\n          Object.keys(routes).forEach((m2) => {\n            if (method === METHOD_NAME_ALL || method === m2) {\n              routes[m2][path2] ||= [\n                ...findMiddleware(middleware2[m2], path2) || findMiddleware(middleware2[METHOD_NAME_ALL], path2) || []\n              ];\n              routes[m2][path2].push([handler, paramCount - len + i + 1]);\n            }\n          });\n        }\n      }\n      match(method, path) {\n        clearWildcardRegExpCache();\n        const matchers = this.#buildAllMatchers();\n        this.match = (method2, path2) => {\n          const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];\n          const staticMatch = matcher[2][path2];\n          if (staticMatch) {\n            return staticMatch;\n          }\n          const match = path2.match(matcher[0]);\n          if (!match) {\n            return [[], emptyParam];\n          }\n          const index = match.indexOf(\"\", 1);\n          return [matcher[1][index], match];\n        };\n        return this.match(method, path);\n      }\n      #buildAllMatchers() {\n        const matchers = /* @__PURE__ */ Object.create(null);\n        Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {\n          matchers[method] ||= this.#buildMatcher(method);\n        });\n        this.#middleware = this.#routes = void 0;\n        return matchers;\n      }\n      #buildMatcher(method) {\n        const routes = [];\n        let hasOwnRoute = method === METHOD_NAME_ALL;\n        [this.#middleware, this.#routes].forEach((r2) => {\n          const ownRoute = r2[method] ? Object.keys(r2[method]).map((path) => [path, r2[method][path]]) : [];\n          if (ownRoute.length !== 0) {\n            hasOwnRoute ||= true;\n            routes.push(...ownRoute);\n          } else if (method !== METHOD_NAME_ALL) {\n            routes.push(\n              ...Object.keys(r2[METHOD_NAME_ALL]).map((path) => [path, r2[METHOD_NAME_ALL][path]])\n            );\n          }\n        });\n        if (!hasOwnRoute) {\n          return null;\n        } else {\n          return buildMatcherFromPreprocessedRoutes(routes);\n        }\n      }\n    };\n    SmartRouter = class {\n      static {\n        __name(this, \"SmartRouter\");\n      }\n      name = \"SmartRouter\";\n      #routers = [];\n      #routes = [];\n      constructor(init2) {\n        this.#routers = init2.routers;\n      }\n      add(method, path, handler) {\n        if (!this.#routes) {\n          throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n        }\n        this.#routes.push([method, path, handler]);\n      }\n      match(method, path) {\n        if (!this.#routes) {\n          throw new Error(\"Fatal error\");\n        }\n        const routers = this.#routers;\n        const routes = this.#routes;\n        const len = routers.length;\n        let i = 0;\n        let res;\n        for (; i < len; i++) {\n          const router = routers[i];\n          try {\n            for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {\n              router.add(...routes[i2]);\n            }\n            res = router.match(method, path);\n          } catch (e) {\n            if (e instanceof UnsupportedPathError) {\n              continue;\n            }\n            throw e;\n          }\n          this.match = router.match.bind(router);\n          this.#routers = [router];\n          this.#routes = void 0;\n          break;\n        }\n        if (i === len) {\n          throw new Error(\"Fatal error\");\n        }\n        this.name = `SmartRouter + ${this.activeRouter.name}`;\n        return res;\n      }\n      get activeRouter() {\n        if (this.#routes || this.#routers.length !== 1) {\n          throw new Error(\"No active router has been determined yet.\");\n        }\n        return this.#routers[0];\n      }\n    };\n    emptyParams = /* @__PURE__ */ Object.create(null);\n    Node2 = class {\n      static {\n        __name(this, \"Node\");\n      }\n      #methods;\n      #children;\n      #patterns;\n      #order = 0;\n      #params = emptyParams;\n      constructor(method, handler, children) {\n        this.#children = children || /* @__PURE__ */ Object.create(null);\n        this.#methods = [];\n        if (method && handler) {\n          const m2 = /* @__PURE__ */ Object.create(null);\n          m2[method] = { handler, possibleKeys: [], score: 0 };\n          this.#methods = [m2];\n        }\n        this.#patterns = [];\n      }\n      insert(method, path, handler) {\n        this.#order = ++this.#order;\n        let curNode = this;\n        const parts = splitRoutingPath(path);\n        const possibleKeys = [];\n        for (let i = 0, len = parts.length; i < len; i++) {\n          const p2 = parts[i];\n          const nextP = parts[i + 1];\n          const pattern = getPattern(p2, nextP);\n          const key = Array.isArray(pattern) ? pattern[0] : p2;\n          if (Object.keys(curNode.#children).includes(key)) {\n            curNode = curNode.#children[key];\n            const pattern2 = getPattern(p2, nextP);\n            if (pattern2) {\n              possibleKeys.push(pattern2[1]);\n            }\n            continue;\n          }\n          curNode.#children[key] = new Node2();\n          if (pattern) {\n            curNode.#patterns.push(pattern);\n            possibleKeys.push(pattern[1]);\n          }\n          curNode = curNode.#children[key];\n        }\n        const m2 = /* @__PURE__ */ Object.create(null);\n        const handlerSet = {\n          handler,\n          possibleKeys: possibleKeys.filter((v3, i, a2) => a2.indexOf(v3) === i),\n          score: this.#order\n        };\n        m2[method] = handlerSet;\n        curNode.#methods.push(m2);\n        return curNode;\n      }\n      #getHandlerSets(node, method, nodeParams, params) {\n        const handlerSets = [];\n        for (let i = 0, len = node.#methods.length; i < len; i++) {\n          const m2 = node.#methods[i];\n          const handlerSet = m2[method] || m2[METHOD_NAME_ALL];\n          const processedSet = {};\n          if (handlerSet !== void 0) {\n            handlerSet.params = /* @__PURE__ */ Object.create(null);\n            handlerSets.push(handlerSet);\n            if (nodeParams !== emptyParams || params && params !== emptyParams) {\n              for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {\n                const key = handlerSet.possibleKeys[i2];\n                const processed = processedSet[handlerSet.score];\n                handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];\n                processedSet[handlerSet.score] = true;\n              }\n            }\n          }\n        }\n        return handlerSets;\n      }\n      search(method, path) {\n        const handlerSets = [];\n        this.#params = emptyParams;\n        const curNode = this;\n        let curNodes = [curNode];\n        const parts = splitPath(path);\n        const curNodesQueue = [];\n        for (let i = 0, len = parts.length; i < len; i++) {\n          const part = parts[i];\n          const isLast = i === len - 1;\n          const tempNodes = [];\n          for (let j3 = 0, len2 = curNodes.length; j3 < len2; j3++) {\n            const node = curNodes[j3];\n            const nextNode = node.#children[part];\n            if (nextNode) {\n              nextNode.#params = node.#params;\n              if (isLast) {\n                if (nextNode.#children[\"*\"]) {\n                  handlerSets.push(\n                    ...this.#getHandlerSets(nextNode.#children[\"*\"], method, node.#params)\n                  );\n                }\n                handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));\n              } else {\n                tempNodes.push(nextNode);\n              }\n            }\n            for (let k2 = 0, len3 = node.#patterns.length; k2 < len3; k2++) {\n              const pattern = node.#patterns[k2];\n              const params = node.#params === emptyParams ? {} : { ...node.#params };\n              if (pattern === \"*\") {\n                const astNode = node.#children[\"*\"];\n                if (astNode) {\n                  handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));\n                  astNode.#params = params;\n                  tempNodes.push(astNode);\n                }\n                continue;\n              }\n              if (part === \"\") {\n                continue;\n              }\n              const [key, name, matcher] = pattern;\n              const child = node.#children[key];\n              const restPathString = parts.slice(i).join(\"/\");\n              if (matcher instanceof RegExp) {\n                const m2 = matcher.exec(restPathString);\n                if (m2) {\n                  params[name] = m2[0];\n                  handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));\n                  if (Object.keys(child.#children).length) {\n                    child.#params = params;\n                    const componentCount = m2[0].match(/\\//)?.length ?? 0;\n                    const targetCurNodes = curNodesQueue[componentCount] ||= [];\n                    targetCurNodes.push(child);\n                  }\n                  continue;\n                }\n              }\n              if (matcher === true || matcher.test(part)) {\n                params[name] = part;\n                if (isLast) {\n                  handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));\n                  if (child.#children[\"*\"]) {\n                    handlerSets.push(\n                      ...this.#getHandlerSets(child.#children[\"*\"], method, params, node.#params)\n                    );\n                  }\n                } else {\n                  child.#params = params;\n                  tempNodes.push(child);\n                }\n              }\n            }\n          }\n          curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);\n        }\n        if (handlerSets.length > 1) {\n          handlerSets.sort((a2, b3) => {\n            return a2.score - b3.score;\n          });\n        }\n        return [handlerSets.map(({ handler, params }) => [handler, params])];\n      }\n    };\n    TrieRouter = class {\n      static {\n        __name(this, \"TrieRouter\");\n      }\n      name = \"TrieRouter\";\n      #node;\n      constructor() {\n        this.#node = new Node2();\n      }\n      add(method, path, handler) {\n        const results = checkOptionalParameter(path);\n        if (results) {\n          for (let i = 0, len = results.length; i < len; i++) {\n            this.#node.insert(method, results[i], handler);\n          }\n          return;\n        }\n        this.#node.insert(method, path, handler);\n      }\n      match(method, path) {\n        return this.#node.search(method, path);\n      }\n    };\n    Hono2 = class extends Hono$1 {\n      static {\n        __name(this, \"Hono\");\n      }\n      constructor(options = {}) {\n        super(options);\n        this.router = options.router ?? new SmartRouter({\n          routers: [new RegExpRouter(), new TrieRouter()]\n        });\n      }\n    };\n    createMiddleware = /* @__PURE__ */ __name((middleware2) => middleware2, \"createMiddleware\");\n    if (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n      const NAME = \"oauth4webapi\";\n      const VERSION2 = \"v2.17.0\";\n      USER_AGENT = `${NAME}/${VERSION2}`;\n    }\n    __name(looseInstanceOf, \"looseInstanceOf\");\n    clockSkew = Symbol();\n    clockTolerance = Symbol();\n    customFetch = Symbol();\n    modifyAssertion = Symbol();\n    jweDecrypt = Symbol();\n    useMtlsAlias = Symbol();\n    encoder2 = new TextEncoder();\n    decoder2 = new TextDecoder();\n    __name(buf, \"buf\");\n    CHUNK_SIZE = 32768;\n    __name(encodeBase64Url, \"encodeBase64Url\");\n    __name(decodeBase64Url, \"decodeBase64Url\");\n    __name(b64u, \"b64u\");\n    LRU = class {\n      static {\n        __name(this, \"LRU\");\n      }\n      constructor(maxSize) {\n        this.cache = /* @__PURE__ */ new Map();\n        this._cache = /* @__PURE__ */ new Map();\n        this.maxSize = maxSize;\n      }\n      get(key) {\n        let v3 = this.cache.get(key);\n        if (v3) {\n          return v3;\n        }\n        if (v3 = this._cache.get(key)) {\n          this.update(key, v3);\n          return v3;\n        }\n        return void 0;\n      }\n      has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n      }\n      set(key, value2) {\n        if (this.cache.has(key)) {\n          this.cache.set(key, value2);\n        } else {\n          this.update(key, value2);\n        }\n        return this;\n      }\n      delete(key) {\n        if (this.cache.has(key)) {\n          return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n          return this._cache.delete(key);\n        }\n        return false;\n      }\n      update(key, value2) {\n        this.cache.set(key, value2);\n        if (this.cache.size >= this.maxSize) {\n          this._cache = this.cache;\n          this.cache = /* @__PURE__ */ new Map();\n        }\n      }\n    };\n    UnsupportedOperationError = class extends Error {\n      static {\n        __name(this, \"UnsupportedOperationError\");\n      }\n      constructor(message) {\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n      }\n    };\n    OperationProcessingError = class extends Error {\n      static {\n        __name(this, \"OperationProcessingError\");\n      }\n      constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n      }\n    };\n    OPE = OperationProcessingError;\n    dpopNonces = new LRU(100);\n    __name(isCryptoKey, \"isCryptoKey\");\n    __name(isPrivateKey, \"isPrivateKey\");\n    __name(isPublicKey, \"isPublicKey\");\n    __name(processDpopNonce, \"processDpopNonce\");\n    __name(isJsonObject, \"isJsonObject\");\n    __name(prepareHeaders, \"prepareHeaders\");\n    __name(signal, \"signal\");\n    __name(discoveryRequest, \"discoveryRequest\");\n    __name(validateString, \"validateString\");\n    __name(processDiscoveryResponse, \"processDiscoveryResponse\");\n    __name(randomBytes$1, \"randomBytes$1\");\n    __name(generateRandomCodeVerifier, \"generateRandomCodeVerifier\");\n    __name(calculatePKCECodeChallenge, \"calculatePKCECodeChallenge\");\n    __name(formUrlEncode, \"formUrlEncode\");\n    __name(clientSecretBasic, \"clientSecretBasic\");\n    __name(psAlg, \"psAlg\");\n    __name(rsAlg, \"rsAlg\");\n    __name(esAlg, \"esAlg\");\n    __name(keyToJws, \"keyToJws\");\n    __name(getClockSkew, \"getClockSkew\");\n    __name(getClockTolerance, \"getClockTolerance\");\n    __name(epochTime, \"epochTime\");\n    __name(assertAs, \"assertAs\");\n    __name(assertClient, \"assertClient\");\n    __name(assertClientSecret, \"assertClientSecret\");\n    __name(assertNoClientPrivateKey, \"assertNoClientPrivateKey\");\n    __name(assertNoClientSecret, \"assertNoClientSecret\");\n    __name(clientAuthentication, \"clientAuthentication\");\n    __name(jwt, \"jwt\");\n    __name(dpopProofJwt, \"dpopProofJwt\");\n    __name(getSetPublicJwkCache, \"getSetPublicJwkCache\");\n    __name(publicJwk, \"publicJwk\");\n    __name(validateEndpoint, \"validateEndpoint\");\n    __name(resolveEndpoint, \"resolveEndpoint\");\n    __name(alias, \"alias\");\n    __name(isOAuth2Error, \"isOAuth2Error\");\n    __name(unquote, \"unquote\");\n    SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\n    SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\n    __name(wwwAuth, \"wwwAuth\");\n    __name(parseWwwAuthenticateChallenges, \"parseWwwAuthenticateChallenges\");\n    __name(protectedResourceRequest, \"protectedResourceRequest\");\n    __name(userInfoRequest, \"userInfoRequest\");\n    skipSubjectCheck = Symbol();\n    __name(getContentType, \"getContentType\");\n    __name(processUserInfoResponse, \"processUserInfoResponse\");\n    __name(authenticatedRequest, \"authenticatedRequest\");\n    __name(tokenEndpointRequest, \"tokenEndpointRequest\");\n    idTokenClaims = /* @__PURE__ */ new WeakMap();\n    jwtResponseBodies = /* @__PURE__ */ new WeakMap();\n    __name(getValidatedIdTokenClaims, \"getValidatedIdTokenClaims\");\n    __name(processGenericAccessTokenResponse, \"processGenericAccessTokenResponse\");\n    __name(validateOptionalAudience, \"validateOptionalAudience\");\n    __name(validateAudience, \"validateAudience\");\n    __name(validateOptionalIssuer, \"validateOptionalIssuer\");\n    __name(validateIssuer, \"validateIssuer\");\n    branded = /* @__PURE__ */ new WeakSet();\n    __name(brand, \"brand\");\n    __name(authorizationCodeGrantRequest, \"authorizationCodeGrantRequest\");\n    jwtClaimNames = {\n      aud: \"audience\",\n      c_hash: \"code hash\",\n      client_id: \"client id\",\n      exp: \"expiration time\",\n      iat: \"issued at\",\n      iss: \"issuer\",\n      jti: \"jwt id\",\n      nonce: \"nonce\",\n      s_hash: \"state hash\",\n      sub: \"subject\",\n      ath: \"access token hash\",\n      htm: \"http method\",\n      htu: \"http uri\",\n      cnf: \"confirmation\"\n    };\n    __name(validatePresence, \"validatePresence\");\n    expectNoNonce = Symbol();\n    skipAuthTimeCheck = Symbol();\n    __name(processAuthorizationCodeOpenIDResponse, \"processAuthorizationCodeOpenIDResponse\");\n    __name(processAuthorizationCodeOAuth2Response, \"processAuthorizationCodeOAuth2Response\");\n    __name(assertReadableResponse, \"assertReadableResponse\");\n    __name(handleOAuthBodyError, \"handleOAuthBodyError\");\n    __name(checkRsaKeyAlgorithm, \"checkRsaKeyAlgorithm\");\n    __name(ecdsaHashName, \"ecdsaHashName\");\n    __name(keyToSubtle, \"keyToSubtle\");\n    noSignatureCheck = Symbol();\n    __name(validateJwsSignature, \"validateJwsSignature\");\n    __name(validateJwt, \"validateJwt\");\n    __name(checkSigningAlgorithm, \"checkSigningAlgorithm\");\n    __name(getURLSearchParameter, \"getURLSearchParameter\");\n    skipStateCheck = Symbol();\n    expectNoState = Symbol();\n    __name(validateAuthResponse, \"validateAuthResponse\");\n    nodeCrypto = {};\n    __name(randomBytes2, \"randomBytes\");\n    __name(genSaltSync, \"genSaltSync\");\n    __name(genSalt, \"genSalt\");\n    __name(hash2, \"hash\");\n    __name(safeStringCompare, \"safeStringCompare\");\n    __name(compare, \"compare\");\n    nextTick2 = typeof process !== \"undefined\" && process && typeof process.nextTick === \"function\" ? typeof setImmediate === \"function\" ? setImmediate : process.nextTick : setTimeout;\n    __name(utf8Length, \"utf8Length\");\n    __name(utf8Array, \"utf8Array\");\n    BASE64_CODE = \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".split(\"\");\n    BASE64_INDEX = [\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      0,\n      1,\n      54,\n      55,\n      56,\n      57,\n      58,\n      59,\n      60,\n      61,\n      62,\n      63,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      16,\n      17,\n      18,\n      19,\n      20,\n      21,\n      22,\n      23,\n      24,\n      25,\n      26,\n      27,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      28,\n      29,\n      30,\n      31,\n      32,\n      33,\n      34,\n      35,\n      36,\n      37,\n      38,\n      39,\n      40,\n      41,\n      42,\n      43,\n      44,\n      45,\n      46,\n      47,\n      48,\n      49,\n      50,\n      51,\n      52,\n      53,\n      -1,\n      -1,\n      -1,\n      -1,\n      -1\n    ];\n    __name(base64_encode, \"base64_encode\");\n    __name(base64_decode, \"base64_decode\");\n    BCRYPT_SALT_LEN = 16;\n    GENSALT_DEFAULT_LOG2_ROUNDS = 10;\n    BLOWFISH_NUM_ROUNDS = 16;\n    MAX_EXECUTION_TIME = 100;\n    P_ORIG = [\n      608135816,\n      2242054355,\n      320440878,\n      57701188,\n      2752067618,\n      698298832,\n      137296536,\n      3964562569,\n      1160258022,\n      953160567,\n      3193202383,\n      887688300,\n      3232508343,\n      3380367581,\n      1065670069,\n      3041331479,\n      2450970073,\n      2306472731\n    ];\n    S_ORIG = [\n      3509652390,\n      2564797868,\n      805139163,\n      3491422135,\n      3101798381,\n      1780907670,\n      3128725573,\n      4046225305,\n      614570311,\n      3012652279,\n      134345442,\n      2240740374,\n      1667834072,\n      1901547113,\n      2757295779,\n      4103290238,\n      227898511,\n      1921955416,\n      1904987480,\n      2182433518,\n      2069144605,\n      3260701109,\n      2620446009,\n      720527379,\n      3318853667,\n      677414384,\n      3393288472,\n      3101374703,\n      2390351024,\n      1614419982,\n      1822297739,\n      2954791486,\n      3608508353,\n      3174124327,\n      2024746970,\n      1432378464,\n      3864339955,\n      2857741204,\n      1464375394,\n      1676153920,\n      1439316330,\n      715854006,\n      3033291828,\n      289532110,\n      2706671279,\n      2087905683,\n      3018724369,\n      1668267050,\n      732546397,\n      1947742710,\n      3462151702,\n      2609353502,\n      2950085171,\n      1814351708,\n      2050118529,\n      680887927,\n      999245976,\n      1800124847,\n      3300911131,\n      1713906067,\n      1641548236,\n      4213287313,\n      1216130144,\n      1575780402,\n      4018429277,\n      3917837745,\n      3693486850,\n      3949271944,\n      596196993,\n      3549867205,\n      258830323,\n      2213823033,\n      772490370,\n      2760122372,\n      1774776394,\n      2652871518,\n      566650946,\n      4142492826,\n      1728879713,\n      2882767088,\n      1783734482,\n      3629395816,\n      2517608232,\n      2874225571,\n      1861159788,\n      326777828,\n      3124490320,\n      2130389656,\n      2716951837,\n      967770486,\n      1724537150,\n      2185432712,\n      2364442137,\n      1164943284,\n      2105845187,\n      998989502,\n      3765401048,\n      2244026483,\n      1075463327,\n      1455516326,\n      1322494562,\n      910128902,\n      469688178,\n      1117454909,\n      936433444,\n      3490320968,\n      3675253459,\n      1240580251,\n      122909385,\n      2157517691,\n      634681816,\n      4142456567,\n      3825094682,\n      3061402683,\n      2540495037,\n      79693498,\n      3249098678,\n      1084186820,\n      1583128258,\n      426386531,\n      1761308591,\n      1047286709,\n      322548459,\n      995290223,\n      1845252383,\n      2603652396,\n      3431023940,\n      2942221577,\n      3202600964,\n      3727903485,\n      1712269319,\n      422464435,\n      3234572375,\n      1170764815,\n      3523960633,\n      3117677531,\n      1434042557,\n      442511882,\n      3600875718,\n      1076654713,\n      1738483198,\n      4213154764,\n      2393238008,\n      3677496056,\n      1014306527,\n      4251020053,\n      793779912,\n      2902807211,\n      842905082,\n      4246964064,\n      1395751752,\n      1040244610,\n      2656851899,\n      3396308128,\n      445077038,\n      3742853595,\n      3577915638,\n      679411651,\n      2892444358,\n      2354009459,\n      1767581616,\n      3150600392,\n      3791627101,\n      3102740896,\n      284835224,\n      4246832056,\n      1258075500,\n      768725851,\n      2589189241,\n      3069724005,\n      3532540348,\n      1274779536,\n      3789419226,\n      2764799539,\n      1660621633,\n      3471099624,\n      4011903706,\n      913787905,\n      3497959166,\n      737222580,\n      2514213453,\n      2928710040,\n      3937242737,\n      1804850592,\n      3499020752,\n      2949064160,\n      2386320175,\n      2390070455,\n      2415321851,\n      4061277028,\n      2290661394,\n      2416832540,\n      1336762016,\n      1754252060,\n      3520065937,\n      3014181293,\n      791618072,\n      3188594551,\n      3933548030,\n      2332172193,\n      3852520463,\n      3043980520,\n      413987798,\n      3465142937,\n      3030929376,\n      4245938359,\n      2093235073,\n      3534596313,\n      375366246,\n      2157278981,\n      2479649556,\n      555357303,\n      3870105701,\n      2008414854,\n      3344188149,\n      4221384143,\n      3956125452,\n      2067696032,\n      3594591187,\n      2921233993,\n      2428461,\n      544322398,\n      577241275,\n      1471733935,\n      610547355,\n      4027169054,\n      1432588573,\n      1507829418,\n      2025931657,\n      3646575487,\n      545086370,\n      48609733,\n      2200306550,\n      1653985193,\n      298326376,\n      1316178497,\n      3007786442,\n      2064951626,\n      458293330,\n      2589141269,\n      3591329599,\n      3164325604,\n      727753846,\n      2179363840,\n      146436021,\n      1461446943,\n      4069977195,\n      705550613,\n      3059967265,\n      3887724982,\n      4281599278,\n      3313849956,\n      1404054877,\n      2845806497,\n      146425753,\n      1854211946,\n      1266315497,\n      3048417604,\n      3681880366,\n      3289982499,\n      290971e4,\n      1235738493,\n      2632868024,\n      2414719590,\n      3970600049,\n      1771706367,\n      1449415276,\n      3266420449,\n      422970021,\n      1963543593,\n      2690192192,\n      3826793022,\n      1062508698,\n      1531092325,\n      1804592342,\n      2583117782,\n      2714934279,\n      4024971509,\n      1294809318,\n      4028980673,\n      1289560198,\n      2221992742,\n      1669523910,\n      35572830,\n      157838143,\n      1052438473,\n      1016535060,\n      1802137761,\n      1753167236,\n      1386275462,\n      3080475397,\n      2857371447,\n      1040679964,\n      2145300060,\n      2390574316,\n      1461121720,\n      2956646967,\n      4031777805,\n      4028374788,\n      33600511,\n      2920084762,\n      1018524850,\n      629373528,\n      3691585981,\n      3515945977,\n      2091462646,\n      2486323059,\n      586499841,\n      988145025,\n      935516892,\n      3367335476,\n      2599673255,\n      2839830854,\n      265290510,\n      3972581182,\n      2759138881,\n      3795373465,\n      1005194799,\n      847297441,\n      406762289,\n      1314163512,\n      1332590856,\n      1866599683,\n      4127851711,\n      750260880,\n      613907577,\n      1450815602,\n      3165620655,\n      3734664991,\n      3650291728,\n      3012275730,\n      3704569646,\n      1427272223,\n      778793252,\n      1343938022,\n      2676280711,\n      2052605720,\n      1946737175,\n      3164576444,\n      3914038668,\n      3967478842,\n      3682934266,\n      1661551462,\n      3294938066,\n      4011595847,\n      840292616,\n      3712170807,\n      616741398,\n      312560963,\n      711312465,\n      1351876610,\n      322626781,\n      1910503582,\n      271666773,\n      2175563734,\n      1594956187,\n      70604529,\n      3617834859,\n      1007753275,\n      1495573769,\n      4069517037,\n      2549218298,\n      2663038764,\n      504708206,\n      2263041392,\n      3941167025,\n      2249088522,\n      1514023603,\n      1998579484,\n      1312622330,\n      694541497,\n      2582060303,\n      2151582166,\n      1382467621,\n      776784248,\n      2618340202,\n      3323268794,\n      2497899128,\n      2784771155,\n      503983604,\n      4076293799,\n      907881277,\n      423175695,\n      432175456,\n      1378068232,\n      4145222326,\n      3954048622,\n      3938656102,\n      3820766613,\n      2793130115,\n      2977904593,\n      26017576,\n      3274890735,\n      3194772133,\n      1700274565,\n      1756076034,\n      4006520079,\n      3677328699,\n      720338349,\n      1533947780,\n      354530856,\n      688349552,\n      3973924725,\n      1637815568,\n      332179504,\n      3949051286,\n      53804574,\n      2852348879,\n      3044236432,\n      1282449977,\n      3583942155,\n      3416972820,\n      4006381244,\n      1617046695,\n      2628476075,\n      3002303598,\n      1686838959,\n      431878346,\n      2686675385,\n      1700445008,\n      1080580658,\n      1009431731,\n      832498133,\n      3223435511,\n      2605976345,\n      2271191193,\n      2516031870,\n      1648197032,\n      4164389018,\n      2548247927,\n      300782431,\n      375919233,\n      238389289,\n      3353747414,\n      2531188641,\n      2019080857,\n      1475708069,\n      455242339,\n      2609103871,\n      448939670,\n      3451063019,\n      1395535956,\n      2413381860,\n      1841049896,\n      1491858159,\n      885456874,\n      4264095073,\n      4001119347,\n      1565136089,\n      3898914787,\n      1108368660,\n      540939232,\n      1173283510,\n      2745871338,\n      3681308437,\n      4207628240,\n      3343053890,\n      4016749493,\n      1699691293,\n      1103962373,\n      3625875870,\n      2256883143,\n      3830138730,\n      1031889488,\n      3479347698,\n      1535977030,\n      4236805024,\n      3251091107,\n      2132092099,\n      1774941330,\n      1199868427,\n      1452454533,\n      157007616,\n      2904115357,\n      342012276,\n      595725824,\n      1480756522,\n      206960106,\n      497939518,\n      591360097,\n      863170706,\n      2375253569,\n      3596610801,\n      1814182875,\n      2094937945,\n      3421402208,\n      1082520231,\n      3463918190,\n      2785509508,\n      435703966,\n      3908032597,\n      1641649973,\n      2842273706,\n      3305899714,\n      1510255612,\n      2148256476,\n      2655287854,\n      3276092548,\n      4258621189,\n      236887753,\n      3681803219,\n      274041037,\n      1734335097,\n      3815195456,\n      3317970021,\n      1899903192,\n      1026095262,\n      4050517792,\n      356393447,\n      2410691914,\n      3873677099,\n      3682840055,\n      3913112168,\n      2491498743,\n      4132185628,\n      2489919796,\n      1091903735,\n      1979897079,\n      3170134830,\n      3567386728,\n      3557303409,\n      857797738,\n      1136121015,\n      1342202287,\n      507115054,\n      2535736646,\n      337727348,\n      3213592640,\n      1301675037,\n      2528481711,\n      1895095763,\n      1721773893,\n      3216771564,\n      62756741,\n      2142006736,\n      835421444,\n      2531993523,\n      1442658625,\n      3659876326,\n      2882144922,\n      676362277,\n      1392781812,\n      170690266,\n      3921047035,\n      1759253602,\n      3611846912,\n      1745797284,\n      664899054,\n      1329594018,\n      3901205900,\n      3045908486,\n      2062866102,\n      2865634940,\n      3543621612,\n      3464012697,\n      1080764994,\n      553557557,\n      3656615353,\n      3996768171,\n      991055499,\n      499776247,\n      1265440854,\n      648242737,\n      3940784050,\n      980351604,\n      3713745714,\n      1749149687,\n      3396870395,\n      4211799374,\n      3640570775,\n      1161844396,\n      3125318951,\n      1431517754,\n      545492359,\n      4268468663,\n      3499529547,\n      1437099964,\n      2702547544,\n      3433638243,\n      2581715763,\n      2787789398,\n      1060185593,\n      1593081372,\n      2418618748,\n      4260947970,\n      69676912,\n      2159744348,\n      86519011,\n      2512459080,\n      3838209314,\n      1220612927,\n      3339683548,\n      133810670,\n      1090789135,\n      1078426020,\n      1569222167,\n      845107691,\n      3583754449,\n      4072456591,\n      1091646820,\n      628848692,\n      1613405280,\n      3757631651,\n      526609435,\n      236106946,\n      48312990,\n      2942717905,\n      3402727701,\n      1797494240,\n      859738849,\n      992217954,\n      4005476642,\n      2243076622,\n      3870952857,\n      3732016268,\n      765654824,\n      3490871365,\n      2511836413,\n      1685915746,\n      3888969200,\n      1414112111,\n      2273134842,\n      3281911079,\n      4080962846,\n      172450625,\n      2569994100,\n      980381355,\n      4109958455,\n      2819808352,\n      2716589560,\n      2568741196,\n      3681446669,\n      3329971472,\n      1835478071,\n      660984891,\n      3704678404,\n      4045999559,\n      3422617507,\n      3040415634,\n      1762651403,\n      1719377915,\n      3470491036,\n      2693910283,\n      3642056355,\n      3138596744,\n      1364962596,\n      2073328063,\n      1983633131,\n      926494387,\n      3423689081,\n      2150032023,\n      4096667949,\n      1749200295,\n      3328846651,\n      309677260,\n      2016342300,\n      1779581495,\n      3079819751,\n      111262694,\n      1274766160,\n      443224088,\n      298511866,\n      1025883608,\n      3806446537,\n      1145181785,\n      168956806,\n      3641502830,\n      3584813610,\n      1689216846,\n      3666258015,\n      3200248200,\n      1692713982,\n      2646376535,\n      4042768518,\n      1618508792,\n      1610833997,\n      3523052358,\n      4130873264,\n      2001055236,\n      3610705100,\n      2202168115,\n      4028541809,\n      2961195399,\n      1006657119,\n      2006996926,\n      3186142756,\n      1430667929,\n      3210227297,\n      1314452623,\n      4074634658,\n      4101304120,\n      2273951170,\n      1399257539,\n      3367210612,\n      3027628629,\n      1190975929,\n      2062231137,\n      2333990788,\n      2221543033,\n      2438960610,\n      1181637006,\n      548689776,\n      2362791313,\n      3372408396,\n      3104550113,\n      3145860560,\n      296247880,\n      1970579870,\n      3078560182,\n      3769228297,\n      1714227617,\n      3291629107,\n      3898220290,\n      166772364,\n      1251581989,\n      493813264,\n      448347421,\n      195405023,\n      2709975567,\n      677966185,\n      3703036547,\n      1463355134,\n      2715995803,\n      1338867538,\n      1343315457,\n      2802222074,\n      2684532164,\n      233230375,\n      2599980071,\n      2000651841,\n      3277868038,\n      1638401717,\n      4028070440,\n      3237316320,\n      6314154,\n      819756386,\n      300326615,\n      590932579,\n      1405279636,\n      3267499572,\n      3150704214,\n      2428286686,\n      3959192993,\n      3461946742,\n      1862657033,\n      1266418056,\n      963775037,\n      2089974820,\n      2263052895,\n      1917689273,\n      448879540,\n      3550394620,\n      3981727096,\n      150775221,\n      3627908307,\n      1303187396,\n      508620638,\n      2975983352,\n      2726630617,\n      1817252668,\n      1876281319,\n      1457606340,\n      908771278,\n      3720792119,\n      3617206836,\n      2455994898,\n      1729034894,\n      1080033504,\n      976866871,\n      3556439503,\n      2881648439,\n      1522871579,\n      1555064734,\n      1336096578,\n      3548522304,\n      2579274686,\n      3574697629,\n      3205460757,\n      3593280638,\n      3338716283,\n      3079412587,\n      564236357,\n      2993598910,\n      1781952180,\n      1464380207,\n      3163844217,\n      3332601554,\n      1699332808,\n      1393555694,\n      1183702653,\n      3581086237,\n      1288719814,\n      691649499,\n      2847557200,\n      2895455976,\n      3193889540,\n      2717570544,\n      1781354906,\n      1676643554,\n      2592534050,\n      3230253752,\n      1126444790,\n      2770207658,\n      2633158820,\n      2210423226,\n      2615765581,\n      2414155088,\n      3127139286,\n      673620729,\n      2805611233,\n      1269405062,\n      4015350505,\n      3341807571,\n      4149409754,\n      1057255273,\n      2012875353,\n      2162469141,\n      2276492801,\n      2601117357,\n      993977747,\n      3918593370,\n      2654263191,\n      753973209,\n      36408145,\n      2530585658,\n      25011837,\n      3520020182,\n      2088578344,\n      530523599,\n      2918365339,\n      1524020338,\n      1518925132,\n      3760827505,\n      3759777254,\n      1202760957,\n      3985898139,\n      3906192525,\n      674977740,\n      4174734889,\n      2031300136,\n      2019492241,\n      3983892565,\n      4153806404,\n      3822280332,\n      352677332,\n      2297720250,\n      60907813,\n      90501309,\n      3286998549,\n      1016092578,\n      2535922412,\n      2839152426,\n      457141659,\n      509813237,\n      4120667899,\n      652014361,\n      1966332200,\n      2975202805,\n      55981186,\n      2327461051,\n      676427537,\n      3255491064,\n      2882294119,\n      3433927263,\n      1307055953,\n      942726286,\n      933058658,\n      2468411793,\n      3933900994,\n      4215176142,\n      1361170020,\n      2001714738,\n      2830558078,\n      3274259782,\n      1222529897,\n      1679025792,\n      2729314320,\n      3714953764,\n      1770335741,\n      151462246,\n      3013232138,\n      1682292957,\n      1483529935,\n      471910574,\n      1539241949,\n      458788160,\n      3436315007,\n      1807016891,\n      3718408830,\n      978976581,\n      1043663428,\n      3165965781,\n      1927990952,\n      4200891579,\n      2372276910,\n      3208408903,\n      3533431907,\n      1412390302,\n      2931980059,\n      4132332400,\n      1947078029,\n      3881505623,\n      4168226417,\n      2941484381,\n      1077988104,\n      1320477388,\n      886195818,\n      18198404,\n      3786409e3,\n      2509781533,\n      112762804,\n      3463356488,\n      1866414978,\n      891333506,\n      18488651,\n      661792760,\n      1628790961,\n      3885187036,\n      3141171499,\n      876946877,\n      2693282273,\n      1372485963,\n      791857591,\n      2686433993,\n      3759982718,\n      3167212022,\n      3472953795,\n      2716379847,\n      445679433,\n      3561995674,\n      3504004811,\n      3574258232,\n      54117162,\n      3331405415,\n      2381918588,\n      3769707343,\n      4154350007,\n      1140177722,\n      4074052095,\n      668550556,\n      3214352940,\n      367459370,\n      261225585,\n      2610173221,\n      4209349473,\n      3468074219,\n      3265815641,\n      314222801,\n      3066103646,\n      3808782860,\n      282218597,\n      3406013506,\n      3773591054,\n      379116347,\n      1285071038,\n      846784868,\n      2669647154,\n      3771962079,\n      3550491691,\n      2305946142,\n      453669953,\n      1268987020,\n      3317592352,\n      3279303384,\n      3744833421,\n      2610507566,\n      3859509063,\n      266596637,\n      3847019092,\n      517658769,\n      3462560207,\n      3443424879,\n      370717030,\n      4247526661,\n      2224018117,\n      4143653529,\n      4112773975,\n      2788324899,\n      2477274417,\n      1456262402,\n      2901442914,\n      1517677493,\n      1846949527,\n      2295493580,\n      3734397586,\n      2176403920,\n      1280348187,\n      1908823572,\n      3871786941,\n      846861322,\n      1172426758,\n      3287448474,\n      3383383037,\n      1655181056,\n      3139813346,\n      901632758,\n      1897031941,\n      2986607138,\n      3066810236,\n      3447102507,\n      1393639104,\n      373351379,\n      950779232,\n      625454576,\n      3124240540,\n      4148612726,\n      2007998917,\n      544563296,\n      2244738638,\n      2330496472,\n      2058025392,\n      1291430526,\n      424198748,\n      50039436,\n      29584100,\n      3605783033,\n      2429876329,\n      2791104160,\n      1057563949,\n      3255363231,\n      3075367218,\n      3463963227,\n      1469046755,\n      985887462\n    ];\n    C_ORIG = [\n      1332899944,\n      1700884034,\n      1701343084,\n      1684370003,\n      1668446532,\n      1869963892\n    ];\n    __name(_encipher, \"_encipher\");\n    __name(_streamtoword, \"_streamtoword\");\n    __name(_key, \"_key\");\n    __name(_ekskey, \"_ekskey\");\n    __name(_crypt, \"_crypt\");\n    __name(_hash, \"_hash\");\n    cors = /* @__PURE__ */ __name((options) => {\n      const defaults = {\n        origin: \"*\",\n        allowMethods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\"],\n        allowHeaders: [],\n        exposeHeaders: []\n      };\n      const opts = {\n        ...defaults,\n        ...options\n      };\n      const findAllowOrigin = ((optsOrigin) => {\n        if (typeof optsOrigin === \"string\") {\n          if (optsOrigin === \"*\") {\n            return () => optsOrigin;\n          } else {\n            return (origin) => optsOrigin === origin ? origin : null;\n          }\n        } else if (typeof optsOrigin === \"function\") {\n          return optsOrigin;\n        } else {\n          return (origin) => optsOrigin.includes(origin) ? origin : null;\n        }\n      })(opts.origin);\n      return /* @__PURE__ */ __name(async function cors2(c, next) {\n        function set2(key, value2) {\n          c.res.headers.set(key, value2);\n        }\n        __name(set2, \"set\");\n        const allowOrigin = findAllowOrigin(c.req.header(\"origin\") || \"\", c);\n        if (allowOrigin) {\n          set2(\"Access-Control-Allow-Origin\", allowOrigin);\n        }\n        if (opts.origin !== \"*\") {\n          const existingVary = c.req.header(\"Vary\");\n          if (existingVary) {\n            set2(\"Vary\", existingVary);\n          } else {\n            set2(\"Vary\", \"Origin\");\n          }\n        }\n        if (opts.credentials) {\n          set2(\"Access-Control-Allow-Credentials\", \"true\");\n        }\n        if (opts.exposeHeaders?.length) {\n          set2(\"Access-Control-Expose-Headers\", opts.exposeHeaders.join(\",\"));\n        }\n        if (c.req.method === \"OPTIONS\") {\n          if (opts.maxAge != null) {\n            set2(\"Access-Control-Max-Age\", opts.maxAge.toString());\n          }\n          if (opts.allowMethods?.length) {\n            set2(\"Access-Control-Allow-Methods\", opts.allowMethods.join(\",\"));\n          }\n          let headers = opts.allowHeaders;\n          if (!headers?.length) {\n            const requestHeaders = c.req.header(\"Access-Control-Request-Headers\");\n            if (requestHeaders) {\n              headers = requestHeaders.split(/\\s*,\\s*/);\n            }\n          }\n          if (headers?.length) {\n            set2(\"Access-Control-Allow-Headers\", headers.join(\",\"));\n            c.res.headers.append(\"Vary\", \"Access-Control-Request-Headers\");\n          }\n          c.res.headers.delete(\"Content-Length\");\n          c.res.headers.delete(\"Content-Type\");\n          return new Response(null, {\n            headers: c.res.headers,\n            status: 204,\n            statusText: \"No Content\"\n          });\n        }\n        await next();\n      }, \"cors2\");\n    }, \"cors\");\n    html = /* @__PURE__ */ __name((strings, ...values) => {\n      const buffer = [\"\"];\n      for (let i = 0, len = strings.length - 1; i < len; i++) {\n        buffer[0] += strings[i];\n        const children = Array.isArray(values[i]) ? values[i].flat(Infinity) : [values[i]];\n        for (let i2 = 0, len2 = children.length; i2 < len2; i2++) {\n          const child = children[i2];\n          if (typeof child === \"string\") {\n            escapeToBuffer(child, buffer);\n          } else if (typeof child === \"number\") {\n            buffer[0] += child;\n          } else if (typeof child === \"boolean\" || child === null || child === void 0) {\n            continue;\n          } else if (typeof child === \"object\" && child.isEscaped) {\n            if (child.callbacks) {\n              buffer.unshift(\"\", child);\n            } else {\n              const tmp = child.toString();\n              if (tmp instanceof Promise) {\n                buffer.unshift(\"\", tmp);\n              } else {\n                buffer[0] += tmp;\n              }\n            }\n          } else if (child instanceof Promise) {\n            buffer.unshift(\"\", child);\n          } else {\n            escapeToBuffer(child.toString(), buffer);\n          }\n        }\n      }\n      buffer[0] += strings.at(-1);\n      return buffer.length === 1 ? \"callbacks\" in buffer ? raw(resolveCallbackSync(raw(buffer[0], buffer.callbacks))) : raw(buffer[0]) : stringBufferToString(buffer, buffer.callbacks);\n    }, \"html\");\n    DOM_RENDERER = Symbol(\"RENDERER\");\n    DOM_ERROR_HANDLER = Symbol(\"ERROR_HANDLER\");\n    DOM_STASH = Symbol(\"STASH\");\n    DOM_INTERNAL_TAG = Symbol(\"INTERNAL\");\n    DOM_MEMO = Symbol(\"MEMO\");\n    PERMALINK = Symbol(\"PERMALINK\");\n    setInternalTagFlag = /* @__PURE__ */ __name((fn2) => {\n      fn2[DOM_INTERNAL_TAG] = true;\n      return fn2;\n    }, \"setInternalTagFlag\");\n    createContextProviderFunction = /* @__PURE__ */ __name((values) => ({ value: value2, children }) => {\n      if (!children) {\n        return void 0;\n      }\n      const props = {\n        children: [\n          {\n            tag: setInternalTagFlag(() => {\n              values.push(value2);\n            }),\n            props: {}\n          }\n        ]\n      };\n      if (Array.isArray(children)) {\n        props.children.push(...children.flat());\n      } else {\n        props.children.push(children);\n      }\n      props.children.push({\n        tag: setInternalTagFlag(() => {\n          values.pop();\n        }),\n        props: {}\n      });\n      const res = { tag: \"\", props, type: \"\" };\n      res[DOM_ERROR_HANDLER] = (err) => {\n        values.pop();\n        throw err;\n      };\n      return res;\n    }, \"createContextProviderFunction\");\n    createContext$1 = /* @__PURE__ */ __name((defaultValue) => {\n      const values = [defaultValue];\n      const context2 = createContextProviderFunction(values);\n      context2.values = values;\n      context2.Provider = context2;\n      globalContexts.push(context2);\n      return context2;\n    }, \"createContext$1\");\n    globalContexts = [];\n    createContext = /* @__PURE__ */ __name((defaultValue) => {\n      const values = [defaultValue];\n      const context2 = /* @__PURE__ */ __name((props) => {\n        values.push(props.value);\n        let string2;\n        try {\n          string2 = props.children ? (Array.isArray(props.children) ? new JSXFragmentNode(\"\", {}, props.children) : props.children).toString() : \"\";\n        } finally {\n          values.pop();\n        }\n        if (string2 instanceof Promise) {\n          return string2.then((resString) => raw(resString, resString.callbacks));\n        } else {\n          return raw(string2);\n        }\n      }, \"context\");\n      context2.values = values;\n      context2.Provider = context2;\n      context2[DOM_RENDERER] = createContextProviderFunction(values);\n      globalContexts.push(context2);\n      return context2;\n    }, \"createContext\");\n    useContext = /* @__PURE__ */ __name((context2) => {\n      return context2.values.at(-1);\n    }, \"useContext\");\n    deDupeKeyMap = {\n      title: [],\n      script: [\"src\"],\n      style: [\"data-href\"],\n      link: [\"href\"],\n      meta: [\"name\", \"httpEquiv\", \"charset\", \"itemProp\"]\n    };\n    domRenderers = {};\n    dataPrecedenceAttr = \"data-precedence\";\n    toArray = /* @__PURE__ */ __name((children) => Array.isArray(children) ? children : [children], \"toArray\");\n    metaTagMap = /* @__PURE__ */ new WeakMap();\n    insertIntoHead = /* @__PURE__ */ __name((tagName, tag, props, precedence) => ({ buffer, context: context2 }) => {\n      if (!buffer) {\n        return;\n      }\n      const map2 = metaTagMap.get(context2) || {};\n      metaTagMap.set(context2, map2);\n      const tags = map2[tagName] ||= [];\n      let duped = false;\n      const deDupeKeys = deDupeKeyMap[tagName];\n      if (deDupeKeys.length > 0) {\n        LOOP:\n          for (const [, tagProps] of tags) {\n            for (const key of deDupeKeys) {\n              if ((tagProps?.[key] ?? null) === props?.[key]) {\n                duped = true;\n                break LOOP;\n              }\n            }\n          }\n      }\n      if (duped) {\n        buffer[0] = buffer[0].replaceAll(tag, \"\");\n      } else if (deDupeKeys.length > 0) {\n        tags.push([tag, props, precedence]);\n      } else {\n        tags.unshift([tag, props, precedence]);\n      }\n      if (buffer[0].indexOf(\"</head>\") !== -1) {\n        let insertTags;\n        if (precedence === void 0) {\n          insertTags = tags.map(([tag2]) => tag2);\n        } else {\n          const precedences = [];\n          insertTags = tags.map(([tag2, , precedence2]) => {\n            let order = precedences.indexOf(precedence2);\n            if (order === -1) {\n              precedences.push(precedence2);\n              order = precedences.length - 1;\n            }\n            return [tag2, order];\n          }).sort((a2, b3) => a2[1] - b3[1]).map(([tag2]) => tag2);\n        }\n        insertTags.forEach((tag2) => {\n          buffer[0] = buffer[0].replaceAll(tag2, \"\");\n        });\n        buffer[0] = buffer[0].replace(/(?=<\\/head>)/, insertTags.join(\"\"));\n      }\n    }, \"insertIntoHead\");\n    returnWithoutSpecialBehavior = /* @__PURE__ */ __name((tag, children, props) => raw(new JSXNode(tag, props, toArray(children ?? [])).toString()), \"returnWithoutSpecialBehavior\");\n    documentMetadataTag$1 = /* @__PURE__ */ __name((tag, children, props, sort) => {\n      if (\"itemProp\" in props) {\n        return returnWithoutSpecialBehavior(tag, children, props);\n      }\n      let { precedence, blocking, ...restProps } = props;\n      precedence = sort ? precedence ?? \"\" : void 0;\n      if (sort) {\n        restProps[dataPrecedenceAttr] = precedence;\n      }\n      const string2 = new JSXNode(tag, restProps, toArray(children || [])).toString();\n      if (string2 instanceof Promise) {\n        return string2.then(\n          (resString) => raw(string2, [\n            ...resString.callbacks || [],\n            insertIntoHead(tag, resString, restProps, precedence)\n          ])\n        );\n      } else {\n        return raw(string2, [insertIntoHead(tag, string2, restProps, precedence)]);\n      }\n    }, \"documentMetadataTag$1\");\n    title$1 = /* @__PURE__ */ __name(({ children, ...props }) => {\n      const nameSpaceContext2 = getNameSpaceContext$1();\n      if (nameSpaceContext2) {\n        const context2 = useContext(nameSpaceContext2);\n        if (context2 === \"svg\" || context2 === \"head\") {\n          return new JSXNode(\n            \"title\",\n            props,\n            toArray(children ?? [])\n          );\n        }\n      }\n      return documentMetadataTag$1(\"title\", children, props, false);\n    }, \"title$1\");\n    script$1 = /* @__PURE__ */ __name(({\n      children,\n      ...props\n    }) => {\n      const nameSpaceContext2 = getNameSpaceContext$1();\n      if ([\"src\", \"async\"].some((k2) => !props[k2]) || nameSpaceContext2 && useContext(nameSpaceContext2) === \"head\") {\n        return returnWithoutSpecialBehavior(\"script\", children, props);\n      }\n      return documentMetadataTag$1(\"script\", children, props, false);\n    }, \"script$1\");\n    style$1 = /* @__PURE__ */ __name(({\n      children,\n      ...props\n    }) => {\n      if (![\"href\", \"precedence\"].every((k2) => k2 in props)) {\n        return returnWithoutSpecialBehavior(\"style\", children, props);\n      }\n      props[\"data-href\"] = props.href;\n      delete props.href;\n      return documentMetadataTag$1(\"style\", children, props, true);\n    }, \"style$1\");\n    link$1 = /* @__PURE__ */ __name(({ children, ...props }) => {\n      if ([\"onLoad\", \"onError\"].some((k2) => k2 in props) || props.rel === \"stylesheet\" && (!(\"precedence\" in props) || \"disabled\" in props)) {\n        return returnWithoutSpecialBehavior(\"link\", children, props);\n      }\n      return documentMetadataTag$1(\"link\", children, props, \"precedence\" in props);\n    }, \"link$1\");\n    meta$1 = /* @__PURE__ */ __name(({ children, ...props }) => {\n      const nameSpaceContext2 = getNameSpaceContext$1();\n      if (nameSpaceContext2 && useContext(nameSpaceContext2) === \"head\") {\n        return returnWithoutSpecialBehavior(\"meta\", children, props);\n      }\n      return documentMetadataTag$1(\"meta\", children, props, false);\n    }, \"meta$1\");\n    newJSXNode = /* @__PURE__ */ __name((tag, { children, ...props }) => new JSXNode(tag, props, toArray(children ?? [])), \"newJSXNode\");\n    form$1 = /* @__PURE__ */ __name((props) => {\n      if (typeof props.action === \"function\") {\n        props.action = PERMALINK in props.action ? props.action[PERMALINK] : void 0;\n      }\n      return newJSXNode(\"form\", props);\n    }, \"form$1\");\n    formActionableElement$1 = /* @__PURE__ */ __name((tag, props) => {\n      if (typeof props.formAction === \"function\") {\n        props.formAction = PERMALINK in props.formAction ? props.formAction[PERMALINK] : void 0;\n      }\n      return newJSXNode(tag, props);\n    }, \"formActionableElement$1\");\n    input$1 = /* @__PURE__ */ __name((props) => formActionableElement$1(\"input\", props), \"input$1\");\n    button$1 = /* @__PURE__ */ __name((props) => formActionableElement$1(\"button\", props), \"button$1\");\n    intrinsicElementTags = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      button: button$1,\n      form: form$1,\n      input: input$1,\n      link: link$1,\n      meta: meta$1,\n      script: script$1,\n      style: style$1,\n      title: title$1\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    normalizeElementKeyMap = /* @__PURE__ */ new Map([\n      [\"className\", \"class\"],\n      [\"htmlFor\", \"for\"],\n      [\"crossOrigin\", \"crossorigin\"],\n      [\"httpEquiv\", \"http-equiv\"],\n      [\"itemProp\", \"itemprop\"],\n      [\"fetchPriority\", \"fetchpriority\"],\n      [\"noModule\", \"nomodule\"],\n      [\"formAction\", \"formaction\"]\n    ]);\n    normalizeIntrinsicElementKey = /* @__PURE__ */ __name((key) => normalizeElementKeyMap.get(key) || key, \"normalizeIntrinsicElementKey\");\n    styleObjectForEach = /* @__PURE__ */ __name((style2, fn2) => {\n      for (const [k2, v3] of Object.entries(style2)) {\n        const key = k2[0] === \"-\" || !/[A-Z]/.test(k2) ? k2 : k2.replace(/[A-Z]/g, (m2) => `-${m2.toLowerCase()}`);\n        fn2(\n          key,\n          v3 == null ? null : typeof v3 === \"number\" ? !key.match(\n            /^(?:a|border-im|column(?:-c|s)|flex(?:$|-[^b])|grid-(?:ar|[^a])|font-w|li|or|sca|st|ta|wido|z)|ty$/\n          ) ? `${v3}px` : `${v3}` : v3\n        );\n      }\n    }, \"styleObjectForEach\");\n    nameSpaceContext$1 = void 0;\n    getNameSpaceContext$1 = /* @__PURE__ */ __name(() => nameSpaceContext$1, \"getNameSpaceContext$1\");\n    toSVGAttributeName = /* @__PURE__ */ __name((key) => /[A-Z]/.test(key) && key.match(\n      /^(?:al|basel|clip(?:Path|Rule)$|co|do|fill|fl|fo|gl|let|lig|i|marker[EMS]|o|pai|pointe|sh|st[or]|text[^L]|tr|u|ve|w)/\n    ) ? key.replace(/([A-Z])/g, \"-$1\").toLowerCase() : key, \"toSVGAttributeName\");\n    emptyTags = [\n      \"area\",\n      \"base\",\n      \"br\",\n      \"col\",\n      \"embed\",\n      \"hr\",\n      \"img\",\n      \"input\",\n      \"keygen\",\n      \"link\",\n      \"meta\",\n      \"param\",\n      \"source\",\n      \"track\",\n      \"wbr\"\n    ];\n    booleanAttributes = [\n      \"allowfullscreen\",\n      \"async\",\n      \"autofocus\",\n      \"autoplay\",\n      \"checked\",\n      \"controls\",\n      \"default\",\n      \"defer\",\n      \"disabled\",\n      \"download\",\n      \"formnovalidate\",\n      \"hidden\",\n      \"inert\",\n      \"ismap\",\n      \"itemscope\",\n      \"loop\",\n      \"multiple\",\n      \"muted\",\n      \"nomodule\",\n      \"novalidate\",\n      \"open\",\n      \"playsinline\",\n      \"readonly\",\n      \"required\",\n      \"reversed\",\n      \"selected\"\n    ];\n    childrenToStringToBuffer = /* @__PURE__ */ __name((children, buffer) => {\n      for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        if (typeof child === \"string\") {\n          escapeToBuffer(child, buffer);\n        } else if (typeof child === \"boolean\" || child === null || child === void 0) {\n          continue;\n        } else if (child instanceof JSXNode) {\n          child.toStringToBuffer(buffer);\n        } else if (typeof child === \"number\" || child.isEscaped) {\n          buffer[0] += child;\n        } else if (child instanceof Promise) {\n          buffer.unshift(\"\", child);\n        } else {\n          childrenToStringToBuffer(child, buffer);\n        }\n      }\n    }, \"childrenToStringToBuffer\");\n    JSXNode = class {\n      static {\n        __name(this, \"JSXNode\");\n      }\n      tag;\n      props;\n      key;\n      children;\n      isEscaped = true;\n      localContexts;\n      constructor(tag, props, children) {\n        this.tag = tag;\n        this.props = props;\n        this.children = children;\n      }\n      get type() {\n        return this.tag;\n      }\n      get ref() {\n        return this.props.ref || null;\n      }\n      toString() {\n        const buffer = [\"\"];\n        this.localContexts?.forEach(([context2, value2]) => {\n          context2.values.push(value2);\n        });\n        try {\n          this.toStringToBuffer(buffer);\n        } finally {\n          this.localContexts?.forEach(([context2]) => {\n            context2.values.pop();\n          });\n        }\n        return buffer.length === 1 ? \"callbacks\" in buffer ? resolveCallbackSync(raw(buffer[0], buffer.callbacks)).toString() : buffer[0] : stringBufferToString(buffer, buffer.callbacks);\n      }\n      toStringToBuffer(buffer) {\n        const tag = this.tag;\n        const props = this.props;\n        let { children } = this;\n        buffer[0] += `<${tag}`;\n        const normalizeKey3 = nameSpaceContext$1 && useContext(nameSpaceContext$1) === \"svg\" ? (key) => toSVGAttributeName(normalizeIntrinsicElementKey(key)) : (key) => normalizeIntrinsicElementKey(key);\n        for (let [key, v3] of Object.entries(props)) {\n          key = normalizeKey3(key);\n          if (key === \"children\") ;\n          else if (key === \"style\" && typeof v3 === \"object\") {\n            let styleStr = \"\";\n            styleObjectForEach(v3, (property2, value2) => {\n              if (value2 != null) {\n                styleStr += `${styleStr ? \";\" : \"\"}${property2}:${value2}`;\n              }\n            });\n            buffer[0] += ' style=\"';\n            escapeToBuffer(styleStr, buffer);\n            buffer[0] += '\"';\n          } else if (typeof v3 === \"string\") {\n            buffer[0] += ` ${key}=\"`;\n            escapeToBuffer(v3, buffer);\n            buffer[0] += '\"';\n          } else if (v3 === null || v3 === void 0) ;\n          else if (typeof v3 === \"number\" || v3.isEscaped) {\n            buffer[0] += ` ${key}=\"${v3}\"`;\n          } else if (typeof v3 === \"boolean\" && booleanAttributes.includes(key)) {\n            if (v3) {\n              buffer[0] += ` ${key}=\"\"`;\n            }\n          } else if (key === \"dangerouslySetInnerHTML\") {\n            if (children.length > 0) {\n              throw \"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\";\n            }\n            children = [raw(v3.__html)];\n          } else if (v3 instanceof Promise) {\n            buffer[0] += ` ${key}=\"`;\n            buffer.unshift('\"', v3);\n          } else if (typeof v3 === \"function\") {\n            if (!key.startsWith(\"on\")) {\n              throw `Invalid prop '${key}' of type 'function' supplied to '${tag}'.`;\n            }\n          } else {\n            buffer[0] += ` ${key}=\"`;\n            escapeToBuffer(v3.toString(), buffer);\n            buffer[0] += '\"';\n          }\n        }\n        if (emptyTags.includes(tag) && children.length === 0) {\n          buffer[0] += \"/>\";\n          return;\n        }\n        buffer[0] += \">\";\n        childrenToStringToBuffer(children, buffer);\n        buffer[0] += `</${tag}>`;\n      }\n    };\n    JSXFunctionNode = class extends JSXNode {\n      static {\n        __name(this, \"JSXFunctionNode\");\n      }\n      toStringToBuffer(buffer) {\n        const { children } = this;\n        const res = this.tag.call(null, {\n          ...this.props,\n          children: children.length <= 1 ? children[0] : children\n        });\n        if (typeof res === \"boolean\" || res == null) {\n          return;\n        } else if (res instanceof Promise) {\n          if (globalContexts.length === 0) {\n            buffer.unshift(\"\", res);\n          } else {\n            const currentContexts = globalContexts.map((c) => [c, c.values.at(-1)]);\n            buffer.unshift(\n              \"\",\n              res.then((childRes) => {\n                if (childRes instanceof JSXNode) {\n                  childRes.localContexts = currentContexts;\n                }\n                return childRes;\n              })\n            );\n          }\n        } else if (res instanceof JSXNode) {\n          res.toStringToBuffer(buffer);\n        } else if (typeof res === \"number\" || res.isEscaped) {\n          buffer[0] += res;\n          if (res.callbacks) {\n            buffer.callbacks ||= [];\n            buffer.callbacks.push(...res.callbacks);\n          }\n        } else {\n          escapeToBuffer(res, buffer);\n        }\n      }\n    };\n    JSXFragmentNode = class extends JSXNode {\n      static {\n        __name(this, \"JSXFragmentNode\");\n      }\n      toStringToBuffer(buffer) {\n        childrenToStringToBuffer(this.children, buffer);\n      }\n    };\n    initDomRenderer = false;\n    jsxFn = /* @__PURE__ */ __name((tag, props, children) => {\n      if (!initDomRenderer) {\n        for (const k2 in domRenderers) {\n          intrinsicElementTags[k2][DOM_RENDERER] = domRenderers[k2];\n        }\n        initDomRenderer = true;\n      }\n      if (typeof tag === \"function\") {\n        return new JSXFunctionNode(tag, props, children);\n      } else if (intrinsicElementTags[tag]) {\n        return new JSXFunctionNode(\n          intrinsicElementTags[tag],\n          props,\n          children\n        );\n      } else if (tag === \"svg\" || tag === \"head\") {\n        nameSpaceContext$1 ||= createContext(\"\");\n        return new JSXNode(tag, props, [\n          new JSXFunctionNode(\n            nameSpaceContext$1,\n            {\n              value: tag\n            },\n            children\n          )\n        ]);\n      } else {\n        return new JSXNode(tag, props, children);\n      }\n    }, \"jsxFn\");\n    Fragment2 = /* @__PURE__ */ __name(({\n      children\n    }) => {\n      return new JSXFragmentNode(\n        \"\",\n        {\n          children\n        },\n        Array.isArray(children) ? children : children ? [children] : []\n      );\n    }, \"Fragment\");\n    HONO_PORTAL_ELEMENT = \"_hp\";\n    eventAliasMap = {\n      Change: \"Input\",\n      DoubleClick: \"DblClick\"\n    };\n    nameSpaceMap = {\n      svg: \"2000/svg\",\n      math: \"1998/Math/MathML\"\n    };\n    buildDataStack = [];\n    refCleanupMap = /* @__PURE__ */ new WeakMap();\n    nameSpaceContext = void 0;\n    getNameSpaceContext = /* @__PURE__ */ __name(() => nameSpaceContext, \"getNameSpaceContext\");\n    isNodeString = /* @__PURE__ */ __name((node) => \"t\" in node, \"isNodeString\");\n    eventCache = {\n      onClick: [\"click\", false]\n    };\n    getEventSpec = /* @__PURE__ */ __name((key) => {\n      if (!key.startsWith(\"on\")) {\n        return void 0;\n      }\n      if (eventCache[key]) {\n        return eventCache[key];\n      }\n      const match = key.match(/^on([A-Z][a-zA-Z]+?(?:PointerCapture)?)(Capture)?$/);\n      if (match) {\n        const [, eventName, capture] = match;\n        return eventCache[key] = [(eventAliasMap[eventName] || eventName).toLowerCase(), !!capture];\n      }\n      return void 0;\n    }, \"getEventSpec\");\n    toAttributeName = /* @__PURE__ */ __name((element, key) => nameSpaceContext && element instanceof SVGElement && /[A-Z]/.test(key) && (key in element.style || key.match(/^(?:o|pai|str|u|ve)/)) ? key.replace(/([A-Z])/g, \"-$1\").toLowerCase() : key, \"toAttributeName\");\n    applyProps = /* @__PURE__ */ __name((container, attributes, oldAttributes) => {\n      attributes ||= {};\n      for (let key in attributes) {\n        const value2 = attributes[key];\n        if (key !== \"children\" && (!oldAttributes || oldAttributes[key] !== value2)) {\n          key = normalizeIntrinsicElementKey(key);\n          const eventSpec = getEventSpec(key);\n          if (eventSpec) {\n            if (oldAttributes?.[key] !== value2) {\n              if (oldAttributes) {\n                container.removeEventListener(eventSpec[0], oldAttributes[key], eventSpec[1]);\n              }\n              if (value2 != null) {\n                if (typeof value2 !== \"function\") {\n                  throw new Error(`Event handler for \"${key}\" is not a function`);\n                }\n                container.addEventListener(eventSpec[0], value2, eventSpec[1]);\n              }\n            }\n          } else if (key === \"dangerouslySetInnerHTML\" && value2) {\n            container.innerHTML = value2.__html;\n          } else if (key === \"ref\") {\n            let cleanup;\n            if (typeof value2 === \"function\") {\n              cleanup = value2(container) || (() => value2(null));\n            } else if (value2 && \"current\" in value2) {\n              value2.current = container;\n              cleanup = /* @__PURE__ */ __name(() => value2.current = null, \"cleanup\");\n            }\n            refCleanupMap.set(container, cleanup);\n          } else if (key === \"style\") {\n            const style2 = container.style;\n            if (typeof value2 === \"string\") {\n              style2.cssText = value2;\n            } else {\n              style2.cssText = \"\";\n              if (value2 != null) {\n                styleObjectForEach(value2, style2.setProperty.bind(style2));\n              }\n            }\n          } else {\n            if (key === \"value\") {\n              const nodeName = container.nodeName;\n              if (nodeName === \"INPUT\" || nodeName === \"TEXTAREA\" || nodeName === \"SELECT\") {\n                container.value = value2 === null || value2 === void 0 || value2 === false ? null : value2;\n                if (nodeName === \"TEXTAREA\") {\n                  container.textContent = value2;\n                  continue;\n                } else if (nodeName === \"SELECT\") {\n                  if (container.selectedIndex === -1) {\n                    container.selectedIndex = 0;\n                  }\n                  continue;\n                }\n              }\n            } else if (key === \"checked\" && container.nodeName === \"INPUT\" || key === \"selected\" && container.nodeName === \"OPTION\") {\n              container[key] = value2;\n            }\n            const k2 = toAttributeName(container, key);\n            if (value2 === null || value2 === void 0 || value2 === false) {\n              container.removeAttribute(k2);\n            } else if (value2 === true) {\n              container.setAttribute(k2, \"\");\n            } else if (typeof value2 === \"string\" || typeof value2 === \"number\") {\n              container.setAttribute(k2, value2);\n            } else {\n              container.setAttribute(k2, value2.toString());\n            }\n          }\n        }\n      }\n      if (oldAttributes) {\n        for (let key in oldAttributes) {\n          const value2 = oldAttributes[key];\n          if (key !== \"children\" && !(key in attributes)) {\n            key = normalizeIntrinsicElementKey(key);\n            const eventSpec = getEventSpec(key);\n            if (eventSpec) {\n              container.removeEventListener(eventSpec[0], value2, eventSpec[1]);\n            } else if (key === \"ref\") {\n              refCleanupMap.get(container)?.();\n            } else {\n              container.removeAttribute(toAttributeName(container, key));\n            }\n          }\n        }\n      }\n    }, \"applyProps\");\n    invokeTag = /* @__PURE__ */ __name((context2, node) => {\n      node[DOM_STASH][0] = 0;\n      buildDataStack.push([context2, node]);\n      const func = node.tag[DOM_RENDERER] || node.tag;\n      const props = func.defaultProps ? {\n        ...func.defaultProps,\n        ...node.props\n      } : node.props;\n      try {\n        return [func.call(null, props)];\n      } finally {\n        buildDataStack.pop();\n      }\n    }, \"invokeTag\");\n    getNextChildren = /* @__PURE__ */ __name((node, container, nextChildren, childrenToRemove, callbacks) => {\n      if (node.vR?.length) {\n        childrenToRemove.push(...node.vR);\n        delete node.vR;\n      }\n      if (typeof node.tag === \"function\") {\n        node[DOM_STASH][1][STASH_EFFECT]?.forEach((data) => callbacks.push(data));\n      }\n      node.vC.forEach((child) => {\n        if (isNodeString(child)) {\n          nextChildren.push(child);\n        } else {\n          if (typeof child.tag === \"function\" || child.tag === \"\") {\n            child.c = container;\n            const currentNextChildrenIndex = nextChildren.length;\n            getNextChildren(child, container, nextChildren, childrenToRemove, callbacks);\n            if (child.s) {\n              for (let i = currentNextChildrenIndex; i < nextChildren.length; i++) {\n                nextChildren[i].s = true;\n              }\n              child.s = false;\n            }\n          } else {\n            nextChildren.push(child);\n            if (child.vR?.length) {\n              childrenToRemove.push(...child.vR);\n              delete child.vR;\n            }\n          }\n        }\n      });\n    }, \"getNextChildren\");\n    findInsertBefore = /* @__PURE__ */ __name((node) => {\n      for (; ; node = node.tag === HONO_PORTAL_ELEMENT || !node.vC || !node.pP ? node.nN : node.vC[0]) {\n        if (!node) {\n          return null;\n        }\n        if (node.tag !== HONO_PORTAL_ELEMENT && node.e) {\n          return node.e;\n        }\n      }\n    }, \"findInsertBefore\");\n    removeNode = /* @__PURE__ */ __name((node) => {\n      if (!isNodeString(node)) {\n        node[DOM_STASH]?.[1][STASH_EFFECT]?.forEach((data) => data[2]?.());\n        refCleanupMap.get(node.e)?.();\n        if (node.p === 2) {\n          node.vC?.forEach((n27) => n27.p = 2);\n        }\n        node.vC?.forEach(removeNode);\n      }\n      if (!node.p) {\n        node.e?.remove();\n        delete node.e;\n      }\n      if (typeof node.tag === \"function\") {\n        updateMap.delete(node);\n        fallbackUpdateFnArrayMap.delete(node);\n        delete node[DOM_STASH][3];\n        node.a = true;\n      }\n    }, \"removeNode\");\n    apply = /* @__PURE__ */ __name((node, container, isNew) => {\n      node.c = container;\n      applyNodeObject(node, container, isNew);\n    }, \"apply\");\n    findChildNodeIndex = /* @__PURE__ */ __name((childNodes, child) => {\n      if (!child) {\n        return;\n      }\n      for (let i = 0, len = childNodes.length; i < len; i++) {\n        if (childNodes[i] === child) {\n          return i;\n        }\n      }\n      return;\n    }, \"findChildNodeIndex\");\n    cancelBuild = Symbol();\n    applyNodeObject = /* @__PURE__ */ __name((node, container, isNew) => {\n      const next = [];\n      const remove = [];\n      const callbacks = [];\n      getNextChildren(node, container, next, remove, callbacks);\n      remove.forEach(removeNode);\n      const childNodes = isNew ? void 0 : container.childNodes;\n      let offset;\n      let insertBeforeNode = null;\n      if (isNew) {\n        offset = -1;\n      } else if (!childNodes.length) {\n        offset = 0;\n      } else {\n        const offsetByNextNode = findChildNodeIndex(childNodes, findInsertBefore(node.nN));\n        if (offsetByNextNode !== void 0) {\n          insertBeforeNode = childNodes[offsetByNextNode];\n          offset = offsetByNextNode;\n        } else {\n          offset = findChildNodeIndex(childNodes, next.find((n27) => n27.tag !== HONO_PORTAL_ELEMENT && n27.e)?.e) ?? -1;\n        }\n        if (offset === -1) {\n          isNew = true;\n        }\n      }\n      for (let i = 0, len = next.length; i < len; i++, offset++) {\n        const child = next[i];\n        let el2;\n        if (child.s && child.e) {\n          el2 = child.e;\n          child.s = false;\n        } else {\n          const isNewLocal = isNew || !child.e;\n          if (isNodeString(child)) {\n            if (child.e && child.d) {\n              child.e.textContent = child.t;\n            }\n            child.d = false;\n            el2 = child.e ||= document.createTextNode(child.t);\n          } else {\n            el2 = child.e ||= child.n ? document.createElementNS(child.n, child.tag) : document.createElement(child.tag);\n            applyProps(el2, child.props, child.pP);\n            applyNodeObject(child, el2, isNewLocal);\n          }\n        }\n        if (child.tag === HONO_PORTAL_ELEMENT) {\n          offset--;\n        } else if (isNew) {\n          if (!el2.parentNode) {\n            container.appendChild(el2);\n          }\n        } else if (childNodes[offset] !== el2 && childNodes[offset - 1] !== el2) {\n          if (childNodes[offset + 1] === el2) {\n            container.appendChild(childNodes[offset]);\n          } else {\n            container.insertBefore(el2, insertBeforeNode || childNodes[offset] || null);\n          }\n        }\n      }\n      if (node.pP) {\n        delete node.pP;\n      }\n      if (callbacks.length) {\n        const useLayoutEffectCbs = [];\n        const useEffectCbs = [];\n        callbacks.forEach(([, useLayoutEffectCb, , useEffectCb, useInsertionEffectCb]) => {\n          if (useLayoutEffectCb) {\n            useLayoutEffectCbs.push(useLayoutEffectCb);\n          }\n          if (useEffectCb) {\n            useEffectCbs.push(useEffectCb);\n          }\n          useInsertionEffectCb?.();\n        });\n        useLayoutEffectCbs.forEach((cb) => cb());\n        if (useEffectCbs.length) {\n          requestAnimationFrame(() => {\n            useEffectCbs.forEach((cb) => cb());\n          });\n        }\n      }\n    }, \"applyNodeObject\");\n    isSameContext = /* @__PURE__ */ __name((oldContexts, newContexts) => !!(oldContexts && oldContexts.length === newContexts.length && oldContexts.every((ctx, i) => ctx[1] === newContexts[i][1])), \"isSameContext\");\n    fallbackUpdateFnArrayMap = /* @__PURE__ */ new WeakMap();\n    build = /* @__PURE__ */ __name((context2, node, children) => {\n      const buildWithPreviousChildren = !children && node.pC;\n      if (children) {\n        node.pC ||= node.vC;\n      }\n      let foundErrorHandler;\n      try {\n        children ||= typeof node.tag == \"function\" ? invokeTag(context2, node) : toArray(node.props.children);\n        if (children[0]?.tag === \"\" && children[0][DOM_ERROR_HANDLER]) {\n          foundErrorHandler = children[0][DOM_ERROR_HANDLER];\n          context2[5].push([context2, foundErrorHandler, node]);\n        }\n        const oldVChildren = buildWithPreviousChildren ? [...node.pC] : node.vC ? [...node.vC] : void 0;\n        const vChildren = [];\n        let prevNode;\n        for (let i = 0; i < children.length; i++) {\n          if (Array.isArray(children[i])) {\n            children.splice(i, 1, ...children[i].flat());\n          }\n          let child = buildNode(children[i]);\n          if (child) {\n            if (typeof child.tag === \"function\" && !child.tag[DOM_INTERNAL_TAG]) {\n              if (globalContexts.length > 0) {\n                child[DOM_STASH][2] = globalContexts.map((c) => [c, c.values.at(-1)]);\n              }\n              if (context2[5]?.length) {\n                child[DOM_STASH][3] = context2[5].at(-1);\n              }\n            }\n            let oldChild;\n            if (oldVChildren && oldVChildren.length) {\n              const i2 = oldVChildren.findIndex(\n                isNodeString(child) ? (c) => isNodeString(c) : child.key !== void 0 ? (c) => c.key === child.key && c.tag === child.tag : (c) => c.tag === child.tag\n              );\n              if (i2 !== -1) {\n                oldChild = oldVChildren[i2];\n                oldVChildren.splice(i2, 1);\n              }\n            }\n            if (oldChild) {\n              if (isNodeString(child)) {\n                if (oldChild.t !== child.t) {\n                  ;\n                  oldChild.t = child.t;\n                  oldChild.d = true;\n                }\n                child = oldChild;\n              } else {\n                const pP = oldChild.pP = oldChild.props;\n                oldChild.props = child.props;\n                oldChild.f ||= child.f || node.f;\n                if (typeof child.tag === \"function\") {\n                  const oldContexts = oldChild[DOM_STASH][2];\n                  oldChild[DOM_STASH][2] = child[DOM_STASH][2] || [];\n                  oldChild[DOM_STASH][3] = child[DOM_STASH][3];\n                  if (!oldChild.f && ((oldChild.o || oldChild) === child.o || oldChild.tag[DOM_MEMO]?.(pP, oldChild.props)) && isSameContext(oldContexts, oldChild[DOM_STASH][2])) {\n                    oldChild.s = true;\n                  }\n                }\n                child = oldChild;\n              }\n            } else if (!isNodeString(child) && nameSpaceContext) {\n              const ns2 = useContext(nameSpaceContext);\n              if (ns2) {\n                child.n = ns2;\n              }\n            }\n            if (!isNodeString(child) && !child.s) {\n              build(context2, child);\n              delete child.f;\n            }\n            vChildren.push(child);\n            if (prevNode && !prevNode.s && !child.s) {\n              for (let p2 = prevNode; p2 && !isNodeString(p2); p2 = p2.vC?.at(-1)) {\n                p2.nN = child;\n              }\n            }\n            prevNode = child;\n          }\n        }\n        node.vR = buildWithPreviousChildren ? [...node.vC, ...oldVChildren || []] : oldVChildren || [];\n        node.vC = vChildren;\n        if (buildWithPreviousChildren) {\n          delete node.pC;\n        }\n      } catch (e) {\n        node.f = true;\n        if (e === cancelBuild) {\n          if (foundErrorHandler) {\n            return;\n          } else {\n            throw e;\n          }\n        }\n        const [errorHandlerContext, errorHandler2, errorHandlerNode] = node[DOM_STASH]?.[3] || [];\n        if (errorHandler2) {\n          const fallbackUpdateFn = /* @__PURE__ */ __name(() => update([0, false, context2[2]], errorHandlerNode), \"fallbackUpdateFn\");\n          const fallbackUpdateFnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode) || [];\n          fallbackUpdateFnArray.push(fallbackUpdateFn);\n          fallbackUpdateFnArrayMap.set(errorHandlerNode, fallbackUpdateFnArray);\n          const fallback = errorHandler2(e, () => {\n            const fnArray = fallbackUpdateFnArrayMap.get(errorHandlerNode);\n            if (fnArray) {\n              const i = fnArray.indexOf(fallbackUpdateFn);\n              if (i !== -1) {\n                fnArray.splice(i, 1);\n                return fallbackUpdateFn();\n              }\n            }\n          });\n          if (fallback) {\n            if (context2[0] === 1) {\n              context2[1] = true;\n            } else {\n              build(context2, errorHandlerNode, [fallback]);\n              if ((errorHandler2.length === 1 || context2 !== errorHandlerContext) && errorHandlerNode.c) {\n                apply(errorHandlerNode, errorHandlerNode.c, false);\n                return;\n              }\n            }\n            throw cancelBuild;\n          }\n        }\n        throw e;\n      } finally {\n        if (foundErrorHandler) {\n          context2[5].pop();\n        }\n      }\n    }, \"build\");\n    buildNode = /* @__PURE__ */ __name((node) => {\n      if (node === void 0 || node === null || typeof node === \"boolean\") {\n        return void 0;\n      } else if (typeof node === \"string\" || typeof node === \"number\") {\n        return { t: node.toString(), d: true };\n      } else {\n        if (\"vR\" in node) {\n          node = {\n            tag: node.tag,\n            props: node.props,\n            key: node.key,\n            f: node.f,\n            type: node.tag,\n            ref: node.props.ref,\n            o: node.o || node\n          };\n        }\n        if (typeof node.tag === \"function\") {\n          node[DOM_STASH] = [0, []];\n        } else {\n          const ns2 = nameSpaceMap[node.tag];\n          if (ns2) {\n            nameSpaceContext ||= createContext$1(\"\");\n            node.props.children = [\n              {\n                tag: nameSpaceContext,\n                props: {\n                  value: node.n = `http://www.w3.org/${ns2}`,\n                  children: node.props.children\n                }\n              }\n            ];\n          }\n        }\n        return node;\n      }\n    }, \"buildNode\");\n    updateSync = /* @__PURE__ */ __name((context2, node) => {\n      node[DOM_STASH][2]?.forEach(([c, v3]) => {\n        c.values.push(v3);\n      });\n      try {\n        build(context2, node, void 0);\n      } catch {\n        return;\n      }\n      if (node.a) {\n        delete node.a;\n        return;\n      }\n      node[DOM_STASH][2]?.forEach(([c]) => {\n        c.values.pop();\n      });\n      if (context2[0] !== 1 || !context2[1]) {\n        apply(node, node.c, false);\n      }\n    }, \"updateSync\");\n    updateMap = /* @__PURE__ */ new WeakMap();\n    currentUpdateSets = [];\n    update = /* @__PURE__ */ __name(async (context2, node) => {\n      context2[5] ||= [];\n      const existing = updateMap.get(node);\n      if (existing) {\n        existing[0](void 0);\n      }\n      let resolve;\n      const promise = new Promise((r2) => resolve = r2);\n      updateMap.set(node, [\n        resolve,\n        () => {\n          if (context2[2]) {\n            context2[2](context2, node, (context22) => {\n              updateSync(context22, node);\n            }).then(() => resolve(node));\n          } else {\n            updateSync(context2, node);\n            resolve(node);\n          }\n        }\n      ]);\n      if (currentUpdateSets.length) {\n        currentUpdateSets.at(-1).add(node);\n      } else {\n        await Promise.resolve();\n        const latest = updateMap.get(node);\n        if (latest) {\n          updateMap.delete(node);\n          latest[1]();\n        }\n      }\n      return promise;\n    }, \"update\");\n    createPortal = /* @__PURE__ */ __name((children, container, key) => ({\n      tag: HONO_PORTAL_ELEMENT,\n      props: {\n        children\n      },\n      key,\n      e: container,\n      p: 1\n    }), \"createPortal\");\n    STASH_SATE = 0;\n    STASH_EFFECT = 1;\n    STASH_CALLBACK = 2;\n    STASH_MEMO = 3;\n    resolvedPromiseValueMap = /* @__PURE__ */ new WeakMap();\n    isDepsChanged = /* @__PURE__ */ __name((prevDeps, deps) => !prevDeps || !deps || prevDeps.length !== deps.length || deps.some((dep, i) => dep !== prevDeps[i]), \"isDepsChanged\");\n    updateHook = void 0;\n    pendingStack = [];\n    useState = /* @__PURE__ */ __name((initialState) => {\n      const resolveInitialState = /* @__PURE__ */ __name(() => typeof initialState === \"function\" ? initialState() : initialState, \"resolveInitialState\");\n      const buildData = buildDataStack.at(-1);\n      if (!buildData) {\n        return [resolveInitialState(), () => {\n        }];\n      }\n      const [, node] = buildData;\n      const stateArray = node[DOM_STASH][1][STASH_SATE] ||= [];\n      const hookIndex = node[DOM_STASH][0]++;\n      return stateArray[hookIndex] ||= [\n        resolveInitialState(),\n        (newState) => {\n          const localUpdateHook = updateHook;\n          const stateData = stateArray[hookIndex];\n          if (typeof newState === \"function\") {\n            newState = newState(stateData[0]);\n          }\n          if (!Object.is(newState, stateData[0])) {\n            stateData[0] = newState;\n            if (pendingStack.length) {\n              const [pendingType, pendingPromise] = pendingStack.at(-1);\n              Promise.all([\n                pendingType === 3 ? node : update([pendingType, false, localUpdateHook], node),\n                pendingPromise\n              ]).then(([node2]) => {\n                if (!node2 || !(pendingType === 2 || pendingType === 3)) {\n                  return;\n                }\n                const lastVC = node2.vC;\n                const addUpdateTask = /* @__PURE__ */ __name(() => {\n                  setTimeout(() => {\n                    if (lastVC !== node2.vC) {\n                      return;\n                    }\n                    update([pendingType === 3 ? 1 : 0, false, localUpdateHook], node2);\n                  });\n                }, \"addUpdateTask\");\n                requestAnimationFrame(addUpdateTask);\n              });\n            } else {\n              update([0, false, localUpdateHook], node);\n            }\n          }\n        }\n      ];\n    }, \"useState\");\n    useCallback = /* @__PURE__ */ __name((callback, deps) => {\n      const buildData = buildDataStack.at(-1);\n      if (!buildData) {\n        return callback;\n      }\n      const [, node] = buildData;\n      const callbackArray = node[DOM_STASH][1][STASH_CALLBACK] ||= [];\n      const hookIndex = node[DOM_STASH][0]++;\n      const prevDeps = callbackArray[hookIndex];\n      if (isDepsChanged(prevDeps?.[1], deps)) {\n        callbackArray[hookIndex] = [callback, deps];\n      } else {\n        callback = callbackArray[hookIndex][0];\n      }\n      return callback;\n    }, \"useCallback\");\n    use = /* @__PURE__ */ __name((promise) => {\n      const cachedRes = resolvedPromiseValueMap.get(promise);\n      if (cachedRes) {\n        if (cachedRes.length === 2) {\n          throw cachedRes[1];\n        }\n        return cachedRes[0];\n      }\n      promise.then(\n        (res) => resolvedPromiseValueMap.set(promise, [res]),\n        (e) => resolvedPromiseValueMap.set(promise, [void 0, e])\n      );\n      throw promise;\n    }, \"use\");\n    useMemo = /* @__PURE__ */ __name((factory, deps) => {\n      const buildData = buildDataStack.at(-1);\n      if (!buildData) {\n        return factory();\n      }\n      const [, node] = buildData;\n      const memoArray = node[DOM_STASH][1][STASH_MEMO] ||= [];\n      const hookIndex = node[DOM_STASH][0]++;\n      const prevDeps = memoArray[hookIndex];\n      if (isDepsChanged(prevDeps?.[1], deps)) {\n        memoArray[hookIndex] = [factory(), deps];\n      }\n      return memoArray[hookIndex][0];\n    }, \"useMemo\");\n    FormContext = createContext$1({\n      pending: false,\n      data: null,\n      method: null,\n      action: null\n    });\n    actions = /* @__PURE__ */ new Set();\n    registerAction = /* @__PURE__ */ __name((action) => {\n      actions.add(action);\n      action.finally(() => actions.delete(action));\n    }, \"registerAction\");\n    composeRef = /* @__PURE__ */ __name((ref, cb) => {\n      return useMemo(\n        () => (e) => {\n          let refCleanup;\n          if (ref) {\n            if (typeof ref === \"function\") {\n              refCleanup = ref(e) || (() => {\n                ref(null);\n              });\n            } else if (ref && \"current\" in ref) {\n              ref.current = e;\n              refCleanup = /* @__PURE__ */ __name(() => {\n                ref.current = null;\n              }, \"refCleanup\");\n            }\n          }\n          const cbCleanup = cb(e);\n          return () => {\n            cbCleanup?.();\n            refCleanup?.();\n          };\n        },\n        [ref]\n      );\n    }, \"composeRef\");\n    blockingPromiseMap = /* @__PURE__ */ Object.create(null);\n    createdElements = /* @__PURE__ */ Object.create(null);\n    documentMetadataTag = /* @__PURE__ */ __name((tag, props, preserveNodeType, supportSort, supportBlocking) => {\n      if (props?.itemProp) {\n        return {\n          tag,\n          props,\n          type: tag,\n          ref: props.ref\n        };\n      }\n      const head = document.head;\n      let { onLoad, onError, precedence, blocking, ...restProps } = props;\n      let element = null;\n      let created = false;\n      const deDupeKeys = deDupeKeyMap[tag];\n      let existingElements = void 0;\n      if (deDupeKeys.length > 0) {\n        const tags = head.querySelectorAll(tag);\n        LOOP:\n          for (const e of tags) {\n            for (const key of deDupeKeyMap[tag]) {\n              if (e.getAttribute(key) === props[key]) {\n                element = e;\n                break LOOP;\n              }\n            }\n          }\n        if (!element) {\n          const cacheKey2 = deDupeKeys.reduce(\n            (acc, key) => props[key] === void 0 ? acc : `${acc}-${key}-${props[key]}`,\n            tag\n          );\n          created = !createdElements[cacheKey2];\n          element = createdElements[cacheKey2] ||= (() => {\n            const e = document.createElement(tag);\n            for (const key of deDupeKeys) {\n              if (props[key] !== void 0) {\n                e.setAttribute(key, props[key]);\n              }\n              if (props.rel) {\n                e.setAttribute(\"rel\", props.rel);\n              }\n            }\n            return e;\n          })();\n        }\n      } else {\n        existingElements = head.querySelectorAll(tag);\n      }\n      precedence = supportSort ? precedence ?? \"\" : void 0;\n      if (supportSort) {\n        restProps[dataPrecedenceAttr] = precedence;\n      }\n      const insert = useCallback(\n        (e) => {\n          if (deDupeKeys.length > 0) {\n            let found = false;\n            for (const existingElement of head.querySelectorAll(tag)) {\n              if (found && existingElement.getAttribute(dataPrecedenceAttr) !== precedence) {\n                head.insertBefore(e, existingElement);\n                return;\n              }\n              if (existingElement.getAttribute(dataPrecedenceAttr) === precedence) {\n                found = true;\n              }\n            }\n            head.appendChild(e);\n          } else if (existingElements) {\n            let found = false;\n            for (const existingElement of existingElements) {\n              if (existingElement === e) {\n                found = true;\n                break;\n              }\n            }\n            if (!found) {\n              head.insertBefore(\n                e,\n                head.contains(existingElements[0]) ? existingElements[0] : head.querySelector(tag)\n              );\n            }\n            existingElements = void 0;\n          }\n        },\n        [precedence]\n      );\n      const ref = composeRef(props.ref, (e) => {\n        const key = deDupeKeys[0];\n        if (preserveNodeType === 2) {\n          e.innerHTML = \"\";\n        }\n        if (created || existingElements) {\n          insert(e);\n        }\n        if (!onError && !onLoad) {\n          return;\n        }\n        let promise = blockingPromiseMap[e.getAttribute(key)] ||= new Promise(\n          (resolve, reject) => {\n            e.addEventListener(\"load\", resolve);\n            e.addEventListener(\"error\", reject);\n          }\n        );\n        if (onLoad) {\n          promise = promise.then(onLoad);\n        }\n        if (onError) {\n          promise = promise.catch(onError);\n        }\n        promise.catch(() => {\n        });\n      });\n      if (supportBlocking && blocking === \"render\") {\n        const key = deDupeKeyMap[tag][0];\n        if (props[key]) {\n          const value2 = props[key];\n          const promise = blockingPromiseMap[value2] ||= new Promise((resolve, reject) => {\n            insert(element);\n            element.addEventListener(\"load\", resolve);\n            element.addEventListener(\"error\", reject);\n          });\n          use(promise);\n        }\n      }\n      const jsxNode = {\n        tag,\n        type: tag,\n        props: {\n          ...restProps,\n          ref\n        },\n        ref\n      };\n      jsxNode.p = preserveNodeType;\n      if (element) {\n        jsxNode.e = element;\n      }\n      return createPortal(\n        jsxNode,\n        head\n      );\n    }, \"documentMetadataTag\");\n    title2 = /* @__PURE__ */ __name((props) => {\n      const nameSpaceContext2 = getNameSpaceContext();\n      const ns2 = nameSpaceContext2 && useContext(nameSpaceContext2);\n      if (ns2?.endsWith(\"svg\")) {\n        return {\n          tag: \"title\",\n          props,\n          type: \"title\",\n          ref: props.ref\n        };\n      }\n      return documentMetadataTag(\"title\", props, void 0, false, false);\n    }, \"title\");\n    script = /* @__PURE__ */ __name((props) => {\n      if (!props || [\"src\", \"async\"].some((k2) => !props[k2])) {\n        return {\n          tag: \"script\",\n          props,\n          type: \"script\",\n          ref: props.ref\n        };\n      }\n      return documentMetadataTag(\"script\", props, 1, false, true);\n    }, \"script\");\n    style = /* @__PURE__ */ __name((props) => {\n      if (!props || ![\"href\", \"precedence\"].every((k2) => k2 in props)) {\n        return {\n          tag: \"style\",\n          props,\n          type: \"style\",\n          ref: props.ref\n        };\n      }\n      props[\"data-href\"] = props.href;\n      delete props.href;\n      return documentMetadataTag(\"style\", props, 2, true, true);\n    }, \"style\");\n    link = /* @__PURE__ */ __name((props) => {\n      if (!props || [\"onLoad\", \"onError\"].some((k2) => k2 in props) || props.rel === \"stylesheet\" && (!(\"precedence\" in props) || \"disabled\" in props)) {\n        return {\n          tag: \"link\",\n          props,\n          type: \"link\",\n          ref: props.ref\n        };\n      }\n      return documentMetadataTag(\"link\", props, 1, \"precedence\" in props, true);\n    }, \"link\");\n    meta = /* @__PURE__ */ __name((props) => {\n      return documentMetadataTag(\"meta\", props, void 0, false, false);\n    }, \"meta\");\n    customEventFormAction = Symbol();\n    form = /* @__PURE__ */ __name((props) => {\n      const { action, ...restProps } = props;\n      if (typeof action !== \"function\") {\n        restProps.action = action;\n      }\n      const [state, setState] = useState([null, false]);\n      const onSubmit = useCallback(\n        async (ev) => {\n          const currentAction = ev.isTrusted ? action : ev.detail[customEventFormAction];\n          if (typeof currentAction !== \"function\") {\n            return;\n          }\n          ev.preventDefault();\n          const formData = new FormData(ev.target);\n          setState([formData, true]);\n          const actionRes = currentAction(formData);\n          if (actionRes instanceof Promise) {\n            registerAction(actionRes);\n            await actionRes;\n          }\n          setState([null, true]);\n        },\n        []\n      );\n      const ref = composeRef(props.ref, (el2) => {\n        el2.addEventListener(\"submit\", onSubmit);\n        return () => {\n          el2.removeEventListener(\"submit\", onSubmit);\n        };\n      });\n      const [data, isDirty] = state;\n      state[1] = false;\n      return {\n        tag: FormContext,\n        props: {\n          value: {\n            pending: data !== null,\n            data,\n            method: data ? \"post\" : null,\n            action: data ? action : null\n          },\n          children: {\n            tag: \"form\",\n            props: {\n              ...restProps,\n              ref\n            },\n            type: \"form\",\n            ref\n          }\n        },\n        f: isDirty\n      };\n    }, \"form\");\n    formActionableElement = /* @__PURE__ */ __name((tag, {\n      formAction,\n      ...props\n    }) => {\n      if (typeof formAction === \"function\") {\n        const onClick = useCallback((ev) => {\n          ev.preventDefault();\n          ev.currentTarget.form.dispatchEvent(\n            new CustomEvent(\"submit\", { detail: { [customEventFormAction]: formAction } })\n          );\n        }, []);\n        props.ref = composeRef(props.ref, (el2) => {\n          el2.addEventListener(\"click\", onClick);\n          return () => {\n            el2.removeEventListener(\"click\", onClick);\n          };\n        });\n      }\n      return {\n        tag,\n        props,\n        type: tag,\n        ref: props.ref\n      };\n    }, \"formActionableElement\");\n    input = /* @__PURE__ */ __name((props) => formActionableElement(\"input\", props), \"input\");\n    button = /* @__PURE__ */ __name((props) => formActionableElement(\"button\", props), \"button\");\n    Object.assign(domRenderers, {\n      title: title2,\n      script,\n      style,\n      link,\n      meta,\n      form,\n      input,\n      button\n    });\n    new TextEncoder();\n    PSEUDO_GLOBAL_SELECTOR = \":-hono-global\";\n    isPseudoGlobalSelectorRe = new RegExp(`^${PSEUDO_GLOBAL_SELECTOR}{(.*)}$`);\n    DEFAULT_STYLE_ID = \"hono-css\";\n    SELECTOR = Symbol();\n    CLASS_NAME = Symbol();\n    STYLE_STRING = Symbol();\n    SELECTORS = Symbol();\n    EXTERNAL_CLASS_NAMES = Symbol();\n    CSS_ESCAPED = Symbol();\n    toHash = /* @__PURE__ */ __name((str) => {\n      let i = 0, out = 11;\n      while (i < str.length) {\n        out = 101 * out + str.charCodeAt(i++) >>> 0;\n      }\n      return \"css-\" + out;\n    }, \"toHash\");\n    cssStringReStr = [\n      '\"(?:(?:\\\\\\\\[\\\\s\\\\S]|[^\"\\\\\\\\])*)\"',\n      \"'(?:(?:\\\\\\\\[\\\\s\\\\S]|[^'\\\\\\\\])*)'\"\n    ].join(\"|\");\n    minifyCssRe = new RegExp(\n      [\n        \"(\" + cssStringReStr + \")\",\n        \"(?:\" + [\n          \"^\\\\s+\",\n          \"\\\\/\\\\*.*?\\\\*\\\\/\\\\s*\",\n          \"\\\\/\\\\/.*\\\\n\\\\s*\",\n          \"\\\\s+$\"\n        ].join(\"|\") + \")\",\n        \"\\\\s*;\\\\s*(}|$)\\\\s*\",\n        \"\\\\s*([{};:,])\\\\s*\",\n        \"(\\\\s)\\\\s+\"\n      ].join(\"|\"),\n      \"g\"\n    );\n    minify = /* @__PURE__ */ __name((css2) => {\n      return css2.replace(minifyCssRe, (_3, $1, $22, $3, $4) => $1 || $22 || $3 || $4 || \"\");\n    }, \"minify\");\n    buildStyleString = /* @__PURE__ */ __name((strings, values) => {\n      const selectors = [];\n      const externalClassNames = [];\n      const label = strings[0].match(/^\\s*\\/\\*(.*?)\\*\\//)?.[1] || \"\";\n      let styleString = \"\";\n      for (let i = 0, len = strings.length; i < len; i++) {\n        styleString += strings[i];\n        let vArray = values[i];\n        if (typeof vArray === \"boolean\" || vArray === null || vArray === void 0) {\n          continue;\n        }\n        if (!Array.isArray(vArray)) {\n          vArray = [vArray];\n        }\n        for (let j3 = 0, len2 = vArray.length; j3 < len2; j3++) {\n          let value2 = vArray[j3];\n          if (typeof value2 === \"boolean\" || value2 === null || value2 === void 0) {\n            continue;\n          }\n          if (typeof value2 === \"string\") {\n            if (/([\\\\\"'\\/])/.test(value2)) {\n              styleString += value2.replace(/([\\\\\"']|(?<=<)\\/)/g, \"\\\\$1\");\n            } else {\n              styleString += value2;\n            }\n          } else if (typeof value2 === \"number\") {\n            styleString += value2;\n          } else if (value2[CSS_ESCAPED]) {\n            styleString += value2[CSS_ESCAPED];\n          } else if (value2[CLASS_NAME].startsWith(\"@keyframes \")) {\n            selectors.push(value2);\n            styleString += ` ${value2[CLASS_NAME].substring(11)} `;\n          } else {\n            if (strings[i + 1]?.match(/^\\s*{/)) {\n              selectors.push(value2);\n              value2 = `.${value2[CLASS_NAME]}`;\n            } else {\n              selectors.push(...value2[SELECTORS]);\n              externalClassNames.push(...value2[EXTERNAL_CLASS_NAMES]);\n              value2 = value2[STYLE_STRING];\n              const valueLen = value2.length;\n              if (valueLen > 0) {\n                const lastChar = value2[valueLen - 1];\n                if (lastChar !== \";\" && lastChar !== \"}\") {\n                  value2 += \";\";\n                }\n              }\n            }\n            styleString += `${value2 || \"\"}`;\n          }\n        }\n      }\n      return [label, minify(styleString), selectors, externalClassNames];\n    }, \"buildStyleString\");\n    cssCommon = /* @__PURE__ */ __name((strings, values) => {\n      let [label, thisStyleString, selectors, externalClassNames] = buildStyleString(strings, values);\n      const isPseudoGlobal = isPseudoGlobalSelectorRe.exec(thisStyleString);\n      if (isPseudoGlobal) {\n        thisStyleString = isPseudoGlobal[1];\n      }\n      const selector = (isPseudoGlobal ? PSEUDO_GLOBAL_SELECTOR : \"\") + toHash(label + thisStyleString);\n      const className = (isPseudoGlobal ? selectors.map((s2) => s2[CLASS_NAME]) : [selector, ...externalClassNames]).join(\" \");\n      return {\n        [SELECTOR]: selector,\n        [CLASS_NAME]: className,\n        [STYLE_STRING]: thisStyleString,\n        [SELECTORS]: selectors,\n        [EXTERNAL_CLASS_NAMES]: externalClassNames\n      };\n    }, \"cssCommon\");\n    cxCommon = /* @__PURE__ */ __name((args) => {\n      for (let i = 0, len = args.length; i < len; i++) {\n        const arg = args[i];\n        if (typeof arg === \"string\") {\n          args[i] = {\n            [SELECTOR]: \"\",\n            [CLASS_NAME]: \"\",\n            [STYLE_STRING]: \"\",\n            [SELECTORS]: [],\n            [EXTERNAL_CLASS_NAMES]: [arg]\n          };\n        }\n      }\n      return args;\n    }, \"cxCommon\");\n    keyframesCommon = /* @__PURE__ */ __name((strings, ...values) => {\n      const [label, styleString] = buildStyleString(strings, values);\n      return {\n        [SELECTOR]: \"\",\n        [CLASS_NAME]: `@keyframes ${toHash(label + styleString)}`,\n        [STYLE_STRING]: styleString,\n        [SELECTORS]: [],\n        [EXTERNAL_CLASS_NAMES]: []\n      };\n    }, \"keyframesCommon\");\n    viewTransitionNameIndex = 0;\n    viewTransitionCommon = /* @__PURE__ */ __name((strings, values) => {\n      if (!strings) {\n        strings = [`/* h-v-t ${viewTransitionNameIndex++} */`];\n      }\n      const content = Array.isArray(strings) ? cssCommon(strings, values) : strings;\n      const transitionName = content[CLASS_NAME];\n      const res = cssCommon([\"view-transition-name:\", \"\"], [transitionName]);\n      content[CLASS_NAME] = PSEUDO_GLOBAL_SELECTOR + content[CLASS_NAME];\n      content[STYLE_STRING] = content[STYLE_STRING].replace(\n        /(?<=::view-transition(?:[a-z-]*)\\()(?=\\))/g,\n        transitionName\n      );\n      res[CLASS_NAME] = res[SELECTOR] = transitionName;\n      res[SELECTORS] = [...content[SELECTORS], content];\n      return res;\n    }, \"viewTransitionCommon\");\n    splitRule = /* @__PURE__ */ __name((rule) => {\n      const result = [];\n      let startPos = 0;\n      let depth = 0;\n      for (let i = 0, len = rule.length; i < len; i++) {\n        const char = rule[i];\n        if (char === \"'\" || char === '\"') {\n          const quote = char;\n          i++;\n          for (; i < len; i++) {\n            if (rule[i] === \"\\\\\") {\n              i++;\n              continue;\n            }\n            if (rule[i] === quote) {\n              break;\n            }\n          }\n          continue;\n        }\n        if (char === \"{\") {\n          depth++;\n          continue;\n        }\n        if (char === \"}\") {\n          depth--;\n          if (depth === 0) {\n            result.push(rule.slice(startPos, i + 1));\n            startPos = i + 1;\n          }\n          continue;\n        }\n      }\n      return result;\n    }, \"splitRule\");\n    createCssJsxDomObjects = /* @__PURE__ */ __name(({ id: id2 }) => {\n      let styleSheet = void 0;\n      const findStyleSheet = /* @__PURE__ */ __name(() => {\n        if (!styleSheet) {\n          styleSheet = document.querySelector(`style#${id2}`)?.sheet;\n          if (styleSheet) {\n            styleSheet.addedStyles = /* @__PURE__ */ new Set();\n          }\n        }\n        return styleSheet ? [styleSheet, styleSheet.addedStyles] : [];\n      }, \"findStyleSheet\");\n      const insertRule = /* @__PURE__ */ __name((className, styleString) => {\n        const [sheet, addedStyles] = findStyleSheet();\n        if (!sheet || !addedStyles) {\n          Promise.resolve().then(() => {\n            if (!findStyleSheet()[0]) {\n              throw new Error(\"style sheet not found\");\n            }\n            insertRule(className, styleString);\n          });\n          return;\n        }\n        if (!addedStyles.has(className)) {\n          addedStyles.add(className);\n          (className.startsWith(PSEUDO_GLOBAL_SELECTOR) ? splitRule(styleString) : [`${className[0] === \"@\" ? \"\" : \".\"}${className}{${styleString}}`]).forEach((rule) => {\n            sheet.insertRule(rule, sheet.cssRules.length);\n          });\n        }\n      }, \"insertRule\");\n      const cssObject = {\n        toString() {\n          const selector = this[SELECTOR];\n          insertRule(selector, this[STYLE_STRING]);\n          this[SELECTORS].forEach(({ [CLASS_NAME]: className, [STYLE_STRING]: styleString }) => {\n            insertRule(className, styleString);\n          });\n          return this[CLASS_NAME];\n        }\n      };\n      const Style2 = /* @__PURE__ */ __name(({ children, nonce }) => ({\n        tag: \"style\",\n        props: {\n          id: id2,\n          nonce,\n          children: children && (Array.isArray(children) ? children : [children]).map(\n            (c) => c[STYLE_STRING]\n          )\n        }\n      }), \"Style2\");\n      return [cssObject, Style2];\n    }, \"createCssJsxDomObjects\");\n    createCssContext = /* @__PURE__ */ __name(({ id: id2 }) => {\n      const [cssJsxDomObject, StyleRenderToDom] = createCssJsxDomObjects({ id: id2 });\n      const contextMap = /* @__PURE__ */ new WeakMap();\n      const nonceMap = /* @__PURE__ */ new WeakMap();\n      const replaceStyleRe = new RegExp(`(<style id=\"${id2}\"(?: nonce=\"[^\"]*\")?>.*?)(</style>)`);\n      const newCssClassNameObject = /* @__PURE__ */ __name((cssClassName) => {\n        const appendStyle = /* @__PURE__ */ __name(({ buffer, context: context2 }) => {\n          const [toAdd, added] = contextMap.get(context2);\n          const names = Object.keys(toAdd);\n          if (!names.length) {\n            return;\n          }\n          let stylesStr = \"\";\n          names.forEach((className2) => {\n            added[className2] = true;\n            stylesStr += className2.startsWith(PSEUDO_GLOBAL_SELECTOR) ? toAdd[className2] : `${className2[0] === \"@\" ? \"\" : \".\"}${className2}{${toAdd[className2]}}`;\n          });\n          contextMap.set(context2, [{}, added]);\n          if (buffer && replaceStyleRe.test(buffer[0])) {\n            buffer[0] = buffer[0].replace(replaceStyleRe, (_3, pre, post) => `${pre}${stylesStr}${post}`);\n            return;\n          }\n          const nonce = nonceMap.get(context2);\n          const appendStyleScript = `<script${nonce ? ` nonce=\"${nonce}\"` : \"\"}>document.querySelector('#${id2}').textContent+=${JSON.stringify(stylesStr)}</script>`;\n          if (buffer) {\n            buffer[0] = `${appendStyleScript}${buffer[0]}`;\n            return;\n          }\n          return Promise.resolve(appendStyleScript);\n        }, \"appendStyle\");\n        const addClassNameToContext = /* @__PURE__ */ __name(({ context: context2 }) => {\n          if (!contextMap.has(context2)) {\n            contextMap.set(context2, [{}, {}]);\n          }\n          const [toAdd, added] = contextMap.get(context2);\n          let allAdded = true;\n          if (!added[cssClassName[SELECTOR]]) {\n            allAdded = false;\n            toAdd[cssClassName[SELECTOR]] = cssClassName[STYLE_STRING];\n          }\n          cssClassName[SELECTORS].forEach(\n            ({ [CLASS_NAME]: className2, [STYLE_STRING]: styleString }) => {\n              if (!added[className2]) {\n                allAdded = false;\n                toAdd[className2] = styleString;\n              }\n            }\n          );\n          if (allAdded) {\n            return;\n          }\n          return Promise.resolve(raw(\"\", [appendStyle]));\n        }, \"addClassNameToContext\");\n        const className = new String(cssClassName[CLASS_NAME]);\n        Object.assign(className, cssClassName);\n        className.isEscaped = true;\n        className.callbacks = [addClassNameToContext];\n        const promise = Promise.resolve(className);\n        Object.assign(promise, cssClassName);\n        promise.toString = cssJsxDomObject.toString;\n        return promise;\n      }, \"newCssClassNameObject\");\n      const css2 = /* @__PURE__ */ __name((strings, ...values) => {\n        return newCssClassNameObject(cssCommon(strings, values));\n      }, \"css2\");\n      const cx2 = /* @__PURE__ */ __name((...args) => {\n        args = cxCommon(args);\n        return css2(Array(args.length).fill(\"\"), ...args);\n      }, \"cx2\");\n      const keyframes2 = keyframesCommon;\n      const viewTransition2 = /* @__PURE__ */ __name((strings, ...values) => {\n        return newCssClassNameObject(viewTransitionCommon(strings, values));\n      }, \"viewTransition2\");\n      const Style2 = /* @__PURE__ */ __name(({ children, nonce } = {}) => raw(\n        `<style id=\"${id2}\"${nonce ? ` nonce=\"${nonce}\"` : \"\"}>${children ? children[STYLE_STRING] : \"\"}</style>`,\n        [\n          ({ context: context2 }) => {\n            nonceMap.set(context2, nonce);\n            return void 0;\n          }\n        ]\n      ), \"Style2\");\n      Style2[DOM_RENDERER] = StyleRenderToDom;\n      return {\n        css: css2,\n        cx: cx2,\n        keyframes: keyframes2,\n        viewTransition: viewTransition2,\n        Style: Style2\n      };\n    }, \"createCssContext\");\n    defaultContext = createCssContext({\n      id: DEFAULT_STYLE_ID\n    });\n    css = defaultContext.css;\n    Style = defaultContext.Style;\n    __name(jsxDEV, \"jsxDEV\");\n    RENDER_TYPE = {\n      STRING_ARRAY: \"string_array\",\n      STRING: \"string\",\n      JSON_STRING: \"json_string\",\n      RAW: \"raw\"\n    };\n    RENDER_TYPE_MAP = {\n      configUrl: RENDER_TYPE.STRING,\n      deepLinking: RENDER_TYPE.RAW,\n      presets: RENDER_TYPE.STRING_ARRAY,\n      plugins: RENDER_TYPE.STRING_ARRAY,\n      spec: RENDER_TYPE.JSON_STRING,\n      url: RENDER_TYPE.STRING,\n      urls: RENDER_TYPE.JSON_STRING,\n      layout: RENDER_TYPE.STRING,\n      docExpansion: RENDER_TYPE.STRING,\n      maxDisplayedTags: RENDER_TYPE.RAW,\n      operationsSorter: RENDER_TYPE.RAW,\n      requestInterceptor: RENDER_TYPE.RAW,\n      responseInterceptor: RENDER_TYPE.RAW,\n      persistAuthorization: RENDER_TYPE.RAW,\n      defaultModelsExpandDepth: RENDER_TYPE.RAW,\n      defaultModelExpandDepth: RENDER_TYPE.RAW,\n      defaultModelRendering: RENDER_TYPE.STRING,\n      displayRequestDuration: RENDER_TYPE.RAW,\n      filter: RENDER_TYPE.RAW,\n      showExtensions: RENDER_TYPE.RAW,\n      showCommonExtensions: RENDER_TYPE.RAW,\n      queryConfigEnabled: RENDER_TYPE.RAW,\n      displayOperationId: RENDER_TYPE.RAW,\n      tagsSorter: RENDER_TYPE.RAW,\n      onComplete: RENDER_TYPE.RAW,\n      syntaxHighlight: RENDER_TYPE.JSON_STRING,\n      tryItOutEnabled: RENDER_TYPE.RAW,\n      requestSnippetsEnabled: RENDER_TYPE.RAW,\n      requestSnippets: RENDER_TYPE.JSON_STRING,\n      oauth2RedirectUrl: RENDER_TYPE.STRING,\n      showMutabledRequest: RENDER_TYPE.RAW,\n      request: RENDER_TYPE.JSON_STRING,\n      supportedSubmitMethods: RENDER_TYPE.JSON_STRING,\n      validatorUrl: RENDER_TYPE.STRING,\n      withCredentials: RENDER_TYPE.RAW,\n      modelPropertyMacro: RENDER_TYPE.RAW,\n      parameterMacro: RENDER_TYPE.RAW\n    };\n    renderSwaggerUIOptions = /* @__PURE__ */ __name((options) => {\n      const optionsStrings = Object.entries(options).map(([k2, v3]) => {\n        const key = k2;\n        if (!RENDER_TYPE_MAP[key] || v3 === void 0) {\n          return \"\";\n        }\n        switch (RENDER_TYPE_MAP[key]) {\n          case RENDER_TYPE.STRING:\n            return `${key}: '${v3}'`;\n          case RENDER_TYPE.STRING_ARRAY:\n            if (!Array.isArray(v3)) {\n              return \"\";\n            }\n            return `${key}: [${v3.map((ve2) => `${ve2}`).join(\",\")}]`;\n          case RENDER_TYPE.JSON_STRING:\n            return `${key}: ${JSON.stringify(v3)}`;\n          case RENDER_TYPE.RAW:\n            return `${key}: ${v3}`;\n          default:\n            return \"\";\n        }\n      }).filter((item) => item !== \"\").join(\",\");\n      return optionsStrings;\n    }, \"renderSwaggerUIOptions\");\n    remoteAssets = /* @__PURE__ */ __name(({ version: version3 }) => {\n      const url = `https://cdn.jsdelivr.net/npm/swagger-ui-dist${version3 !== void 0 ? `@${version3}` : \"\"}`;\n      return {\n        css: [`${url}/swagger-ui.css`],\n        js: [`${url}/swagger-ui-bundle.js`]\n      };\n    }, \"remoteAssets\");\n    SwaggerUI = /* @__PURE__ */ __name((options) => {\n      const asset = remoteAssets({ version: options?.version });\n      delete options.version;\n      if (options.manuallySwaggerUIHtml) {\n        return options.manuallySwaggerUIHtml(asset);\n      }\n      const optionsStrings = renderSwaggerUIOptions(options);\n      return `\n    <div>\n      <div id=\"swagger-ui\"></div>\n      ${asset.css.map((url) => html`<link rel=\"stylesheet\" href=\"${url}\" />`)}\n      ${asset.js.map((url) => html`<script src=\"${url}\" crossorigin=\"anonymous\"></script>`)}\n      <script>\n        window.onload = () => {\n          window.ui = SwaggerUIBundle({\n            dom_id: '#swagger-ui',${optionsStrings},\n          })\n        }\n      </script>\n    </div>\n  `;\n    }, \"SwaggerUI\");\n    middleware = /* @__PURE__ */ __name((options) => async (c) => {\n      const title3 = options?.title ?? \"SwaggerUI\";\n      return c.html(\n        /* html */\n        `\n      <html lang=\"en\">\n        <head>\n          <meta charset=\"utf-8\" />\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n          <meta name=\"description\" content=\"SwaggerUI\" />\n          <title>${title3}</title>\n        </head>\n        <body>\n          ${SwaggerUI(options)}\n        </body>\n      </html>\n    `\n      );\n    }, \"middleware\");\n    Pa = Object.create;\n    li$1 = Object.defineProperty;\n    ja = Object.getOwnPropertyDescriptor;\n    Ma = Object.getOwnPropertyNames;\n    Ia = Object.getPrototypeOf;\n    Da = Object.prototype.hasOwnProperty;\n    Ls = /* @__PURE__ */ __name((n252, e) => () => (e || n252((e = { exports: {} }).exports, e), e.exports), \"Ls\");\n    Je$2 = /* @__PURE__ */ __name((n252, e) => {\n      for (var t in e) li$1(n252, t, { get: e[t], enumerable: true });\n    }, \"Je$2\");\n    $a = /* @__PURE__ */ __name((n252, e, t, r2) => {\n      if (e && typeof e == \"object\" || typeof e == \"function\") for (let i of Ma(e)) !Da.call(n252, i) && i !== t && li$1(n252, i, { get: /* @__PURE__ */ __name(() => e[i], \"get\"), enumerable: !(r2 = ja(e, i)) || r2.enumerable });\n      return n252;\n    }, \"$a\");\n    Qs = /* @__PURE__ */ __name((n252, e, t) => (t = n252 != null ? Pa(Ia(n252)) : {}, $a(li$1(t, \"default\", { value: n252, enumerable: true }), n252)), \"Qs\");\n    no$1 = Ls((Dd, wi2) => {\n      var x = String, ro2 = /* @__PURE__ */ __name(function() {\n        return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };\n      }, \"ro\");\n      wi2.exports = ro2();\n      wi2.exports.createColors = ro2;\n    });\n    Oa = Ls((gT, sd) => {\n      sd.exports = { \"_TextareaWidget-q7sH1MbQ.js\": { file: \"assets/TextareaWidget-q7sH1MbQ.js\", name: \"TextareaWidget\", imports: [\"src/ui/main.tsx\"] }, \"src/ui/components/code/CodeEditor.tsx\": { file: \"assets/CodeEditor-CPKIW2Ts.js\", name: \"CodeEditor\", src: \"src/ui/components/code/CodeEditor.tsx\", isDynamicEntry: true, imports: [\"src/ui/main.tsx\"] }, \"src/ui/components/form/json-schema/JsonSchemaForm.tsx\": { file: \"assets/JsonSchemaForm-BJVi5Sy2.js\", name: \"JsonSchemaForm\", src: \"src/ui/components/form/json-schema/JsonSchemaForm.tsx\", isDynamicEntry: true, imports: [\"src/ui/main.tsx\", \"_TextareaWidget-q7sH1MbQ.js\"] }, \"src/ui/main.tsx\": { file: \"assets/main-CdZTJiGz.js\", name: \"main\", src: \"src/ui/main.tsx\", isEntry: true, dynamicImports: [\"src/ui/components/form/json-schema/JsonSchemaForm.tsx\", \"src/ui/components/code/CodeEditor.tsx\", \"src/ui/modules/data/components/canvas/DataSchemaCanvas.tsx\", \"src/ui/components/code/CodeEditor.tsx\", \"src/ui/routes/test/index.tsx\"], css: [\"assets/main-BLjkA8xT.css\"] }, \"src/ui/modules/data/components/canvas/DataSchemaCanvas.tsx\": { file: \"assets/DataSchemaCanvas-BdQ2iAKC.js\", name: \"DataSchemaCanvas\", src: \"src/ui/modules/data/components/canvas/DataSchemaCanvas.tsx\", isDynamicEntry: true, imports: [\"src/ui/main.tsx\"] }, \"src/ui/routes/test/index.tsx\": { file: \"assets/index-DULxYrBd.js\", name: \"index\", src: \"src/ui/routes/test/index.tsx\", isDynamicEntry: true, imports: [\"src/ui/main.tsx\", \"_TextareaWidget-q7sH1MbQ.js\"] } };\n    });\n    __name(Ir, \"Ir\");\n    __name(Ba, \"Ba\");\n    __name(Ks, \"Ks\");\n    __name(Js, \"Js\");\n    __name(zs, \"zs\");\n    I$1 = class I extends Error {\n      static {\n        __name(this, \"I\");\n      }\n      code = 400;\n      name = \"Exception\";\n      _context = void 0;\n      constructor(e, t) {\n        super(e), t && (this.code = t);\n      }\n      context(e) {\n        return this._context = e, this;\n      }\n      toJSON() {\n        return { error: this.message, type: this.name, context: this._context };\n      }\n    };\n    he$2 = class n extends Error {\n      static {\n        __name(this, \"n\");\n      }\n      constructor(t, r2, i) {\n        super(t);\n        this.details = r2;\n        this.type = i;\n      }\n      static with(t, r2, i) {\n        throw new n(t, r2, i);\n      }\n      toJSON() {\n        return { type: this.type ?? \"unknown\", message: this.message, details: this.details };\n      }\n    };\n    ui$1 = /* @__PURE__ */ __name((n252, e) => typeof n252 == \"string\" ? [1, \"1\", \"true\"].includes(n252) : !!(n252 || e), \"ui$1\");\n    __name(K$1, \"K$1\");\n    __name(Gs, \"Gs\");\n    Na = { cli_log_level: { key: \"BKND_CLI_LOG_LEVEL\", validate: /* @__PURE__ */ __name((n252) => {\n      if (typeof n252 == \"string\" && [\"log\", \"info\", \"warn\", \"error\", \"debug\"].includes(n252.toLowerCase())) return n252.toLowerCase();\n    }, \"validate\") }, cli_create_ref: { key: \"BKND_CLI_CREATE_REF\", validate: /* @__PURE__ */ __name((n252) => typeof n252 == \"string\" ? n252 : void 0, \"validate\") }, cli_telemetry: { key: \"BKND_CLI_TELEMETRY\", validate: /* @__PURE__ */ __name((n252) => {\n      if (!(typeof n252 > \"u\")) return ui$1(n252, true);\n    }, \"validate\") }, modules_debug: { key: \"BKND_MODULES_DEBUG\", validate: ui$1 } };\n    sr$1 = /* @__PURE__ */ __name((n252, e, t) => {\n      try {\n        let r2 = t?.source ?? process.env, i = Na[n252], s2 = r2[i.key], o = i.validate(s2);\n        if (typeof o < \"u\") return t?.onValid?.(o), o;\n        t?.onFallback?.(s2);\n      } catch {\n      }\n      return e;\n    }, \"sr$1\");\n    ot$1 = { server: { assets_path: \"/\" }, data: { default_primary_field: \"id\" } };\n    __name(Vs, \"Vs\");\n    __name(Dr$1, \"Dr$1\");\n    __name(Ot$1, \"Ot$1\");\n    __name(Ws, \"Ws\");\n    __name(Hs, \"Hs\");\n    __name(Ys, \"Ys\");\n    __name(Ua, \"Ua\");\n    __name(Rt$1, \"Rt$1\");\n    __name(Nr$1, \"Nr$1\");\n    __name($r$1, \"$r$1\");\n    __name(di$1, \"di$1\");\n    __name(O$2, \"O$2\");\n    ze$1 = O$2;\n    __name(mi$1, \"mi$1\");\n    __name(fi$1, \"fi$1\");\n    __name(qr$1, \"qr$1\");\n    __name(yi$1, \"yi$1\");\n    __name(Br$1, \"Br$1\");\n    __name(Xs, \"Xs\");\n    or$1 = class or extends AwsClient {\n      static {\n        __name(this, \"or\");\n      }\n      #e;\n      constructor(e, t) {\n        super(e), this.#e = t ?? { responseType: \"json\" };\n      }\n      convertParams(e) {\n        switch (this.#e.convertParams) {\n          case \"pascalToKebab\":\n            return $r$1(e);\n          default:\n            return e;\n        }\n      }\n      getUrl(e = \"/\", t = {}) {\n        let r2 = new URL(e), i = this.convertParams(t);\n        return Object.entries(i).forEach(([s2, o]) => {\n          r2.searchParams.append(s2, o);\n        }), r2.toString();\n      }\n      updateKeysRecursively(e, t) {\n        return e == null ? e : Array.isArray(e) ? e.map((r2) => this.updateKeysRecursively(r2, t)) : typeof e == \"object\" ? Object.keys(e).reduce((r2, i) => {\n          let s2 = i;\n          return i.indexOf(\" \") === -1 && (s2 = i.charAt(0)[t]() + i.slice(1)), r2[s2] = this.updateKeysRecursively(e[i], t), r2;\n        }, {}) : e;\n      }\n      async fetchJson(e, t) {\n        let r2 = await this.fetch(e, t);\n        if (this.#e.responseType === \"xml\") {\n          if (!r2.ok) {\n            let o = await r2.text();\n            throw new Error(o);\n          }\n          let s2 = await r2.text();\n          return Xs(s2);\n        }\n        if (!r2.ok) {\n          let s2 = await r2.json();\n          throw new Error(s2.message);\n        }\n        let i = await r2.json();\n        return this.#e.responseKeysToUpper ? this.updateKeysRecursively(i, \"toUpperCase\") : i;\n      }\n    };\n    Ct$1 = class Ct {\n      static {\n        __name(this, \"Ct\");\n      }\n      constructor(e = {}, t = {}) {\n        this.variables = e;\n        this.options = t;\n      }\n      another() {\n        return 1;\n      }\n      static hasMarkup(e) {\n        let t = \"\";\n        if (Array.isArray(e) || typeof e == \"object\") {\n          if (![\"Array\", \"Object\"].includes(e.constructor.name)) return false;\n          t = JSON.stringify(e);\n        } else t = String(e);\n        return [\"{{\"].some((i) => t.includes(i));\n      }\n      async render(e) {\n        if (typeof e > \"u\" || e === null) return e;\n        if (typeof e == \"string\") return await this.renderString(e);\n        if (Array.isArray(e)) return await Promise.all(e.map((t) => this.render(t)));\n        if (typeof e == \"object\") return await this.renderObject(e);\n        throw new Error(\"Invalid template type\");\n      }\n      async renderString(e) {\n        return e.replace(/{{\\s*([^{}]+?)\\s*}}/g, (t, r2) => {\n          let i = get(this.variables, r2.trim());\n          return i == null ? \"\" : String(i);\n        });\n      }\n      async renderObject(e) {\n        let t = {};\n        for (let [r2, i] of Object.entries(e)) {\n          let s2 = r2;\n          this.options.renderKeys && (s2 = await this.renderString(r2)), t[s2] = await this.render(i);\n        }\n        return t;\n      }\n    };\n    hi$1 = { video: [\"mp4\", \"webm\"], audio: [\"ogg\"], image: [\"jpeg\", \"png\", \"gif\", \"webp\", \"bmp\", \"tiff\", \"avif\", \"heic\", \"heif\"], text: [\"html\", \"css\", \"mdx\", \"yaml\", \"vcard\", \"csv\", \"vtt\"], application: [\"zip\", \"xml\", \"toml\", \"json\", \"json5\"], font: [\"woff\", \"woff2\", \"ttf\", \"otf\"] };\n    E$3 = { vnd: \"vnd.openxmlformats-officedocument\", z: \"application/x-7z-compressed\", t: /* @__PURE__ */ __name((n252 = \"plain\") => `text/${n252}`, \"t\"), a: /* @__PURE__ */ __name((n252 = \"octet-stream\") => `application/${n252}`, \"a\"), i: /* @__PURE__ */ __name((n252) => `image/${n252}`, \"i\"), v: /* @__PURE__ */ __name((n252) => `video/${n252}`, \"v\") };\n    gi$1 = /* @__PURE__ */ new Map([[\"7z\", E$3.z], [\"7zip\", E$3.z], [\"ai\", E$3.a(\"pdf\")], [\"apk\", E$3.a(\"vnd.android.package-archive\")], [\"doc\", E$3.a(\"msword\")], [\"docx\", `${E$3.vnd}.wordprocessingml.document`], [\"eps\", E$3.a(\"postscript\")], [\"epub\", E$3.a(\"epub+zip\")], [\"ini\", E$3.t()], [\"jar\", E$3.a(\"java-archive\")], [\"jsonld\", E$3.a(\"ld+json\")], [\"jpg\", E$3.i(\"jpeg\")], [\"log\", E$3.t()], [\"m3u\", E$3.t()], [\"m3u8\", E$3.a(\"vnd.apple.mpegurl\")], [\"manifest\", E$3.t(\"cache-manifest\")], [\"md\", E$3.t(\"markdown\")], [\"mkv\", E$3.v(\"x-matroska\")], [\"mp3\", E$3.a(\"mpeg\")], [\"mobi\", E$3.a(\"x-mobipocket-ebook\")], [\"ppt\", E$3.a(\"powerpoint\")], [\"pptx\", `${E$3.vnd}.presentationml.presentation`], [\"qt\", E$3.v(\"quicktime\")], [\"svg\", E$3.i(\"svg+xml\")], [\"tif\", E$3.i(\"tiff\")], [\"tsv\", E$3.t(\"tab-separated-values\")], [\"tgz\", E$3.a(\"x-tar\")], [\"txt\", E$3.t()], [\"text\", E$3.t()], [\"vcd\", E$3.a(\"x-cdlink\")], [\"vcs\", E$3.t(\"x-vcalendar\")], [\"wav\", E$3.a(\"x-wav\")], [\"webmanifest\", E$3.a(\"manifest+json\")], [\"xls\", E$3.a(\"vnd.ms-excel\")], [\"xlsx\", `${E$3.vnd}.spreadsheetml.sheet`], [\"yml\", E$3.t(\"yaml\")]]);\n    __name(Zs, \"Zs\");\n    __name(Ur$1, \"Ur$1\");\n    __name(Lr$1, \"Lr$1\");\n    __name(bi$1, \"bi$1\");\n    eo$1 = { redirects_non_fq: true };\n    __name(to$1, \"to$1\");\n    __name(xi$1, \"xi$1\");\n    te$3 = Qs(no$1());\n    __name(za, \"za\");\n    Ei$1 = { critical: { prefix: \"CRT\", color: te$3.default.red, args_color: te$3.default.red, original: console.error }, error: { prefix: \"ERR\", color: te$3.default.red, args_color: te$3.default.red, original: console.error }, warn: { prefix: \"WRN\", color: te$3.default.yellow, args_color: te$3.default.yellow, original: console.warn }, info: { prefix: \"INF\", color: te$3.default.cyan, original: console.info }, log: { prefix: \"LOG\", color: te$3.default.dim, args_color: te$3.default.dim, original: console.log }, debug: { prefix: \"DBG\", color: te$3.default.yellow, args_color: te$3.default.dim, original: console.debug } };\n    __name(Ga, \"Ga\");\n    so$1 = sr$1(\"cli_log_level\", \"log\");\n    Qr$1 = globalThis.__consoleConfig ??= { level: so$1 };\n    io$1 = Object.keys(Ei$1);\n    m$1 = new Proxy(Qr$1, { get: /* @__PURE__ */ __name((n252, e) => {\n      switch (e) {\n        case \"original\":\n          return console;\n        case \"setLevel\":\n          return (i) => {\n            Qr$1.level = i;\n          };\n        case \"resetLevel\":\n          return () => {\n            Qr$1.level = so$1;\n          };\n      }\n      let t = io$1.indexOf(Qr$1.level), r2 = io$1.indexOf(e);\n      return e in Ei$1 && r2 <= t ? (...i) => Ga(e, i) : () => null;\n    }, \"get\") });\n    __name(Va, \"Va\");\n    __name(Wa, \"Wa\");\n    __name(Jr$1, \"Jr$1\");\n    __name(Ae$2, \"Ae$2\");\n    __name(Ha, \"Ha\");\n    __name(Ya, \"Ya\");\n    Xa = { \"89504E47\": \"image/png\", FFD8FF: \"image/jpeg\", 47494638: \"image/gif\", \"49492A00\": \"image/tiff\", \"4D4D002A\": \"image/tiff\", \"52494646????57454250\": \"image/webp\", \"504B0304\": \"application/zip\", 25504446: \"application/pdf\", \"00000020667479706D70\": \"video/mp4\", \"000001BA\": \"video/mpeg\", \"000001B3\": \"video/mpeg\", \"1A45DFA3\": \"video/webm\", \"4F676753\": \"audio/ogg\", 494433: \"audio/mpeg\", FFF1: \"audio/aac\", FFF9: \"audio/aac\", \"52494646????41564920\": \"audio/wav\", \"52494646????57415645\": \"audio/wave\", \"52494646????415550\": \"audio/aiff\" };\n    __name(Za, \"Za\");\n    __name(zr$1, \"zr$1\");\n    __name(ao$1, \"ao$1\");\n    __name(oo, \"oo\");\n    Ti$1 = Symbol(\"tb-parse-validation\");\n    De$2 = class De extends Error {\n      static {\n        __name(this, \"De\");\n      }\n      constructor(t, r2, i) {\n        super(i ?? `Invalid: ${JSON.stringify(r2)}`);\n        this.schema = t;\n        this.data = r2;\n        this.errors = [...Errors(t, r2)];\n      }\n      errors;\n      first() {\n        return this.errors[0];\n      }\n      firstToString() {\n        let t = this.first();\n        return `${t.message} at \"${t.path}\"`;\n      }\n      toJSON() {\n        return { message: this.message, schema: this.schema, data: this.data, errors: this.errors };\n      }\n    };\n    __name(Gr$1, \"Gr$1\");\n    __name(ar$1, \"ar$1\");\n    __name(_$2, \"_$2\");\n    __name(nc, \"nc\");\n    nc(type$1);\n    w$4 = /* @__PURE__ */ __name((n252, e) => Type.Unsafe({ [Kind]: \"StringEnum\", type: \"string\", enum: n252, ...e }), \"w$4\");\n    ce$2 = /* @__PURE__ */ __name((n252, e) => Type.Object({}, { ...e, additionalProperties: n252 }), \"ce$2\");\n    be$2 = /* @__PURE__ */ __name((n252, e) => Type.Literal(n252, { ...e, default: n252, const: n252, readOnly: true }), \"be$2\");\n    Type.String({ pattern: \"^[a-zA-Z_][a-zA-Z0-9_]*$\", minLength: 2, maxLength: 150 });\n    Ve$1 = /* @__PURE__ */ __name((n252, e) => Type.Object(n252, { ...e, additionalProperties: false }), \"Ve$1\");\n    SetErrorFunction((n252) => n252?.schema?.errorMessage ? n252.schema.errorMessage : n252?.schema?.[Kind] === \"StringEnum\" ? `Expected: ${n252.schema.enum.map((e) => `\"${e}\"`).join(\", \")}` : DefaultErrorFunction(n252));\n    ze$2.extend(Pr$1);\n    __name(Kr$1, \"Kr$1\");\n    __name(po, \"po\");\n    __name(uo, \"uo\");\n    __name(mo, \"mo\");\n    sc = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n    __name(fo, \"fo\");\n    Vr$1 = { sha256: /* @__PURE__ */ __name(async (n252, e, t) => fo(\"SHA-256\", n252, e, t), \"sha256\"), sha1: /* @__PURE__ */ __name(async (n252, e, t) => fo(\"SHA-1\", n252, e, t), \"sha1\") };\n    __name(yo, \"yo\");\n    __name(ho, \"ho\");\n    __name(go, \"go\");\n    He$1 = /* @__PURE__ */ __name((n252, e) => n252 === e, \"He$1\");\n    cc = /* @__PURE__ */ __name((n252) => IsString$2(n252) || IsNumber$2(n252) || IsBoolean$2(n252), \"cc\");\n    lc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && IsArray$2(n252.enum) && n252.enum.every((e) => cc(e)), \"lc\");\n    pc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && IsArray$2(n252.allOf), \"pc\");\n    uc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && IsArray$2(n252.anyOf), \"uc\");\n    dc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && IsArray$2(n252.oneOf), \"dc\");\n    mc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"array\") && IsArray$2(n252.items), \"mc\");\n    fc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"array\") && !IsArray$2(n252.items) && IsObject$2(n252.items), \"fc\");\n    yc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && IsObject$2(n252.const), \"yc\");\n    hc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"string\"), \"hc\");\n    gc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"number\"), \"gc\");\n    bc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"integer\"), \"bc\");\n    xc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"boolean\"), \"xc\");\n    wc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"null\"), \"wc\");\n    Ec = /* @__PURE__ */ __name((n252) => IsObject$2(n252), \"Ec\");\n    Tc = /* @__PURE__ */ __name((n252) => IsObject$2(n252) && He$1(n252.type, \"object\") && Ec(n252.properties) && (n252.required === void 0 || IsArray$2(n252.required) && n252.required.every((e) => IsString$2(e))), \"Tc\");\n    __name(Wr$1, \"Wr$1\");\n    __name(Sc, \"Sc\");\n    __name(vc, \"vc\");\n    __name(Oc, \"Oc\");\n    __name(Rc, \"Rc\");\n    __name(Cc, \"Cc\");\n    __name(Ac, \"Ac\");\n    __name(Fc, \"Fc\");\n    __name(_c, \"_c\");\n    __name(kc, \"kc\");\n    __name(We$3, \"We$3\");\n    __name(Si$1, \"Si$1\");\n    At$1 = class At {\n      static {\n        __name(this, \"At\");\n      }\n      constructor(e, t, r2) {\n        this._schema = e;\n        this.options = r2;\n        this._default = Default(e, {}), this._value = t ? _$2(e, structuredClone(t), { forceParse: this.isForceParse(), skipMark: this.isForceParse() }) : this._default, this._config = Object.freeze(this._value);\n      }\n      _default;\n      _value;\n      _config;\n      _restriction_bypass = false;\n      isForceParse() {\n        return this.options?.forceParse ?? true;\n      }\n      default() {\n        return this._default;\n      }\n      async onBeforeUpdate(e, t) {\n        return this.options?.onBeforeUpdate ? this.options.onBeforeUpdate(e, t) : t;\n      }\n      get(e) {\n        return e?.stripMark ? Gr$1(this._config) : this._config;\n      }\n      clone() {\n        return structuredClone(this._config);\n      }\n      async set(e, t) {\n        let r2 = _$2(this._schema, structuredClone(e), { forceParse: true, skipMark: this.isForceParse() }), i = await this.onBeforeUpdate(this._config, r2);\n        return this._value = i, this._config = Object.freeze(i), t !== true && await this.options?.onUpdate?.(this._config), this._config;\n      }\n      bypass() {\n        return this._restriction_bypass = true, this;\n      }\n      throwIfRestricted(e) {\n        if (this._restriction_bypass) {\n          this._restriction_bypass = false;\n          return;\n        }\n        let t = this.options?.restrictPaths ?? [];\n        if (Array.isArray(t) && t.length > 0) {\n          for (let r2 of t) if (typeof e == \"string\" ? e.startsWith(r2) : has(e, r2)) throw new Error(`Path \"${r2}\" is restricted`);\n        }\n      }\n      async patch(e, t) {\n        let r2 = this.clone(), i = e.length > 0 ? set({}, e, t) : t;\n        this.throwIfRestricted(i);\n        let s2 = yi$1(r2, i, (c, a2) => {\n          if (Array.isArray(c) && Array.isArray(a2)) return a2;\n        });\n        if (this.options?.overwritePaths) {\n          let a2 = fi$1(t).map((l2) => e.length > 0 ? e + \".\" + l2 : l2).filter((l2) => this.options?.overwritePaths?.some((p2) => typeof p2 == \"string\" ? l2 === p2 : p2.test(l2)));\n          if (a2.length > 0) {\n            let l2 = a2.length > 1 ? a2.filter((p2) => a2.some((u3) => u3 !== p2 && u3.startsWith(p2))) : a2;\n            for (let p2 of l2) set(s2, p2, get(i, p2));\n          }\n        }\n        let o = await this.set(s2);\n        return [i, o];\n      }\n      async overwrite(e, t) {\n        let r2 = this.clone(), i = e.length > 0 ? set({}, e, t) : t;\n        this.throwIfRestricted(i);\n        let s2 = set(r2, e, t), o = await this.set(s2);\n        return [i, o];\n      }\n      has(e) {\n        let t = e.split(\".\");\n        if (t.length > 1) {\n          let r2 = t.slice(0, -1).join(\".\");\n          if (!has(this._config, r2)) throw new Error(`Parent path \"${r2}\" does not exist`);\n        }\n        return has(this._config, e);\n      }\n      async remove(e) {\n        if (this.throwIfRestricted(e), !this.has(e)) throw new Error(`Path \"${e}\" does not exist`);\n        let t = this.clone(), r2 = get(t, e), i = omit(t, e), s2 = await this.set(i);\n        return [r2, s2];\n      }\n    };\n    lr$1 = class lr {\n      static {\n        __name(this, \"lr\");\n      }\n      _context = [];\n      _enabled = true;\n      id = Math.random().toString(36).substr(2, 9);\n      last = 0;\n      constructor(e = true) {\n        this._enabled = e;\n      }\n      context(e) {\n        return this._context.push(e), this;\n      }\n      clear() {\n        return this._context.pop(), this;\n      }\n      reset() {\n        return this.last = 0, this;\n      }\n      log(...e) {\n        if (!this._enabled) return this;\n        let t = performance.now(), r2 = this.last === 0 ? 0 : Number.parseInt(String(t - this.last)), i = \"  \".repeat(Math.max(this._context.length - 1, 0)), s2 = this._context.length > 0 ? `[${this._context[this._context.length - 1]}]` : \"\";\n        return console.log(i, s2, r2, ...e), this.last = t, this;\n      }\n    };\n    R$2 = class R {\n      static {\n        __name(this, \"R\");\n      }\n      constructor(e) {\n        this.name = e;\n        this.name = e;\n      }\n      toJSON() {\n        return { name: this.name };\n      }\n    };\n    __name(Fe$1, \"Fe$1\");\n    __name(Ri$1, \"Ri$1\");\n    Oi$1 = class Oi {\n      static {\n        __name(this, \"Oi\");\n      }\n      constructor(e, t, r2) {\n        this.key = e;\n        this.valid = t;\n        this.validate = r2;\n      }\n      expect;\n    };\n    __name(re$3, \"re$3\");\n    __name(Eo, \"Eo\");\n    xo = \"$or\";\n    __name(Ci$1, \"Ci$1\");\n    __name(wo, \"wo\");\n    __name(jc, \"jc\");\n    __name(Ai$1, \"Ai$1\");\n    pr = class {\n      static {\n        __name(this, \"pr\");\n      }\n      constructor(e) {\n        this.registerFn = e;\n      }\n      is_set = false;\n      items = {};\n      set(e) {\n        if (this.is_set) throw new Error(\"Registry is already set\");\n        return this.items = e, this.is_set = true, this;\n      }\n      add(e, t) {\n        return this.items[e] = t, this;\n      }\n      register(e, t) {\n        if (this.registerFn) {\n          let r2 = this.registerFn(t);\n          return this.items[e] = r2, this;\n        }\n        return this.add(e, t);\n      }\n      get(e) {\n        return this.items[e];\n      }\n      has(e) {\n        return e in this.items;\n      }\n      all() {\n        return this.items;\n      }\n    };\n    Ic = \"__bknd_flash\";\n    __name(Ft$1, \"Ft$1\");\n    f = {};\n    Je$2(f, { $kind: /* @__PURE__ */ __name(() => ki$1, \"$kind\"), $optional: /* @__PURE__ */ __name(() => Pi$1, \"$optional\"), $raw: /* @__PURE__ */ __name(() => at$1, \"$raw\"), any: /* @__PURE__ */ __name(() => Cl, \"any\"), anyOf: /* @__PURE__ */ __name(() => jl, \"anyOf\"), array: /* @__PURE__ */ __name(() => Po, \"array\"), boolean: /* @__PURE__ */ __name(() => jo$1, \"boolean\"), error: /* @__PURE__ */ __name(() => A$4, \"error\"), fromSchema: /* @__PURE__ */ __name(() => ct$1, \"fromSchema\"), integer: /* @__PURE__ */ __name(() => _o, \"integer\"), makeOpts: /* @__PURE__ */ __name(() => pt$1, \"makeOpts\"), number: /* @__PURE__ */ __name(() => Fo, \"number\"), object: /* @__PURE__ */ __name(() => dr, \"object\"), oneOf: /* @__PURE__ */ __name(() => Ml, \"oneOf\"), partialObject: /* @__PURE__ */ __name(() => Fl, \"partialObject\"), record: /* @__PURE__ */ __name(() => _l, \"record\"), recursive: /* @__PURE__ */ __name(() => $l, \"recursive\"), ref: /* @__PURE__ */ __name(() => Il, \"ref\"), refId: /* @__PURE__ */ __name(() => Dl, \"refId\"), schema: /* @__PURE__ */ __name(() => B$4, \"schema\"), strictObject: /* @__PURE__ */ __name(() => Al, \"strictObject\"), string: /* @__PURE__ */ __name(() => Ao, \"string\"), stringConst: /* @__PURE__ */ __name(() => kl, \"stringConst\"), valid: /* @__PURE__ */ __name(() => g$1, \"valid\") });\n    ki$1 = Symbol.for(\"kind\");\n    Pi$1 = Symbol.for(\"optional\");\n    at$1 = Symbol.for(\"raw\");\n    lt$1 = class lt extends Error {\n      static {\n        __name(this, \"lt\");\n      }\n      constructor(n252) {\n        super(`Expected ${n252}`);\n      }\n    };\n    Dc = class extends Error {\n      static {\n        __name(this, \"Dc\");\n      }\n      constructor(n252, e) {\n        super(`${n252 ?? \"Invalid raw schema\"}: ${JSON.stringify(e)}`), this.schema = e;\n      }\n    };\n    $c = class extends Error {\n      static {\n        __name(this, \"$c\");\n      }\n      constructor(n252, e) {\n        super(`${n252}, got: '${JSON.stringify(e)}'`), this.value = e;\n      }\n    };\n    __name(qc, \"qc\");\n    __name(J$2, \"J$2\");\n    __name(_e$2, \"_e$2\");\n    __name(qe$2, \"qe$2\");\n    __name(Bc, \"Bc\");\n    __name(_t$1, \"_t$1\");\n    __name(Be$2, \"Be$2\");\n    __name(Nc, \"Nc\");\n    __name(Uc, \"Uc\");\n    __name(Lc, \"Lc\");\n    __name(le$2, \"le$2\");\n    __name(Qc, \"Qc\");\n    __name(Fi$1, \"Fi$1\");\n    __name($e, \"$e\");\n    _i$1 = /* @__PURE__ */ __name((n252 = [], e = \"\") => \"/\" + [e, ...n252.map((t) => String(t).replace(/\\./g, \"/\"))].filter(Boolean).join(\"/\"), \"_i$1\");\n    Kc = /* @__PURE__ */ __name((n252) => n252.split(\"/\").slice(1), \"Kc\");\n    __name(Jc, \"Jc\");\n    __name(Oo, \"Oo\");\n    A$4 = /* @__PURE__ */ __name((n252 = {}, e, t, r2) => ({ valid: false, errors: [...n252.errors ?? [], { keywordLocation: _i$1([...n252.keywordPath ?? [], e]), instanceLocation: _i$1(n252.instancePath), error: typeof t == \"string\" ? t : `Invalid value for ${e}`, data: r2 }] }), \"A$4\");\n    g$1 = /* @__PURE__ */ __name(() => ({ valid: true, errors: [] }), \"g$1\");\n    pt$1 = /* @__PURE__ */ __name((n252, e, t) => {\n      let r2 = Array.isArray(e) ? e : [e], i = t ? Array.isArray(t) ? t : [t] : [];\n      return { ...n252, keywordPath: [...n252.keywordPath ?? [], ...r2], instancePath: i ? [...n252.instancePath ?? [], ...i] : n252.instancePath };\n    }, \"pt$1\");\n    Yr$1 = /* @__PURE__ */ __name((n252 = {}) => ({ ...n252, errors: [] }), \"Yr$1\");\n    zc = /* @__PURE__ */ __name(({ type: n252 }, e, t = {}) => {\n      if (n252 === void 0) return g$1();\n      let r2, i = { string: _e$2, number: qe$2, integer: Bc, object: J$2, array: Be$2, boolean: _t$1, null: qc };\n      if (Array.isArray(n252)) {\n        for (let s2 of n252) {\n          if (!(s2 in i)) throw new lt$1(`Unknown type: ${s2}`);\n          if (i[s2](e)) return g$1();\n        }\n        r2 = `Expected one of: ${n252.join(\", \")}`;\n      } else {\n        if (!(n252 in i)) throw new lt$1(`Unknown type: ${n252}`);\n        i[n252](e) || (r2 = `Expected ${n252}`);\n      }\n      return r2 ? A$4(t, \"type\", r2, e) : g$1();\n    }, \"zc\");\n    Gc = /* @__PURE__ */ __name(({ const: n252 }, e, t = {}) => {\n      let r2 = JSON.stringify($e(n252)), i = JSON.stringify($e(e));\n      return r2 !== i ? A$4(t, \"const\", `Expected const: ${r2}`, i) : g$1();\n    }, \"Gc\");\n    Vc = /* @__PURE__ */ __name(({ enum: n252 = [] }, e, t = {}) => {\n      let r2 = JSON.stringify(n252.map($e)), i = JSON.stringify($e(e));\n      return r2.includes(i) ? g$1() : A$4(t, \"enum\", `Expected enum: ${r2}`, e);\n    }, \"Vc\");\n    __name(ur, \"ur\");\n    Wc = /* @__PURE__ */ __name(({ anyOf: n252 = [] }, e, t = {}) => ur(n252, e, t).length > 0 ? g$1() : A$4(t, \"anyOf\", \"Expected at least one to match\", e), \"Wc\");\n    Hc = /* @__PURE__ */ __name(({ oneOf: n252 = [] }, e, t = {}) => ur(n252, e).length === 1 ? g$1() : A$4(t, \"oneOf\", \"Expected exactly one to match\", e), \"Hc\");\n    Yc = /* @__PURE__ */ __name(({ allOf: n252 = [] }, e, t = {}) => ur(n252, e, t).length === n252.length ? g$1() : A$4(t, \"allOf\", \"Expected all to match\", e), \"Yc\");\n    Xc = /* @__PURE__ */ __name(({ not: n252 }, e, t = {}) => le$2(n252) && n252.validate(e, t).valid ? A$4(t, \"not\", \"Expected not to match\", e) : g$1(), \"Xc\");\n    Zc = /* @__PURE__ */ __name(({ if: n252, then: e, else: t }, r2, i = {}) => {\n      if (n252 && (e || t)) {\n        if (n252.validate(r2, Yr$1(i)).valid) return e ? e.validate(r2, Yr$1(i)) : g$1();\n        if (t) return t.validate(r2, Yr$1(i));\n      }\n      return g$1();\n    }, \"Zc\");\n    el = /* @__PURE__ */ __name(({ pattern: n252 = \"\" }, e, t = {}) => _e$2(e) ? new RegExp(n252, \"u\").test(e) ? g$1() : A$4(t, \"pattern\", `Expected string matching pattern ${n252}`, e) : g$1(), \"el\");\n    tl = /* @__PURE__ */ __name(({ minLength: n252 = 0 }, e, t = {}) => _e$2(e) ? [...$e(e)].length >= n252 ? g$1() : A$4(t, \"minLength\", `Expected string with minimum length of ${n252}`, e) : g$1(), \"tl\");\n    rl = /* @__PURE__ */ __name(({ maxLength: n252 = 0 }, e, t = {}) => _e$2(e) ? [...$e(e)].length <= n252 ? g$1() : A$4(t, \"maxLength\", `Expected string with maximum length of ${n252}`, e) : g$1(), \"rl\");\n    nl = /* @__PURE__ */ __name(({ multipleOf: n252 = 0 }, e, t = {}) => {\n      if (!qe$2(e)) return g$1();\n      if (!(Number.isFinite(e) && Number.isFinite(n252)) || n252 <= 0) throw new lt$1(\"number\");\n      let r2 = e / n252, i = Number.EPSILON * Math.max(1, Math.abs(r2));\n      return Math.abs(r2 - Math.round(r2)) <= i ? g$1() : A$4(t, \"multipleOf\", `Expected number being a multiple of ${n252}`, e);\n    }, \"nl\");\n    il = /* @__PURE__ */ __name(({ maximum: n252 = 0 }, e, t = {}) => !qe$2(e) || e <= n252 ? g$1() : A$4(t, \"maximum\", `Expected number less than or equal to ${n252}`, e), \"il\");\n    sl = /* @__PURE__ */ __name(({ exclusiveMaximum: n252 = 0 }, e, t = {}) => !qe$2(e) || e < n252 ? g$1() : A$4(t, \"exclusiveMaximum\", `Expected number less than ${n252}`, e), \"sl\");\n    ol = /* @__PURE__ */ __name(({ minimum: n252 = 0 }, e, t = {}) => !qe$2(e) || e >= n252 ? g$1() : A$4(t, \"minimum\", `Expected number greater than or equal to ${n252}`, e), \"ol\");\n    al = /* @__PURE__ */ __name(({ exclusiveMinimum: n252 = 0 }, e, t = {}) => !qe$2(e) || e > n252 ? g$1() : A$4(t, \"exclusiveMinimum\", `Expected number greater than ${n252}`, e), \"al\");\n    cl = /* @__PURE__ */ __name(({ properties: n252 = {} }, e, t = {}) => {\n      if (!J$2(e)) return g$1();\n      for (let [r2, i] of Object.entries(e)) {\n        let s2 = n252[r2];\n        if (!le$2(s2)) continue;\n        let o = s2.validate(i, pt$1(t, [\"properties\", r2], r2));\n        if (!o.valid) return o;\n      }\n      return g$1();\n    }, \"cl\");\n    ll = /* @__PURE__ */ __name(({ properties: n252 = {}, additionalProperties: e, patternProperties: t }, r2, i = {}) => {\n      if (!J$2(r2)) return g$1();\n      if (!le$2(e)) throw new lt$1(\"additionalProperties must be a boolean or a managed schema\");\n      let s2 = Object.keys(n252), o = J$2(t) ? Object.keys(r2).filter((a2) => Object.keys(t).some((l2) => new RegExp(l2).test(a2))) : [], c = Object.keys(r2).filter((a2) => !s2.includes(a2) && !o.includes(a2));\n      if (c.length > 0) {\n        if (Qc(e)) return e.validate(void 0);\n        if (le$2(e)) for (let a2 of c) {\n          let l2 = e.validate(r2[a2], pt$1(i, [\"additionalProperties\"], a2));\n          if (!l2.valid) return l2;\n        }\n      }\n      return g$1();\n    }, \"ll\");\n    pl = /* @__PURE__ */ __name(({ dependentRequired: n252 }, e, t = {}) => {\n      if (!J$2(e)) return g$1();\n      let r2 = Object.keys(e).filter((i) => typeof e[i] != \"function\");\n      if (J$2(n252)) {\n        for (let [i, s2] of Object.entries(n252)) if (r2.includes(i)) {\n          for (let o of s2) if (!r2.includes(o)) return A$4(t, \"dependentRequired\", `Expected dependent required property ${o}`, e);\n        }\n      }\n      return g$1();\n    }, \"pl\");\n    ul = /* @__PURE__ */ __name(({ required: n252 = [] }, e, t = {}) => {\n      if (!J$2(e)) return g$1();\n      let r2 = Object.keys(e).filter((i) => typeof e[i] != \"function\");\n      return n252.every((i) => r2.includes(i)) ? g$1() : A$4(t, \"required\", `Expected object with required properties ${n252.join(\", \")}`, e);\n    }, \"ul\");\n    dl = /* @__PURE__ */ __name(({ dependentSchemas: n252 }, e, t = {}) => {\n      if (!J$2(e)) return g$1();\n      let r2 = Object.keys(e).filter((i) => typeof e[i] != \"function\");\n      if (J$2(n252)) {\n        for (let [i, s2] of Object.entries(n252)) if (r2.includes(i)) {\n          let o = s2.validate(e, t);\n          if (!o.valid) return o;\n        }\n      }\n      return g$1();\n    }, \"dl\");\n    ml = /* @__PURE__ */ __name(({ minProperties: n252 = 0 }, e, t = {}) => J$2(e) ? Object.keys(e).length >= n252 ? g$1() : A$4(t, \"minProperties\", `Expected object with at least ${n252} properties`, e) : g$1(), \"ml\");\n    fl = /* @__PURE__ */ __name(({ maxProperties: n252 = 0 }, e, t = {}) => !J$2(e) || Object.keys(e).length <= n252 ? g$1() : A$4(t, \"maxProperties\", `Expected object with at most ${n252} properties`, e), \"fl\");\n    yl = /* @__PURE__ */ __name(({ patternProperties: n252 = {} }, e, t = {}) => {\n      if (!J$2(e)) return g$1();\n      if (!J$2(n252)) throw new lt$1(\"patternProperties must be an object\");\n      for (let [r2, i] of Object.entries(e)) for (let [s2, o] of Object.entries(n252)) if (new RegExp(s2, \"u\").test(r2)) {\n        let c = o.validate(i, pt$1(t, [\"patternProperties\"], r2));\n        if (!c.valid) return c;\n      }\n      return g$1();\n    }, \"yl\");\n    hl = /* @__PURE__ */ __name(({ propertyNames: n252 }, e, t = {}) => {\n      if (!J$2(e) || n252 === void 0) return g$1();\n      if (!le$2(n252)) throw new lt$1(\"propertyNames must be a managed schema\");\n      for (let r2 of Object.keys(e)) {\n        let i = n252.validate(r2, pt$1(t, [\"propertyNames\"], r2));\n        if (!i.valid) return i;\n      }\n      return g$1();\n    }, \"hl\");\n    gl = /* @__PURE__ */ __name(({ items: n252, prefixItems: e = [] }, t, r2 = {}) => {\n      if (!Be$2(t) || n252 === void 0) return g$1();\n      if (!le$2(n252)) throw new lt$1(\"items must be a managed schema\");\n      for (let [i, s2] of t.slice(e.length).entries()) {\n        let o = n252.validate(s2, pt$1(r2, [\"items\"], String(i)));\n        if (!o.valid) return o;\n      }\n      return g$1();\n    }, \"gl\");\n    bl = /* @__PURE__ */ __name(({ minItems: n252 = 0 }, e, t = {}) => !Be$2(e) || e.length >= n252 ? g$1() : A$4(t, \"minItems\", `Expected array with at least ${n252} items`, e), \"bl\");\n    xl = /* @__PURE__ */ __name(({ maxItems: n252 = 0 }, e, t = {}) => !Be$2(e) || e.length <= n252 ? g$1() : A$4(t, \"maxItems\", `Expected array with at most ${n252} items`, e), \"xl\");\n    wl = /* @__PURE__ */ __name(({ uniqueItems: n252 = false }, e, t = {}) => {\n      if (!Be$2(e) || !n252) return g$1();\n      let r2 = e.map($e);\n      return new Set(r2.map((i) => JSON.stringify(i))).size === e.length ? g$1() : A$4(t, \"uniqueItems\", \"Expected array with unique items\", e);\n    }, \"wl\");\n    El = /* @__PURE__ */ __name(({ contains: n252, minContains: e, maxContains: t }, r2, i = {}) => {\n      if (!le$2(n252)) throw new Error(\"contains must be a managed schema\");\n      if (!Be$2(r2)) return g$1();\n      let s2 = r2.filter((o) => n252.validate(o).valid).length;\n      return s2 < (e ?? 1) ? A$4(i, e ? \"minContains\" : \"contains\", `Expected array to contain at least ${e ?? 1}, but found ${s2}`, r2) : t !== void 0 && s2 > t ? A$4(i, \"maxContains\", `Expected array to contain at most ${t}, but found ${s2}`, r2) : g$1();\n    }, \"El\");\n    Tl = /* @__PURE__ */ __name(({ prefixItems: n252 = [] }, e, t = {}) => {\n      if (!Be$2(e)) return g$1();\n      for (let r2 = 0; r2 < e.length; r2++) {\n        let i = n252[r2]?.validate(e[r2], pt$1(t, String(r2), String(r2)));\n        if (i && i?.valid !== true) return i;\n      }\n      return g$1();\n    }, \"Tl\");\n    To = { email: /* @__PURE__ */ __name((n252) => {\n      if (n252.length > 318) return false;\n      if (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(n252)) return true;\n      if (!n252.includes(\"@\") || /(^\\.|^\"|\\.@|\\.\\.)/.test(n252)) return false;\n      let [e, t, ...r2] = n252.split(\"@\");\n      return !e || !t || r2.length !== 0 || e.length > 64 || t.length > 253 || !/^[a-z0-9.-]+$/i.test(t) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(e) ? false : t.split(\".\").every((i) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(i));\n    }, \"email\"), hostname: /* @__PURE__ */ __name((n252) => n252.length > (n252.endsWith(\".\") ? 254 : 253) ? false : /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\\.?$/i.test(n252), \"hostname\"), date: /* @__PURE__ */ __name((n252) => {\n      if (n252.length !== 10) return false;\n      if (n252[5] === \"0\" && n252[6] === \"2\") {\n        if (/^\\d\\d\\d\\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(n252)) return true;\n        let e = n252.match(/^(\\d\\d\\d\\d)-02-29$/);\n        if (!e) return false;\n        let t = Number(e[1]);\n        return t % 16 === 0 || t % 4 === 0 && t % 25 !== 0;\n      }\n      return n252.endsWith(\"31\") ? /^\\d\\d\\d\\d-(?:0[13578]|1[02])-31$/.test(n252) : /^\\d\\d\\d\\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(n252);\n    }, \"date\"), time: /* @__PURE__ */ __name((n252) => {\n      if (n252.length > 27 || !/^(?:2[0-3]|[0-1]\\d):[0-5]\\d:(?:[0-5]\\d|60)(?:\\.\\d+)?(?:z|[+-](?:2[0-3]|[0-1]\\d)(?::?[0-5]\\d)?)?$/i.test(n252)) return false;\n      if (!/:60/.test(n252)) return true;\n      let e = n252.match(/([0-9.]+|[^0-9.])/g);\n      if (!e) return false;\n      let t = Number(e[0]) * 60 + Number(e[2]);\n      return e[5] === \"+\" ? t += 24 * 60 - Number(e[6] || 0) * 60 - Number(e[8] || 0) : e[5] === \"-\" && (t += Number(e[6] || 0) * 60 + Number(e[8] || 0)), t % (24 * 60) === 23 * 60 + 59;\n    }, \"time\"), \"date-time\": /* @__PURE__ */ __name((n252) => {\n      if (n252.length > 38) return false;\n      let e = /^\\d\\d\\d\\d-(?:0[1-9]|1[0-2])-(?:[0-2]\\d|3[01])[t\\s](?:2[0-3]|[0-1]\\d):[0-5]\\d:(?:[0-5]\\d|60)(?:\\.\\d+)?(?:z|[+-](?:2[0-3]|[0-1]\\d)(?::?[0-5]\\d)?)$/i, t = n252[5] === \"0\" && n252[6] === \"2\";\n      if (t && n252[8] === \"3\" || !e.test(n252)) return false;\n      if (n252[17] === \"6\") {\n        let r2 = n252.slice(11).match(/([0-9.]+|[^0-9.])/g);\n        if (!r2) return false;\n        let i = Number(r2[0]) * 60 + Number(r2[2]);\n        if (r2[5] === \"+\" ? i += 24 * 60 - Number(r2[6] || 0) * 60 - Number(r2[8] || 0) : r2[5] === \"-\" && (i += Number(r2[6] || 0) * 60 + Number(r2[8] || 0)), i % (24 * 60) !== 23 * 60 + 59) return false;\n      }\n      if (t) {\n        if (/^\\d\\d\\d\\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(n252)) return true;\n        let r2 = n252.match(/^(\\d\\d\\d\\d)-02-29/);\n        if (!r2) return false;\n        let i = Number(r2[1] ?? 0);\n        return i % 16 === 0 || i % 4 === 0 && i % 25 !== 0;\n      }\n      return n252[8] === \"3\" && n252[9] === \"1\" ? /^\\d\\d\\d\\d-(?:0[13578]|1[02])-31/.test(n252) : /^\\d\\d\\d\\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(n252);\n    }, \"date-time\"), ipv4: /* @__PURE__ */ __name((n252) => n252.length <= 15 && /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)$/.test(n252), \"ipv4\"), ipv6: /* @__PURE__ */ __name((n252) => {\n      if (n252.length > 45 || n252.length < 2) return false;\n      let e = 0, t = 0, r2 = 0, i = false, s2 = false, o = 0, c = true;\n      for (let l2 = 0; l2 < n252.length; l2++) {\n        let p2 = n252.charCodeAt(l2);\n        if (l2 === 1 && o === 58 && p2 !== 58) return false;\n        if (p2 >= 48 && p2 <= 57) {\n          if (++r2 > 4) return false;\n        } else if (p2 === 46) {\n          if (e > 6 || t >= 3 || r2 === 0 || s2) return false;\n          t++, r2 = 0;\n        } else if (p2 === 58) {\n          if (t > 0 || e >= 7) return false;\n          if (o === 58) {\n            if (i) return false;\n            i = true;\n          } else l2 === 0 && (c = false);\n          e++, r2 = 0, s2 = false;\n        } else if (p2 >= 97 && p2 <= 102 || p2 >= 65 && p2 <= 70) {\n          if (t > 0 || ++r2 > 4) return false;\n          s2 = true;\n        } else return false;\n        o = p2;\n      }\n      if (e < 2 || t > 0 && (t !== 3 || r2 === 0)) return false;\n      if (i && n252.length === 2) return true;\n      if (t > 0 && !/(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}$/.test(n252)) return false;\n      let a2 = t > 0 ? 6 : 7;\n      return i ? (c || r2 > 0) && e < a2 : e === a2 && c && r2 > 0;\n    }, \"ipv6\"), uri: /* @__PURE__ */ __name((n252) => /^[a-z][a-z0-9+\\-.]*:(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/?(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i.test(n252), \"uri\"), \"uri-reference\": /* @__PURE__ */ __name((n252) => /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/?(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i.test(n252), \"uri-reference\"), \"uri-template\": /* @__PURE__ */ __name((n252) => /^(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2}|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i.test(n252), \"uri-template\"), \"json-pointer\": /* @__PURE__ */ __name((n252) => /^(?:|\\/(?:[^~]|~0|~1)*)$/.test(n252), \"json-pointer\"), \"relative-json-pointer\": /* @__PURE__ */ __name((n252) => /^(?:0|[1-9][0-9]*)(?:|#|\\/(?:[^~]|~0|~1)*)$/.test(n252), \"relative-json-pointer\"), uuid: /* @__PURE__ */ __name((n252) => /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(n252), \"uuid\"), duration: /* @__PURE__ */ __name((n252) => n252.length > 1 && n252.length < 80 && (/^P\\d+([.,]\\d+)?W$/.test(n252) || /^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(n252) && /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(n252)), \"duration\"), regex: /* @__PURE__ */ __name((n252) => {\n      if (/[^\\\\]\\\\Z/.test(n252)) return false;\n      try {\n        return new RegExp(n252, \"u\"), true;\n      } catch {\n        return false;\n      }\n    }, \"regex\") };\n    Sl = /* @__PURE__ */ __name(({ format: n252 }, e, t = {}) => !_e$2(e) || !n252 ? g$1() : To[n252] ? To[n252](e) ? g$1() : A$4(t, \"format\", `Expected format: ${n252}`, e) : g$1(), \"Sl\");\n    ji$1 = class ji {\n      static {\n        __name(this, \"ji\");\n      }\n      constructor(n252) {\n        this.root = n252, this.cache = /* @__PURE__ */ new Map();\n      }\n      cache;\n      hasRef(n252, e) {\n        return e !== void 0 && \"$ref\" in n252 && _e$2(n252.$ref);\n      }\n      resolve(n252) {\n        let e = this.cache.get(n252);\n        if (!e) {\n          if (e = Jc(this.root, n252), !le$2(e)) throw new Error(`ref not found: ${n252}`);\n          if (\"$ref\" in e && e.$ref === n252) throw new Error(`ref loop: ${n252}`);\n          this.cache.set(n252, e);\n        }\n        return e;\n      }\n    };\n    vl = { type: zc, const: Gc, enum: Vc, allOf: Yc, anyOf: Wc, oneOf: Hc, not: Xc, minLength: tl, maxLength: rl, pattern: el, format: Sl, minimum: ol, exclusiveMinimum: al, maximum: il, exclusiveMaximum: sl, multipleOf: nl, required: ul, dependentRequired: pl, dependentSchemas: dl, minProperties: ml, maxProperties: fl, propertyNames: hl, properties: cl, patternProperties: yl, additionalProperties: ll, minItems: bl, maxItems: xl, uniqueItems: wl, contains: El, prefixItems: Tl, items: gl, if: Zc };\n    __name(Ol, \"Ol\");\n    __name(Rl, \"Rl\");\n    B$4 = /* @__PURE__ */ __name((n252 = {}, e = \"any\") => {\n      let t = J$2(n252) ? n252 : {}, r2 = _t$1(n252) ? n252 : at$1 in n252 ? n252[at$1] : void 0, i = { ...t, [ki$1]: e, [at$1]: r2, optional: /* @__PURE__ */ __name(function() {\n        return B$4({ ...this, validate: void 0, [at$1]: r2, [Pi$1]: true }, e);\n      }, \"optional\"), template: /* @__PURE__ */ __name(function(s2 = {}) {\n        if (t.const !== void 0) return t.const;\n        if (t.default !== void 0) return t.default;\n        if (t.enum !== void 0) return t.enum[0];\n        if (t.template) return t.template(s2);\n      }, \"template\"), toJSON: /* @__PURE__ */ __name(function() {\n        let s2 = this[at$1];\n        return _t$1(s2) ? s2 : JSON.parse(JSON.stringify(t));\n      }, \"toJSON\") };\n      return i.coerce = function(s2, o = {}) {\n        let c = { ...o, resolver: o.resolver || new ji$1(i), depth: o.depth ? o.depth + 1 : 0 }, a2 = s2;\n        return \"coerce\" in t && t.coerce !== void 0 ? t.coerce(a2, c) : Rl(i, a2, c);\n      }, i.validate = function(s2, o = {}) {\n        if (_t$1(r2)) return r2 === false ? A$4(o, \"\", \"Always fails\") : g$1();\n        let c = o.errors || [];\n        if (\"validate\" in t && t.validate !== void 0) {\n          let a2 = t.validate(s2, o);\n          a2.valid || (c = [...c, ...a2.errors]);\n        }\n        return Ol(i, s2, { ...o, errors: c });\n      }, i;\n    }, \"B$4\");\n    Cl = /* @__PURE__ */ __name((n252 = {}) => B$4(n252, \"any\"), \"Cl\");\n    dr = /* @__PURE__ */ __name((n252, e = {}) => {\n      for (let r2 of Object.keys(n252 || {})) Fi$1(Nc(r2), \"invalid property name\", r2), Fi$1(le$2(n252[r2]), \"properties must be managed schemas\", n252[r2]);\n      let t = Object.entries(n252 || {}).filter(([, r2]) => !(Pi$1 in r2)).map(([r2]) => r2);\n      return B$4({ template: Ro, coerce: Co, ...e, type: \"object\", properties: n252, required: t.length > 0 ? t : void 0 }, \"object\");\n    }, \"dr\");\n    Al = /* @__PURE__ */ __name((n252, e = {}) => dr(n252, { ...e, additionalProperties: B$4(false) }), \"Al\");\n    Fl = /* @__PURE__ */ __name((n252, e = {}) => {\n      let t = Object.fromEntries(Object.entries(n252).map(([r2, i]) => [r2, \"optional\" in i ? i.optional() : i]));\n      return dr(t, e);\n    }, \"Fl\");\n    _l = /* @__PURE__ */ __name((n252, e = {}, t) => B$4({ template: Ro, coerce: Co, ...e, type: \"object\", additionalProperties: dr(n252, t) }, \"object\"), \"_l\");\n    __name(Ro, \"Ro\");\n    __name(Co, \"Co\");\n    Ao = /* @__PURE__ */ __name((n252 = {}) => B$4({ template: /* @__PURE__ */ __name(() => \"\", \"template\"), coerce: /* @__PURE__ */ __name((e) => qe$2(e) ? String(e) : e, \"coerce\"), ...n252, type: \"string\" }, \"string\"), \"Ao\");\n    kl = /* @__PURE__ */ __name((n252, e = {}) => B$4({ const: n252, default: n252, readOnly: true, template: /* @__PURE__ */ __name(() => n252, \"template\"), coerce: /* @__PURE__ */ __name((t) => String(t), \"coerce\"), ...e, type: \"string\" }, \"string\"), \"kl\");\n    Fo = /* @__PURE__ */ __name((n252 = {}) => B$4({ coerce: /* @__PURE__ */ __name((e) => _e$2(e) ? Number(e) : e, \"coerce\"), template: ko$1, ...n252, type: \"number\" }, \"number\"), \"Fo\");\n    _o = /* @__PURE__ */ __name((n252 = {}) => B$4({ coerce: /* @__PURE__ */ __name((e) => _e$2(e) ? Number.parseInt(e) : e, \"coerce\"), template: ko$1, ...n252, type: \"integer\" }, \"integer\"), \"_o\");\n    __name(ko$1, \"ko$1\");\n    Po = /* @__PURE__ */ __name((n252, e = {}) => (n252 !== void 0 && Fi$1(le$2(n252), \"items must be a schema\", n252), B$4({ template: /* @__PURE__ */ __name(() => [], \"template\"), coerce: Pl, ...e, type: \"array\", items: n252 }, \"array\")), \"Po\");\n    __name(Pl, \"Pl\");\n    jo$1 = /* @__PURE__ */ __name((n252 = {}) => B$4({ ...n252, coerce: /* @__PURE__ */ __name(function(e) {\n      if (\"coerce\" in n252 && n252.coerce) return n252.coerce(e);\n      if (_e$2(e) && [\"true\", \"false\", \"1\", \"0\"].includes(e)) return e === \"true\" || e === \"1\";\n      if (qe$2(e)) {\n        if (e === 1) return true;\n        if (e === 0) return false;\n      }\n      return e;\n    }, \"coerce\"), type: \"boolean\" }, \"boolean\"), \"jo$1\");\n    __name(So, \"So\");\n    __name(vo, \"vo\");\n    __name(ct$1, \"ct$1\");\n    jl = /* @__PURE__ */ __name((n252, e = {}) => B$4({ ...e, coerce: /* @__PURE__ */ __name(function(t, r2 = {}) {\n      let i = t;\n      if (\"coerce\" in e && e.coerce !== void 0) return e.coerce.bind(this)(t, r2);\n      let s2 = ur(n252, i, { ignoreUnsupported: true, resolver: r2.resolver, coerce: true });\n      return s2.length > 0 ? s2[0].coerce(i, r2) : i;\n    }, \"coerce\"), anyOf: n252 }, \"anyOf\"), \"jl\");\n    Ml = /* @__PURE__ */ __name((n252, e = {}) => B$4({ ...e, coerce: /* @__PURE__ */ __name(function(t, r2 = {}) {\n      let i = ur(n252, t, { ignoreUnsupported: true, resolver: r2.resolver, coerce: true });\n      return i.length === 1 ? i[0].coerce(t, r2) : t;\n    }, \"coerce\"), oneOf: n252 }, \"oneOf\"), \"Ml\");\n    Il = /* @__PURE__ */ __name((n252, e) => {\n      if (!n252.$id) throw new Error(\"Schema must have an $id\");\n      return B$4({ $ref: e ?? n252.$id, coerce: /* @__PURE__ */ __name(function(t, r2 = {}) {\n        return n252.coerce(t, r2);\n      }, \"coerce\") }, \"ref\");\n    }, \"Il\");\n    Dl = /* @__PURE__ */ __name((n252) => B$4({ $ref: n252 }, \"ref\"), \"Dl\");\n    $l = /* @__PURE__ */ __name((n252) => {\n      let { validate: e, ...t } = n252(B$4({ $ref: \"#\" }, \"recursive\"));\n      return B$4(t, \"recursive\");\n    }, \"$l\");\n    Xr$1 = Symbol.for(\"jsonv\");\n    T$1 = /* @__PURE__ */ __name((n252, e, t, r2) => {\n      let i = validator(n252, async (s2, o) => {\n        let c = t?.coerce !== false ? e.coerce(s2) : s2, a2 = e.validate(c);\n        if (!a2.valid) return o.json({ ...a2, schema: e }, 400);\n        return c;\n      });\n      return t?.skipOpenAPI ? i : Object.assign(i, { [Xr$1]: { type: \"parameters\", value: { target: n252, schema: e } } });\n    }, \"T$1\");\n    __name(Bl, \"Bl\");\n    __name(Nl, \"Nl\");\n    __name(Ii$1, \"Ii$1\");\n    Ul = { query: \"query\", param: \"path\", header: \"header\", cookie: \"cookie\" };\n    Ll = { json: { type: \"application/json\" }, form: { type: \"multipart/form-data\" } };\n    __name(Zr$1, \"Zr$1\");\n    Ql = /* @__PURE__ */ __name((n252) => n252.split(\"/\").map((e) => {\n      let t = e;\n      if (t.startsWith(\":\")) {\n        let r2 = t.match(/^:([^{?]+)(?:{(.+)})?(\\?)?$/);\n        r2 ? t = `{${r2[1]}}` : (t = t.slice(1, t.length), t.endsWith(\"?\") && (t = t.slice(0, -1)), t = `{${t}}`);\n      }\n      return t;\n    }).join(\"/\"), \"Ql\");\n    Mo$1 = /* @__PURE__ */ __name((n252) => n252.charAt(0).toUpperCase() + n252.slice(1), \"Mo$1\");\n    Mi$1 = /* @__PURE__ */ new Map();\n    Kl = /* @__PURE__ */ __name((n252, e) => {\n      let t = `${n252}:${e}`;\n      if (Mi$1.has(t)) return Mi$1.get(t);\n      let r2 = n252;\n      if (e === \"/\") return `${r2}Index`;\n      for (let i of e.split(\"/\")) i.charCodeAt(0) === 123 ? r2 += `By${Mo$1(i.slice(1, -1))}` : r2 += Mo$1(i);\n      return Mi$1.set(t, r2), r2;\n    }, \"Kl\");\n    Di$1 = /* @__PURE__ */ __name((n252, e = {}) => {\n      let t = false;\n      return async (r2) => {\n        if (!t) {\n          t = true, e.paths = e.paths ?? {};\n          for (let i of n252.routes) if (Xr$1 in i.handler) {\n            let s2 = i.method.toLowerCase(), o = Ql(i.path), { type: c, value: a2 } = i.handler[Xr$1];\n            e.paths[o] || (e.paths[o] = {}), e.paths[o][s2] || (e.paths[o][s2] = { responses: {}, operationId: Kl(s2, o) });\n            let l2 = e.paths[o][s2];\n            switch (c) {\n              case \"parameters\":\n                let { parameters: p2, requestBody: u3 } = Zr$1(a2.schema, a2.target);\n                p2 && (l2.parameters || (l2.parameters = []), l2.parameters.push(...p2.filter((d2) => {\n                  try {\n                    return !l2.parameters.some((y3) => y3.name === d2.name && y3.in === d2.in);\n                  } catch {\n                    return true;\n                  }\n                }))), u3 && (l2.requestBody || (l2.requestBody = {}), Ii$1(l2.requestBody, u3));\n                break;\n              case \"route-doc\":\n                Ii$1(e.paths[o][s2], a2);\n                break;\n            }\n          }\n        }\n        return r2.json({ openapi: \"3.1.0\", info: { title: \"API\", ...e.info }, ...e });\n      };\n    }, \"Di$1\");\n    S$2 = /* @__PURE__ */ __name((n252) => Object.assign(async (e, t) => {\n      await t();\n    }, { [Xr$1]: { type: \"route-doc\", value: n252 } }), \"S$2\");\n    M$3 = class M {\n      static {\n        __name(this, \"M\");\n      }\n      _returning;\n      static slug = \"untitled-event\";\n      params;\n      returned = false;\n      validate(e) {\n        throw new $i$1(this, e);\n      }\n      clone(e) {\n        let t = new this.constructor(e);\n        return t.returned = true, t;\n      }\n      constructor(e) {\n        this.params = e;\n      }\n    };\n    ke$2 = class ke extends Error {\n      static {\n        __name(this, \"ke\");\n      }\n      constructor(e, t) {\n        super(`Expected \"${e}\", got \"${t}\"`);\n      }\n    };\n    $i$1 = class $i extends Error {\n      static {\n        __name(this, \"$i\");\n      }\n      constructor(t, r2) {\n        super(`Event \"${t.constructor.slug}\" returned without validation`);\n        this.data = r2;\n      }\n    };\n    en$1 = class en {\n      static {\n        __name(this, \"en\");\n      }\n      mode = \"async\";\n      event;\n      handler;\n      once = false;\n      id;\n      constructor(e, t, r2 = \"async\", i) {\n        this.event = e, this.handler = t, this.mode = r2, this.id = i;\n      }\n    };\n    V$2 = class V {\n      static {\n        __name(this, \"V\");\n      }\n      constructor(e, t) {\n        this.options = t;\n        e && this.registerEvents(e), t?.listeners?.forEach((r2) => this.addListener(r2));\n      }\n      events = [];\n      listeners = [];\n      enabled = true;\n      asyncs = [];\n      enable() {\n        return this.enabled = true, this;\n      }\n      disable() {\n        return this.enabled = false, this;\n      }\n      clearEvents() {\n        return this.events = [], this;\n      }\n      clearAll() {\n        return this.clearEvents(), this.listeners = [], this;\n      }\n      getListeners() {\n        return [...this.listeners];\n      }\n      get Events() {\n        return new Proxy(this, { get: /* @__PURE__ */ __name((e, t) => this.events.find((r2) => r2.slug === t), \"get\") });\n      }\n      eventExists(e) {\n        let t;\n        return typeof e == \"string\" ? t = e : t = e.constructor?.slug ?? e.slug, !!this.events.find((r2) => t === r2.slug);\n      }\n      throwIfEventNotRegistered(e) {\n        if (!this.eventExists(e)) {\n          let t = e.constructor?.slug ?? e.slug ?? e;\n          throw new Error(`Event \"${t}\" not registered`);\n        }\n      }\n      registerEvent(e, t = false) {\n        if (this.eventExists(e)) {\n          if (t) return this;\n          throw new Error(`Event \"${e.name}\" already registered.`);\n        }\n        return this.events.push(e), this;\n      }\n      registerEvents(e) {\n        return (typeof e == \"object\" ? Object.values(e) : e).forEach((r2) => this.registerEvent(r2, true)), this;\n      }\n      addListener(e) {\n        return this.throwIfEventNotRegistered(e.event), e.id && this.listeners.find((r2) => r2.id === e.id) ? (m$1.debug(`Listener with id \"${e.id}\" already exists.`), this) : (this.listeners.push(e), this);\n      }\n      createEventListener(e, t, r2 = \"async\") {\n        let i = typeof e == \"string\" ? this.events.find((c) => c.slug === e) : e, s2 = typeof r2 == \"string\" ? { mode: r2 } : r2, o = new en$1(i, t, s2.mode);\n        s2.once && (o.once = true), s2.id && (o.id = `${i.slug}-${s2.id}`), this.addListener(o);\n      }\n      onEvent(e, t, r2) {\n        this.createEventListener(e, t, r2);\n      }\n      on(e, t, r2) {\n        this.createEventListener(e, t, r2);\n      }\n      onAny(e, t) {\n        this.events.forEach((r2) => this.onEvent(r2, e, t));\n      }\n      collectAsyncs(e) {\n        this.asyncs.push(...e);\n      }\n      async executeAsyncs(e = (t) => Promise.all(t)) {\n        if (this.asyncs.length === 0) return;\n        let t = [...this.asyncs];\n        this.asyncs = [], await e(t.map((r2) => r2()));\n      }\n      async emit(e) {\n        let t = e.constructor.slug;\n        if (!this.enabled) return m$1.debug(\"EventManager disabled, not emitting\", t), e;\n        if (!this.eventExists(e)) throw new Error(`Event \"${t}\" not registered`);\n        let r2 = [], i = [];\n        this.listeners = this.listeners.filter((o) => o.event.slug !== t ? true : (o.mode === \"sync\" ? r2.push(o) : i.push(async () => await o.handler(e, o.event.slug)), !o.once)), this.collectAsyncs(i);\n        let s2 = e;\n        for (let o of r2) try {\n          let c = await o.handler(s2, o.event.slug);\n          if (typeof c < \"u\") {\n            let a2 = s2.validate(c);\n            if (a2 && a2.constructor.slug === t) {\n              if (!a2.returned) throw new Error(`Returned event ${a2.constructor.slug} must be marked as returned.`);\n              s2 = a2;\n            }\n          }\n        } catch (c) {\n          if (c instanceof ke$2) this.options?.onInvalidReturn?.(s2, c), m$1.warn(`Invalid return of event listener for \"${t}\": ${c.message}`);\n          else if (this.options?.onError) this.options.onError(s2, c);\n          else throw c;\n        }\n        return s2;\n      }\n    };\n    qi$1 = class qi extends M$3 {\n      static {\n        __name(this, \"qi\");\n      }\n      static slug = \"mutator-insert-before\";\n      validate(e) {\n        let { entity: t } = this.params;\n        if (!t.isValidData(e, \"create\")) throw m$1.warn(\"MutatorInsertBefore.validate: invalid\", { entity: t.name, data: e }), new ke$2(\"EntityData\", \"invalid\");\n        return this.clone({ entity: t, data: e });\n      }\n    };\n    Bi$1 = class Bi extends M$3 {\n      static {\n        __name(this, \"Bi\");\n      }\n      static slug = \"mutator-insert-after\";\n    };\n    Ni$1 = class Ni extends M$3 {\n      static {\n        __name(this, \"Ni\");\n      }\n      static slug = \"mutator-update-before\";\n      validate(e) {\n        let { entity: t, entityId: r2 } = this.params;\n        if (!t.isValidData(e, \"update\")) throw m$1.warn(\"MutatorUpdateBefore.validate: invalid\", { entity: t.name, entityId: r2, data: e }), new ke$2(\"EntityData\", \"invalid\");\n        return this.clone({ entityId: r2, entity: t, data: e });\n      }\n    };\n    Ui$1 = class Ui extends M$3 {\n      static {\n        __name(this, \"Ui\");\n      }\n      static slug = \"mutator-update-after\";\n    };\n    Li$1 = class Li extends M$3 {\n      static {\n        __name(this, \"Li\");\n      }\n      static slug = \"mutator-delete-before\";\n    };\n    Qi$1 = class Qi extends M$3 {\n      static {\n        __name(this, \"Qi\");\n      }\n      static slug = \"mutator-delete-after\";\n    };\n    Ne$2 = { MutatorInsertBefore: qi$1, MutatorInsertAfter: Bi$1, MutatorUpdateBefore: Ni$1, MutatorUpdateAfter: Ui$1, MutatorDeleteBefore: Li$1, MutatorDeleteAfter: Qi$1 };\n    Ki$1 = class Ki extends M$3 {\n      static {\n        __name(this, \"Ki\");\n      }\n      static slug = \"repository-find-one-before\";\n    };\n    Ji$1 = class Ji extends M$3 {\n      static {\n        __name(this, \"Ji\");\n      }\n      static slug = \"repository-find-one-after\";\n    };\n    zi$1 = class zi extends M$3 {\n      static {\n        __name(this, \"zi\");\n      }\n      static slug = \"repository-find-many-before\";\n      static another = \"one\";\n    };\n    Gi$1 = class Gi extends M$3 {\n      static {\n        __name(this, \"Gi\");\n      }\n      static slug = \"repository-find-many-after\";\n    };\n    kt$1 = { RepositoryFindOneBefore: Ki$1, RepositoryFindOneAfter: Ji$1, RepositoryFindManyBefore: zi$1, RepositoryFindManyAfter: Gi$1 };\n    tn$1 = class tn extends I$1 {\n      static {\n        __name(this, \"tn\");\n      }\n      name = \"UnableToConnectException\";\n      code = 500;\n    };\n    ne$1 = class ne extends I$1 {\n      static {\n        __name(this, \"ne\");\n      }\n      name = \"InvalidSearchParamsException\";\n      code = 422;\n    };\n    rn$1 = class rn extends I$1 {\n      static {\n        __name(this, \"rn\");\n      }\n      name = \"TransformRetrieveFailedException\";\n      code = 422;\n    };\n    D$4 = class n2 extends I$1 {\n      static {\n        __name(this, \"n2\");\n      }\n      name = \"TransformPersistFailedException\";\n      code = 422;\n      static invalidType(e, t, r2) {\n        let i = typeof r2 == \"object\" ? JSON.stringify(r2) : r2, s2 = `Property \"${e}\" must be of type \"${t}\", \"${i}\" of type \"${typeof r2}\" given.`;\n        return new n2(s2);\n      }\n      static required(e) {\n        return new n2(`Property \"${e}\" is required`);\n      }\n    };\n    nn$1 = class nn extends I$1 {\n      static {\n        __name(this, \"nn\");\n      }\n      constructor(t, r2, i) {\n        console.error(\"InvalidFieldConfigException\", { given: r2, error: i.firstToString() });\n        super(`Invalid Field config given for field \"${t.name}\": ${i.firstToString()}`);\n        this.given = r2;\n      }\n      name = \"InvalidFieldConfigException\";\n      code = 400;\n    };\n    sn$1 = class sn extends I$1 {\n      static {\n        __name(this, \"sn\");\n      }\n      name = \"EntityNotDefinedException\";\n      code = 400;\n      constructor(e) {\n        e ? super(`Entity \"${typeof e != \"string\" ? e.name : e}\" not defined`) : super(\"Cannot find an entity that is undefined\");\n      }\n    };\n    ({ Type: q$2 } = p$1);\n    zl = [\"create\", \"read\", \"update\", \"delete\"];\n    Gl = [\"create\", \"read\", \"update\", \"delete\", \"form\", \"table\", \"submit\"];\n    Vl = false;\n    Vi$1 = true;\n    Wi$1 = false;\n    N$3 = q$2.Object({ label: q$2.Optional(q$2.String()), description: q$2.Optional(q$2.String()), required: q$2.Optional(q$2.Boolean({ default: Vl })), fillable: q$2.Optional(q$2.Union([q$2.Boolean({ title: \"Boolean\", default: Vi$1 }), q$2.Array(w$4(zl), { title: \"Context\", uniqueItems: true })], { default: Vi$1 })), hidden: q$2.Optional(q$2.Union([q$2.Boolean({ title: \"Boolean\", default: Wi$1 }), q$2.Array(w$4(Gl), { title: \"Context\", uniqueItems: true })], { default: Wi$1 })), virtual: q$2.Optional(q$2.Boolean()), default_value: q$2.Optional(q$2.Any()) }, { additionalProperties: false });\n    P$3 = class P {\n      static {\n        __name(this, \"P\");\n      }\n      _required;\n      _type;\n      name;\n      type = \"field\";\n      config;\n      constructor(e, t) {\n        this.name = e, this._type, this._required;\n        try {\n          this.config = _$2(this.getSchema(), t || {});\n        } catch (r2) {\n          throw r2 instanceof De$2 ? new nn$1(this, t, r2) : r2;\n        }\n      }\n      getType() {\n        return this.type;\n      }\n      schema() {\n        return Object.freeze({ name: this.name, type: \"text\", nullable: true, dflt: this.getDefault() });\n      }\n      hasDefault() {\n        return this.config.default_value !== void 0;\n      }\n      getDefault() {\n        return this.config?.default_value;\n      }\n      isFillable(e) {\n        return Array.isArray(this.config.fillable) ? e ? this.config.fillable.includes(e) : Vi$1 : !!this.config.fillable;\n      }\n      isHidden(e) {\n        return Array.isArray(this.config.hidden) ? e ? this.config.hidden.includes(e) : Wi$1 : this.config.hidden ?? false;\n      }\n      isRequired() {\n        return this.config?.required ?? false;\n      }\n      isVirtual() {\n        return this.config.virtual ?? false;\n      }\n      getLabel(e) {\n        return this.config.label ? this.config.label : e?.fallback !== false ? Ot$1(this.name) : void 0;\n      }\n      getDescription() {\n        return this.config.description;\n      }\n      getValue(e, t) {\n        return e;\n      }\n      getHtmlConfig() {\n        return { element: \"input\", props: { type: \"text\" } };\n      }\n      isValid(e, t) {\n        return typeof e < \"u\" ? this.isFillable(t) : t === \"create\" ? !this.isRequired() : true;\n      }\n      transformRetrieve(e) {\n        return e;\n      }\n      async transformPersist(e, t, r2) {\n        if (this.nullish(e)) {\n          if (this.isRequired() && !this.hasDefault()) throw D$4.required(this.name);\n          return this.getDefault();\n        }\n        return e;\n      }\n      toSchemaWrapIfRequired(e) {\n        return this.isRequired() ? e : q$2.Optional(e);\n      }\n      nullish(e) {\n        return e == null;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(q$2.Any());\n      }\n      toType() {\n        return { required: this.isRequired(), comment: this.getDescription(), type: \"any\" };\n      }\n      toJSON() {\n        return { type: this.type, config: this.config };\n      }\n    };\n    ({ Type: mr$1 } = p$1);\n    Hi$1 = mr$1.Composite([mr$1.Object({ default_value: mr$1.Optional(mr$1.Boolean({ default: false })) }), N$3]);\n    Pt$1 = class Pt extends P$3 {\n      static {\n        __name(this, \"Pt\");\n      }\n      type = \"boolean\";\n      getSchema() {\n        return Hi$1;\n      }\n      getValue(e, t) {\n        switch (t) {\n          case \"table\":\n            return e ? \"Yes\" : \"No\";\n          default:\n            return e;\n        }\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: \"boolean\" });\n      }\n      getHtmlConfig() {\n        return { ...super.getHtmlConfig(), element: \"boolean\" };\n      }\n      transformRetrieve(e) {\n        return typeof e > \"u\" || e === null ? this.isRequired() ? false : this.hasDefault() ? this.getDefault() : null : typeof e == \"string\" ? e === \"1\" : !!e;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return this.isRequired() ? !!this.config.default_value : void 0;\n        if (typeof i == \"number\") return i !== 0;\n        if (typeof i != \"boolean\") throw D$4.invalidType(this.name, \"boolean\", i);\n        return i;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(mr$1.Boolean({ default: this.getDefault() }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"boolean\" };\n      }\n    };\n    ({ Type: Ue$2 } = p$1);\n    Yi$1 = Ue$2.Composite([Ue$2.Object({ type: w$4([\"date\", \"datetime\", \"week\"], { default: \"date\" }), timezone: Ue$2.Optional(Ue$2.String()), min_date: Ue$2.Optional(Ue$2.String()), max_date: Ue$2.Optional(Ue$2.String()) }), N$3], { additionalProperties: false });\n    ut$1 = class ut extends P$3 {\n      static {\n        __name(this, \"ut\");\n      }\n      type = \"date\";\n      getSchema() {\n        return Yi$1;\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: this.config.type === \"datetime\" ? \"datetime\" : \"date\" });\n      }\n      getHtmlConfig() {\n        let e = this.config.type === \"datetime\" ? \"datetime-local\" : this.config.type;\n        return { ...super.getHtmlConfig(), element: \"date\", props: { type: e } };\n      }\n      parseDateFromString(e) {\n        if (this.config.type === \"week\" && e.includes(\"-W\")) {\n          let [t, r2] = e.split(\"-W\").map((i) => Number.parseInt(i, 10));\n          return ze$2().year(t).week(r2).toDate();\n        }\n        return new Date(e);\n      }\n      getValue(e, t) {\n        if (e === null || !e) return;\n        let r2 = this.parseDateFromString(e);\n        if (t === \"submit\") try {\n          return r2.toISOString();\n        } catch {\n          return;\n        }\n        if (this.config.type === \"week\") try {\n          return `${r2.getFullYear()}-W${ze$2(r2).week()}`;\n        } catch (i) {\n          m$1.warn(\"DateField.getValue:week error\", e, String(i));\n          return;\n        }\n        try {\n          let s2 = (/* @__PURE__ */ new Date()).getTimezoneOffset(), o = new Date(r2.getTime() - s2 * 6e4);\n          return this.formatDate(o);\n        } catch (i) {\n          m$1.warn(\"DateField.getValue error\", this.config.type, e, String(i));\n          return;\n        }\n      }\n      formatDate(e) {\n        switch (this.config.type) {\n          case \"datetime\":\n            return e.toISOString().split(\".\")[0].replace(\"T\", \" \");\n          default:\n            return e.toISOString().split(\"T\")[0];\n        }\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        if (t === null) return null;\n        try {\n          return new Date(t);\n        } catch {\n          return null;\n        }\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        switch (this.config.type) {\n          case \"date\":\n          case \"week\":\n            return new Date(i).toISOString().split(\"T\")[0];\n          default:\n            return new Date(i).toISOString();\n        }\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(Ue$2.String({ default: this.getDefault() }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"Date | string\" };\n      }\n    };\n    ({ Type: X$3 } = p$1);\n    Xi$1 = X$3.Composite([X$3.Object({ default_value: X$3.Optional(X$3.String()), options: X$3.Optional(X$3.Union([X$3.Object({ type: be$2(\"strings\"), values: X$3.Array(X$3.String()) }, { title: \"Strings\" }), X$3.Object({ type: be$2(\"objects\"), values: X$3.Array(X$3.Object({ label: X$3.String(), value: X$3.String() })) }, { title: \"Objects\", additionalProperties: false })])) }), N$3], { additionalProperties: false });\n    jt$1 = class jt extends P$3 {\n      static {\n        __name(this, \"jt\");\n      }\n      type = \"enum\";\n      constructor(e, t) {\n        if (super(e, t), this.config.default_value && !this.isValidValue(this.config.default_value)) throw new Error(`Default value \"${this.config.default_value}\" is not a valid option`);\n      }\n      getSchema() {\n        return Xi$1;\n      }\n      getOptions() {\n        let e = this.config?.options ?? { type: \"strings\", values: [] };\n        return e.type === \"strings\" ? e.values?.map((t) => ({ label: t, value: t })) : e?.values;\n      }\n      isValidValue(e) {\n        return this.getOptions().map((r2) => r2.value).includes(e);\n      }\n      getValue(e, t) {\n        if (!this.isValidValue(e)) return this.hasDefault() ? this.getDefault() : null;\n        switch (t) {\n          case \"table\":\n            return this.getOptions().find((r2) => r2.value === e)?.label ?? e;\n        }\n        return e;\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        return t === null && this.hasDefault() ? this.getDefault() : this.isValidValue(t) ? t : this.hasDefault() ? this.getDefault() : null;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (!this.isValidValue(i)) throw new D$4(`Field \"${this.name}\" must be one of the following values: ${this.getOptions().map((s2) => s2.value).join(\", \")}`);\n        return i;\n      }\n      toJsonSchema() {\n        let t = (this.config?.options ?? { values: [] }).values?.map((r2) => typeof r2 == \"string\" ? r2 : r2.value) ?? [];\n        return this.toSchemaWrapIfRequired(w$4(t, { default: this.getDefault() }));\n      }\n      toType() {\n        let e = this.getOptions().map(({ value: t }) => typeof t == \"string\" ? `\"${t}\"` : t);\n        return { ...super.toType(), type: e.length > 0 ? e.join(\" | \") : \"string\" };\n      }\n    };\n    ({ Type: Io } = p$1);\n    Zi$1 = Io.Composite([N$3, Io.Object({})]);\n    Mt$1 = class Mt extends P$3 {\n      static {\n        __name(this, \"Mt\");\n      }\n      type = \"json\";\n      getSchema() {\n        return Zi$1;\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        return t === null && this.hasDefault() ? this.getDefault() : this.isSerialized(t) ? JSON.parse(t) : t;\n      }\n      isSerializable(e) {\n        try {\n          let t = JSON.stringify(e);\n          if (t === JSON.stringify(JSON.parse(t))) return true;\n        } catch {\n        }\n        return false;\n      }\n      isSerialized(e) {\n        try {\n          if (typeof e == \"string\") return e === JSON.stringify(JSON.parse(e));\n        } catch {\n        }\n        return false;\n      }\n      getValue(e, t) {\n        switch (t) {\n          case \"form\":\n            return e === null ? \"\" : JSON.stringify(e, null, 2);\n          case \"table\":\n            return e === null ? null : JSON.stringify(e);\n          case \"submit\":\n            return typeof e == \"string\" && e.length === 0 ? null : JSON.parse(e);\n        }\n        return e;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (!this.isSerializable(i)) throw new D$4(`Field \"${this.name}\" must be serializable to JSON.`);\n        return this.isSerialized(i) ? i : JSON.stringify(i);\n      }\n      toType() {\n        return { ...super.toType(), type: \"any\" };\n      }\n    };\n    ({ Type: dt$1 } = p$1);\n    es$1 = dt$1.Composite([dt$1.Object({ schema: dt$1.Object({}, { default: {} }), ui_schema: dt$1.Optional(dt$1.Object({})), default_from_schema: dt$1.Optional(dt$1.Boolean()) }), N$3], { additionalProperties: false });\n    It$1 = class It extends P$3 {\n      static {\n        __name(this, \"It\");\n      }\n      type = \"jsonschema\";\n      validator;\n      constructor(e, t) {\n        super(e, t), this.validator = new Validator(this.getJsonSchema());\n      }\n      getSchema() {\n        return es$1;\n      }\n      getJsonSchema() {\n        return this.config?.schema;\n      }\n      getJsonUiSchema() {\n        return this.config.ui_schema ?? {};\n      }\n      isValid(e, t = \"update\") {\n        return super.isValid(e, t) ? !this.isRequired() && (!e || typeof e != \"object\") ? true : this.validator.validate(e).valid : false;\n      }\n      getValue(e, t) {\n        switch (t) {\n          case \"form\":\n            return e === null ? \"\" : e;\n          case \"table\":\n            return e === null ? null : JSON.stringify(e);\n        }\n        return e;\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        if (t === null) {\n          if (this.config.default_from_schema) try {\n            return Default(We$3(this.getJsonSchema()), {});\n          } catch {\n            return null;\n          }\n          else if (this.hasDefault()) return this.getDefault();\n        }\n        return t;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (!this.isValid(i)) throw new D$4(this.name, i);\n        return !i || typeof i != \"object\" ? this.getDefault() : JSON.stringify(i);\n      }\n      toJsonSchema() {\n        let e = this.getJsonSchema() ?? { type: \"object\" };\n        return this.toSchemaWrapIfRequired(We$3({ default: this.getDefault(), ...e }));\n      }\n      toType() {\n        return { ...super.toType(), import: [{ package: \"json-schema-to-ts\", name: \"FromSchema\" }], type: `FromSchema<${Br$1(this.getJsonSchema(), 2, 1)}>` };\n      }\n    };\n    ({ Type: W$3 } = p$1);\n    ts$1 = W$3.Composite([W$3.Object({ default_value: W$3.Optional(W$3.Number()), minimum: W$3.Optional(W$3.Number()), maximum: W$3.Optional(W$3.Number()), exclusiveMinimum: W$3.Optional(W$3.Number()), exclusiveMaximum: W$3.Optional(W$3.Number()), multipleOf: W$3.Optional(W$3.Number()) }), N$3], { additionalProperties: false });\n    Ye$1 = class Ye extends P$3 {\n      static {\n        __name(this, \"Ye\");\n      }\n      type = \"number\";\n      getSchema() {\n        return ts$1;\n      }\n      getHtmlConfig() {\n        return { element: \"input\", props: { type: \"number\", pattern: \"d*\", inputMode: \"numeric\" } };\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: \"integer\" });\n      }\n      getValue(e, t) {\n        if (typeof e > \"u\" || e === null) return null;\n        switch (t) {\n          case \"submit\":\n            return Number.parseInt(e);\n        }\n        return e;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (!this.nullish(i) && typeof i != \"number\") throw D$4.invalidType(this.name, \"number\", i);\n        if (this.config.maximum && i > this.config.maximum) throw new D$4(`Field \"${this.name}\" cannot be greater than ${this.config.maximum}`);\n        if (this.config.minimum && i < this.config.minimum) throw new D$4(`Field \"${this.name}\" cannot be less than ${this.config.minimum}`);\n        return i;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(W$3.Number({ default: this.getDefault(), minimum: this.config?.minimum, maximum: this.config?.maximum, exclusiveMinimum: this.config?.exclusiveMinimum, exclusiveMaximum: this.config?.exclusiveMaximum, multipleOf: this.config?.multipleOf }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"number\" };\n      }\n    };\n    ({ Type: Xe$1 } = p$1);\n    fr$1 = [\"integer\", \"uuid\"];\n    rs$1 = Xe$1.Composite([Xe$1.Omit(N$3, [\"required\"]), Xe$1.Object({ format: Xe$1.Optional(w$4(fr$1, { default: \"integer\" })), required: Xe$1.Optional(Xe$1.Literal(false)) })]);\n    xe$3 = class xe extends P$3 {\n      static {\n        __name(this, \"xe\");\n      }\n      type = \"primary\";\n      constructor(e = ot$1.data.default_primary_field, t) {\n        super(e, { fillable: false, required: false, ...t });\n      }\n      isRequired() {\n        return false;\n      }\n      getSchema() {\n        return rs$1;\n      }\n      get format() {\n        return this.config.format ?? \"integer\";\n      }\n      get fieldType() {\n        return this.format === \"integer\" ? \"integer\" : \"text\";\n      }\n      schema() {\n        return Object.freeze({ type: this.fieldType, name: this.name, primary: true, nullable: false });\n      }\n      getNewValue() {\n        if (this.format === \"uuid\") return go();\n      }\n      async transformPersist(e) {\n        throw new Error(\"PrimaryField: This function should not be called\");\n      }\n      toJsonSchema() {\n        return this.format === \"uuid\" ? this.toSchemaWrapIfRequired(Xe$1.String({ writeOnly: void 0 })) : this.toSchemaWrapIfRequired(Xe$1.Number({ writeOnly: void 0 }));\n      }\n      toType() {\n        let e = this.format === \"integer\" ? \"number\" : \"string\";\n        return { ...super.toType(), required: true, import: [{ package: \"kysely\", name: \"Generated\" }], type: `Generated<${e}>` };\n      }\n    };\n    ({ Type: U$3 } = p$1);\n    ns$1 = U$3.Composite([U$3.Object({ default_value: U$3.Optional(U$3.String()), minLength: U$3.Optional(U$3.Number()), maxLength: U$3.Optional(U$3.Number()), pattern: U$3.Optional(U$3.String()), html_config: U$3.Optional(U$3.Object({ element: U$3.Optional(U$3.String({ default: \"input\" })), props: U$3.Optional(U$3.Object({}, { additionalProperties: U$3.Union([U$3.String({ title: \"String\" }), U$3.Number({ title: \"Number\" })]) })) })) }), N$3], { additionalProperties: false });\n    Ze$1 = class Ze extends P$3 {\n      static {\n        __name(this, \"Ze\");\n      }\n      type = \"text\";\n      getSchema() {\n        return ns$1;\n      }\n      getHtmlConfig() {\n        return this.config.html_config ? this.config.html_config : super.getHtmlConfig();\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        return this.config.maxLength ? t.substring(0, this.config.maxLength) : this.isRequired() ? t ? t.toString() : \"\" : t;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (i !== null && typeof i != \"string\" && (i = String(i)), this.config.maxLength && i?.length > this.config.maxLength) throw new D$4(`Field \"${this.name}\" must be at most ${this.config.maxLength} character(s)`);\n        if (this.config.minLength && i?.length < this.config.minLength) throw new D$4(`Field \"${this.name}\" must be at least ${this.config.minLength} character(s)`);\n        if (this.config.pattern && i && !new RegExp(this.config.pattern).test(i)) throw new D$4(`Field \"${this.name}\" must match the pattern ${this.config.pattern}`);\n        return i;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(U$3.String({ default: this.getDefault(), minLength: this.config?.minLength, maxLength: this.config?.maxLength, pattern: this.config?.pattern }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"string\" };\n      }\n    };\n    Dt$1 = class Dt {\n      static {\n        __name(this, \"Dt\");\n      }\n      constructor(e, t, r2 = false, i) {\n        this.entity = e;\n        this.fields = t;\n        this.unique = r2;\n        this.name = i;\n        if (t.length === 0) throw new Error(\"Indices must contain at least one field\");\n        if (t.some((s2) => !(s2 instanceof P$3))) throw new Error(\"All fields must be instances of Field\");\n        if (r2 && !t[0]?.isRequired()) throw new Error(`Unique indices must have first field as required: ${t.map((o) => o.name).join(\", \")}`);\n        i || (this.name = [r2 ? \"idx_unique\" : \"idx\", e.name, ...t.map((s2) => s2.name)].join(\"_\"));\n      }\n      toJSON() {\n        return { entity: this.entity.name, fields: this.fields.map((e) => e.name), unique: this.unique };\n      }\n    };\n    Do$1 = { primary: { schema: rs$1, field: xe$3 }, text: { schema: ns$1, field: Ze$1 }, number: { schema: ts$1, field: Ye$1 }, boolean: { schema: Hi$1, field: Pt$1 }, date: { schema: Yi$1, field: ut$1 }, enum: { schema: Xi$1, field: jt$1 }, json: { schema: Zi$1, field: Mt$1 }, jsonschema: { schema: es$1, field: It$1 } };\n    ({ Type: pe$3 } = p$1);\n    is$1 = pe$3.Object({ name: pe$3.Optional(pe$3.String()), name_singular: pe$3.Optional(pe$3.String()), description: pe$3.Optional(pe$3.String()), sort_field: pe$3.Optional(pe$3.String({ default: ot$1.data.default_primary_field })), sort_dir: pe$3.Optional(w$4([\"asc\", \"desc\"], { default: \"asc\" })), primary_format: pe$3.Optional(w$4(fr$1)) }, { additionalProperties: false });\n    $o$1 = [\"regular\", \"system\", \"generated\"];\n    Z$1 = class n3 {\n      static {\n        __name(this, \"n3\");\n      }\n      #e;\n      #t;\n      name;\n      fields;\n      config;\n      data;\n      type = \"regular\";\n      constructor(e, t, r2, i) {\n        if (typeof e != \"string\" || e.length === 0) throw new Error(\"Entity name must be a non-empty string\");\n        this.name = e, this.config = _$2(is$1, r2 || {});\n        let s2 = t?.filter((o) => o instanceof xe$3).length ?? 0;\n        if (s2 > 1) throw new Error(`Entity \"${e}\" has more than one primary field`);\n        this.fields = s2 === 1 ? [] : [new xe$3(void 0, { format: this.config.primary_format })], t && t.forEach((o) => this.addField(o)), i && (this.type = i);\n      }\n      static create(e) {\n        return new n3(e.name, e.fields, e.config, e.type);\n      }\n      getType() {\n        return this.type;\n      }\n      getSelect(e, t) {\n        return this.getFields().filter((r2) => !r2.isHidden(t ?? \"read\")).map((r2) => e ? `${e}.${r2.name} as ${r2.name}` : r2.name);\n      }\n      getDefaultSort() {\n        return { by: this.config.sort_field ?? \"id\", dir: this.config.sort_dir ?? \"asc\" };\n      }\n      getAliasedSelectFrom(e, t, r2) {\n        let i = t ?? this.name;\n        return this.getFields().filter((s2) => !s2.isVirtual() && !s2.isHidden(r2 ?? \"read\") && e.includes(s2.name)).map((s2) => i ? `${i}.${s2.name} as ${s2.name}` : s2.name);\n      }\n      getFillableFields(e, t) {\n        return this.getFields(t).filter((r2) => r2.isFillable(e));\n      }\n      getRequiredFields() {\n        return this.getFields().filter((e) => e.isRequired());\n      }\n      getDefaultObject() {\n        return this.getFields().reduce((e, t) => (t.hasDefault() && (e[t.name] = t.getDefault()), e), {});\n      }\n      getField(e) {\n        return this.fields.find((t) => t.name === e);\n      }\n      __replaceField(e, t) {\n        let r2 = this.fields.findIndex((i) => i.name === e);\n        if (r2 === -1) throw new Error(`Field \"${e}\" not found on entity \"${this.name}\"`);\n        this.fields[r2] = t;\n      }\n      getPrimaryField() {\n        return this.fields[0];\n      }\n      id() {\n        return this.getPrimaryField();\n      }\n      get label() {\n        return this.config.name ?? Ot$1(this.name);\n      }\n      field(e) {\n        return this.getField(e);\n      }\n      hasField(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        return this.fields.findIndex((r2) => r2.name === t) !== -1;\n      }\n      getFields(e = false) {\n        return e ? this.fields : this.fields.filter((t) => !t.isVirtual());\n      }\n      addField(e) {\n        let t = this.getField(e.name);\n        if (t) {\n          if (JSON.stringify(t) === JSON.stringify(e)) {\n            m$1.warn(`Field \"${e.name}\" already exists on entity \"${this.name}\", but it's the same, so skipping.`);\n            return;\n          }\n          throw new Error(`Field \"${e.name}\" already exists on entity \"${this.name}\"`);\n        }\n        this.fields.push(e);\n      }\n      __setData(e) {\n        this.data = e;\n      }\n      isValidData(e, t, r2) {\n        if (typeof e != \"object\" && r2?.explain) throw new Error(`Entity \"${this.name}\" data must be an object`);\n        let i = this.getFillableFields(t, false);\n        if (r2?.ignoreUnknown !== true) {\n          let s2 = i.map((a2) => a2.name), c = Object.keys(e).filter((a2) => !s2.includes(a2));\n          if (c.length > 0 && r2?.explain) throw new Error(`Entity \"${this.name}\" data must only contain known keys, unknown: \"${c}\"`);\n        }\n        for (let s2 of i) if (!s2.isValid(e?.[s2.name], t)) {\n          if (m$1.warn(\"invalid data given for\", this.name, t, s2.name, e[s2.name]), r2?.explain) throw new Error(`Field \"${s2.name}\" has invalid data: \"${e[s2.name]}\"`);\n          return false;\n        }\n        return true;\n      }\n      toSchema(e) {\n        let t;\n        switch (e?.context) {\n          case \"create\":\n          case \"update\":\n            t = this.getFillableFields(e.context);\n            break;\n          default:\n            t = this.getFields(true);\n        }\n        let r2 = Object.fromEntries(t.map((s2) => [s2.name, s2])), i = pe$3.Object(O$2(r2, (s2) => {\n          let o = s2.isFillable(e?.context);\n          return { title: s2.config.label, $comment: s2.config.description, $field: s2.type, readOnly: o ? void 0 : true, ...s2.toJsonSchema() };\n        }), { additionalProperties: false });\n        return e?.clean ? JSON.parse(JSON.stringify(i)) : i;\n      }\n      toTypes() {\n        return { name: this.name, type: this.type, comment: this.config.description, fields: Object.fromEntries(this.getFields().map((e) => [e.name, e.toType()])) };\n      }\n      toJSON() {\n        return { type: this.type, fields: Object.fromEntries(this.fields.map((e) => [e.name, e.toJSON()])), config: this.config };\n      }\n    };\n    qo$1 = [\"text\", \"integer\", \"real\", \"blob\", \"date\", \"datetime\", \"timestamp\", \"boolean\", \"json\"];\n    Bo$1 = Symbol.for(\"bknd:connection\");\n    we$2 = class we {\n      static {\n        __name(this, \"we\");\n      }\n      constructor(e, t = {}, r2 = []) {\n        this.fn = t;\n        this.plugins = r2;\n        this.kysely = e, this[Bo$1] = true;\n      }\n      initialized = false;\n      kysely;\n      supported = { batching: false };\n      async init() {\n        this.initialized = true;\n      }\n      static isConnection(e) {\n        return e ? e[Bo$1] === true : false;\n      }\n      getIntrospector() {\n        return this.kysely.introspection;\n      }\n      supports(e) {\n        return this.supported[e] ?? false;\n      }\n      async ping() {\n        return (await sql`SELECT 1`.execute(this.kysely)).rows.length > 0;\n      }\n      async batch(e) {\n        throw new Error(\"Batching not supported\");\n      }\n      async batchQuery(e) {\n        if (!this.supports(\"batching\")) {\n          let t = [];\n          for (let r2 of e) {\n            let i = await r2.execute();\n            t.push(i);\n          }\n          return t;\n        }\n        return await this.batch(e);\n      }\n      validateFieldSpecType(e) {\n        if (!qo$1.includes(e)) throw new Error(`Invalid field type \"${e}\". Allowed types are: ${qo$1.join(\", \")}`);\n        return true;\n      }\n      async close() {\n      }\n    };\n    on$1 = class on2 {\n      static {\n        __name(this, \"on\");\n      }\n      _relations = [];\n      constructor(e) {\n        this._relations = e;\n      }\n      get all() {\n        return this._relations;\n      }\n      relationsOf(e) {\n        return this._relations.filter((t) => t.visibleFrom(\"source\") && t.source.entity.name === e.name || t.visibleFrom(\"target\") && t.target.entity.name === e.name);\n      }\n      sourceRelationsOf(e) {\n        return this._relations.filter((t) => t.source.entity.name === e.name);\n      }\n      targetRelationsOf(e) {\n        return this._relations.filter((t) => t.visibleFrom(\"target\") && t.target.entity.name === e.name);\n      }\n      listableRelationsOf(e) {\n        return this.relationsOf(e).filter((t) => t.isListableFor(e));\n      }\n      relationOf(e, t) {\n        return this.relationsOf(e).find((r2) => r2.target.entity.name === e.name && r2.source.reference === t || r2.source.entity.name === e.name && r2.target.reference === t);\n      }\n      hasRelations(e) {\n        return this.relationsOf(e).length > 0;\n      }\n      relatedEntitiesOf(e) {\n        return this.relationsOf(e).map((t) => t.other(e).entity);\n      }\n      relationReferencesOf(e) {\n        return this.relationsOf(e).map((t) => t.other(e).reference);\n      }\n    };\n    an$1 = class n4 {\n      static {\n        __name(this, \"n4\");\n      }\n      constructor(e) {\n        this.em = e;\n      }\n      static EXCLUDE_TABLES = [\"libsql_wasm_func_table\", \"sqlite_sequence\", \"_cf_KV\"];\n      getIntrospector() {\n        return this.em.connection.getIntrospector();\n      }\n      async introspect() {\n        let e = await this.getIntrospector().getTables({ withInternalKyselyTables: false }), t = await this.getIntrospector().getIndices(), r2 = [];\n        for (let i of e) n4.EXCLUDE_TABLES.includes(i.name) || r2.push({ ...i, indices: t.filter((s2) => s2.table === i.name) });\n        return r2;\n      }\n      getIntrospectionFromEntity(e) {\n        let t = e.getFields(false), r2 = this.em.getIndicesOf(e);\n        return { name: e.name, isView: false, columns: t.map((i) => ({ name: i.name, dataType: \"TEXT\", isNullable: true, isAutoIncrementing: i instanceof xe$3, hasDefaultValue: false, comment: void 0 })), indices: r2.map((i) => ({ name: i.name, table: e.name, isUnique: i.unique, columns: i.fields.map((s2) => ({ name: s2.name, order: 0 })) })) };\n      }\n      async getDiff() {\n        let e = await this.introspect(), t = this.em.entities.map((s2) => this.getIntrospectionFromEntity(s2)), r2 = [], i = /* @__PURE__ */ __name((s2) => s2.name, \"i\");\n        e.filter((s2) => /bknd/.test(s2.name) || s2.isView ? false : !t.map((o) => o.name).includes(s2.name)).forEach((s2) => {\n          r2.push({ name: s2.name, isDrop: true, isNew: false, columns: { add: [], drop: [], change: [] }, indices: { add: [], drop: [] } });\n        });\n        for (let s2 of t) {\n          let o = e.find((c) => c.name === s2.name);\n          if (!o) r2.push({ name: s2.name, isNew: true, columns: { add: s2.columns.map(i), drop: [], change: [] }, indices: { add: s2.indices.map(i), drop: [] } });\n          else {\n            let c = s2.columns.filter((y3) => !o.columns.map(i).includes(y3.name)), a2 = o.columns.filter((y3) => !s2.columns.map(i).includes(y3.name)), l2 = [];\n            for (let y3 of s2.columns) {\n              let b3 = o.columns.find(($3) => $3.name === y3.name), L2 = [];\n              for (let [$3, ye2] of Object.entries(y3)) b3 && b3[$3] !== ye2 && L2.push({ attribute: $3, prev: b3[$3], next: ye2 });\n              Object.keys(L2).length > 0 && l2.push({ name: y3.name, changes: L2 });\n            }\n            let p2 = s2.indices.filter((y3) => !o.indices.map((b3) => b3.name).includes(y3.name)), u3 = o.indices.filter((y3) => !s2.indices.map((b3) => b3.name).includes(y3.name));\n            [c, a2, p2, u3].some((y3) => y3.length > 0) && r2.push({ name: s2.name, isNew: false, columns: { add: c.map(i), drop: a2.map(i), change: [] }, indices: { add: p2.map(i), drop: u3.map(i) } });\n          }\n        }\n        return r2;\n      }\n      collectFieldSchemas(e, t) {\n        let r2 = [];\n        if (t.length === 0) return r2;\n        for (let i of t) {\n          let o = this.em.entity(e).getField(i).schema();\n          o && r2.push(this.em.connection.getFieldSchema(o));\n        }\n        return r2;\n      }\n      async sync(e = { force: false, drop: false }) {\n        let t = await this.getDiff(), i = [], s2 = this.em.connection.kysely.schema;\n        for (let o of t) {\n          let c = [], a2 = 0, l2 = this.collectFieldSchemas(o.name, o.columns.add), p2 = o.columns.drop, u3 = o.indices.drop;\n          if (o.isDrop) a2++, e.drop && c.push(s2.dropTable(o.name));\n          else if (o.isNew) {\n            let d2 = s2.createTable(o.name);\n            for (let y3 of l2) a2++, d2 = d2.addColumn(...y3);\n            c.push(d2);\n          } else {\n            if (l2.length > 0) for (let d2 of l2) a2++, c.push(s2.alterTable(o.name).addColumn(...d2));\n            if (e.drop && p2.length > 0) for (let d2 of p2) a2++, c.push(s2.alterTable(o.name).dropColumn(d2));\n          }\n          for (let d2 of o.indices.add) {\n            let b3 = this.em.getIndicesOf(o.name).find(($3) => $3.name === d2), L2 = s2.createIndex(d2).on(o.name).columns(b3.fields.map(($3) => $3.name));\n            b3.unique && (L2 = L2.unique()), c.push(L2), a2++;\n          }\n          if (e.drop) for (let d2 of u3) c.push(s2.dropIndex(d2)), a2++;\n          if (a2 !== 0) for (let d2 of c) {\n            let { sql: y3, parameters: b3 } = d2.compile();\n            if (i.push({ sql: y3, parameters: b3 }), e.force) try {\n              m$1.info(\"[SchemaManager]\", y3, b3), await d2.execute();\n            } catch (L2) {\n              throw new Error(`Failed to execute query: ${y3}: ${L2.message}`);\n            }\n          }\n        }\n        return i;\n      }\n    };\n    et$1 = class n5 {\n      static {\n        __name(this, \"n5\");\n      }\n      connection;\n      _entities = [];\n      _relations = [];\n      _indices = [];\n      _schema;\n      emgr;\n      static Events = { ...Ne$2, ...kt$1 };\n      constructor(e, t, r2 = [], i = [], s2) {\n        if (e.forEach((o) => this.addEntity(o)), r2.forEach((o) => this.addRelation(o)), i.forEach((o) => this.addIndex(o)), !we$2.isConnection(t)) throw new tn$1(\"\");\n        this.connection = t, this.emgr = s2 ?? new V$2(), this.emgr.registerEvents(n5.Events);\n      }\n      fork() {\n        return new n5(this._entities, this.connection, this._relations, this._indices);\n      }\n      get entities() {\n        return this._entities;\n      }\n      get relations() {\n        return new on$1(this._relations);\n      }\n      get indices() {\n        return this._indices;\n      }\n      async ping() {\n        return (await sql`SELECT 1`.execute(this.connection.kysely)).rows.length > 0;\n      }\n      addEntity(e) {\n        let t = this.entities.find((r2) => r2.name === e.name);\n        if (t) {\n          if (JSON.stringify(t) === JSON.stringify(e)) {\n            m$1.warn(`Entity \"${e.name}\" already exists, but it's the same, skipping adding it.`);\n            return;\n          }\n          throw new Error(`Entity \"${e.name}\" already exists`);\n        }\n        this.entities.push(e);\n      }\n      __replaceEntity(e, t = e.name) {\n        let r2 = this._entities.findIndex((i) => i.name === t);\n        if (r2 === -1) throw new Error(`Entity \"${t}\" not found and cannot be replaced`);\n        this._entities[r2] = e;\n      }\n      entity(e, t) {\n        let r2 = this.entities.find((i) => e instanceof Z$1 ? i.name === e.name : i.name === e);\n        if (!r2) {\n          if (t === true) return;\n          throw new sn$1(e instanceof Z$1 ? e.name : e);\n        }\n        return r2;\n      }\n      hasEntity(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        return this.entities.some((r2) => r2.name === t);\n      }\n      hasIndex(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        return this.indices.some((r2) => r2.name === t);\n      }\n      getIndexedFields(e) {\n        let t = this.entity(e), r2 = this.getIndicesOf(t), i = t.fields.filter((o) => o.type === \"relation\"), s2 = r2.map((o) => o.fields[0]);\n        return [t.getPrimaryField(), ...i, ...s2].filter(Boolean);\n      }\n      addRelation(e) {\n        if (!this.entity(e.source.entity.name) || !this.entity(e.target.entity.name)) throw new Error(\"Relation source or target entity not found\");\n        if (this._relations.find((r2) => {\n          let i = r2.source.entity.name === e.source.entity.name && r2.target.entity.name === e.target.entity.name, s2 = r2.source.reference === e.source.reference && r2.target.reference === e.target.reference;\n          return i && s2;\n        })) throw new Error(`Relation \"${e.type}\" between \"${e.source.entity.name}\" and \"${e.target.entity.name}\" already exists`);\n        this._relations.push(e), e.initialize(this);\n      }\n      relationsOf(e) {\n        return this.relations.relationsOf(this.entity(e));\n      }\n      relationOf(e, t) {\n        return this.relations.relationOf(this.entity(e), t);\n      }\n      hasRelations(e) {\n        return this.relations.hasRelations(this.entity(e));\n      }\n      relatedEntitiesOf(e) {\n        return this.relations.relatedEntitiesOf(this.entity(e));\n      }\n      relationReferencesOf(e) {\n        return this.relations.relationReferencesOf(this.entity(e));\n      }\n      repository(e) {\n        return this.repo(e);\n      }\n      repo(e, t = {}) {\n        return new ln$1(this, this.entity(e), { ...t, emgr: this.emgr });\n      }\n      mutator(e) {\n        return new cn$1(this, this.entity(e), { emgr: this.emgr });\n      }\n      addIndex(e, t = false) {\n        if (this.indices.find((r2) => r2.name === e.name)) {\n          if (t) throw new Error(`Index \"${e.name}\" already exists`);\n          return;\n        }\n        this._indices.push(e);\n      }\n      getIndicesOf(e) {\n        let t = e instanceof Z$1 ? e : this.entity(e);\n        return this.indices.filter((r2) => r2.entity.name === t.name);\n      }\n      schema() {\n        return this._schema || (this._schema = new an$1(this)), this._schema;\n      }\n      hydrate(e, t) {\n        let r2 = this.entity(e), i = [];\n        for (let s2 of t) {\n          for (let [o, c] of Object.entries(s2)) {\n            let a2 = r2.getField(o);\n            if (!a2 || a2.isVirtual()) {\n              let l2 = this.relationOf(e, o);\n              if (l2) {\n                if (!c) continue;\n                c = l2.hydrate(o, Array.isArray(c) ? c : [c], this), s2[o] = c;\n                continue;\n              } else if (a2?.isVirtual()) continue;\n              throw new Error(`Field \"${o}\" not found on entity \"${r2.name}\"`);\n            }\n            try {\n              c === null && a2.hasDefault() && (s2[o] = a2.getDefault()), s2[o] = a2.transformRetrieve(c);\n            } catch (l2) {\n              throw new rn$1(`\"${a2.type}\" field \"${o}\" on entity \"${r2.name}\": ${l2.message}`);\n            }\n          }\n          i.push(s2);\n        }\n        return i;\n      }\n      toJSON() {\n        return { entities: Object.fromEntries(this.entities.map((e) => [e.name, e.toJSON()])), relations: Object.fromEntries(this.relations.all.map((e) => [e.getName(), e.toJSON()])), indices: Object.fromEntries(this.indices.map((e) => [e.name, e.toJSON()])) };\n      }\n    };\n    ({ Type: mt$1 } = p$1);\n    Ee$2 = class Ee {\n      static {\n        __name(this, \"Ee\");\n      }\n      config;\n      source;\n      target;\n      directions = [\"source\", \"target\"];\n      static schema = mt$1.Object({ mappedBy: mt$1.Optional(mt$1.String()), inversedBy: mt$1.Optional(mt$1.String()), required: mt$1.Optional(mt$1.Boolean()) });\n      constructor(e, t, r2 = {}) {\n        this.source = e, this.target = t;\n        let i = this.constructor.schema;\n        this.config = _$2(i, r2);\n      }\n      getReferenceQuery(e, t, r2) {\n        return {};\n      }\n      helper(e) {\n        return new pn$1(this, e);\n      }\n      other(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        if (this.source.entity.name === this.target.entity.name) return this.source.cardinality === 1 ? this.target : this.source;\n        if (this.source.entity.name === t) return this.target;\n        if (this.target.entity.name === t) return this.source;\n        throw new Error(`Entity \"${t}\" is not part of the relation \"${this.source.entity.name} <-> ${this.target.entity.name}\"`);\n      }\n      self(e) {\n        return this.other(e).entity.name === this.source.entity.name ? this.target : this.source;\n      }\n      ref(e) {\n        return this.source.reference === e ? this.source : this.target;\n      }\n      otherRef(e) {\n        return this.source.reference === e ? this.target : this.source;\n      }\n      visibleFrom(e) {\n        return this.directions.includes(e);\n      }\n      hydrate(e, t, r2) {\n        let i = typeof e == \"string\" ? e : e.name, s2 = this.ref(i), o = r2.hydrate(s2.entity.name, t);\n        if (s2.cardinality === 1) {\n          if (Array.isArray(o) && o.length > 1) throw new Error(`Failed to hydrate \"${s2.entity.name}\" with value: ${JSON.stringify(t)} (cardinality: 1)`);\n          return o[0];\n        }\n        if (!o) throw new Error(`Failed to hydrate \"${s2.entity.name}\" with value: ${JSON.stringify(t)} (cardinality: -)`);\n        return o;\n      }\n      isListableFor(e) {\n        return this.target.entity.name === e.name;\n      }\n      get required() {\n        return !!this.config.required;\n      }\n      async $set(e, t, r2) {\n        throw new Error(\"$set is not allowed\");\n      }\n      async $create(e, t, r2) {\n        throw new Error(\"$create is not allowed\");\n      }\n      async $attach(e, t, r2) {\n        throw new Error(\"$attach is not allowed\");\n      }\n      async $detach(e, t, r2) {\n        throw new Error(\"$detach is not allowed\");\n      }\n      getName() {\n        return [this.type().replace(\":\", \"\"), this.source.entity.name, this.target.entity.name, this.config.mappedBy, this.config.inversedBy].filter(Boolean).join(\"_\");\n      }\n      toJSON() {\n        return { type: this.type(), source: this.source.entity.name, target: this.target.entity.name, config: this.config };\n      }\n    };\n    Te$3 = class Te {\n      static {\n        __name(this, \"Te\");\n      }\n      entity;\n      cardinality;\n      reference;\n      constructor(e, t, r2) {\n        this.entity = e, this.cardinality = r2, this.reference = t;\n      }\n      toJSON() {\n        return { entity: this.entity.name, cardinality: this.cardinality, name: this.reference };\n      }\n    };\n    ({ Type: Le$2 } = p$1);\n    lp = [\"cascade\", \"set null\", \"set default\", \"restrict\", \"no action\"];\n    ss = Le$2.Composite([N$3, Le$2.Object({ reference: Le$2.String(), target: Le$2.String(), target_field: Le$2.Optional(Le$2.String({ default: \"id\" })), target_field_type: Le$2.Optional(w$4([\"integer\", \"text\"], { default: \"integer\" })), on_delete: Le$2.Optional(w$4(lp, { default: \"set null\" })) })]);\n    z$2 = class n6 extends P$3 {\n      static {\n        __name(this, \"n6\");\n      }\n      type = \"relation\";\n      getSchema() {\n        return ss;\n      }\n      static create(e, t, r2) {\n        let i = [t.reference ?? t.entity.name, t.entity.getPrimaryField().name].join(\"_\");\n        return new n6(i, { ...r2, required: e.required, reference: t.reference, target: t.entity.name, target_field: t.entity.getPrimaryField().name, target_field_type: t.entity.getPrimaryField().fieldType });\n      }\n      reference() {\n        return this.config.reference;\n      }\n      target() {\n        return this.config.target;\n      }\n      targetField() {\n        return this.config.target_field;\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: this.config.target_field_type ?? \"integer\", references: `${this.config.target}.${this.config.target_field}`, onDelete: this.config.on_delete ?? \"set null\" });\n      }\n      transformRetrieve(e) {\n        return e;\n      }\n      async transformPersist(e, t) {\n        throw new Error(\"RelationField: This function should not be called\");\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(Le$2.Number({ $ref: `${this.config?.target}#/properties/${this.config?.target_field}` }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"number\" };\n      }\n    };\n    G$2 = { OneToOne: \"1:1\", ManyToOne: \"n:1\", ManyToMany: \"m:n\", Polymorphic: \"poly\" };\n    ({ Type: $t } = p$1);\n    ie$2 = class n7 extends Ee$2 {\n      static {\n        __name(this, \"n7\");\n      }\n      connectionEntity;\n      additionalFields = [];\n      connectionTableMappedName;\n      em;\n      static schema = $t.Composite([Ee$2.schema, $t.Object({ connectionTable: $t.Optional($t.String()), connectionTableMappedName: $t.Optional($t.String()) })], { additionalProperties: false });\n      constructor(e, t, r2, i) {\n        let s2 = r2?.connectionTable || n7.defaultConnectionTable(e, t), o = new Te$3(e, e.name), c = new Te$3(t, t.name);\n        super(o, c, r2), this.connectionEntity = new Z$1(s2, i, void 0, \"generated\"), this.connectionTableMappedName = r2?.connectionTableMappedName || s2, this.additionalFields = i || [];\n      }\n      static defaultConnectionTable(e, t) {\n        return `${e.name}_${t.name}`;\n      }\n      type() {\n        return G$2.ManyToMany;\n      }\n      isListableFor() {\n        return true;\n      }\n      getField(e) {\n        let t = this.connectionEntity, r2 = t.fields.find((i) => i instanceof z$2 && i.target() === e.name);\n        if (!r2 || !(r2 instanceof z$2)) throw new Error(`Connection entity \"${t.name}\" does not have a relation to \"${e.name}\"`);\n        return r2;\n      }\n      getQueryInfo(e) {\n        let t = this.other(e), r2 = this.connectionEntity, i = this.getField(e), s2 = this.getField(t.entity), o = `${e.name}.${e.getPrimaryField().name}`, c = `${r2.name}.${i.name}`, a2 = `${r2.name}.${s2.name}`, l2 = [r2.name, `${t.entity.name}.${t.entity.getPrimaryField().name}`, a2], p2 = `${e.name}.${e.getPrimaryField().name}`;\n        return { other: t, join: l2, entityRef: o, selfRef: c, otherRef: a2, groupBy: p2 };\n      }\n      getReferenceQuery(e, t) {\n        let { other: r2, otherRef: i } = this.getQueryInfo(e);\n        return { where: { [i]: t }, join: [r2.reference] };\n      }\n      buildJoin(e, t) {\n        let { other: r2, join: i, entityRef: s2, selfRef: o, groupBy: c } = this.getQueryInfo(e);\n        return t.innerJoin(r2.entity.name, s2, o).innerJoin(...i).groupBy(c);\n      }\n      buildWith(e) {\n        if (!this.em) throw new Error(\"EntityManager not set, can't build\");\n        let t = this.em.connection.fn.jsonBuildObject;\n        if (!t) throw new Error(\"Connection does not support jsonBuildObject\");\n        let r2 = 5, { other: i, join: s2, entityRef: o, selfRef: c } = this.getQueryInfo(e), a2 = this.connectionEntity.fields.filter((l2) => !(l2 instanceof z$2 || l2 instanceof xe$3));\n        return (l2) => l2.selectFrom(i.entity.name).select((p2) => {\n          let u3 = [];\n          if (a2.length > 0) {\n            let d2 = this.connectionEntity.name;\n            u3.push(t(Object.fromEntries(a2.map((y3) => [y3.name, p2.ref(`${d2}.${y3.name}`)]))).as(this.connectionTableMappedName));\n          }\n          return u3;\n        }).whereRef(o, \"=\", c).innerJoin(...s2).limit(r2);\n      }\n      initialize(e) {\n        this.em = e;\n        let t = z$2.create(this, this.source), r2 = z$2.create(this, this.target);\n        e.hasEntity(this.connectionEntity) ? (this.connectionEntity.hasField(t) || this.connectionEntity.addField(t), this.connectionEntity.hasField(r2) || this.connectionEntity.addField(r2)) : (this.connectionEntity.addField(t), this.connectionEntity.addField(r2), e.addEntity(this.connectionEntity));\n      }\n      getName() {\n        return [super.getName(), [this.connectionEntity.name, this.connectionTableMappedName].filter(Boolean)].join(\"_\");\n      }\n    };\n    ({ Type: Qe$1 } = p$1);\n    Se$1 = class n8 extends Ee$2 {\n      static {\n        __name(this, \"n8\");\n      }\n      fieldConfig;\n      static DEFAULTS = { with_limit: 5 };\n      static schema = Qe$1.Composite([Ee$2.schema, Qe$1.Object({ sourceCardinality: Qe$1.Optional(Qe$1.Number()), with_limit: Qe$1.Optional(Qe$1.Number({ default: n8.DEFAULTS.with_limit })), fieldConfig: Qe$1.Optional(Qe$1.Object({ label: Qe$1.String() })) })], { additionalProperties: false });\n      constructor(e, t, r2 = {}) {\n        let i = r2.mappedBy || t.name, s2 = r2.inversedBy || e.name, o = typeof r2.sourceCardinality == \"number\" && r2.sourceCardinality > 0 ? r2.sourceCardinality : void 0, c = new Te$3(e, s2, o), a2 = new Te$3(t, i, 1);\n        super(c, a2, r2), this.fieldConfig = r2.fieldConfig ?? {};\n      }\n      type() {\n        return G$2.ManyToOne;\n      }\n      initialize(e) {\n        let t = Ot$1(this.target.reference), r2 = z$2.create(this, this.target, { label: t, ...this.fieldConfig });\n        this.source.entity.field(r2.name) || this.source.entity.addField(z$2.create(this, this.target, { label: t, ...this.fieldConfig }));\n      }\n      getField() {\n        let e = this.target.entity.getPrimaryField().name, t = this.source.entity.getField(`${this.target.reference}_${e}`);\n        if (!(t instanceof z$2)) throw new Error(`Field \"${this.target.reference}_${e}\" not found on entity \"${this.source.entity.name}\"`);\n        return t;\n      }\n      queryInfo(e, t) {\n        let r2 = this.source.reference === t ? \"source\" : \"target\", i = this[r2], s2 = this[r2 === \"source\" ? \"target\" : \"source\"], o, c, a2;\n        r2 === \"source\" ? (o = this.source.reference, c = `${o}.${this.getField().name}`, a2 = `${e.name}.${i.entity.getPrimaryField().name}`) : (o = this.target.reference, c = `${o}.${e.getPrimaryField().name}`, a2 = `${e.name}.${this.getField().name}`);\n        let l2 = `${e.name}.${e.getPrimaryField().name}`;\n        return { other: s2, self: i, relationRef: o, entityRef: c, otherRef: a2, groupBy: l2 };\n      }\n      getReferenceQuery(e, t, r2) {\n        let i = this.source.reference === r2 ? \"source\" : \"target\", s2 = this[i], o = this[i === \"source\" ? \"target\" : \"source\"];\n        return { where: { [`${o.reference}_${o.entity.getPrimaryField().name}`]: t }, join: o.entity.name === s2.entity.name ? [] : [o.entity.name] };\n      }\n      buildJoin(e, t, r2) {\n        let { self: i, entityRef: s2, otherRef: o, groupBy: c } = this.queryInfo(e, r2);\n        return t.innerJoin(i.entity.name, s2, o).groupBy(c);\n      }\n      buildWith(e, t) {\n        let { self: r2, entityRef: i, otherRef: s2, relationRef: o } = this.queryInfo(e, t);\n        return (c) => c.selectFrom(`${r2.entity.name} as ${o}`).whereRef(i, \"=\", s2).$if(r2.cardinality === 1, (a2) => a2.limit(1));\n      }\n      async $set(e, t, r2) {\n        if (typeof r2 != \"object\") throw new Error(`Invalid value for relation field \"${t}\" given, expected object.`);\n        let i = this.source.entity, o = this.helper(i.name).getMutationInfo();\n        if (!o.$set) throw new Error(`Cannot perform $set for relation \"${t}\"`);\n        let c = o.local_field, a2 = this.getField(), l2 = r2[Object.keys(r2)[0]];\n        if (!c || !(a2 instanceof z$2)) throw new Error(`Cannot perform $set for relation \"${t}\"`);\n        if (l2 === null && !a2.isRequired()) return [c, null];\n        if (!(await e.repository(a2.target()).exists({ [a2.targetField()]: l2 })).exists) {\n          let u3 = a2.targetField();\n          throw new Error(`Cannot connect \"${i.name}.${t}\" to \"${a2.target()}.${u3}\" = \"${l2}\": not found.`);\n        }\n        return [c, l2];\n      }\n    };\n    ft$1 = class ft extends Se$1 {\n      static {\n        __name(this, \"ft\");\n      }\n      constructor(e, t, r2) {\n        let { mappedBy: i, inversedBy: s2, required: o } = r2 || {};\n        super(e, t, { mappedBy: i, inversedBy: s2, sourceCardinality: 1, required: o });\n      }\n      type() {\n        return G$2.OneToOne;\n      }\n      isListableFor() {\n        return false;\n      }\n      async $set(e, t, r2) {\n        throw new Error(\"$set is not allowed\");\n      }\n      async $create(e, t, r2) {\n        if (r2 === null || typeof r2 != \"object\") throw new Error(`Invalid value for relation field \"${t}\" given, expected object.`);\n        let i = this.other(this.source.entity).entity, o = this.helper(this.source.entity.name).getMutationInfo(), c = o.primary, a2 = o.local_field;\n        if (!o.$create || !c || !a2) throw new Error(`Cannot perform $create for relation \"${t}\"`);\n        try {\n          let { data: l2 } = await e.mutator(i).insertOne(r2), p2 = l2[c];\n          return [a2, p2];\n        } catch {\n          throw new Error(`Error performing $create on \"${i.name}\".`);\n        }\n      }\n    };\n    ({ Type: un$1 } = p$1);\n    tt = class extends Ee$2 {\n      static {\n        __name(this, \"tt\");\n      }\n      static schema = un$1.Composite([Ee$2.schema, un$1.Object({ targetCardinality: un$1.Optional(un$1.Number()) })], { additionalProperties: false });\n      constructor(e, t, r2 = {}) {\n        let i = r2.mappedBy || t.name, s2 = r2.inversedBy || e.name, o = typeof r2.targetCardinality == \"number\" && r2.targetCardinality > 0 ? r2.targetCardinality : void 0, c = new Te$3(e, s2, 1), a2 = new Te$3(t, i, o);\n        super(c, a2, r2), this.directions = [\"source\"];\n      }\n      type() {\n        return G$2.Polymorphic;\n      }\n      queryInfo(e) {\n        let t = this.other(e), r2 = `${t.entity.name}.${this.getReferenceField().name}`, i = `${e.name}.${this.config.mappedBy}`, s2 = `${t.entity.name}.${this.config.mappedBy}`, o = `${e.name}.${e.getPrimaryField().name}`, c = `${t.entity.name}.${this.getEntityIdField().name}`, a2 = `${e.name}.${e.getPrimaryField().name}`;\n        return { other: t, whereLhs: r2, reference: i, reference_other: s2, entityRef: o, otherRef: c, groupBy: a2 };\n      }\n      buildJoin(e, t) {\n        let { other: r2, whereLhs: i, reference: s2, entityRef: o, otherRef: c, groupBy: a2 } = this.queryInfo(e);\n        return t.innerJoin(r2.entity.name, (l2) => l2.onRef(o, \"=\", c).on(i, \"=\", s2)).groupBy(a2);\n      }\n      getReferenceQuery(e, t) {\n        let r2 = this.queryInfo(e);\n        return { where: { [this.getReferenceField().name]: r2.reference_other, [this.getEntityIdField().name]: t } };\n      }\n      buildWith(e) {\n        let { other: t, whereLhs: r2, reference: i, entityRef: s2, otherRef: o } = this.queryInfo(e);\n        return (c) => c.selectFrom(t.entity.name).where(r2, \"=\", i).whereRef(s2, \"=\", o).$if(t.cardinality === 1, (a2) => a2.limit(1));\n      }\n      isListableFor(e) {\n        return this.source.entity.name === e.name && this.target.cardinality !== 1;\n      }\n      getReferenceField() {\n        return new Ze$1(\"reference\", { hidden: true, fillable: [\"create\"] });\n      }\n      getEntityIdField() {\n        return new Ye$1(\"entity_id\", { hidden: true, fillable: [\"create\"] });\n      }\n      initialize(e) {\n        let t = this.getReferenceField(), r2 = this.getEntityIdField();\n        this.target.entity.field(t.name) || this.target.entity.addField(t), this.target.entity.field(r2.name) || this.target.entity.addField(r2);\n      }\n    };\n    os$1 = [\"$set\", \"$create\", \"$attach\", \"$detach\"];\n    pn$1 = class pn {\n      static {\n        __name(this, \"pn\");\n      }\n      relation;\n      access;\n      self;\n      other;\n      constructor(e, t) {\n        if (this.relation = e, e.source.entity.name === t) this.access = \"source\", this.self = e.source, this.other = e.target;\n        else if (e.target.entity.name === t) this.access = \"target\", this.self = e.target, this.other = e.source;\n        else throw new Error(`Entity \"${t}\" is not part of the relation \"${e.source.entity.name} <-> ${e.target.entity.name}\"`);\n      }\n      getMutationInfo() {\n        let e = { $set: false, $create: false, $attach: false, $detach: false }, t, r2;\n        switch (this.relation.type()) {\n          case G$2.ManyToOne:\n            typeof this.self.cardinality > \"u\" && this.other.cardinality === 1 && (e.$set = true, t = this.relation.getField()?.name, r2 = this.other.entity.getPrimaryField().name);\n            break;\n          case G$2.OneToOne:\n            this.access === \"source\" && (e.$create = true, e.$set = true, t = this.relation.getField()?.name, r2 = this.other.entity.getPrimaryField().name);\n            break;\n          case G$2.ManyToMany:\n            this.access === \"source\" && (e.$attach = true, e.$detach = true, r2 = this.other.entity.getPrimaryField().name);\n            break;\n        }\n        return { reference: this.other.reference, local_field: t, ...e, primary: r2, cardinality: this.other.cardinality, relation_type: this.relation.type() };\n      }\n    };\n    dn$1 = class dn {\n      static {\n        __name(this, \"dn\");\n      }\n      constructor(e, t) {\n        this.entity = e;\n        this.em = t;\n      }\n      getRelationalKeys() {\n        let e = [];\n        return this.entity.type === \"generated\" && this.em.relations.all.find((r2) => r2 instanceof ie$2 && r2.connectionEntity.name === this.entity.name) instanceof ie$2 && e.push(...this.entity.fields.filter((r2) => r2.type === \"relation\").map((r2) => r2.name)), this.em.relationsOf(this.entity.name).map((t) => {\n          let r2 = t.helper(this.entity.name).getMutationInfo();\n          e.push(r2.reference), r2.local_field && e.push(r2.local_field);\n        }), e;\n      }\n      async persistRelationField(e, t, r2) {\n        if (r2 === null && !e.isRequired()) return [t, r2];\n        if (typeof r2 == \"object\") throw new Error(`Invalid value for relation field \"${t}\" given, expected primitive.`);\n        if (!(await this.em.repository(e.target()).exists({ [e.targetField()]: r2 })).exists) {\n          let s2 = e.targetField();\n          throw new Error(`Cannot connect \"${this.entity.name}.${t}\" to \"${e.target()}.${s2}\" = \"${r2}\": not found.`);\n        }\n        return [t, r2];\n      }\n      async persistReference(e, t, r2) {\n        if (typeof r2 != \"object\" || r2 === null || typeof r2 > \"u\") throw new Error(`Invalid value for relation \"${t}\" given, expected object to persist reference. Like '{$set: {id: 1}}'.`);\n        let i = Object.keys(r2)[0];\n        if (!os$1.includes(i)) throw new Error(`Invalid operation \"${i}\" for relation \"${t}\". Allowed: ${os$1.join(\", \")}`);\n        let s2 = r2[i];\n        return await e[i](this.em, t, s2);\n      }\n      async persistRelation(e, t) {\n        let r2 = this.entity.getField(e);\n        if (r2 instanceof z$2) return this.persistRelationField(r2, e, t);\n        let i = this.em.relationOf(this.entity.name, e);\n        if (i) return this.persistReference(i, e, t);\n        throw new Error(`Relation \"${e}\" failed to resolve on entity \"${this.entity.name}\": Unable to resolve relation origin.`);\n      }\n    };\n    as = { [G$2.OneToOne]: { schema: ft$1.schema, cls: ft$1 }, [G$2.ManyToOne]: { schema: Se$1.schema, cls: Se$1 }, [G$2.ManyToMany]: { schema: ie$2.schema, cls: ie$2 }, [G$2.Polymorphic]: { schema: tt.schema, cls: tt } };\n    No$1 = { relation: { schema: ss, field: z$2 } };\n    cn$1 = class n9 {\n      static {\n        __name(this, \"n9\");\n      }\n      constructor(e, t, r2) {\n        this.em = e;\n        this.entity = t;\n        this.options = r2;\n        this.emgr = r2?.emgr ?? new V$2(Ne$2);\n      }\n      static Events = Ne$2;\n      emgr;\n      __unstable_disable_system_entity_creation = true;\n      __unstable_toggleSystemEntityCreation(e) {\n        this.__unstable_disable_system_entity_creation = e;\n      }\n      get conn() {\n        return this.em.connection.kysely;\n      }\n      async getValidatedData(e, t) {\n        let r2 = this.entity;\n        if (!t) throw new Error(\"Context must be provided for validation\");\n        let i = Object.keys(e), s2 = {}, o = new dn$1(r2, this.em), c = o.getRelationalKeys();\n        for (let a2 of i) {\n          if (c.includes(a2)) {\n            let p2 = await o.persistRelation(a2, e[a2]);\n            if (Array.isArray(p2)) {\n              let [u3, d2] = p2;\n              s2[u3] = d2;\n            }\n            continue;\n          }\n          let l2 = r2.getField(a2);\n          if (!l2) throw new Error(`Field \"${a2}\" not found on entity \"${r2.name}\". Fields: ${r2.getFillableFields().map((p2) => p2.name).join(\", \")}`);\n          if (!l2.isFillable(t)) throw new Error(`Field \"${a2}\" is not fillable on entity \"${r2.name}\"`);\n          s2[a2] = await l2.transformPersist(e[a2], this.em, t);\n        }\n        if (Object.keys(s2).length === 0) throw new Error(`No data left to update \"${r2.name}\"`);\n        return s2;\n      }\n      async many(e) {\n        let t = this.entity, { sql: r2, parameters: i } = e.compile();\n        try {\n          let s2 = await e.execute(), o = this.em.hydrate(t.name, s2);\n          return { entity: t, sql: r2, parameters: [...i], result: s2, data: o };\n        } catch (s2) {\n          throw m$1.error(\"[Error in query]\", r2), s2;\n        }\n      }\n      async single(e) {\n        let { data: t, ...r2 } = await this.many(e);\n        return { ...r2, data: t[0] };\n      }\n      async insertOne(e) {\n        let t = this.entity;\n        if (t.type === \"system\" && this.__unstable_disable_system_entity_creation) throw new Error(`Creation of system entity \"${t.name}\" is disabled`);\n        let r2 = await this.emgr.emit(new n9.Events.MutatorInsertBefore({ entity: t, data: e })), i = r2.returned ? r2.params.data : e, s2 = { ...t.getDefaultObject(), ...await this.getValidatedData(i, \"create\") }, o = t.getRequiredFields();\n        for (let u3 of o) if (typeof s2[u3.name] > \"u\" || s2[u3.name] === null) throw new Error(`Field \"${u3.name}\" is required`);\n        let c = t.getPrimaryField(), a2 = c.getNewValue();\n        a2 && (s2 = { [c.name]: a2, ...s2 });\n        let l2 = this.conn.insertInto(t.name).values(s2).returning(t.getSelect()), p2 = await this.single(l2);\n        return await this.emgr.emit(new n9.Events.MutatorInsertAfter({ entity: t, data: p2.data, changed: s2 })), p2;\n      }\n      async updateOne(e, t) {\n        let r2 = this.entity;\n        if (!e) throw new Error(\"ID must be provided for update\");\n        let i = await this.emgr.emit(new n9.Events.MutatorUpdateBefore({ entity: r2, entityId: e, data: t })), s2 = i.returned ? i.params.data : t, o = await this.getValidatedData(s2, \"update\"), c = this.conn.updateTable(r2.name).set(o).where(r2.id().name, \"=\", e).returning(r2.getSelect()), a2 = await this.single(c);\n        return await this.emgr.emit(new n9.Events.MutatorUpdateAfter({ entity: r2, entityId: e, data: a2.data, changed: o })), a2;\n      }\n      async deleteOne(e) {\n        let t = this.entity;\n        if (!e) throw new Error(\"ID must be provided for deletion\");\n        await this.emgr.emit(new n9.Events.MutatorDeleteBefore({ entity: t, entityId: e }));\n        let r2 = this.conn.deleteFrom(t.name).where(t.id().name, \"=\", e).returning(t.getSelect()), i = await this.single(r2);\n        return await this.emgr.emit(new n9.Events.MutatorDeleteAfter({ entity: t, entityId: e, data: i.data })), i;\n      }\n      getValidOptions(e) {\n        let t = this.entity, r2 = {};\n        if (e?.where) {\n          let i = se$1.getPropertyNames(e.where).filter((s2) => typeof t.getField(s2) > \"u\");\n          if (i.length > 0) throw new ne$1(`Invalid where field(s): ${i.join(\", \")}`);\n          r2.where = e.where;\n        }\n        return r2;\n      }\n      appendWhere(e, t) {\n        let r2 = this.entity;\n        r2.name;\n        if (t) {\n          let o = se$1.getPropertyNames(t).filter((c) => typeof r2.getField(c) > \"u\");\n          if (o.length > 0) throw new ne$1(`Invalid where field(s): ${o.join(\", \")}`);\n          return se$1.addClause(e, t);\n        }\n        return e;\n      }\n      async deleteWhere(e) {\n        let t = this.entity;\n        if (!e || typeof e != \"object\" || Object.keys(e).length === 0) throw new Error(\"Where clause must be provided for mass deletion\");\n        let r2 = this.appendWhere(this.conn.deleteFrom(t.name), e).returning(t.getSelect());\n        return await this.many(r2);\n      }\n      async updateWhere(e, t) {\n        let r2 = this.entity, i = await this.getValidatedData(e, \"update\");\n        if (!t || typeof t != \"object\" || Object.keys(t).length === 0) throw new Error(\"Where clause must be provided for mass update\");\n        let s2 = this.appendWhere(this.conn.updateTable(r2.name), t).set(i).returning(r2.getSelect());\n        return await this.many(s2);\n      }\n      async insertMany(e) {\n        let t = this.entity;\n        if (t.type === \"system\" && this.__unstable_disable_system_entity_creation) throw new Error(`Creation of system entity \"${t.name}\" is disabled`);\n        let r2 = [];\n        for (let s2 of e) {\n          let o = { ...t.getDefaultObject(), ...await this.getValidatedData(s2, \"create\") }, c = t.getRequiredFields();\n          for (let a2 of c) if (typeof o[a2.name] > \"u\" || o[a2.name] === null) throw new Error(`Field \"${a2.name}\" is required`);\n          r2.push(o);\n        }\n        let i = this.conn.insertInto(t.name).values(r2).returning(t.getSelect());\n        return await this.many(i);\n      }\n    };\n    mn$1 = f.string({ pattern: \"^(?:[a-zA-Z_$][\\\\w$]*)(?:,[a-zA-Z_$][\\\\w$]*)*$\" });\n    Uo = f.anyOf([mn$1, f.array(mn$1, { uniqueItems: true })], { default: [], coerce: /* @__PURE__ */ __name((n252) => Array.isArray(n252) ? n252 : typeof n252 == \"string\" ? n252.includes(\",\") ? n252.split(\",\") : [n252] : [], \"coerce\") });\n    Lo = { by: \"id\", dir: \"asc\" };\n    mp = f.object({ by: f.string(), dir: f.string({ enum: [\"asc\", \"desc\"] }).optional() });\n    fp = f.anyOf([f.string(), mp], { default: Lo, coerce: /* @__PURE__ */ __name((n252) => {\n      if (typeof n252 == \"string\") {\n        if (/^-?[a-zA-Z_][a-zA-Z0-9_.]*$/.test(n252)) {\n          let e = n252[0] === \"-\" ? \"desc\" : \"asc\";\n          return { by: e === \"desc\" ? n252.slice(1) : n252, dir: e };\n        } else if (/^{.*}$/.test(n252)) return JSON.parse(n252);\n        return m$1.warn(`Invalid sort given: '${JSON.stringify(n252)}'`), Lo;\n      }\n      return n252;\n    }, \"coerce\") });\n    yp = f.anyOf([f.string(), f.object({})], { default: {}, examples: [{ attribute: { $eq: 1 } }], coerce: /* @__PURE__ */ __name((n252) => {\n      let e = typeof n252 == \"string\" ? JSON.parse(n252) : n252;\n      return se$1.convert(e);\n    }, \"coerce\") });\n    hp = /* @__PURE__ */ __name((n252) => f.anyOf([mn$1, f.array(mn$1), n252], { coerce: /* @__PURE__ */ __name(function(e, t = {}) {\n      let r2 = e;\n      if (typeof r2 == \"string\" && (r2.match(/^\\{/) || r2.match(/^\\[/) ? r2 = JSON.parse(r2) : r2.includes(\",\") ? r2 = r2.split(\",\") : r2 = [r2]), Array.isArray(r2) && (r2 = r2.reduce((i, s2) => (i[s2] = {}, i), {})), Rt$1(r2)) for (let i in r2) r2[i] = n252.coerce(r2[i], t);\n      return r2;\n    }, \"coerce\") }), \"hp\");\n    oe$3 = f.recursive((n252) => f.partialObject({ limit: f.number({ default: 10 }), offset: f.number({ default: 0 }), sort: fp, where: yp, select: Uo, join: Uo, with: hp(n252) }));\n    cs$1 = /* @__PURE__ */ __name(() => oe$3.template({ withOptional: true }), \"cs$1\");\n    yr = class n10 {\n      static {\n        __name(this, \"n10\");\n      }\n      static buildClause(e, t, r2, i) {\n        let s2 = e.relationOf(r2.name, i);\n        if (!s2) throw new Error(`Relation \"${i}\" not found`);\n        return s2.buildJoin(r2, t, i);\n      }\n      static getJoinedEntityNames(e, t, r2) {\n        return r2.flatMap((i) => {\n          let s2 = e.relationOf(t.name, i);\n          if (!s2) throw new Error(`Relation \"${i}\" not found`);\n          let o = s2.other(t);\n          return s2 instanceof Se$1 ? [o.entity.name] : s2 instanceof ie$2 ? [o.entity.name, s2.connectionEntity.name] : [];\n        });\n      }\n      static addClause(e, t, r2, i) {\n        if (i.length === 0) return t;\n        let s2 = t;\n        for (let o of i) s2 = n10.buildClause(e, s2, r2, o);\n        return s2;\n      }\n    };\n    ln$1 = class n11 {\n      static {\n        __name(this, \"n11\");\n      }\n      constructor(e, t, r2 = {}) {\n        this.em = e;\n        this.entity = t;\n        this.options = r2;\n        this.emgr = r2?.emgr ?? new V$2(Ne$2);\n      }\n      static Events = kt$1;\n      emgr;\n      cloneFor(e, t = {}) {\n        return new n11(this.em, this.em.entity(e), { ...this.options, ...t, emgr: this.emgr });\n      }\n      get conn() {\n        return this.em.connection.kysely;\n      }\n      checkIndex(e, t, r2) {\n        !this.em.getIndexedFields(e).map((s2) => s2.name).includes(t) && this.options?.silent !== true && m$1.warn(`Field \"${e}.${t}\" used in \"${r2}\" is not indexed`);\n      }\n      getValidOptions(e) {\n        let t = this.entity, r2 = { ...structuredClone(cs$1()), sort: t.getDefaultSort(), select: t.getSelect() };\n        if (!e) return r2;\n        if (e.sort) {\n          if (!r2.select.includes(e.sort.by)) throw new ne$1(`Invalid sort field \"${e.sort.by}\"`);\n          if (![\"asc\", \"desc\"].includes(e.sort.dir)) throw new ne$1(`Invalid sort direction \"${e.sort.dir}\"`);\n          this.checkIndex(t.name, e.sort.by, \"sort\"), r2.sort = { dir: \"asc\", ...e.sort };\n        }\n        if (e.select && e.select.length > 0) {\n          let i = e.select.filter((s2) => !r2.select.includes(s2));\n          if (i.length > 0) throw new ne$1(`Invalid select field(s): ${i.join(\", \")}`).context({ entity: t.name, valid: r2.select });\n          r2.select = e.select;\n        }\n        if (e.with) {\n          hr$1.validateWiths(this.em, t.name, e.with);\n          r2.with = e.with;\n        }\n        if (e.join && e.join.length > 0) for (let i of e.join) {\n          if (!this.em.relationOf(t.name, i)) throw new ne$1(`JOIN: \"${i}\" is not a relation of \"${t.name}\"`);\n          r2.join.push(i);\n        }\n        if (e.where) {\n          let i = [t.name];\n          r2.join.length > 0 && i.push(...yr.getJoinedEntityNames(this.em, t, r2.join));\n          let s2 = se$1.getPropertyNames(e.where).filter((o) => {\n            if (o.includes(\".\")) {\n              let [c, a2] = o.split(\".\");\n              return i.includes(c) ? (this.checkIndex(c, a2, \"where\"), !this.em.entity(c).getField(a2)) : true;\n            }\n            return this.checkIndex(t.name, o, \"where\"), typeof t.getField(o) > \"u\";\n          });\n          if (s2.length > 0) throw new ne$1(`Invalid where field(s): ${s2.join(\", \")}`).context({ aliases: i, entity: t.name });\n          r2.where = e.where;\n        }\n        return e.limit && (r2.limit = e.limit), e.offset && (r2.offset = e.offset), r2;\n      }\n      async executeQb(e) {\n        let t = e.compile();\n        this.options?.silent !== true && m$1.debug(`Repository: query\n${t.sql}\n`, t.parameters);\n        let r2;\n        try {\n          r2 = await e.execute();\n        } catch (i) {\n          if (this.options?.silent !== true) throw i instanceof Error && m$1.error(\"[ERROR] Repository.executeQb\", i.message), i;\n        }\n        return { result: r2, sql: t.sql, parameters: [...t.parameters] };\n      }\n      async performQuery(e) {\n        let t = this.entity, r2 = e.compile(), i = { entity: t, sql: r2.sql, parameters: [...r2.parameters], result: [], data: [], meta: { total: 0, count: 0, items: 0, time: 0, query: { sql: r2.sql, parameters: r2.parameters } } };\n        if (this.options?.includeCounts === false || this.options?.includeCounts === true && !this.em.connection.supports(\"batching\")) {\n          let a2 = performance.now(), l2 = await this.executeQb(e), p2 = Number.parseFloat((performance.now() - a2).toFixed(2)), u3 = l2.result ?? [], d2 = this.em.hydrate(t.name, u3);\n          return { ...i, result: u3, data: d2, meta: { ...i.meta, total: void 0, count: void 0, items: d2.length, time: p2 } };\n        }\n        this.options?.silent !== true && m$1.debug(`Repository: query\n${r2.sql}\n`, r2.parameters);\n        let s2 = /* @__PURE__ */ __name((a2 = \"count\") => this.conn.fn.countAll().as(a2), \"s\"), o = e.clearSelect().select(s2()).clearLimit().clearOffset().clearGroupBy().clearOrderBy(), c = this.conn.selectFrom(t.name).select(s2());\n        try {\n          let a2 = performance.now(), [l2, p2, u3] = await this.em.connection.batchQuery([o, c, e]), d2 = Number.parseFloat((performance.now() - a2).toFixed(2)), y3 = this.em.hydrate(t.name, u3);\n          return { ...i, result: u3, data: y3, meta: { ...i.meta, total: Si$1(p2[0]?.count), count: Si$1(l2[0]?.count), items: u3.length, time: d2 } };\n        } catch (a2) {\n          if (this.options?.silent !== true) throw a2 instanceof Error && m$1.error(\"[ERROR] Repository.performQuery\", a2.message), a2;\n          return i;\n        }\n      }\n      async triggerFindBefore(e, t) {\n        let r2 = t.limit === 1 ? n11.Events.RepositoryFindOneBefore : n11.Events.RepositoryFindManyBefore;\n        await this.emgr.emit(new r2({ entity: e, options: t }));\n      }\n      async triggerFindAfter(e, t, r2) {\n        t.limit === 1 ? await this.emgr.emit(new n11.Events.RepositoryFindOneAfter({ entity: e, options: t, data: r2[0] })) : await this.emgr.emit(new n11.Events.RepositoryFindManyAfter({ entity: e, options: t, data: r2 }));\n      }\n      async single(e, t) {\n        await this.triggerFindBefore(this.entity, t);\n        let { data: r2, ...i } = await this.performQuery(e);\n        return await this.triggerFindAfter(this.entity, t, r2), { ...i, data: r2[0] };\n      }\n      addOptionsToQueryBuilder(e, t, r2) {\n        let i = this.entity, s2 = e ?? this.conn.selectFrom(i.name), o = r2?.validate !== false ? this.getValidOptions(t) : t;\n        if (!o) return s2;\n        let c = r2?.alias ?? i.name, a2 = /* @__PURE__ */ __name((u3) => `${c}.${u3}`, \"a\"), l2 = r2?.ignore ?? [], p2 = { limit: 10, offset: 0, ...r2?.defaults };\n        return !l2.includes(\"select\") && o.select && (s2 = s2.select(i.getAliasedSelectFrom(o.select, c))), !l2.includes(\"with\") && o.with && (s2 = hr$1.addClause(this.em, s2, i, o.with)), !l2.includes(\"join\") && o.join && (s2 = yr.addClause(this.em, s2, i, o.join)), !l2.includes(\"where\") && o.where && (s2 = se$1.addClause(s2, o.where)), l2.includes(\"limit\") || (s2 = s2.limit(o.limit ?? p2.limit)), l2.includes(\"offset\") || (s2 = s2.offset(o.offset ?? p2.offset)), l2.includes(\"sort\") || (s2 = s2.orderBy(a2(o.sort?.by ?? \"id\"), o.sort?.dir ?? \"asc\")), s2;\n      }\n      buildQuery(e, t = []) {\n        let r2 = this.entity, i = this.getValidOptions(e);\n        return { qb: this.addOptionsToQueryBuilder(void 0, i, { ignore: t, alias: r2.name, validate: false }), options: i };\n      }\n      async findId(e, t) {\n        let { qb: r2, options: i } = this.buildQuery({ ...t, where: { [this.entity.getPrimaryField().name]: e }, limit: 1 }, [\"offset\", \"sort\"]);\n        return this.single(r2, i);\n      }\n      async findOne(e, t) {\n        let { qb: r2, options: i } = this.buildQuery({ ...t, where: e, limit: 1 });\n        return await this.single(r2, i);\n      }\n      async findMany(e) {\n        let { qb: t, options: r2 } = this.buildQuery(e);\n        await this.triggerFindBefore(this.entity, r2);\n        let i = await this.performQuery(t);\n        return await this.triggerFindAfter(this.entity, r2, i.data), i;\n      }\n      async findManyByReference(e, t, r2) {\n        let i = this.entity, o = this.em.relations.listableRelationsOf(i).find((p2) => p2.ref(t).reference === t);\n        if (!o) throw new Error(`Relation \"${t}\" not found or not listable on entity \"${i.name}\"`);\n        let c = o.other(i).entity, a2 = o.getReferenceQuery(c, e, t);\n        if (!(\"where\" in a2) || Object.keys(a2.where).length === 0) throw new Error(`Invalid reference query for \"${t}\" on entity \"${c.name}\"`);\n        let l2 = { ...r2, ...a2, where: { ...a2.where, ...r2?.where } };\n        return this.cloneFor(c).findMany(l2);\n      }\n      async count(e) {\n        let t = this.entity, r2 = this.getValidOptions({ where: e }), i = this.conn.fn.count(sql`*`).as(\"count\"), s2 = this.conn.selectFrom(t.name).select(i);\n        r2.where && (s2 = se$1.addClause(s2, r2.where));\n        let { result: o, ...c } = await this.executeQb(s2);\n        return { sql: c.sql, parameters: [...c.parameters], result: o, count: o[0]?.count ?? 0 };\n      }\n      async exists(e) {\n        let t = this.entity, r2 = this.getValidOptions({ where: e }), i = this.conn.fn.count(sql`*`).as(\"count\"), s2 = this.conn.selectFrom(t.name).select(i);\n        s2 = se$1.addClause(s2, r2.where).limit(1);\n        let { result: o, ...c } = await this.executeQb(s2);\n        return { sql: c.sql, parameters: [...c.parameters], result: o, exists: o[0].count > 0 };\n      }\n    };\n    __name(ve$3, \"ve$3\");\n    gp = [re$3(\"$eq\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \"=\", n252)), re$3(\"$ne\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \"!=\", n252)), re$3(\"$gt\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \">\", n252)), re$3(\"$gte\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \">=\", n252)), re$3(\"$lt\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \"<\", n252)), re$3(\"$lte\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \"<=\", n252)), re$3(\"$isnull\", (n252) => Ri$1(n252), (n252, e, t) => t(ve$3(e), n252 ? \"is\" : \"is not\", null)), re$3(\"$in\", (n252) => Array.isArray(n252), (n252, e, t) => t(ve$3(e), \"in\", n252)), re$3(\"$notin\", (n252) => Array.isArray(n252), (n252, e, t) => t(ve$3(e), \"not in\", n252)), re$3(\"$between\", (n252) => Array.isArray(n252) && n252.length === 2, (n252, e, t) => t.between(ve$3(e), n252[0], n252[1])), re$3(\"$like\", (n252) => Fe$1(n252), (n252, e, t) => t(ve$3(e), \"like\", String(n252).replace(/\\*/g, \"%\")))];\n    fn$1 = Ai$1(gp);\n    se$1 = class se {\n      static {\n        __name(this, \"se\");\n      }\n      static addClause(e, t) {\n        return Object.keys(t).length === 0 ? e : e.where((r2) => {\n          let i = fn$1.build(t, { value_is_kv: true, exp_ctx: r2, convert: true });\n          return i.$or.length > 0 && i.$and.length > 0 ? r2.and(i.$and).or(r2.and(i.$or)) : i.$or.length > 0 ? r2.or(i.$or) : r2.and(i.$and);\n        });\n      }\n      static convert(e) {\n        return fn$1.convert(e);\n      }\n      static getPropertyNames(e) {\n        let { keys: t } = fn$1.build(e, { value_is_kv: true, exp_ctx: /* @__PURE__ */ __name(() => null, \"exp_ctx\"), convert: true });\n        return Array.from(t);\n      }\n    };\n    hr$1 = class n12 {\n      static {\n        __name(this, \"n12\");\n      }\n      static addClause(e, t, r2, i) {\n        if (!i || !Rt$1(i)) return console.warn(`'withs' undefined or invalid, given: ${JSON.stringify(i)}`), t;\n        let s2 = e.connection.fn, o = t;\n        for (let [c, a2] of Object.entries(i)) {\n          let l2 = e.relationOf(r2.name, c);\n          if (!l2) throw new Error(`Relation \"${r2.name}<>${c}\" not found`);\n          let p2 = l2.ref(c).cardinality, u3 = p2 === 1 ? s2.jsonObjectFrom : s2.jsonArrayFrom;\n          if (!u3) throw new Error(\"Connection does not support jsonObjectFrom/jsonArrayFrom\");\n          let d2 = l2.other(r2);\n          o = o.select((y3) => {\n            let b3 = l2.buildWith(r2, c)(y3);\n            return a2 && (b3 = e.repo(d2.entity).addOptionsToQueryBuilder(b3, a2, { ignore: [\"with\", \"join\", p2 === 1 ? \"limit\" : void 0].filter(Boolean) })), a2.with && (b3 = n12.addClause(e, b3, d2.entity, a2.with)), u3(b3).as(d2.reference);\n          });\n        }\n        return o;\n      }\n      static validateWiths(e, t, r2) {\n        let i = 0;\n        if (!r2 || !Rt$1(r2)) return r2 && console.warn(`'withs' invalid, given: ${JSON.stringify(r2)}`), i;\n        let s2 = [];\n        for (let [o, c] of Object.entries(r2)) {\n          if (!e.relationOf(t, o)) throw new ne$1(`WITH: \"${o}\" is not a relation of \"${t}\"`);\n          i++, \"with\" in c && s2.push(n12.validateWiths(e, o, c.with));\n        }\n        return s2.length > 0 && (i += Math.max(...s2)), i;\n      }\n    };\n    yn$1 = class yn extends we$2 {\n      static {\n        __name(this, \"yn\");\n      }\n      supported = { batching: true };\n      constructor() {\n        super(void 0);\n      }\n      getFieldSchema(e, t) {\n        throw new Error(\"Method not implemented.\");\n      }\n    };\n    ({ Type: Pe$1 } = p$1);\n    ls$1 = Pe$1.Composite([Pe$1.Object({ entity: Pe$1.String(), min_items: Pe$1.Optional(Pe$1.Number()), max_items: Pe$1.Optional(Pe$1.Number()), mime_types: Pe$1.Optional(Pe$1.Array(Pe$1.String())) }), N$3]);\n    Ke$1 = class Ke extends P$3 {\n      static {\n        __name(this, \"Ke\");\n      }\n      type = \"media\";\n      constructor(e, t) {\n        super(e, { ...t, fillable: [\"update\"], virtual: true });\n      }\n      getSchema() {\n        return ls$1;\n      }\n      getMaxItems() {\n        return this.config.max_items;\n      }\n      getMinItems() {\n        return this.config.min_items;\n      }\n      schema() {\n      }\n      toJsonSchema() {\n        let e = \"../schema.json#/properties/media\", t = this.config?.min_items, r2 = this.config?.max_items;\n        return r2 === 1 ? { $ref: e } : { type: \"array\", items: { $ref: e }, minItems: t, maxItems: r2 };\n      }\n    };\n    hn$1 = { text: /* @__PURE__ */ __name((n252) => new Ze$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"text\"), number: /* @__PURE__ */ __name((n252) => new Ye$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"number\"), date: /* @__PURE__ */ __name((n252) => new ut$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"date\"), datetime: /* @__PURE__ */ __name((n252) => new ut$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"datetime\"), boolean: /* @__PURE__ */ __name((n252) => new Pt$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"boolean\"), enumm: /* @__PURE__ */ __name((n252) => new jt$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"enumm\"), json: /* @__PURE__ */ __name((n252) => new Mt$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"json\"), jsonSchema: /* @__PURE__ */ __name((n252) => new It$1(n252.field_name, { ...n252.config, required: n252.is_required }), \"jsonSchema\"), media: /* @__PURE__ */ __name((n252) => new Ke$1(n252.field_name, { ...n252.config, entity: n252.entity.name, required: n252.is_required }), \"media\"), medium: /* @__PURE__ */ __name((n252) => new Ke$1(n252.field_name, { ...n252.config, entity: n252.entity.name, required: n252.is_required }), \"medium\") };\n    __name(Oe$2, \"Oe$2\");\n    __name(gr$1, \"gr$1\");\n    __name(br$1, \"br$1\");\n    __name(Ko, \"Ko\");\n    __name(xr$1, \"xr$1\");\n    __name(Jo, \"Jo\");\n    __name(zo, \"zo\");\n    __name(Go, \"Go\");\n    ue$2 = class ue {\n      static {\n        __name(this, \"ue\");\n      }\n      constructor(e, t, r2) {\n        this.type = e;\n        this.config = t;\n        this.is_required = r2;\n      }\n      required() {\n        return this.is_required = true, this;\n      }\n      getField(e) {\n        if (!hn$1[this.type]) throw new Error(`Unknown field type: ${this.type}`);\n        try {\n          return hn$1[this.type](e);\n        } catch (t) {\n          throw new Error(`Faild to construct field \"${this.type}\": ${t}`);\n        }\n      }\n      make(e) {\n        if (!hn$1[this.type]) throw new Error(`Unknown field type: ${this.type}`);\n        try {\n          return hn$1[this.type]({ entity: { name: \"unknown\", fields: {} }, field_name: e, config: this.config, is_required: this.is_required });\n        } catch (t) {\n          throw new Error(`Faild to construct field \"${this.type}\": ${t}`);\n        }\n      }\n    };\n    __name(qt$1, \"qt$1\");\n    __name(xp, \"xp\");\n    __name(wp, \"wp\");\n    ps$1 = class ps extends et$1 {\n      static {\n        __name(this, \"ps\");\n      }\n      constructor(t, r2 = [], i = []) {\n        super(Object.values(t), new yn$1(), r2, i);\n        this.__entities = t;\n      }\n      withConnection(t) {\n        return new et$1(this.entities, t, this.relations.all, this.indices);\n      }\n    };\n    __name(gn$1, \"gn$1\");\n    Bt$1 = class Bt {\n      static {\n        __name(this, \"Bt\");\n      }\n      plugins;\n      constructor(e = []) {\n        this.plugins = new Set(e);\n      }\n      async transformResultRows(e) {\n        let t = e;\n        for (let r2 of this.plugins) t = (await r2.transformResult({ queryId: \"1\", result: { rows: t } })).rows;\n        return t;\n      }\n    };\n    bn = class {\n      static {\n        __name(this, \"bn\");\n      }\n      constructor(e, t = {}) {\n        this.db = e;\n        this._excludeTables = t.excludeTables ?? [], this._plugins = t.plugins ?? [new ParseJSONResultsPlugin()];\n      }\n      _excludeTables = [];\n      _plugins;\n      getExcludedTableNames() {\n        return [...this._excludeTables, DEFAULT_MIGRATION_TABLE, DEFAULT_MIGRATION_LOCK_TABLE];\n      }\n      async executeWithPlugins(e) {\n        let t = await e.execute(this.db);\n        return await new Bt$1(this._plugins ?? []).transformResultRows(t.rows);\n      }\n      async getMetadata(e) {\n        return { tables: await this.getTables(e) };\n      }\n      async getIndices(e) {\n        return (await this.getSchemaSpec()).flatMap((r2) => r2.indices).filter((r2) => !e || r2.table === e);\n      }\n      async getTables(e = { withInternalKyselyTables: false }) {\n        return (await this.getSchemaSpec()).map((r2) => ({ name: r2.name, isView: r2.isView, columns: r2.columns }));\n      }\n    };\n    xn$1 = class xn {\n      static {\n        __name(this, \"xn\");\n      }\n      #e;\n      constructor(e) {\n        this.#e = e;\n      }\n      createAdapter() {\n        return new SqliteAdapter();\n      }\n      createDriver() {\n        let e, t;\n        if (\"client\" in this.#e) e = this.#e.client, t = false;\n        else if (this.#e.url !== void 0) e = createClient(this.#e), t = true;\n        else throw new Error(\"Please specify either `client` or `url` in the LibsqlDialect config\");\n        return new us$1(e, t);\n      }\n      createIntrospector(e) {\n        return new SqliteIntrospector(e);\n      }\n      createQueryCompiler() {\n        return new SqliteQueryCompiler();\n      }\n    };\n    us$1 = class us {\n      static {\n        __name(this, \"us\");\n      }\n      client;\n      #e;\n      constructor(e, t) {\n        this.client = e, this.#e = t;\n      }\n      async init() {\n      }\n      async acquireConnection() {\n        return new ds$1(this.client);\n      }\n      async beginTransaction(e, t) {\n        await e.beginTransaction();\n      }\n      async commitTransaction(e) {\n        await e.commitTransaction();\n      }\n      async rollbackTransaction(e) {\n        await e.rollbackTransaction();\n      }\n      async releaseConnection(e) {\n      }\n      async destroy() {\n        this.#e && this.client.close();\n      }\n    };\n    ds$1 = class ds {\n      static {\n        __name(this, \"ds\");\n      }\n      client;\n      #e;\n      constructor(e) {\n        this.client = e;\n      }\n      async executeQuery(e) {\n        let r2 = await (this.#e ?? this.client).execute({ sql: e.sql, args: e.parameters });\n        return { insertId: r2.lastInsertRowid, numAffectedRows: BigInt(r2.rowsAffected), rows: r2.rows };\n      }\n      async beginTransaction() {\n        if (this.#e) throw new Error(\"Transaction already in progress\");\n        this.#e = await this.client.transaction();\n      }\n      async commitTransaction() {\n        if (!this.#e) throw new Error(\"No transaction to commit\");\n        await this.#e.commit(), this.#e = void 0;\n      }\n      async rollbackTransaction() {\n        if (!this.#e) throw new Error(\"No transaction to rollback\");\n        await this.#e.rollback(), this.#e = void 0;\n      }\n      async *streamQuery(e, t) {\n        throw new Error(\"Libsql Driver does not support streaming yet\");\n      }\n    };\n    wn = class {\n      static {\n        __name(this, \"wn\");\n      }\n      transformQuery(e) {\n        return e.node;\n      }\n      transformResult(e) {\n        return Promise.resolve({ ...e.result, rows: e.result.rows.map((t) => {\n          let r2 = {};\n          for (let i in t) Number.isNaN(+i) && (r2[i] = t[i]);\n          return r2;\n        }) });\n      }\n    };\n    En = class extends we$2 {\n      static {\n        __name(this, \"En\");\n      }\n      constructor(e, t = {}, r2 = []) {\n        super(e, { ...t, jsonArrayFrom, jsonObjectFrom, jsonBuildObject }, r2);\n      }\n      getFieldSchema(e) {\n        this.validateFieldSpecType(e.type);\n        let t = e.type;\n        switch (e.type) {\n          case \"json\":\n            t = \"text\";\n            break;\n        }\n        return [e.name, t, (r2) => {\n          if (e.primary) return e.type === \"integer\" ? r2.primaryKey().notNull().autoIncrement() : r2.primaryKey().notNull();\n          if (e.references) {\n            let i = r2.references(e.references);\n            return e.onDelete && (i = i.onDelete(e.onDelete)), e.onUpdate && (i = i.onUpdate(e.onUpdate)), i;\n          }\n          return e.nullable ? r2 : r2.notNull();\n        }];\n      }\n    };\n    Tn = class extends bn {\n      static {\n        __name(this, \"Tn\");\n      }\n      async getSchemas() {\n        return [];\n      }\n      async getSchemaSpec() {\n        let e = this.getExcludedTableNames().map((i) => `'${i}'`).join(\", \"), t = sql`\n         SELECT m.name, m.type, m.sql,\n            (SELECT json_group_array(\n               json_object(\n                  'name', p.name,\n                  'type', p.type,\n                  'notnull', p.\"notnull\",\n                  'default', p.dflt_value,\n                  'primary_key', p.pk\n               )) FROM pragma_table_info(m.name) p) AS columns,\n            (SELECT json_group_array(\n               json_object(\n                  'name', i.name,\n                  'origin', i.origin,\n                  'partial', i.partial,\n                  'sql', im.sql,\n                  'columns', (SELECT json_group_array(\n                     json_object(\n                        'name', ii.name,\n                        'seqno', ii.seqno\n                     )) FROM pragma_index_info(i.name) ii)\n               )) FROM pragma_index_list(m.name) i\n                 LEFT JOIN sqlite_master im ON im.name = i.name\n                  AND im.type = 'index'\n            ) AS indices\n         FROM sqlite_master m\n         WHERE m.type IN ('table', 'view')\n           and m.name not like 'sqlite_%'\n           and m.name not in (${sql.raw(e)})\n      `;\n        return (await this.executeWithPlugins(t)).map((i) => ({ name: i.name, isView: i.type === \"view\", columns: i.columns.map((s2) => {\n          let o = i.sql?.split(/[\\(\\),]/)?.find((c) => c.toLowerCase().includes(\"autoincrement\"))?.trimStart()?.split(/\\s+/)?.[0]?.replace(/[\"`]/g, \"\");\n          return { name: s2.name, dataType: s2.type, isNullable: !s2.notnull, isAutoIncrementing: s2.name === o, hasDefaultValue: s2.dflt_value != null, comment: void 0 };\n        }), indices: i.indices.map((s2) => ({ name: s2.name, table: i.name, isUnique: s2.sql?.match(/unique/i) != null, columns: s2.columns.map((o) => ({ name: o.name, order: o.seqno })) })) }));\n      }\n    };\n    _p = [\"wss\", \"https\", \"libsql\"];\n    ms = [new wn(), new ParseJSONResultsPlugin()];\n    fs$1 = class fs extends xn$1 {\n      static {\n        __name(this, \"fs\");\n      }\n      createIntrospector(e) {\n        return new Tn(e, { excludeTables: [\"libsql_wasm_func_table\"], plugins: ms });\n      }\n    };\n    yt$1 = class yt extends En {\n      static {\n        __name(this, \"yt\");\n      }\n      client;\n      supported = { batching: true };\n      constructor(e) {\n        let t, r2 = true;\n        if (e && \"url\" in e) {\n          let { url: s2, authToken: o, protocol: c } = e;\n          if (c && _p.includes(c)) {\n            m$1.log(\"changing protocol to\", c);\n            let [, a2] = s2.split(\"://\");\n            s2 = `${c}://${a2}`;\n          }\n          t = createClient({ url: s2, authToken: o });\n        } else t = e;\n        let i = new Kysely({ dialect: new fs$1({ client: t }), plugins: ms });\n        super(i, {}, ms), this.client = t, this.supported.batching = r2;\n      }\n      getClient() {\n        return this.client;\n      }\n      async batch(e) {\n        let t = e.map((o) => {\n          let c = o.compile();\n          return { sql: c.sql, args: c.parameters };\n        }), r2 = await this.client.batch(t), i = new Bt$1(this.plugins), s2 = [];\n        for (let o of r2) {\n          let c = await i.transformResultRows(o.rows);\n          s2.push(c);\n        }\n        return s2;\n      }\n    };\n    Sn = { ...Do$1, ...No$1, media: { schema: ls$1, field: Ke$1 } };\n    Ho = as;\n    kp = ze$1(Sn, (n252, e) => Type.Object({ type: Type.Const(e, { default: e, readOnly: true }), config: Type.Optional(n252.schema) }, { title: e }));\n    Pp = Type.Union(Object.values(kp));\n    jp = ce$2(Pp);\n    Mp = Type.Object({ type: Type.Optional(Type.String({ enum: $o$1, default: \"regular\", readOnly: true })), config: Type.Optional(is$1), fields: Type.Optional(jp) });\n    Ip = Object.entries(as).map(([n252, e]) => Type.Object({ type: Type.Const(n252, { default: n252, readOnly: true }), source: Type.String(), target: Type.String(), config: Type.Optional(e.schema) }, { title: n252 }));\n    Dp = Type.Object({ entity: Type.String(), fields: Type.Array(Type.String(), { minItems: 1 }), unique: Type.Optional(Type.Boolean({ default: false })) }, { additionalProperties: false });\n    Yo = Type.Object({ basepath: Type.Optional(Type.String({ default: \"/api/data\" })), default_primary_format: Type.Optional(w$4(fr$1, { default: \"integer\" })), entities: Type.Optional(ce$2(Mp, { default: {} })), relations: Type.Optional(ce$2(Type.Union(Ip), { default: {} })), indices: Type.Optional(ce$2(Dp, { default: {} })) }, { additionalProperties: false });\n    __name(ys$1, \"ys$1\");\n    __name(hs, \"hs\");\n    j$3 = {};\n    Je$2(j$3, { databaseSync: /* @__PURE__ */ __name(() => Up, \"databaseSync\"), entityCreate: /* @__PURE__ */ __name(() => qp, \"entityCreate\"), entityDelete: /* @__PURE__ */ __name(() => Np, \"entityDelete\"), entityRead: /* @__PURE__ */ __name(() => $p, \"entityRead\"), entityUpdate: /* @__PURE__ */ __name(() => Bp, \"entityUpdate\"), rawMutate: /* @__PURE__ */ __name(() => Qp, \"rawMutate\"), rawQuery: /* @__PURE__ */ __name(() => Lp, \"rawQuery\") });\n    $p = new R$2(\"data.entity.read\");\n    qp = new R$2(\"data.entity.create\");\n    Bp = new R$2(\"data.entity.update\");\n    Np = new R$2(\"data.entity.delete\");\n    Up = new R$2(\"data.database.sync\");\n    Lp = new R$2(\"data.raw.query\");\n    Qp = new R$2(\"data.raw.mutate\");\n    ({ ...Ne$2 });\n    rt$1 = class rt extends I$1 {\n      static {\n        __name(this, \"rt\");\n      }\n      getSafeErrorAndCode() {\n        return { error: \"Invalid credentials\", code: 401 };\n      }\n      toJSON() {\n        return K$1() ? super.toJSON() : { error: this.getSafeErrorAndCode().error, type: \"AuthException\" };\n      }\n    };\n    wr$1 = class wr extends rt$1 {\n      static {\n        __name(this, \"wr\");\n      }\n      name = \"UserNotFoundException\";\n      code = 404;\n      constructor() {\n        super(\"User not found\");\n      }\n    };\n    ht$1 = class ht extends rt$1 {\n      static {\n        __name(this, \"ht\");\n      }\n      name = \"InvalidCredentialsException\";\n      code = 401;\n      constructor() {\n        super(\"Invalid credentials\");\n      }\n    };\n    vn = class extends rt$1 {\n      static {\n        __name(this, \"vn\");\n      }\n      name = \"UnableToCreateUserException\";\n      code = 500;\n      constructor() {\n        super(\"Unable to create user\");\n      }\n    };\n    de$2 = class de extends rt$1 {\n      static {\n        __name(this, \"de\");\n      }\n      code = 422;\n      constructor(e) {\n        super(e ?? \"Invalid conditions\");\n      }\n    };\n    ({ Type: Q$1 } = p$1);\n    Zo = 60 * 60 * 24 * 7;\n    gs = Q$1.Partial(Q$1.Object({ path: Q$1.String({ default: \"/\" }), sameSite: w$4([\"strict\", \"lax\", \"none\"], { default: \"lax\" }), secure: Q$1.Boolean({ default: true }), httpOnly: Q$1.Boolean({ default: true }), expires: Q$1.Number({ default: Zo }), renew: Q$1.Boolean({ default: true }), pathSuccess: Q$1.String({ default: \"/\" }), pathLoggedOut: Q$1.String({ default: \"/\" }) }), { default: {}, additionalProperties: false });\n    On = Q$1.Object({ secret: Q$1.String({ default: \"\" }), alg: Q$1.Optional(w$4([\"HS256\", \"HS384\", \"HS512\"], { default: \"HS256\" })), expires: Q$1.Optional(Q$1.Number()), issuer: Q$1.Optional(Q$1.String()), fields: Q$1.Array(Q$1.String(), { default: [\"id\", \"email\", \"role\"] }) }, { default: {}, additionalProperties: false });\n    ea = Q$1.Object({ jwt: On, cookie: gs });\n    Er$1 = class Er {\n      static {\n        __name(this, \"Er\");\n      }\n      constructor(e, t, r2) {\n        this.strategies = e;\n        this.userPool = t;\n        this.config = _$2(ea, r2 ?? {});\n      }\n      config;\n      async resolveLogin(e, t, r2, i, s2) {\n        try {\n          let o = s2?.identifier || \"email\";\n          if (typeof o != \"string\" || o.length === 0) throw new de$2(\"Identifier must be a string\");\n          if (!(o in r2)) throw new de$2(`Profile must have identifier \"${o}\"`);\n          let c = await this.userPool.findBy(t.getName(), o, r2[o]);\n          if (c.strategy_value) {\n            if (c.strategy !== t.getName()) throw new de$2(\"User signed up with a different strategy\");\n          } else throw new de$2(\"User must have a strategy value\");\n          await i(c);\n          let a2 = await this.safeAuthResponse(c);\n          return this.respondWithUser(e, a2, s2);\n        } catch (o) {\n          return this.respondWithError(e, o, s2);\n        }\n      }\n      async resolveRegister(e, t, r2, i, s2) {\n        try {\n          let o = s2?.identifier || \"email\";\n          if (typeof o != \"string\" || o.length === 0) throw new de$2(\"Identifier must be a string\");\n          if (!(o in r2)) throw new de$2(`Profile must have identifier \"${o}\"`);\n          if (!(\"strategy_value\" in r2)) throw new de$2(\"Profile must have a strategy value\");\n          let c = await this.userPool.create(t.getName(), { ...r2, strategy_value: r2.strategy_value });\n          await i(c);\n          let a2 = await this.safeAuthResponse(c);\n          return this.respondWithUser(e, a2, s2);\n        } catch (o) {\n          return this.respondWithError(e, o, s2);\n        }\n      }\n      async respondWithUser(e, t, r2) {\n        let i = this.getSafeUrl(e, r2?.redirect ?? this.config.cookie.pathSuccess ?? \"/\");\n        if (\"token\" in t) return await this.setAuthCookie(e, t.token), this.isJsonRequest(e) || r2?.forceJsonResponse ? e.json(t) : e.redirect(i);\n        throw new I$1(\"Invalid response\");\n      }\n      async respondWithError(e, t, r2) {\n        if (m$1.error(\"respondWithError\", t), this.isJsonRequest(e) || r2?.forceJsonResponse) throw t;\n        await Ft$1(e, String(t), \"error\");\n        let i = this.getSafeUrl(e, r2?.redirect ?? e.req.header(\"Referer\") ?? \"/\");\n        return e.redirect(i);\n      }\n      getStrategies() {\n        return this.strategies;\n      }\n      strategy(e) {\n        try {\n          return this.strategies[e];\n        } catch {\n          throw new Error(`Strategy \"${String(e)}\" not found`);\n        }\n      }\n      async jwt(e) {\n        let r2 = { ...pick(e, this.config.jwt.fields), iat: Math.floor(Date.now() / 1e3) };\n        this.config.jwt?.issuer && (r2.iss = this.config.jwt.issuer), this.config.jwt?.expires && (r2.exp = Math.floor(Date.now() / 1e3) + this.config.jwt.expires);\n        let i = this.config.jwt.secret;\n        if (!i || i.length === 0) throw new Error(\"Cannot sign JWT without a secret\");\n        return sign2(r2, i, this.config.jwt?.alg ?? \"HS256\");\n      }\n      async safeAuthResponse(e) {\n        let t = pick(e, this.config.jwt.fields);\n        return { user: t, token: await this.jwt(t) };\n      }\n      async verify(e) {\n        try {\n          let t = await verify2(e, this.config.jwt?.secret ?? \"\", this.config.jwt?.alg ?? \"HS256\");\n          if (this.config.jwt?.issuer && t.iss !== this.config.jwt.issuer) throw new I$1(\"Invalid issuer\", 403);\n          return t;\n        } catch {\n        }\n      }\n      get cookieOptions() {\n        let { expires: e = Zo, renew: t, ...r2 } = this.config.cookie;\n        return { ...r2, expires: new Date(Date.now() + e * 1e3) };\n      }\n      async getAuthCookie(e) {\n        try {\n          let t = this.config.jwt.secret, r2 = await getSignedCookie(e, t, \"auth\");\n          return typeof r2 != \"string\" ? void 0 : r2;\n        } catch (t) {\n          t instanceof Error && m$1.error(\"[getAuthCookie]\", t.message);\n          return;\n        }\n      }\n      async requestCookieRefresh(e) {\n        if (this.config.cookie.renew && e.get(\"auth\")?.user) {\n          let t = await this.getAuthCookie(e);\n          t && await this.setAuthCookie(e, t);\n        }\n      }\n      async setAuthCookie(e, t) {\n        m$1.debug(\"setting auth cookie\", Ys(t));\n        let r2 = this.config.jwt.secret;\n        await setSignedCookie(e, \"auth\", t, r2, this.cookieOptions);\n      }\n      async deleteAuthCookie(e) {\n        m$1.debug(\"deleting auth cookie\"), await deleteCookie(e, \"auth\", this.cookieOptions);\n      }\n      async logout(e) {\n        m$1.info(\"Logging out\"), e.set(\"auth\", void 0), await this.getAuthCookie(e) && (await this.deleteAuthCookie(e), await Ft$1(e, \"Signed out\", \"info\"));\n      }\n      isJsonRequest(e) {\n        return e.req.header(\"Content-Type\") === \"application/json\";\n      }\n      async getBody(e) {\n        return this.isJsonRequest(e) ? await e.req.json() : Object.fromEntries((await e.req.formData()).entries());\n      }\n      getSafeUrl(e, t) {\n        let r2 = t.replace(/\\/+$/, \"/\");\n        return to$1(\"redirects_non_fq\") ? r2 : new URL(e.req.url).origin + r2;\n      }\n      async resolveAuthFromRequest(e) {\n        let t;\n        if (e.req.raw.headers.has(\"Authorization\") ? t = String(e.req.header(\"Authorization\")).replace(\"Bearer \", \"\") : t = await this.getAuthCookie(e), t) return await this.verify(t);\n      }\n      toJSON(e) {\n        return { ...this.config, jwt: e ? this.config.jwt : void 0 };\n      }\n    };\n    H$3 = class H {\n      static {\n        __name(this, \"H\");\n      }\n      constructor(e, t) {\n        this._ctx = t;\n        this._schema = new At$1(this.getSchema(), e, { forceParse: this.useForceParse(), onUpdate: /* @__PURE__ */ __name(async (r2) => {\n          await this._listener(r2);\n        }, \"onUpdate\"), restrictPaths: this.getRestrictedPaths(), overwritePaths: this.getOverwritePaths(), onBeforeUpdate: this.onBeforeUpdate.bind(this) });\n      }\n      _built = false;\n      _schema;\n      _listener = /* @__PURE__ */ __name(() => null, \"_listener\");\n      static ctx_flags = { sync_required: false, ctx_reload_required: false };\n      onBeforeUpdate(e, t) {\n        return t;\n      }\n      setListener(e) {\n        return this._listener = e, this;\n      }\n      useForceParse() {\n        return false;\n      }\n      getRestrictedPaths() {\n      }\n      getOverwritePaths() {\n      }\n      get configDefault() {\n        return this._schema.default();\n      }\n      get config() {\n        return this._schema.get();\n      }\n      setContext(e) {\n        return this._ctx = e, this;\n      }\n      schema() {\n        return this._schema;\n      }\n      onServerInit(e) {\n      }\n      get ctx() {\n        if (!this._ctx) throw new Error(\"Context not set\");\n        return this._ctx;\n      }\n      async build() {\n        throw new Error(\"Not implemented\");\n      }\n      setBuilt() {\n        this._built = true, this._schema = new At$1(this.getSchema(), this.toJSON(true), { onUpdate: /* @__PURE__ */ __name(async (e) => {\n          await this._listener(e);\n        }, \"onUpdate\"), forceParse: this.useForceParse(), restrictPaths: this.getRestrictedPaths(), overwritePaths: this.getOverwritePaths(), onBeforeUpdate: this.onBeforeUpdate.bind(this) });\n      }\n      isBuilt() {\n        return this._built;\n      }\n      throwIfNotBuilt() {\n        if (!this._built) throw new Error(\"Config not built: \" + this.constructor.name);\n      }\n      toJSON(e) {\n        return this.config;\n      }\n      ensureEntity(e) {\n        let t = this.ctx.em.entity(e.name, true);\n        if (!t) {\n          this.ctx.em.addEntity(e), this.ctx.flags.sync_required = true;\n          return;\n        }\n        for (let r2 of e.fields) {\n          let i = t.field(r2.name);\n          i ? this.setEntityFieldConfigs(r2, i) > 0 && (this.ctx.flags.sync_required = true) : (t.addField(r2), this.ctx.flags.sync_required = true);\n        }\n        this.ctx.em.__replaceEntity(new Z$1(t.name, t.fields, t.config, e.type));\n      }\n      ensureIndex(e) {\n        this.ctx.em.hasIndex(e) || (this.ctx.em.addIndex(e), this.ctx.flags.sync_required = true);\n      }\n      ensureSchema(e) {\n        return Object.values(e.entities ?? {}).forEach(this.ensureEntity.bind(this)), e.indices?.forEach(this.ensureIndex.bind(this)), e;\n      }\n      setEntityFieldConfigs(e, t, r2 = [\"hidden\", \"fillable\", \"required\"]) {\n        let i = 0;\n        for (let s2 of r2) isEqual(t.config[s2], e.config[s2]) || (t.config[s2] = e.config[s2], i++);\n        return i;\n      }\n      replaceEntityField(e, t, r2) {\n        let i = this.ctx.em.entity(e), s2 = typeof t == \"string\" ? t : t.name, o = r2 instanceof ue$2 ? Go(s2, r2) : r2;\n        this.setEntityFieldConfigs(i.field(s2), o), i.__replaceField(s2, o);\n      }\n    };\n    Rn = {};\n    Je$2(Rn, { auth: /* @__PURE__ */ __name(() => ra, \"auth\"), permission: /* @__PURE__ */ __name(() => na, \"permission\") });\n    __name(bs, \"bs\");\n    __name(Yp, \"Yp\");\n    ra = /* @__PURE__ */ __name((n252) => createMiddleware(async (e, t) => {\n      e.get(\"auth\") || e.set(\"auth\", { registered: false, resolved: false, skip: false, user: void 0 });\n      let r2 = e.get(\"app\"), i = e.get(\"auth\"), s2 = r2?.module.auth.authenticator, o = Yp(e, n252?.skip) || !r2?.module.auth.enabled;\n      i.registered ? (o = true, m$1.warn(`auth middleware already registered for ${bs(e)}`)) : (i.registered = true, !o && !i.resolved && r2?.module.auth.enabled && (i.user = await s2?.resolveAuthFromRequest(e), i.resolved = true)), await t(), i.skip = false, i.resolved = false, i.user = void 0;\n    }), \"ra\");\n    na = /* @__PURE__ */ __name((n252, e) => createMiddleware(async (t, r2) => {\n      let i = t.get(\"app\"), s2 = t.get(\"auth\");\n      if (!s2) throw new Error(\"auth ctx not found\");\n      if (!s2.registered || !i) {\n        let o = `auth middleware not registered, cannot check permissions for ${bs(t)}`;\n        if (i?.module.auth.enabled) throw new Error(o);\n        m$1.warn(o);\n      } else if (!s2.skip) {\n        let o = i.modules.ctx().guard, c = Array.isArray(n252) ? n252 : [n252];\n        if (e?.onGranted || e?.onDenied) {\n          let a2;\n          if (c.every((l2) => o.granted(l2, t)) ? a2 = await e?.onGranted?.(t) : a2 = await e?.onDenied?.(t), a2 instanceof Response) return a2;\n        } else c.some((a2) => o.throwUnlessGranted(a2, t));\n      }\n      await r2();\n    }), \"na\");\n    me$3 = class n13 {\n      static {\n        __name(this, \"n13\");\n      }\n      middlewares = Rn;\n      create() {\n        return n13.createServer();\n      }\n      static createServer() {\n        return new Hono2();\n      }\n      getController() {\n        return this.create();\n      }\n      isJsonRequest(e) {\n        return e.req.header(\"Content-Type\") === \"application/json\" || e.req.header(\"Accept\") === \"application/json\";\n      }\n      notFound(e) {\n        return this.isJsonRequest(e) ? e.json({ error: \"Not found\" }, 404) : e.notFound();\n      }\n      getEntitiesEnum(e) {\n        let t = e.entities.map((r2) => r2.name);\n        return t.length > 0 ? f.string({ enum: t }) : f.string();\n      }\n    };\n    Cn$1 = class Cn extends me$3 {\n      static {\n        __name(this, \"Cn\");\n      }\n      constructor(t) {\n        super();\n        this.auth = t;\n      }\n      get guard() {\n        return this.auth.ctx.guard;\n      }\n      get em() {\n        return this.auth.ctx.em;\n      }\n      get userRepo() {\n        let t = this.auth.config.entity_name;\n        return this.em.repo(t);\n      }\n      registerStrategyActions(t, r2) {\n        if (!this.auth.isStrategyEnabled(t)) return;\n        let i = t.getActions?.();\n        if (!i) return;\n        let { auth: s2, permission: o } = this.middlewares, c = this.create().use(s2()), a2 = t.getName(), { create: l2, change: p2 } = i, u3 = this.auth.em;\n        l2 && (c.post(\"/create\", o([Ut$1.createUser, j$3.entityCreate]), S$2({ summary: \"Create a new user\", tags: [\"auth\"] }), async (d2) => {\n          try {\n            let y3 = await this.auth.authenticator.getBody(d2), b3 = _$2(l2.schema, y3, { skipMark: true }), L2 = await l2.preprocess?.(b3) ?? b3, $3 = u3.mutator(this.auth.config.entity_name);\n            $3.__unstable_toggleSystemEntityCreation(false);\n            let { data: ye2 } = await $3.insertOne({ ...L2, strategy: a2 });\n            return $3.__unstable_toggleSystemEntityCreation(true), d2.json({ success: true, action: \"create\", strategy: a2, data: ye2 });\n          } catch (y3) {\n            if (y3 instanceof De$2) return d2.json({ success: false, errors: y3.errors }, 400);\n            throw y3;\n          }\n        }), c.get(\"create/schema.json\", S$2({ summary: \"Get the schema for creating a user\", tags: [\"auth\"] }), async (d2) => d2.json(l2.schema))), r2.route(`/${a2}/actions`, c);\n      }\n      getController() {\n        let { auth: t } = this.middlewares, r2 = this.create();\n        r2.get(\"/me\", S$2({ summary: \"Get the current user\", tags: [\"auth\"] }), t(), async (s2) => {\n          let o = s2.get(\"auth\")?.user;\n          if (o) {\n            let { data: c } = await this.userRepo.findId(o.id);\n            return await this.auth.authenticator?.requestCookieRefresh(s2), s2.json({ user: c });\n          }\n          return s2.json({ user: null }, 403);\n        }), r2.get(\"/logout\", S$2({ summary: \"Logout the current user\", tags: [\"auth\"] }), t(), async (s2) => {\n          if (await this.auth.authenticator.logout(s2), this.auth.authenticator.isJsonRequest(s2)) return s2.json({ ok: true });\n          let o = s2.req.header(\"referer\");\n          return o ? s2.redirect(o) : s2.redirect(\"/\");\n        }), r2.get(\"/strategies\", S$2({ summary: \"Get the available authentication strategies\", tags: [\"auth\"] }), T$1(\"query\", f.object({ include_disabled: f.boolean().optional() })), async (s2) => {\n          let { include_disabled: o } = s2.req.valid(\"query\"), { strategies: c, basepath: a2 } = this.auth.toJSON(false);\n          return o ? s2.json({ strategies: c, basepath: a2 }) : s2.json({ strategies: O$2(c ?? {}, (l2, p2) => this.auth.isStrategyEnabled(p2) ? l2 : void 0), basepath: a2 });\n        });\n        let i = this.auth.authenticator.getStrategies();\n        for (let [s2, o] of Object.entries(i)) this.auth.isStrategyEnabled(o) && (r2.route(`/${s2}`, o.getController(this.auth.authenticator)), this.registerStrategyActions(o, r2));\n        return r2.all(\"*\", (s2) => s2.notFound());\n      }\n    };\n    Tr$1 = {};\n    Je$2(Tr$1, { github: /* @__PURE__ */ __name(() => sa, \"github\"), google: /* @__PURE__ */ __name(() => ia, \"google\") });\n    ia = { type: \"oidc\", client: { token_endpoint_auth_method: \"client_secret_basic\" }, as: { issuer: \"https://accounts.google.com\" }, profile: /* @__PURE__ */ __name(async (n252) => ({ ...n252, sub: n252.sub, email: n252.email }), \"profile\") };\n    sa = { type: \"oauth2\", client: { token_endpoint_auth_method: \"client_secret_basic\" }, as: { code_challenge_methods_supported: [\"S256\"], issuer: \"https://github.com\", scopes_supported: [\"read:user\", \"user:email\"], scope_separator: \" \", authorization_endpoint: \"https://github.com/login/oauth/authorize\", token_endpoint: \"https://github.com/login/oauth/access_token\", userinfo_endpoint: \"https://api.github.com/user\" }, profile: /* @__PURE__ */ __name(async (n252, e, t) => {\n      try {\n        let s2 = (await (await fetch(\"https://api.github.com/user/emails\", { headers: { \"User-Agent\": \"bknd\", Accept: \"application/json\", Authorization: `Bearer ${t.access_token}` } })).json()).find((o) => o.primary)?.email;\n        if (!s2) throw new Error(\"No primary email found\");\n        return { ...n252, sub: String(n252.id), email: s2 };\n      } catch {\n        throw new Error(\"Couldn't retrive github email\");\n      }\n    }, \"profile\") };\n    Lt$1 = class Lt {\n      static {\n        __name(this, \"Lt\");\n      }\n      constructor(e, t, r2, i) {\n        this.config = e;\n        this.type = t;\n        this.name = r2;\n        this.mode = i;\n        this.config = _$2(this.getSchema(), e ?? {});\n      }\n      actions = {};\n      registerAction(e, t, r2) {\n        this.actions[e] = { schema: t, preprocess: r2 };\n      }\n      getType() {\n        return this.type;\n      }\n      getMode() {\n        return this.mode;\n      }\n      getName() {\n        return this.name;\n      }\n      toJSON(e) {\n        return { type: this.getType(), config: e ? this.config : void 0 };\n      }\n      getActions() {\n        return this.actions;\n      }\n    };\n    ({ Type: xs } = p$1);\n    nu = xs.Object({ name: w$4(Object.keys(Tr$1)), type: w$4([\"oidc\", \"oauth2\"], { default: \"oauth2\" }), client: Ve$1({ client_id: xs.String(), client_secret: xs.String() }) }, { title: \"OAuth\" });\n    nt$1 = class nt extends I$1 {\n      static {\n        __name(this, \"nt\");\n      }\n      constructor(t, r2) {\n        super(\"OAuthCallbackException on \" + r2);\n        this.error = t;\n        this.step = r2;\n      }\n      name = \"OAuthCallbackException\";\n    };\n    it = class extends Lt$1 {\n      static {\n        __name(this, \"it\");\n      }\n      constructor(e) {\n        super(e, \"oauth\", e.name, \"external\");\n      }\n      getSchema() {\n        return nu;\n      }\n      getIssuerConfig() {\n        return Tr$1[this.config.name];\n      }\n      async getConfig() {\n        let e = this.getIssuerConfig();\n        if (e.type === \"oidc\") {\n          let t = new URL(e.as.issuer), r2 = await discoveryRequest(t);\n          e.as = await processDiscoveryResponse(t, r2);\n        }\n        return { ...e, type: e.type, client: { ...e.client, ...this.config.client } };\n      }\n      async getCodeChallenge(e, t, r2 = \"S256\") {\n        let i = e.code_challenge_methods_supported?.includes(r2), s2, o;\n        return i && (s2 = await calculatePKCECodeChallenge(t), o = r2), { challenge_supported: i, challenge: s2, challenge_method: o };\n      }\n      async request(e) {\n        let { client: t, as: r2 } = await this.getConfig(), { challenge_supported: i, challenge: s2, challenge_method: o } = await this.getCodeChallenge(r2, e.state);\n        if (!r2.authorization_endpoint) throw new Error(\"authorization_endpoint is not provided\");\n        let c = e.scopes ?? r2.scopes_supported;\n        if (!Array.isArray(c) || c.length === 0) throw new Error(\"No scopes provided\");\n        if (c.every((p2) => !r2.scopes_supported?.includes(p2))) throw new Error(\"Invalid scopes provided\");\n        let a2 = r2.authorization_endpoint, l2 = { client_id: t.client_id, redirect_uri: e.redirect_uri, response_type: \"code\", scope: c.join(r2.scope_separator ?? \" \") };\n        return i ? (l2.code_challenge = s2, l2.code_challenge_method = o) : l2.nonce = e.state, { url: new URL(a2) + \"?\" + new URLSearchParams(l2).toString(), endpoint: a2, params: l2 };\n      }\n      async oidc(e, t) {\n        let r2 = await this.getConfig(), { client: i, as: s2, type: o } = r2, c = validateAuthResponse(s2, i, e, expectNoState);\n        if (isOAuth2Error(c)) throw new nt$1(c, \"validateAuthResponse\");\n        let a2 = await authorizationCodeGrantRequest(s2, i, c, t.redirect_uri, t.state), l2 = parseWwwAuthenticateChallenges(a2);\n        if (l2) throw new nt$1(l2, \"www-authenticate\");\n        let { challenge_supported: p2, challenge: u3 } = await this.getCodeChallenge(s2, t.state), y3 = await processAuthorizationCodeOpenIDResponse(s2, i, a2, p2 ? void 0 : u3);\n        if (isOAuth2Error(y3)) throw new nt$1(y3, \"processAuthorizationCodeOpenIDResponse\");\n        let b3 = getValidatedIdTokenClaims(y3), L2 = await userInfoRequest(s2, i, y3.access_token), $3 = await processUserInfoResponse(s2, i, b3.sub, L2);\n        return await r2.profile($3, r2, b3);\n      }\n      async oauth2(e, t) {\n        let r2 = await this.getConfig(), { client: i, type: s2, as: o, profile: c } = r2, a2 = validateAuthResponse(o, i, e, expectNoState);\n        if (isOAuth2Error(a2)) throw new nt$1(a2, \"validateAuthResponse\");\n        let l2 = await authorizationCodeGrantRequest(o, i, a2, t.redirect_uri, t.state), p2 = parseWwwAuthenticateChallenges(l2);\n        if (p2) throw new nt$1(p2, \"www-authenticate\");\n        let u3 = l2.clone(), d2 = {};\n        try {\n          if (d2 = await processAuthorizationCodeOAuth2Response(o, i, l2), isOAuth2Error(d2)) throw new Error();\n        } catch {\n          d2 = await u3.json();\n        }\n        let b3 = await (await userInfoRequest(o, i, d2.access_token)).json();\n        return await r2.profile(b3, r2, d2);\n      }\n      async callback(e, t) {\n        switch (this.getIssuerConfig().type) {\n          case \"oidc\":\n            return await this.oidc(e, t);\n          case \"oauth2\":\n            return await this.oauth2(e, t);\n          default:\n            throw new Error(\"Unsupported type\");\n        }\n      }\n      getController(e) {\n        let t = new Hono2(), r2 = \"secret\", i = \"_challenge\", s2 = /* @__PURE__ */ __name(async (c, a2) => {\n          await setSignedCookie(c, i, JSON.stringify(a2), r2, { secure: true, httpOnly: true, sameSite: \"Lax\", maxAge: 60 * 5 });\n        }, \"s\"), o = /* @__PURE__ */ __name(async (c) => {\n          if (c.req.header(\"X-State-Challenge\")) return { state: c.req.header(\"X-State-Challenge\"), action: c.req.header(\"X-State-Action\"), mode: \"token\" };\n          let a2 = await getSignedCookie(c, r2, i);\n          try {\n            return JSON.parse(a2);\n          } catch {\n            throw new Error(\"Invalid state\");\n          }\n        }, \"o\");\n        return t.get(\"/callback\", async (c) => {\n          let a2 = new URL(c.req.url), l2 = new URLSearchParams(a2.search), p2 = await o(c), u3 = p2.mode === \"cookie\" ? a2.origin + a2.pathname : a2.origin + a2.pathname.replace(\"/callback\", \"/token\"), d2 = await this.callback(l2, { redirect_uri: u3, state: p2.state }), y3 = { email: d2.email, strategy_value: d2.sub }, b3 = /* @__PURE__ */ __name(async ($3) => {\n            if ($3.strategy_value !== d2.sub) throw new I$1(\"Invalid credentials\");\n          }, \"b\"), L2 = { redirect: p2.redirect, forceJsonResponse: p2.mode !== \"cookie\" };\n          switch (p2.action) {\n            case \"login\":\n              return e.resolveLogin(c, this, y3, b3, L2);\n            case \"register\":\n              return e.resolveRegister(c, this, y3, b3, L2);\n            default:\n              throw new Error(\"Invalid action\");\n          }\n        }), t.get(\"/token\", async (c) => {\n          let a2 = new URL(c.req.url), l2 = new URLSearchParams(a2.search);\n          return c.json({ code: l2.get(\"code\") ?? null });\n        }), t.post(\"/:action\", async (c) => {\n          let a2 = c.req.param(\"action\");\n          if (![\"login\", \"register\"].includes(a2)) return c.notFound();\n          let l2 = new URL(c.req.url), p2 = l2.pathname.replace(`/${a2}`, \"\"), u3 = l2.origin + p2 + \"/callback\", d2 = new URL(c.req.header(\"Referer\") ?? \"/\"), y3 = generateRandomCodeVerifier(), b3 = await this.request({ redirect_uri: u3, state: y3 });\n          return await s2(c, { state: y3, action: a2, redirect: d2.toString(), mode: \"cookie\" }), c.redirect(b3.url);\n        }), t.get(\"/:action\", async (c) => {\n          let a2 = c.req.param(\"action\");\n          if (![\"login\", \"register\"].includes(a2)) return c.notFound();\n          let l2 = new URL(c.req.url), p2 = l2.pathname.replace(`/${a2}`, \"\"), u3 = l2.origin + p2 + \"/token\", d2 = generateRandomCodeVerifier(), y3 = await this.request({ redirect_uri: u3, state: d2 });\n          return K$1() ? c.json({ url: y3.url, redirect_uri: u3, challenge: d2, action: a2, params: y3.params }) : c.json({ url: y3.url, challenge: d2, action: a2 });\n        }), t;\n      }\n      toJSON(e) {\n        let t = e ? this.config : di$1(this.config, [\"secret\", \"client_id\"]);\n        return { ...super.toJSON(e), config: { ...t, type: this.getIssuerConfig().type } };\n      }\n    };\n    ({ Type: ee$2 } = p$1);\n    ws = ee$2.String({ pattern: \"^(https?|wss?)://[^\\\\s/$.?#].[^\\\\s]*$\" });\n    su = Ve$1({ type: w$4([\"oidc\", \"oauth2\"], { default: \"oidc\" }), name: ee$2.String(), client: Ve$1({ client_id: ee$2.String(), client_secret: ee$2.String(), token_endpoint_auth_method: w$4([\"client_secret_basic\"]) }), as: Ve$1({ issuer: ee$2.String(), code_challenge_methods_supported: ee$2.Optional(w$4([\"S256\"])), scopes_supported: ee$2.Optional(ee$2.Array(ee$2.String())), scope_separator: ee$2.Optional(ee$2.String({ default: \" \" })), authorization_endpoint: ee$2.Optional(ws), token_endpoint: ee$2.Optional(ws), userinfo_endpoint: ee$2.Optional(ws) }) }, { title: \"Custom OAuth\" });\n    Qt$1 = class Qt extends it {\n      static {\n        __name(this, \"Qt\");\n      }\n      constructor(e) {\n        super(e), this.type = \"custom_oauth\";\n      }\n      getIssuerConfig() {\n        return { ...this.config, profile: /* @__PURE__ */ __name(async (e) => e, \"profile\") };\n      }\n      getSchema() {\n        return su;\n      }\n    };\n    ({ Type: st$1 } = p$1);\n    uu = Ve$1({ hashing: w$4([\"plain\", \"sha256\", \"bcrypt\"], { default: \"sha256\" }), rounds: st$1.Optional(st$1.Number({ minimum: 1, maximum: 10 })) });\n    Kt$1 = class Kt extends Lt$1 {\n      static {\n        __name(this, \"Kt\");\n      }\n      constructor(e = {}) {\n        super(e, \"password\", \"password\", \"form\"), this.registerAction(\"create\", this.getPayloadSchema(), async ({ password: t, ...r2 }) => ({ ...r2, strategy_value: await this.hash(t) }));\n      }\n      getSchema() {\n        return uu;\n      }\n      getPayloadSchema() {\n        return st$1.Object({ email: st$1.String({ pattern: \"^[\\\\w-\\\\.\\\\+_]+@([\\\\w-]+\\\\.)+[\\\\w-]{2,4}$\" }), password: st$1.String({ minLength: 8 }) });\n      }\n      async hash(e) {\n        switch (this.config.hashing) {\n          case \"sha256\":\n            return Vr$1.sha256(e);\n          case \"bcrypt\": {\n            let t = await genSalt(this.config.rounds ?? 4);\n            return hash2(e, t);\n          }\n          default:\n            return e;\n        }\n      }\n      async compare(e, t) {\n        switch (this.config.hashing) {\n          case \"sha256\": {\n            let r2 = await this.hash(t);\n            return e === r2;\n          }\n          case \"bcrypt\":\n            return await compare(t, e);\n        }\n        return false;\n      }\n      verify(e) {\n        return async (t) => {\n          if (await this.compare(t?.strategy_value, e) !== true) throw new ht$1();\n        };\n      }\n      getController(e) {\n        let t = new Hono2(), r2 = st$1.Object({ redirect: st$1.Optional(st$1.String()) }), i = this.getPayloadSchema();\n        return t.post(\"/login\", Ir(\"query\", r2), async (s2) => {\n          try {\n            let o = _$2(i, await e.getBody(s2), { onError: /* @__PURE__ */ __name((a2) => {\n              throw m$1.error(\"Invalid login payload\", [...a2]), new ht$1();\n            }, \"onError\") }), { redirect: c } = s2.req.valid(\"query\");\n            return await e.resolveLogin(s2, this, o, this.verify(o.password), { redirect: c });\n          } catch (o) {\n            return e.respondWithError(s2, o);\n          }\n        }), t.post(\"/register\", Ir(\"query\", r2), async (s2) => {\n          try {\n            let { redirect: o } = s2.req.valid(\"query\"), { password: c, email: a2, ...l2 } = _$2(i, await e.getBody(s2), { onError: /* @__PURE__ */ __name((u3) => {\n              m$1.error(\"Invalid register payload\", [...u3]), new ht$1();\n            }, \"onError\") }), p2 = { ...l2, email: a2, strategy_value: await this.hash(c) };\n            return await e.resolveRegister(s2, this, p2, async () => {\n            }, { redirect: o });\n          } catch (o) {\n            return e.respondWithError(s2, o);\n          }\n        }), t;\n      }\n    };\n    ({ Type: k$1 } = p$1);\n    mu = { password: { cls: Kt$1, schema: Kt$1.prototype.getSchema() }, oauth: { cls: it, schema: it.prototype.getSchema() }, custom_oauth: { cls: Qt$1, schema: Qt$1.prototype.getSchema() } };\n    Es = mu;\n    fu = ze$1(Es, (n252, e) => k$1.Object({ enabled: k$1.Optional(k$1.Boolean({ default: true })), type: k$1.Const(e, { default: e, readOnly: true }), config: n252.schema }, { title: e, additionalProperties: false }));\n    yu = k$1.Union(Object.values(fu));\n    hu = k$1.Object({ enabled: k$1.Optional(k$1.Boolean({ default: false })) });\n    gu = k$1.Object({ permissions: k$1.Optional(k$1.Array(k$1.String())), is_default: k$1.Optional(k$1.Boolean()), implicit_allow: k$1.Optional(k$1.Boolean()) }, { additionalProperties: false });\n    Ts = k$1.Object({ enabled: k$1.Boolean({ default: false }), basepath: k$1.String({ default: \"/api/auth\" }), entity_name: k$1.String({ default: \"users\" }), allow_register: k$1.Optional(k$1.Boolean({ default: true })), jwt: On, cookie: gs, strategies: k$1.Optional(ce$2(yu, { title: \"Strategies\", default: { password: { type: \"password\", enabled: true, config: { hashing: \"sha256\" } } } })), guard: k$1.Optional(hu), roles: k$1.Optional(ce$2(gu, { default: {} })) }, { title: \"Authentication\", additionalProperties: false });\n    An$1 = class An {\n      static {\n        __name(this, \"An\");\n      }\n      constructor(e) {\n        this.appAuth = e;\n      }\n      get em() {\n        return this.appAuth.em;\n      }\n      get users() {\n        return this.appAuth.getUsersEntity();\n      }\n      async findBy(e, t, r2) {\n        m$1.debug(\"[AppUserPool:findBy]\", { strategy: e, prop: t, value: r2 }), this.toggleStrategyValueVisibility(true);\n        let i = await this.em.repo(this.users).findOne({ [t]: r2, strategy: e });\n        if (this.toggleStrategyValueVisibility(false), !i.data) throw m$1.debug(\"[AppUserPool]: User not found\"), new wr$1();\n        return i.data;\n      }\n      async create(e, t) {\n        if (m$1.debug(\"[AppUserPool:create]\", { strategy: e, payload: t }), !(\"strategy_value\" in t)) throw new de$2(\"Profile must have a strategy_value value\");\n        let r2 = this.users.getSelect(void 0, \"create\"), s2 = { ...pick(t, r2), strategy: e }, o = this.em.mutator(this.users);\n        o.__unstable_toggleSystemEntityCreation(false), this.toggleStrategyValueVisibility(true);\n        let c = await o.insertOne(s2);\n        if (o.__unstable_toggleSystemEntityCreation(true), this.toggleStrategyValueVisibility(false), !c.data) throw new vn();\n        return m$1.debug(\"[AppUserPool]: User created\", c.data), c.data;\n      }\n      toggleStrategyValueVisibility(e) {\n        let t = /* @__PURE__ */ __name((r2, i) => {\n          let s2 = this.users.field(r2);\n          if (i) s2.config.hidden = false, s2.config.fillable = true;\n          else {\n            let o = Jt$1.usersFields.strategy_value.config;\n            s2.config.hidden = o.hidden, s2.config.fillable = o.fillable;\n          }\n        }, \"t\");\n        t(\"strategy_value\", e), t(\"strategy\", e);\n      }\n    };\n    Jt$1 = class n14 extends H$3 {\n      static {\n        __name(this, \"n14\");\n      }\n      _authenticator;\n      cache = {};\n      _controller;\n      async onBeforeUpdate(e, t) {\n        let r2 = Ts.properties.jwt.properties.secret.default;\n        return !e.enabled && t.enabled && t.jwt.secret === r2 && (m$1.warn(\"No JWT secret provided, generating a random one\"), t.jwt.secret = yo(64)), t.strategies?.password?.enabled || (m$1.warn(\"Password strategy cannot be disabled.\"), t.strategies.password.enabled = true), t;\n      }\n      get enabled() {\n        return this.config.enabled;\n      }\n      async build() {\n        if (!this.enabled) {\n          this.setBuilt();\n          return;\n        }\n        let e = O$2(this.config.roles ?? {}, (r2, i) => gt$1.create({ name: i, ...r2 }));\n        this.ctx.guard.setRoles(Object.values(e)), this.ctx.guard.setConfig(this.config.guard ?? {});\n        let t = O$2(this.config.strategies ?? {}, (r2, i) => {\n          try {\n            return new Es[r2.type].cls(r2.config);\n          } catch {\n            throw new Error(`Could not build strategy ${String(i)} with config ${JSON.stringify(r2.config)}`);\n          }\n        });\n        this._authenticator = new Er$1(t, new An$1(this), { jwt: this.config.jwt, cookie: this.config.cookie }), this.registerEntities(), super.setBuilt(), this._controller = new Cn$1(this), this.ctx.server.route(this.config.basepath, this._controller.getController()), this.ctx.guard.registerPermissions(Ut$1);\n      }\n      isStrategyEnabled(e) {\n        let t = typeof e == \"string\" ? e : e.getName();\n        return t === \"password\" ? true : this.config.strategies?.[t]?.enabled ?? false;\n      }\n      get controller() {\n        if (!this.isBuilt()) throw new Error(\"Can't access controller, AppAuth not built yet\");\n        return this._controller;\n      }\n      getSchema() {\n        return Ts;\n      }\n      get authenticator() {\n        return this.throwIfNotBuilt(), this._authenticator;\n      }\n      get em() {\n        return this.ctx.em;\n      }\n      getUsersEntity(e) {\n        let t = this.config.entity_name;\n        return e || !this.em.hasEntity(t) ? qt$1(t, n14.usersFields, void 0, \"system\") : this.em.entity(t);\n      }\n      static usersFields = { email: Oe$2().required(), strategy: Oe$2({ fillable: [\"create\"], hidden: [\"update\", \"form\"] }).required(), strategy_value: Oe$2({ fillable: [\"create\"], hidden: [\"read\", \"table\", \"update\", \"form\"] }).required(), role: Oe$2() };\n      registerEntities() {\n        let e = this.getUsersEntity(true);\n        this.ensureSchema(gn$1({ [e.name]: e }, ({ index: t }, { users: r2 }) => {\n          t(r2).on([\"email\"], true).on([\"strategy\"]).on([\"strategy_value\"]);\n        }));\n        try {\n          let t = Object.keys(this.config.roles ?? {});\n          this.replaceEntityField(e, \"role\", xr$1({ enum: t }));\n        } catch {\n        }\n        try {\n          let t = Object.keys(this.config.strategies ?? {});\n          this.replaceEntityField(e, \"strategy\", xr$1({ enum: t }));\n        } catch {\n        }\n      }\n      async createUser({ email: e, password: t, ...r2 }) {\n        if (!this.enabled) throw new Error(\"Cannot create user, auth not enabled\");\n        let i = \"password\", o = await this.authenticator.strategy(i).hash(t), c = this.em.mutator(this.config.entity_name);\n        c.__unstable_toggleSystemEntityCreation(false);\n        let { data: a2 } = await c.insertOne({ ...r2, email: e, strategy: i, strategy_value: o });\n        return c.__unstable_toggleSystemEntityCreation(true), a2;\n      }\n      toJSON(e) {\n        if (!this.config.enabled) return this.configDefault;\n        let t = this.authenticator.getStrategies();\n        return { ...this.config, ...this.authenticator.toJSON(e), strategies: O$2(t, (r2) => ({ enabled: this.isStrategyEnabled(r2), ...r2.toJSON(e) })) };\n      }\n    };\n    Fn = class {\n      static {\n        __name(this, \"Fn\");\n      }\n      constructor(e, t) {\n        this.permission = e;\n        this.config = t;\n      }\n    };\n    gt$1 = class n15 {\n      static {\n        __name(this, \"n15\");\n      }\n      constructor(e, t = [], r2 = false, i = false) {\n        this.name = e;\n        this.permissions = t;\n        this.is_default = r2;\n        this.implicit_allow = i;\n      }\n      static createWithPermissionNames(e, t, r2 = false, i = false) {\n        return new n15(e, t.map((s2) => new Fn(new R$2(s2))), r2, i);\n      }\n      static create(e) {\n        return new n15(e.name, e.permissions?.map((t) => new Fn(new R$2(t))) ?? [], e.is_default, e.implicit_allow);\n      }\n    };\n    Sr$1 = class n16 {\n      static {\n        __name(this, \"n16\");\n      }\n      permissions;\n      roles;\n      config;\n      constructor(e = [], t = [], r2) {\n        this.permissions = e, this.roles = t, this.config = r2;\n      }\n      static create(e, t, r2) {\n        let i = t ? ze$1(t, ({ permissions: o = [], is_default: c, implicit_allow: a2 }, l2) => gt$1.createWithPermissionNames(l2, o, c, a2)) : {}, s2 = e.map((o) => new R$2(o));\n        return new n16(s2, Object.values(i), r2);\n      }\n      getPermissionNames() {\n        return this.permissions.map((e) => e.name);\n      }\n      getPermissions() {\n        return this.permissions;\n      }\n      permissionExists(e) {\n        return !!this.permissions.find((t) => t.name === e);\n      }\n      setRoles(e) {\n        return this.roles = e, this;\n      }\n      getRoles() {\n        return this.roles;\n      }\n      setConfig(e) {\n        return this.config = { ...this.config, ...e }, this;\n      }\n      registerPermission(e) {\n        if (this.permissions.find((t) => t.name === e.name)) throw new Error(`Permission ${e.name} already exists`);\n        return this.permissions.push(e), this;\n      }\n      registerPermissions(e) {\n        let t = Array.isArray(e) ? e : Object.values(e);\n        for (let r2 of t) this.registerPermission(r2);\n        return this;\n      }\n      getUserRole(e) {\n        if (e && typeof e.role == \"string\") {\n          let t = this.roles?.find((r2) => r2.name === e?.role);\n          if (t) return m$1.debug(`guard: role \"${e.role}\" found`), t;\n        }\n        return m$1.debug(\"guard: role not found\", { user: e }), this.getDefaultRole();\n      }\n      getDefaultRole() {\n        return this.roles?.find((e) => e.is_default);\n      }\n      isEnabled() {\n        return this.config?.enabled === true;\n      }\n      hasPermission(e, t) {\n        if (!this.isEnabled()) return true;\n        let r2 = typeof e == \"string\" ? e : e.name;\n        if (m$1.debug(\"guard: checking permission\", { name: r2, user: { id: t?.id, role: t?.role } }), !this.permissionExists(r2)) throw new Error(`Permission ${r2} does not exist`);\n        let s2 = this.getUserRole(t);\n        if (s2) {\n          if (s2.implicit_allow === true) return m$1.debug(`guard: role \"${s2.name}\" has implicit allow, allowing`), true;\n        } else return m$1.debug(\"guard: user has no role, denying\"), false;\n        let o = s2.permissions.find((c) => c.permission.name === r2);\n        return m$1.debug(\"guard: rolePermission, allowing?\", { permission: r2, role: s2.name, allowing: !!o }), !!o;\n      }\n      granted(e, t) {\n        let r2 = t && \"get\" in t ? t.get(\"auth\")?.user : t;\n        return this.hasPermission(e, r2);\n      }\n      throwUnlessGranted(e, t) {\n        if (!this.granted(e, t)) throw new I$1(`Permission \"${typeof e == \"string\" ? e : e.name}\" not granted`, 403);\n      }\n    };\n    Ut$1 = {};\n    Je$2(Ut$1, { createUser: /* @__PURE__ */ __name(() => xu, \"createUser\") });\n    xu = new R$2(\"auth.user.create\");\n    __name(Ss, \"Ss\");\n    __name(oa, \"oa\");\n    __name(aa, \"aa\");\n    __name(ca2, \"ca\");\n    __name(wu, \"wu\");\n    __name(Eu, \"Eu\");\n    __name(zt$1, \"zt$1\");\n    vs = [{ version: 1, up: /* @__PURE__ */ __name(async (n252) => n252, \"up\") }, { version: 2, up: /* @__PURE__ */ __name(async (n252, { db: e }) => n252, \"up\") }, { version: 3, up: /* @__PURE__ */ __name(async (n252) => n252, \"up\") }, { version: 4, up: /* @__PURE__ */ __name(async (n252, { db: e }) => ({ ...n252, auth: { ...n252.auth, basepath: \"/api/auth2\" } }), \"up\") }, { version: 5, up: /* @__PURE__ */ __name(async (n252, { db: e }) => {\n      let t = n252.server.cors?.allow_methods ?? [];\n      return set(n252.server, \"cors.allow_methods\", [.../* @__PURE__ */ new Set([...t, \"PATCH\"])]), n252;\n    }, \"up\") }, { version: 6, up: /* @__PURE__ */ __name(async (n252, { db: e }) => n252, \"up\") }, { version: 7, up: /* @__PURE__ */ __name(async (n252, { db: e }) => {\n      let { expiresIn: t, ...r2 } = n252.auth.jwt;\n      return { ...n252, auth: { ...n252.auth, jwt: r2 } };\n    }, \"up\") }, { version: 8, up: /* @__PURE__ */ __name(async (n252) => {\n      let e = O$2(n252.auth.strategies, (t) => ({ ...t, enabled: true }));\n      return { ...n252, auth: { ...n252.auth, strategies: e } };\n    }, \"up\") }, { version: 9, up: /* @__PURE__ */ __name(async (n252) => {\n      let { admin: e, ...t } = n252.server;\n      return { ...n252, server: t };\n    }, \"up\") }];\n    Gt$1 = vs[vs.length - 1]?.version ?? 0;\n    la = \"__bknd\";\n    __name(vu, \"vu\");\n    __name(pa, \"pa\");\n    ({ Type: Vt$1 } = p$1);\n    ua = [\"GET\", \"POST\", \"PATCH\", \"PUT\", \"DELETE\"];\n    Cu = Vt$1.Object({ cors: Vt$1.Object({ origin: Vt$1.String({ default: \"*\" }), allow_methods: Vt$1.Array(w$4(ua), { default: ua, uniqueItems: true }), allow_headers: Vt$1.Array(Vt$1.String(), { default: [\"Content-Type\", \"Content-Length\", \"Authorization\", \"Accept\"] }) }, { default: {}, additionalProperties: false }) }, { additionalProperties: false });\n    _n$1 = class _n extends H$3 {\n      static {\n        __name(this, \"_n\");\n      }\n      getRestrictedPaths() {\n        return [];\n      }\n      get client() {\n        return this.ctx.server;\n      }\n      getSchema() {\n        return Cu;\n      }\n      async build() {\n        this.client.use(\"*\", cors({ origin: this.config.cors.origin, allowMethods: this.config.cors.allow_methods, allowHeaders: this.config.cors.allow_headers })), this.client.use(\"/\", async (e, t) => {\n          await t(), (!e.finalized || e.res.status === 404) && new URL(e.req.url).pathname === \"/\" && (e.res = void 0, e.res = Response.json({ bknd: \"hello world!\" }));\n        }), this.client.onError((e, t) => (m$1.error(\"[AppServer:onError]\", e), e instanceof Response ? e : e instanceof rt$1 ? t.json(e.toJSON(), e.getSafeErrorAndCode().code) : e instanceof I$1 ? t.json(e.toJSON(), e.code) : e instanceof Error && K$1() ? t.json({ error: e.message, stack: e.stack }, 500) : t.json({ error: e.message }, 500))), this.setBuilt();\n      }\n      toJSON(e) {\n        return this.config;\n      }\n    };\n    Ht$1 = {};\n    Je$2(Ht$1, { accessAdmin: /* @__PURE__ */ __name(() => kn$1, \"accessAdmin\"), accessApi: /* @__PURE__ */ __name(() => Os, \"accessApi\"), build: /* @__PURE__ */ __name(() => Rs, \"build\"), configRead: /* @__PURE__ */ __name(() => Pn$1, \"configRead\"), configReadSecrets: /* @__PURE__ */ __name(() => vr$1, \"configReadSecrets\"), configWrite: /* @__PURE__ */ __name(() => bt$1, \"configWrite\"), schemaRead: /* @__PURE__ */ __name(() => Wt$1, \"schemaRead\") });\n    kn$1 = new R$2(\"system.access.admin\");\n    Os = new R$2(\"system.access.api\");\n    Pn$1 = new R$2(\"system.config.read\");\n    vr$1 = new R$2(\"system.config.read.secrets\");\n    bt$1 = new R$2(\"system.config.write\");\n    Wt$1 = new R$2(\"system.schema.read\");\n    Rs = new R$2(\"system.build\");\n    jn$1 = class jn extends me$3 {\n      static {\n        __name(this, \"jn\");\n      }\n      constructor(t, r2) {\n        super();\n        this.ctx = t;\n        this.config = r2;\n      }\n      get em() {\n        return this.ctx.em;\n      }\n      get guard() {\n        return this.ctx.guard;\n      }\n      repoResult(t) {\n        let r2 = {};\n        if (\"meta\" in t) {\n          let { query: s2, ...o } = t.meta;\n          r2 = o, K$1() && (r2.query = s2);\n        }\n        let i = { data: t.data, meta: r2 };\n        return Object.fromEntries(Object.entries(i).filter(([s2, o]) => typeof o < \"u\" && o !== null));\n      }\n      mutatorResult(t) {\n        let r2 = { data: t.data };\n        return Object.fromEntries(Object.entries(r2).filter(([i, s2]) => s2 !== void 0));\n      }\n      entityExists(t) {\n        try {\n          return !!this.em.entity(t);\n        } catch {\n          return false;\n        }\n      }\n      getController() {\n        let { permission: t, auth: r2 } = this.middlewares, i = this.create().use(r2(), t(Os)), s2 = this.getEntitiesEnum(this.em);\n        function o(c, a2) {\n          let l2 = a2;\n          return l2.description = c, l2;\n        }\n        __name(o, \"o\");\n        return i.get(\"/\", S$2({ summary: \"Retrieve data configuration\", tags: [\"data\"] }), o(\"data info\", (c) => c.json(this.em.toJSON()))), i.get(\"/sync\", t(j$3.databaseSync), S$2({ summary: \"Sync database schema\", tags: [\"data\"] }), T$1(\"query\", f.partialObject({ force: f.boolean(), drop: f.boolean() })), async (c) => {\n          let { force: a2, drop: l2 } = c.req.valid(\"query\"), p2 = await this.em.schema().introspect(), u3 = await this.em.schema().sync({ force: a2, drop: l2 });\n          return c.json({ tables: p2.map((d2) => d2.name), changes: u3 });\n        }), i.get(\"/schema.json\", t(j$3.entityRead), S$2({ summary: \"Retrieve data schema\", tags: [\"data\"] }), async (c) => {\n          let a2 = `${this.config.basepath}/schema.json`, l2 = Object.fromEntries(this.em.entities.map((p2) => [p2.name, { $ref: `${this.config.basepath}/schemas/${p2.name}` }]));\n          return c.json({ $schema: \"https://json-schema.org/draft/2020-12/schema\", $id: a2, properties: l2 });\n        }), i.get(\"/schemas/:entity/:context?\", t(j$3.entityRead), S$2({ summary: \"Retrieve entity schema\", tags: [\"data\"] }), T$1(\"param\", f.object({ entity: s2, context: f.string({ enum: [\"create\", \"update\"], default: \"create\" }).optional() })), async (c) => {\n          let { entity: a2, context: l2 } = c.req.param();\n          if (!this.entityExists(a2)) return this.notFound(c);\n          let p2 = this.em.entity(a2), u3 = p2.toSchema({ context: l2 }), y3 = `${new URL(c.req.url).origin}${this.config.basepath}`, b3 = `${this.config.basepath}/schemas/${a2}`;\n          return c.json({ $schema: `${y3}/schema.json`, $id: b3, title: p2.label, $comment: p2.config.description, ...u3 });\n        }), i.route(\"/entity\", this.getEntityRoutes()), i.get(\"/info/:entity\", t(j$3.entityRead), S$2({ summary: \"Retrieve entity info\", tags: [\"data\"] }), T$1(\"param\", f.object({ entity: s2 })), async (c) => {\n          let { entity: a2 } = c.req.param();\n          if (!this.entityExists(a2)) return this.notFound(c);\n          let l2 = this.em.entity(a2), p2 = l2.fields.map((d2) => d2.name), u3 = /* @__PURE__ */ __name((d2) => d2.map((y3) => ({ entity: y3.other(l2).entity.name, ref: y3.other(l2).reference })), \"u\");\n          return c.json({ name: l2.name, fields: p2, relations: { all: u3(this.em.relations.relationsOf(l2)), listable: u3(this.em.relations.listableRelationsOf(l2)), source: u3(this.em.relations.sourceRelationsOf(l2)), target: u3(this.em.relations.targetRelationsOf(l2)) } });\n        }), i.all(\"*\", (c) => c.notFound());\n      }\n      getEntityRoutes() {\n        let { permission: t } = this.middlewares, r2 = this.create(), i = this.getEntitiesEnum(this.em), s2 = f.anyOf([f.number(), f.string()], { coerce: /* @__PURE__ */ __name((l2) => l2, \"coerce\") });\n        r2.post(\"/:entity/fn/count\", t(j$3.entityRead), S$2({ summary: \"Count entities\", tags: [\"data\"] }), T$1(\"param\", f.object({ entity: i })), T$1(\"json\", oe$3.properties.where), async (l2) => {\n          let { entity: p2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let u3 = l2.req.valid(\"json\"), d2 = await this.em.repository(p2).count(u3);\n          return l2.json({ entity: p2, count: d2.count });\n        }), r2.post(\"/:entity/fn/exists\", t(j$3.entityRead), S$2({ summary: \"Check if entity exists\", tags: [\"data\"] }), T$1(\"param\", f.object({ entity: i })), T$1(\"json\", oe$3.properties.where), async (l2) => {\n          let { entity: p2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let u3 = l2.req.valid(\"json\"), d2 = await this.em.repository(p2).exists(u3);\n          return l2.json({ entity: p2, exists: d2.exists });\n        });\n        let o = f.partialObject({ ...Nr$1(oe$3.properties, [\"with\"]), sort: f.string({ default: \"id\" }), select: f.array(f.string()), join: f.array(f.string()) }), c = /* @__PURE__ */ __name((l2 = Object.keys(oe$3.properties)) => [...Zr$1(o, \"query\").parameters?.filter((p2) => l2.includes(p2.name))], \"c\");\n        r2.get(\"/:entity\", S$2({ summary: \"Read many\", parameters: c([\"limit\", \"offset\", \"sort\", \"select\", \"join\"]), tags: [\"data\"] }), t(j$3.entityRead), T$1(\"param\", f.object({ entity: i })), T$1(\"query\", oe$3, { skipOpenAPI: true }), async (l2) => {\n          let { entity: p2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let u3 = l2.req.valid(\"query\"), d2 = await this.em.repository(p2).findMany(u3);\n          return l2.json(this.repoResult(d2), { status: d2.data ? 200 : 404 });\n        }), r2.get(\"/:entity/:id\", S$2({ summary: \"Read one\", parameters: c([\"offset\", \"sort\", \"select\"]), tags: [\"data\"] }), t(j$3.entityRead), T$1(\"param\", f.object({ entity: i, id: s2 })), T$1(\"query\", oe$3, { skipOpenAPI: true }), async (l2) => {\n          let { entity: p2, id: u3 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let d2 = l2.req.valid(\"query\"), y3 = await this.em.repository(p2).findId(u3, d2);\n          return l2.json(this.repoResult(y3), { status: y3.data ? 200 : 404 });\n        }), r2.get(\"/:entity/:id/:reference\", S$2({ summary: \"Read many by reference\", parameters: c(), tags: [\"data\"] }), t(j$3.entityRead), T$1(\"param\", f.object({ entity: i, id: s2, reference: f.string() })), T$1(\"query\", oe$3, { skipOpenAPI: true }), async (l2) => {\n          let { entity: p2, id: u3, reference: d2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let y3 = l2.req.valid(\"query\"), b3 = await this.em.repository(p2).findManyByReference(u3, d2, y3);\n          return l2.json(this.repoResult(b3), { status: b3.data ? 200 : 404 });\n        });\n        let a2 = f.partialObject({ ...o.properties, with: f.object({}) });\n        return r2.post(\"/:entity/query\", S$2({ summary: \"Query entities\", requestBody: { content: { \"application/json\": { schema: a2.toJSON(), example: a2.template({ withOptional: true }) } } }, tags: [\"data\"] }), t(j$3.entityRead), T$1(\"param\", f.object({ entity: i })), T$1(\"json\", oe$3, { skipOpenAPI: true }), async (l2) => {\n          let { entity: p2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let u3 = await l2.req.json(), d2 = await this.em.repository(p2).findMany(u3);\n          return l2.json(this.repoResult(d2), { status: d2.data ? 200 : 404 });\n        }), r2.post(\"/:entity\", S$2({ summary: \"Insert one or many\", tags: [\"data\"] }), t(j$3.entityCreate), T$1(\"param\", f.object({ entity: i })), T$1(\"json\", f.anyOf([f.object({}), f.array(f.object({}))])), async (l2) => {\n          let { entity: p2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let u3 = await l2.req.json();\n          if (Array.isArray(u3)) {\n            let y3 = await this.em.mutator(p2).insertMany(u3);\n            return l2.json(this.mutatorResult(y3), 201);\n          }\n          let d2 = await this.em.mutator(p2).insertOne(u3);\n          return l2.json(this.mutatorResult(d2), 201);\n        }), r2.patch(\"/:entity\", S$2({ summary: \"Update many\", tags: [\"data\"] }), t(j$3.entityUpdate), T$1(\"param\", f.object({ entity: i })), T$1(\"json\", f.object({ update: f.object({}), where: oe$3.properties.where })), async (l2) => {\n          let { entity: p2 } = l2.req.param();\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let { update: u3, where: d2 } = await l2.req.json(), y3 = await this.em.mutator(p2).updateWhere(u3, d2);\n          return l2.json(this.mutatorResult(y3));\n        }), r2.patch(\"/:entity/:id\", S$2({ summary: \"Update one\", tags: [\"data\"] }), t(j$3.entityUpdate), T$1(\"param\", f.object({ entity: i, id: s2 })), T$1(\"json\", f.object({})), async (l2) => {\n          let { entity: p2, id: u3 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let d2 = await l2.req.json(), y3 = await this.em.mutator(p2).updateOne(u3, d2);\n          return l2.json(this.mutatorResult(y3));\n        }), r2.delete(\"/:entity/:id\", S$2({ summary: \"Delete one\", tags: [\"data\"] }), t(j$3.entityDelete), T$1(\"param\", f.object({ entity: i, id: s2 })), async (l2) => {\n          let { entity: p2, id: u3 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let d2 = await this.em.mutator(p2).deleteOne(u3);\n          return l2.json(this.mutatorResult(d2));\n        }), r2.delete(\"/:entity\", S$2({ summary: \"Delete many\", tags: [\"data\"] }), t(j$3.entityDelete), T$1(\"param\", f.object({ entity: i })), T$1(\"json\", oe$3.properties.where), async (l2) => {\n          let { entity: p2 } = l2.req.valid(\"param\");\n          if (!this.entityExists(p2)) return this.notFound(l2);\n          let u3 = await l2.req.json(), d2 = await this.em.mutator(p2).deleteWhere(u3);\n          return l2.json(this.mutatorResult(d2));\n        }), r2;\n      }\n    };\n    Mn$1 = class Mn extends H$3 {\n      static {\n        __name(this, \"Mn\");\n      }\n      async build() {\n        let { entities: e = {}, relations: t = {}, indices: r2 = {} } = this.config, i = O$2(e, (a2, l2) => ys$1(l2, a2)), s2 = /* @__PURE__ */ __name((a2) => {\n          let l2 = typeof a2 == \"string\" ? a2 : a2.name, p2 = i[l2];\n          if (p2) return p2;\n          throw new Error(`[AppData] Entity \"${l2}\" not found`);\n        }, \"s\"), o = O$2(t, (a2) => hs(a2, s2)), c = O$2(r2, (a2, l2) => {\n          let p2 = s2(a2.entity), u3 = a2.fields.map((d2) => p2.field(d2));\n          return new Dt$1(p2, u3, a2.unique, l2);\n        });\n        for (let a2 of Object.values(i)) this.ctx.em.addEntity(a2);\n        for (let a2 of Object.values(o)) this.ctx.em.addRelation(a2);\n        for (let a2 of Object.values(c)) this.ctx.em.addIndex(a2);\n        this.ctx.server.route(this.basepath, new jn$1(this.ctx, this.config).getController()), this.ctx.guard.registerPermissions(Object.values(j$3)), this.setBuilt();\n      }\n      async onBeforeUpdate(e, t) {\n        let r2 = { from: Object.keys(e.entities ?? {}), to: Object.keys(t.entities ?? {}) };\n        if (r2.from.length - r2.to.length > 1) throw new Error(\"Cannot remove more than one entity at a time\");\n        return t;\n      }\n      getSchema() {\n        return Yo;\n      }\n      get em() {\n        return this.throwIfNotBuilt(), this.ctx.em;\n      }\n      get basepath() {\n        return this.config.basepath ?? \"/api/data\";\n      }\n      getOverwritePaths() {\n        return [/^entities\\..*\\.config$/, /^entities\\..*\\.fields\\..*\\.config$/];\n      }\n      toJSON(e) {\n        return { ...this.config, ...this.em.toJSON() };\n      }\n    };\n    ({ Type: In } = p$1);\n    __name(xt$1, \"xt$1\");\n    je$3 = class n17 {\n      static {\n        __name(this, \"n17\");\n      }\n      name;\n      static schema = In.Object({});\n      _params;\n      constructor(e, t) {\n        if (typeof e != \"string\") throw new Error(`Task name must be a string, got ${typeof e}`);\n        this.name = e;\n        let r2 = this.constructor.schema;\n        if (r2 === n17.schema && typeof t < \"u\" && Object.keys(t).length > 0) throw new Error(`Task \"${e}\" has no schema defined but params passed: ${JSON.stringify(t)}`);\n        this._params = _$2(r2, t || {});\n      }\n      get params() {\n        return this._params;\n      }\n      clone(e, t) {\n        return new this.constructor(e, t);\n      }\n      static async resolveParams(e, t, r2 = {}) {\n        let i = {}, s2 = new Ct$1(r2, { renderKeys: true });\n        for (let [o, c] of Object.entries(t)) {\n          if (c && Ct$1.hasMarkup(c)) {\n            try {\n              i[o] = await s2.render(c);\n            } catch (a2) {\n              throw a2 instanceof he$2 ? a2 : new he$2(\"Failed to resolve param\", { key: o, value: c, error: a2.message }, \"resolve-params\");\n            }\n            continue;\n          }\n          i[o] = c;\n        }\n        return Decode(e, i);\n      }\n      async cloneWithResolvedParams(e) {\n        let t = Object.fromEntries(e.entries()), r2 = await n17.resolveParams(this.constructor.schema, this._params, t);\n        return this.clone(this.name, r2);\n      }\n      async run(e = /* @__PURE__ */ new Map()) {\n        let t = /* @__PURE__ */ new Date(), r2, i, s2, o, a2 = performance.now();\n        try {\n          let l2 = await this.cloneWithResolvedParams(e);\n          o = l2.params, r2 = await l2.execute(e), s2 = true;\n        } catch (l2) {\n          s2 = false, l2 instanceof he$2 ? i = l2.toJSON() : i = { type: \"unknown\", message: l2.message };\n        }\n        return { start: t, output: r2, error: i, success: s2, params: o, time: performance.now() - a2 };\n      }\n      error(e, t) {\n        return new he$2(e, t, \"runtime\");\n      }\n      get label() {\n        return this.name;\n      }\n      toJSON() {\n        return { type: this.type, params: this.params };\n      }\n    };\n    ({ Type: fe$1 } = p$1);\n    Cs = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n    Dn$1 = class Dn extends je$3 {\n      static {\n        __name(this, \"Dn\");\n      }\n      type = \"fetch\";\n      static schema = fe$1.Object({ url: fe$1.String({ pattern: \"^(http|https)://\" }), method: fe$1.Optional(xt$1(w$4(Cs, { default: \"GET\" }))), headers: fe$1.Optional(xt$1(fe$1.Array(fe$1.Object({ key: fe$1.String(), value: fe$1.String() })), JSON.parse)), body: fe$1.Optional(xt$1(fe$1.String())), normal: fe$1.Optional(xt$1(fe$1.Number(), Number.parseInt)) });\n      getBody() {\n        let e = this.params.body;\n        if (e) {\n          if (typeof e == \"string\") return e;\n          if (typeof e == \"object\") return JSON.stringify(e);\n          throw new Error(`Invalid body type: ${typeof e}`);\n        }\n      }\n      async execute() {\n        if (!Cs.includes(this.params.method ?? \"GET\")) throw this.error(\"Invalid method\", { given: this.params.method, valid: Cs });\n        let e = this.getBody(), t = new Headers(this.params.headers?.map((s2) => [s2.key, s2.value])), r2 = await fetch(this.params.url, { method: this.params.method ?? \"GET\", headers: t, body: e });\n        if (!r2.ok) throw this.error(\"Failed to fetch\", { status: r2.status, statusText: r2.statusText });\n        return await r2.json();\n      }\n    };\n    ({ Type: da } = p$1);\n    $n$1 = class $n extends je$3 {\n      static {\n        __name(this, \"$n\");\n      }\n      type = \"log\";\n      static schema = da.Object({ delay: da.Number({ default: 10 }) });\n      async execute() {\n        return await new Promise((e) => setTimeout(e, this.params.delay)), m$1.log(`[DONE] LogTask: ${this.name}`), true;\n      }\n    };\n    ({ Type: ma } = p$1);\n    qn$1 = class qn extends je$3 {\n      static {\n        __name(this, \"qn\");\n      }\n      type = \"render\";\n      static schema = ma.Object({ render: ma.String() });\n      async execute() {\n        return this.params.render;\n      }\n    };\n    Yt$1 = class Yt {\n      static {\n        __name(this, \"Yt\");\n      }\n      source;\n      target;\n      config;\n      id;\n      constructor(e, t, r2, i) {\n        this.source = e, this.target = t, this.config = r2 ?? {}, this.config.condition instanceof Xt$1 || (this.config.condition = Xt$1.default()), this.id = i ?? ho();\n      }\n      get condition() {\n        return this.config.condition;\n      }\n      get max_retries() {\n        return this.config.max_retries ?? 0;\n      }\n      toJSON() {\n        return qr$1({ source: this.source.name, target: this.target.name, config: { ...this.config, condition: this.config.condition?.toJSON() } });\n      }\n    };\n    Xt$1 = class n18 {\n      static {\n        __name(this, \"n18\");\n      }\n      constructor(e, t = \"\", r2 = void 0) {\n        this.type = e;\n        this.path = t;\n        this.value = r2;\n      }\n      static default() {\n        return n18.success();\n      }\n      static success() {\n        return new n18(\"success\");\n      }\n      static error() {\n        return new n18(\"error\");\n      }\n      static matches(e, t) {\n        if (typeof e != \"string\" || e.length === 0) throw new Error(\"Invalid path\");\n        return new n18(\"matches\", e, t);\n      }\n      isMet(e) {\n        switch (this.type) {\n          case \"success\":\n            return e.success;\n          case \"error\":\n            return e.success === false;\n          case \"matches\":\n            return get(e.output, this.path) === this.value;\n        }\n      }\n      sameAs(e = n18.default()) {\n        return this.type === e.type && this.path === e.path && this.value === e.value;\n      }\n      toJSON() {\n        return { type: this.type, path: this.path.length === 0 ? void 0 : this.path, value: this.value };\n      }\n      static fromObject(e) {\n        return new n18(e.type, e.path, e.value);\n      }\n    };\n    Or$1 = class Or extends M$3 {\n      static {\n        __name(this, \"Or\");\n      }\n      static slug = \"flow-execution-event\";\n      task() {\n        return this.params.task;\n      }\n      getState() {\n        return this.succeeded() ? \"success\" : this.failed() ? \"failed\" : this.isStart() ? \"running\" : \"idle\";\n      }\n      isStart() {\n        return this.params.end === void 0;\n      }\n      isEnd() {\n        return !this.isStart();\n      }\n      succeeded() {\n        return this.isEnd() && this.params.result?.success;\n      }\n      failed() {\n        return this.isEnd() && !this.params.result?.success;\n      }\n    };\n    Rr = class extends M$3 {\n      static {\n        __name(this, \"Rr\");\n      }\n      static slug = \"flow-execution-state\";\n    };\n    Bn = class n19 {\n      static {\n        __name(this, \"n19\");\n      }\n      flow;\n      started_at;\n      finished_at;\n      logs = [];\n      inputs = /* @__PURE__ */ new Map();\n      queue = [];\n      emgr;\n      static Events = { ExecutionEvent: Or$1, ExecutionState: Rr };\n      constructor(e) {\n        this.flow = e, this.logs = [], this.queue = [this.flow.startTask], this.emgr = new V$2(n19.Events);\n      }\n      subscribe(e) {\n        this.emgr.onAny(e);\n      }\n      async onDone(e, t) {\n        let r2 = /* @__PURE__ */ new Date();\n        if (this.logs.push({ ...t, task: e, end: r2 }), this.inputs.set(e.name, t), this.flow.respondingTask === e) {\n          this.queue = [];\n          return;\n        }\n        this.queue = this.queue.filter((s2) => s2 !== e);\n        let i = this.flow.task(e).getOutConnections(t).filter((s2) => {\n          let o = s2.target, c = this.logs.filter((l2) => l2.task === o && l2.success).length, a2 = this.flow.task(o).getInConnections().find((l2) => l2.source === e)?.max_retries ?? 0;\n          if (c > a2) throw new Error(`Task \"${o.name}\" reached max retries (${c}/${a2})`);\n          return this.flow.task(o).getInTasks(true).every((l2) => this.logs.some((p2) => p2.task === l2 && p2.end !== void 0));\n        }).map((s2) => s2.target);\n        this.queue.push(...i);\n      }\n      __getLastTaskLog(e) {\n        for (let t = this.logs.length - 1; t >= 0; t--) if (this.logs[t]?.task === e) return this.logs[t];\n        return null;\n      }\n      async run() {\n        let e = this.queue;\n        if (e.length === 0) return;\n        let t = e.map(async (r2) => {\n          await this.emgr.emit(new Or$1({ task: r2 }));\n          let i = await r2.run(this.inputs);\n          return await this.emgr.emit(new Or$1({ task: r2, result: i, end: /* @__PURE__ */ new Date() })), await this.onDone(r2, i), i;\n        });\n        try {\n          return await Promise.all(t), this.run();\n        } catch (r2) {\n          throw m$1.error(\"RuntimeExecutor: error\", r2), r2;\n        }\n      }\n      async start(e) {\n        await this.emgr.emit(new Rr({ execution: this, state: \"started\" })), this.inputs.set(\"flow\", { start: /* @__PURE__ */ new Date(), output: e, error: void 0, success: true, params: e }), this.started_at = /* @__PURE__ */ new Date(), await this.run(), this.finished_at = /* @__PURE__ */ new Date(), await this.emgr.emit(new Rr({ execution: this, state: \"ended\" }));\n      }\n      finished() {\n        return this.finished_at !== void 0;\n      }\n      errorCount() {\n        return this.logs.filter((e) => !e.success).length;\n      }\n      hasErrors() {\n        return this.errorCount() > 0;\n      }\n      getErrorLogs() {\n        return this.logs.filter((e) => !e.success);\n      }\n      getErrors() {\n        return this.getErrorLogs().map((e) => e.error);\n      }\n      getResponse() {\n        let e = this.flow.respondingTask;\n        e || (e = this.flow.tasks[this.flow.tasks.length - 1]);\n        let t = this.__getLastTaskLog(e);\n        if (t) return t.output;\n      }\n    };\n    Nn$1 = class n20 {\n      static {\n        __name(this, \"n20\");\n      }\n      flow;\n      source;\n      constructor(e, t) {\n        this.flow = e, this.source = t;\n      }\n      task(e) {\n        return new n20(this.flow, e);\n      }\n      asInputFor(e, t, r2) {\n        let i = this.getDepth(), s2 = this.getOutConnections(), o = s2.map((a2) => a2.condition), c = s2.some((a2) => this.task(a2.target).getDepth() <= i);\n        if (o.length > 0 && c && this.getOutConnections().some((a2) => a2.condition.sameAs(t))) throw new Error(\"Task cannot be connected to a deeper task with the same condition\");\n        this.flow.addConnection(new Yt$1(this.source, e, { condition: t, max_retries: r2 }));\n      }\n      asOutputFor(e, t) {\n        this.task(e).asInputFor(this.source, t);\n      }\n      getNext() {\n        return this.flow.connections.filter((e) => e.source === this.source).map((e) => e.target);\n      }\n      getDepth() {\n        return this.flow.getSequence().findIndex((e) => e.includes(this.source));\n      }\n      getInConnections(e = false) {\n        if (e) {\n          let t = this.getDepth();\n          return this.getInConnections().filter((r2) => r2.target === this.source && this.task(r2.source).getDepth() < t);\n        }\n        return this.flow.connections.filter((t) => t.target === this.source);\n      }\n      getInTasks(e = false) {\n        if (e) {\n          let t = this.getDepth();\n          return this.getInConnections().map((r2) => r2.source).filter((r2) => this.task(r2).getDepth() < t);\n        }\n        return this.getInConnections().map((t) => t.source);\n      }\n      getOutConnections(e) {\n        return e ? this.flow.connections.filter((t) => t.source === this.source && t.condition.isMet(e)) : this.flow.connections.filter((t) => t.source === this.source);\n      }\n      getOutTasks(e) {\n        return this.getOutConnections(e).map((t) => t.target);\n      }\n    };\n    ({ Type: Mu } = p$1);\n    ae$2 = class ae {\n      static {\n        __name(this, \"ae\");\n      }\n      executions = [];\n      type = \"manual\";\n      config;\n      static schema = Mu.Object({ mode: w$4([\"sync\", \"async\"], { default: \"async\" }) });\n      constructor(e) {\n        let t = this.constructor.schema;\n        this.config = _$2(t, e ?? {});\n      }\n      async register(e, ...t) {\n        this.executions.push(await e.start());\n      }\n      toJSON() {\n        return { type: this.type, config: this.config };\n      }\n    };\n    wt$1 = class n21 {\n      static {\n        __name(this, \"n21\");\n      }\n      name;\n      trigger;\n      tasks = [];\n      connections = [];\n      respondingTask;\n      startTask;\n      sequence;\n      constructor(e, t, r2, i) {\n        this.name = e, this.trigger = i ?? new ae$2(), t.map((s2) => this.addTask(s2)), this.connections = r2 || [], this.startTask = t[0], this.sequence = this.getSequence();\n      }\n      setStartTask(e) {\n        return this.startTask = e, this.sequence = this.getSequence(), this;\n      }\n      getSequence(e = []) {\n        if (e.length === 0) return e.push([this.startTask]), this.getSequence(e);\n        let t = e[e.length - 1], r2 = [];\n        return t?.forEach((i) => {\n          this.task(i).getOutTasks().forEach((o) => {\n            e.some((c) => c.includes(o)) || r2.push(o);\n          });\n        }), r2.length === 0 ? e : (e.push(r2), this.getSequence(e));\n      }\n      addTask(e) {\n        if (this.tasks.includes(e)) throw new Error(\"Task already defined\");\n        if (this.tasks.some((t) => t.name === e.name)) throw new Error(`Task with name \"${e.name}\" already defined. Use a unique name.`);\n        return this.tasks.push(e), this;\n      }\n      setRespondingTask(e) {\n        if (!this.tasks.includes(e)) throw new Error(`Cannot set task \"${e.name}\" as responding, not registered.`);\n        return this.respondingTask = e, this;\n      }\n      addConnection(e) {\n        if (this.connections.some((r2) => r2.source === e.source && r2.target === e.target && r2.condition[0] === e.condition[0] && r2.condition[1] === e.condition[1])) throw new Error(\"Connection already defined\");\n        return this.connections.push(e), this;\n      }\n      task(e) {\n        return new Nn$1(this, e);\n      }\n      createExecution() {\n        return this.sequence = this.getSequence(), new Bn(this);\n      }\n      async start(e = void 0) {\n        let t = this.createExecution();\n        return await t.start(e), t;\n      }\n      toJSON() {\n        return { trigger: this.trigger.toJSON(), tasks: Object.fromEntries(this.tasks.map((e) => [e.name, e.toJSON()])), connections: Object.fromEntries(this.connections.map((e) => [e.id, e.toJSON()])), start_task: this.startTask?.name, responding_task: this.respondingTask?.name };\n      }\n      static fromObject(e, t, r2) {\n        let i = O$2(t.tasks ?? {}, (a2, l2) => {\n          let p2 = r2[a2.type];\n          if (!p2) throw new Error(`Task ${l2} not found in taskMap`);\n          try {\n            let u3 = p2.cls;\n            return new u3(l2, a2.params);\n          } catch (u3) {\n            throw m$1.error(\"Error creating task\", l2, a2.type, a2, p2), new Error(`Error creating task ${a2.type}: ${u3.message}`);\n          }\n        }), s2 = O$2(t.connections ?? {}, (a2, l2) => {\n          let p2 = a2.config.condition ? Xt$1.fromObject(a2.config.condition) : void 0;\n          return new Yt$1(i[a2.source], i[a2.target], { ...a2.config, condition: p2 }, l2);\n        }), o;\n        if (t.trigger) {\n          let a2 = Cr[t.trigger.type]?.cls;\n          a2 && (o = new a2(t.trigger.config));\n        }\n        let c = new n21(e, Object.values(i), Object.values(s2), o);\n        return c.startTask = t.start_task ? i[t.start_task] : null, t.responding_task && (c.respondingTask = i[t.responding_task]), c;\n      }\n    };\n    ({ Type: Zt$1 } = p$1);\n    Un$1 = class Un extends je$3 {\n      static {\n        __name(this, \"Un\");\n      }\n      type = \"subflow\";\n      static schema = Zt$1.Object({ flow: Zt$1.Any(), input: Zt$1.Optional(xt$1(Zt$1.Any(), JSON.parse)), loop: Zt$1.Optional(Zt$1.Boolean()) });\n      async execute() {\n        let e = this.params.flow;\n        if (!(e instanceof wt$1)) throw new Error(\"Invalid flow provided\");\n        if (this.params.loop) {\n          let r2 = Array.isArray(this.params.input) ? this.params.input : [this.params.input], i = [];\n          for (let s2 of r2) {\n            let o = e.createExecution();\n            await o.start(s2), i.push(await o.getResponse());\n          }\n          return i;\n        }\n        let t = e.createExecution();\n        return await t.start(this.params.input), t.getResponse();\n      }\n    };\n    ({ Type: As } = p$1);\n    Ar$1 = class Ar extends ae$2 {\n      static {\n        __name(this, \"Ar\");\n      }\n      type = \"event\";\n      static schema = As.Composite([ae$2.schema, As.Object({ event: As.String() })]);\n      async register(e, t) {\n        if (!t.eventExists(this.config.event)) throw new Error(`Event ${this.config.event} is not registered.`);\n        t.on(this.config.event, async (r2) => {\n          let i = e.createExecution();\n          this.executions.push(i);\n          try {\n            await i.start(r2.params);\n          } catch (s2) {\n            m$1.error(s2);\n          }\n        }, this.config.mode);\n      }\n    };\n    ({ Type: Fs } = p$1);\n    qu = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n    Et$1 = class Et extends ae$2 {\n      static {\n        __name(this, \"Et\");\n      }\n      type = \"http\";\n      static schema = Fs.Composite([ae$2.schema, Fs.Object({ path: Fs.String({ pattern: \"^/.*$\" }), method: w$4(qu, { default: \"GET\" }), response_type: w$4([\"json\", \"text\", \"html\"], { default: \"json\" }) })]);\n      async register(e, t) {\n        let r2 = this.config.method.toLowerCase();\n        t[r2](this.config.path, async (i) => {\n          let s2 = i.req.raw, o = i[this.config.response_type], c = e.createExecution();\n          if (this.executions.push(c), this.config.mode === \"sync\") {\n            await c.start(s2);\n            let a2 = c.getResponse(), l2 = c.getErrors();\n            return l2.length > 0 ? i.json({ success: false, errors: l2 }) : o(a2);\n          }\n          return c.start(s2), i.json({ success: true });\n        });\n      }\n    };\n    Cr = { manual: { cls: ae$2 }, event: { cls: Ar$1 }, http: { cls: Et$1 } };\n    fa = { fetch: { cls: Dn$1 }, log: { cls: $n$1 }, render: { cls: qn$1 }, subflow: { cls: Un$1 } };\n    ({ Type: F$3 } = p$1);\n    _s = { ...fa };\n    Nu = Cr;\n    ya = O$2(_s, (n252, e) => F$3.Object({ type: be$2(e), params: n252.cls.schema }, { title: String(e), additionalProperties: false }));\n    F$3.Union(Object.values(ya));\n    Uu = O$2(Nu, (n252, e) => F$3.Object({ type: be$2(e), config: n252.cls.schema }, { title: String(e), additionalProperties: false }));\n    Lu$1 = F$3.Object({ source: F$3.String(), target: F$3.String(), config: F$3.Object({ condition: F$3.Optional(F$3.Union([F$3.Object({ type: be$2(\"success\") }, { additionalProperties: false, title: \"success\" }), F$3.Object({ type: be$2(\"error\") }, { additionalProperties: false, title: \"error\" }), F$3.Object({ type: be$2(\"matches\"), path: F$3.String(), value: F$3.String() }, { additionalProperties: false, title: \"matches\" })])), max_retries: F$3.Optional(F$3.Number()) }, { default: {}, additionalProperties: false }) });\n    Qu$1 = F$3.Object({ trigger: F$3.Union(Object.values(Uu)), tasks: F$3.Optional(ce$2(F$3.Union(Object.values(ya)))), connections: F$3.Optional(ce$2(Lu$1)), start_task: F$3.Optional(F$3.String()), responding_task: F$3.Optional(F$3.String()) }, { additionalProperties: false });\n    ha = F$3.Object({ basepath: F$3.String({ default: \"/api/flows\" }), flows: ce$2(Qu$1, { default: {} }) }, { default: {}, additionalProperties: false });\n    Ln$1 = class Ln extends H$3 {\n      static {\n        __name(this, \"Ln\");\n      }\n      flows = {};\n      getSchema() {\n        return ha;\n      }\n      getFlowInfo(e) {\n        return { ...e.toJSON(), tasks: e.tasks.length, connections: e.connections };\n      }\n      async build() {\n        let e = O$2(this.config.flows, (r2, i) => wt$1.fromObject(i, r2, _s));\n        this.flows = e;\n        let t = new Hono2();\n        t.get(\"/\", async (r2) => {\n          let i = O$2(this.flows, (s2) => this.getFlowInfo(s2));\n          return r2.json(i);\n        }), t.get(\"/flow/:name\", async (r2) => {\n          let i = r2.req.param(\"name\");\n          return r2.json(this.flows[i]?.toJSON());\n        }), t.get(\"/flow/:name/run\", async (r2) => {\n          let i = r2.req.param(\"name\"), s2 = this.flows[i], o = s2.createExecution(), c = performance.now();\n          await o.start();\n          let a2 = performance.now() - c, l2 = o.getErrors();\n          return r2.json({ success: l2.length === 0, time: a2, errors: l2, response: o.getResponse(), flow: this.getFlowInfo(s2), logs: o.logs });\n        }), t.all(\"*\", (r2) => r2.notFound()), this.ctx.server.route(this.config.basepath, t);\n        for (let [r2, i] of Object.entries(this.flows)) {\n          let s2 = i.trigger;\n          switch (true) {\n            case s2 instanceof Et$1:\n              await s2.register(i, this.ctx.server);\n              break;\n          }\n        }\n        this.setBuilt();\n      }\n      toJSON() {\n        return { ...this.config, flows: O$2(this.flows, (e) => e.toJSON()) };\n      }\n    };\n    er$1 = {};\n    Je$2(er$1, { FileAccessEvent: /* @__PURE__ */ __name(() => ks, \"FileAccessEvent\"), FileDeletedEvent: /* @__PURE__ */ __name(() => _r$1, \"FileDeletedEvent\"), FileUploadedEvent: /* @__PURE__ */ __name(() => Fr, \"FileUploadedEvent\") });\n    Fr = class extends M$3 {\n      static {\n        __name(this, \"Fr\");\n      }\n      static slug = \"file-uploaded\";\n      validate(e) {\n        if (typeof e != \"object\") throw new ke$2(\"object\", typeof e);\n        return this.clone({ ...e, ...this.params });\n      }\n    };\n    _r$1 = class _r extends M$3 {\n      static {\n        __name(this, \"_r\");\n      }\n      static slug = \"file-deleted\";\n    };\n    ks = class extends M$3 {\n      static {\n        __name(this, \"ks\");\n      }\n      static slug = \"file-access\";\n    };\n    Tt$1 = class n22 {\n      static {\n        __name(this, \"n22\");\n      }\n      #e;\n      static Events = er$1;\n      emgr;\n      config;\n      constructor(e, t = {}, r2) {\n        this.#e = e, this.config = { ...t, body_max_size: t.body_max_size }, this.emgr = r2 ?? new V$2(), this.emgr.registerEvents(n22.Events);\n      }\n      getAdapter() {\n        return this.#e;\n      }\n      async objectMetadata(e) {\n        return await this.#e.getObjectMeta(e);\n      }\n      getConfig() {\n        return this.config;\n      }\n      async uploadFile(e, t, r2) {\n        let i = await this.#e.putObject(t, e);\n        if (typeof i > \"u\") throw new Error(\"Failed to upload file\");\n        let s2 = { name: t, meta: { size: 0, type: \"application/octet-stream\" }, etag: typeof i == \"string\" ? i : \"\" };\n        if (typeof i == \"object\" ? s2 = i : Ae$2(e) && (s2.meta.size = e.size, s2.meta.type = e.type), !Ur$1(s2.meta.type, [\"application/octet-stream\", \"application/json\"])) {\n          let c = await this.#e.getObjectMeta(t);\n          if (!c) throw new Error(\"Failed to get object meta\");\n          s2.meta = c;\n        }\n        if (s2.meta.type.startsWith(\"image\") && (!s2.meta.width || !s2.meta.height)) try {\n          let c = await ao$1(e);\n          s2.meta = { ...s2.meta, ...c };\n        } catch (c) {\n          m$1.warn(\"Failed to get image dimensions\", c);\n        }\n        let o = { file: e, ...s2, state: { name: s2.name, path: s2.name } };\n        if (!r2) {\n          let c = await this.emgr.emit(new Fr(o));\n          if (c.returned) return c.params;\n        }\n        return o;\n      }\n      async deleteFile(e) {\n        await this.#e.deleteObject(e), await this.emgr.emit(new _r$1({ name: e }));\n      }\n      async fileExists(e) {\n        return await this.#e.objectExists(e);\n      }\n    };\n    ga = Symbol.for(\"bknd:storage\");\n    tr = class {\n      static {\n        __name(this, \"tr\");\n      }\n      constructor() {\n        this[ga] = true;\n      }\n      static isAdapter(e) {\n        return e ? e[ga] === true : false;\n      }\n    };\n    ({ Type: rr$1 } = p$1);\n    ba = rr$1.Object({ cloud_name: rr$1.String(), api_key: rr$1.String(), api_secret: rr$1.String(), upload_preset: rr$1.Optional(rr$1.String()) }, { title: \"Cloudinary\", description: \"Cloudinary media storage\" });\n    nr$1 = class nr extends tr {\n      static {\n        __name(this, \"nr\");\n      }\n      config;\n      constructor(e) {\n        super(), this.config = _$2(ba, e);\n      }\n      getSchema() {\n        return ba;\n      }\n      getMimeType(e) {\n        switch (true) {\n          case (e.format === \"jpeg\" || e.format === \"jpg\"):\n            return \"image/jpeg\";\n        }\n        return `${e.resource_type}/${e.format}`;\n      }\n      getName() {\n        return \"cloudinary\";\n      }\n      getAuthorizationHeader() {\n        return { Authorization: `Basic ${btoa(`${this.config.api_key}:${this.config.api_secret}`)}` };\n      }\n      async putObject(e, t) {\n        let r2 = e.replace(/\\.[a-z0-9]{2,5}$/, \"\"), i = new FormData();\n        i.append(\"file\", t), i.append(\"public_id\", r2), i.append(\"api_key\", this.config.api_key), this.config.upload_preset && i.append(\"upload_preset\", this.config.upload_preset);\n        let s2 = await fetch(`https://api.cloudinary.com/v1_1/${this.config.cloud_name}/auto/upload`, { method: \"POST\", headers: { Accept: \"application/json\" }, body: i });\n        if (!s2.ok) return;\n        let o = await s2.json();\n        return { name: o.public_id + \".\" + o.format, etag: o.etag, meta: { type: this.getMimeType(o), size: o.bytes } };\n      }\n      async listObjects(e) {\n        let t = await fetch(`https://api.cloudinary.com/v1_1/${this.config.cloud_name}/resources/search`, { method: \"GET\", headers: { Accept: \"application/json\", \"Cache-Control\": \"no-cache\", ...this.getAuthorizationHeader() } });\n        if (!t.ok) throw new Error(\"Failed to list objects\");\n        return (await t.json()).resources.map((s2) => ({ key: s2.public_id, last_modified: new Date(s2.uploaded_at), size: s2.bytes }));\n      }\n      async headObject(e) {\n        let t = this.getObjectUrl(e);\n        return await fetch(t, { method: \"HEAD\", headers: { \"Cache-Control\": \"no-cache, no-store, must-revalidate\", Pragma: \"no-cache\", Expires: \"0\", Range: \"bytes=0-1\" } });\n      }\n      async objectExists(e) {\n        return (await this.headObject(e)).ok;\n      }\n      async getObjectMeta(e) {\n        let t = await this.headObject(e);\n        if (t.ok) {\n          let r2 = t.headers.get(\"content-type\"), i = Number(t.headers.get(\"content-range\")?.split(\"/\")[1]);\n          return { type: r2, size: i };\n        }\n        throw new Error(\"Cannot get object meta\");\n      }\n      guessType(e) {\n        let t = { image: [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", \"svg\"], video: [\"mp4\", \"webm\", \"ogg\"] }, r2 = e.split(\".\").pop();\n        return Object.keys(t).find((i) => t[i].includes(r2));\n      }\n      getObjectUrl(e) {\n        let t = this.guessType(e) ?? \"image\";\n        return `https://res.cloudinary.com/${this.config.cloud_name}/${t}/upload/${e}`;\n      }\n      async generateSignature(e, t) {\n        let r2 = e.timestamp ?? Math.floor(Date.now() / 1e3), i = Object.entries({ ...e, timestamp: r2 }).sort(([o], [c]) => o.localeCompare(c)).map(([o, c]) => `${o}=${c}`).join(\"&\");\n        return { signature: await Vr$1.sha1(i + (t ?? this.config.api_secret)), timestamp: r2 };\n      }\n      filenameToPublicId(e) {\n        return e.split(\".\").slice(0, -1).join(\".\");\n      }\n      async getObject(e, t) {\n        let r2 = await fetch(this.getObjectUrl(e), { method: \"GET\", headers: Ks(t, [\"range\"]) });\n        return new Response(r2.body, { status: r2.status, statusText: r2.statusText, headers: r2.headers });\n      }\n      async deleteObject(e) {\n        let t = this.guessType(e) ?? \"image\", r2 = this.filenameToPublicId(e), { timestamp: i, signature: s2 } = await this.generateSignature({ public_id: r2 }), o = new FormData();\n        o.append(\"public_id\", r2), o.append(\"timestamp\", String(i)), o.append(\"signature\", s2), o.append(\"api_key\", this.config.api_key);\n        let c = `https://api.cloudinary.com/v1_1/${this.config.cloud_name}/${t}/destroy`, a2 = await fetch(c, { headers: { Accept: \"application/json\", \"Cache-Control\": \"no-cache\", ...this.getAuthorizationHeader() }, method: \"POST\", body: o });\n        if (!a2.ok) throw new Error(`Failed to delete object: ${a2.status} ${a2.statusText}`);\n      }\n      toJSON(e) {\n        return { type: \"cloudinary\", config: e ? this.config : { cloud_name: this.config.cloud_name } };\n      }\n    };\n    ({ Type: Qn$1 } = p$1);\n    xa = Qn$1.Object({ access_key: Qn$1.String(), secret_access_key: Qn$1.String(), url: Qn$1.String({ pattern: \"^https?://(?:.*)?[^/.]+$\", description: \"URL to S3 compatible endpoint without trailing slash\", examples: [\"https://{account_id}.r2.cloudflarestorage.com/{bucket}\", \"https://{bucket}.s3.{region}.amazonaws.com\"] }) }, { title: \"AWS S3\", description: \"AWS S3 or compatible storage\" });\n    ir$1 = class ir extends tr {\n      static {\n        __name(this, \"ir\");\n      }\n      #e;\n      client;\n      constructor(e) {\n        super(), this.client = new or$1({ accessKeyId: e.access_key, secretAccessKey: e.secret_access_key, retries: K$1() ? 0 : 10 }, { convertParams: \"pascalToKebab\", responseType: \"xml\" }), this.#e = _$2(xa, e);\n      }\n      getName() {\n        return \"s3\";\n      }\n      getSchema() {\n        return xa;\n      }\n      getUrl(e = \"\", t = {}) {\n        let r2 = this.getObjectUrl(\"\").slice(0, -1);\n        return e.length > 0 && (r2 += `/${e}`), this.client.getUrl(r2, t);\n      }\n      getObjectUrl(e) {\n        return `${this.#e.url}/${e}`;\n      }\n      async listObjects(e = \"\") {\n        let t = { ListType: 2, Prefix: e }, r2 = this.getUrl(\"\", t), i = await this.client.fetchJson(r2, { method: \"GET\" }), { Contents: s2 } = i.ListBucketResult, o = s2 ? Array.isArray(s2) ? s2 : [s2] : [];\n        return transform(o, (a2, l2) => {\n          l2.Key && l2.LastModified && l2.Size && a2.push({ key: l2.Key, last_modified: l2.LastModified, size: l2.Size });\n        }, []);\n      }\n      async putObject(e, t, r2 = {}) {\n        let i = this.getUrl(e, {}), s2 = await this.client.fetch(i, { method: \"PUT\", body: t, headers: Ae$2(t) ? { \"Content-Length\": String(t.size) } : {} });\n        if (!s2.ok) throw new Error(`Failed to upload object: ${s2.status} ${s2.statusText}`);\n        return String(s2.headers.get(\"etag\"));\n      }\n      async headObject(e, t = {}) {\n        let r2 = this.getUrl(e, {});\n        return await this.client.fetch(r2, { method: \"HEAD\", headers: { Range: \"bytes=0-1\" } });\n      }\n      async getObjectMeta(e) {\n        let t = await this.headObject(e), r2 = String(t.headers.get(\"content-type\")), i = Number(String(t.headers.get(\"content-range\")?.split(\"/\")[1]));\n        return { type: r2, size: i };\n      }\n      async objectExists(e, t = {}) {\n        return (await this.headObject(e)).ok;\n      }\n      async getObject(e, t) {\n        let r2 = this.getUrl(e), i = await this.client.fetch(r2, { method: \"GET\", headers: Js(t, [\"if-none-match\", \"accept-encoding\", \"accept\", \"if-modified-since\"]) });\n        return new Response(i.body, { status: i.status, statusText: i.statusText, headers: i.headers });\n      }\n      async deleteObject(e, t = {}) {\n        let r2 = this.getUrl(e, t);\n        await this.client.fetch(r2, { method: \"DELETE\" });\n      }\n      toJSON(e) {\n        return { type: this.getName(), config: e ? this.#e : void 0 };\n      }\n    };\n    Me$1 = {};\n    Je$2(Me$1, { deleteFile: /* @__PURE__ */ __name(() => Yu, \"deleteFile\"), listFiles: /* @__PURE__ */ __name(() => Wu, \"listFiles\"), readFile: /* @__PURE__ */ __name(() => Vu, \"readFile\"), uploadFile: /* @__PURE__ */ __name(() => Hu, \"uploadFile\") });\n    Vu = new R$2(\"media.file.read\");\n    Wu = new R$2(\"media.file.list\");\n    Hu = new R$2(\"media.file.upload\");\n    Yu = new R$2(\"media.file.delete\");\n    __name(Xu, \"Xu\");\n    __name(Ps, \"Ps\");\n    wa = new pr((n252) => ({ cls: n252, schema: n252.prototype.getSchema() })).register(\"s3\", ir$1).register(\"cloudinary\", nr$1);\n    ({ s3: { schema: ir$1.prototype.getSchema() }, cloudinary: { schema: nr$1.prototype.getSchema() } });\n    Kn$1 = class Kn extends me$3 {\n      static {\n        __name(this, \"Kn\");\n      }\n      constructor(t) {\n        super();\n        this.media = t;\n      }\n      getStorageAdapter() {\n        return this.getStorage().getAdapter();\n      }\n      getStorage() {\n        return this.media.storage;\n      }\n      getController() {\n        let { auth: t, permission: r2 } = this.middlewares, i = this.create().use(t()), s2 = this.getEntitiesEnum(this.media.em);\n        i.get(\"/files\", S$2({ summary: \"Get the list of files\", tags: [\"media\"] }), r2(Me$1.listFiles), async (a2) => {\n          let l2 = await this.getStorageAdapter().listObjects();\n          return a2.json(l2);\n        }), i.get(\"/file/:filename\", S$2({ summary: \"Get a file by name\", tags: [\"media\"] }), r2(Me$1.readFile), async (a2) => {\n          let { filename: l2 } = a2.req.param();\n          if (!l2) throw new Error(\"No file name provided\");\n          await this.getStorage().emgr.emit(new er$1.FileAccessEvent({ name: l2 }));\n          let p2 = await this.getStorageAdapter().getObject(l2, a2.req.raw.headers), u3 = new Headers(p2.headers);\n          return u3.set(\"Cache-Control\", \"public, max-age=31536000, immutable\"), new Response(p2.body, { status: p2.status, statusText: p2.statusText, headers: u3 });\n        }), i.delete(\"/file/:filename\", S$2({ summary: \"Delete a file by name\", tags: [\"media\"] }), r2(Me$1.deleteFile), async (a2) => {\n          let { filename: l2 } = a2.req.param();\n          if (!l2) throw new Error(\"No file name provided\");\n          return await this.getStorage().deleteFile(l2), a2.json({ message: \"File deleted\" });\n        });\n        let o = this.getStorage().getConfig().body_max_size ?? Number.POSITIVE_INFINITY;\n        K$1() && i.post(\"/inspect\", S$2({ summary: \"Inspect a file\", tags: [\"media\"] }), async (a2) => {\n          let l2 = await zr$1(a2);\n          return a2.json({ type: l2?.type, name: l2?.name, size: l2?.size });\n        });\n        let c = { content: { \"multipart/form-data\": { schema: { type: \"object\", properties: { file: { type: \"string\", format: \"binary\" } }, required: [\"file\"] } }, \"application/octet-stream\": { schema: { type: \"string\", format: \"binary\" } } } };\n        return i.post(\"/upload/:filename?\", S$2({ summary: \"Upload a file\", tags: [\"media\"], requestBody: c }), T$1(\"param\", f.object({ filename: f.string().optional() })), r2(Me$1.uploadFile), async (a2) => {\n          let l2 = a2.req.param(\"filename\"), p2 = await zr$1(a2);\n          if (!p2) return a2.json({ error: \"No file provided\" }, 400);\n          if (p2.size > o) return a2.json({ error: `Max size (${o} bytes) exceeded` }, 413);\n          let u3 = l2 ?? Ps(p2), d2 = await this.getStorage().uploadFile(p2, u3);\n          return a2.json(d2, 201);\n        }), i.post(\"/entity/:entity/:id/:field\", S$2({ summary: \"Add a file to an entity\", tags: [\"media\"], requestBody: c }), T$1(\"param\", f.object({ entity: s2, id: f.number(), field: f.string() })), T$1(\"query\", f.object({ overwrite: f.boolean().optional() })), r2([j$3.entityCreate, Me$1.uploadFile]), async (a2) => {\n          let l2 = a2.req.param(\"entity\"), p2 = a2.req.param(\"field\"), u3 = Number.parseInt(a2.req.param(\"id\")), d2 = this.media.em.entity(l2);\n          if (!d2) return a2.json({ error: `Entity \"${l2}\" not found` }, 404);\n          let y3 = d2.field(p2);\n          if (!y3 || !(y3 instanceof Ke$1)) return a2.json({ error: `Invalid field \"${p2}\"` }, 400);\n          let b3 = this.media.getMediaEntity().name, L2 = `${l2}.${p2}`, $3 = { scope: p2, reference: L2, entity_id: u3 }, ye2 = y3.getMaxItems(), si2 = [];\n          if (ye2) {\n            let { overwrite: ai2 } = a2.req.valid(\"query\"), { count: Mr2 } = await this.media.em.repository(b3).count($3);\n            if (Mr2 >= ye2) {\n              if (!ai2) return a2.json({ error: `Max items (${ye2}) reached` }, 400);\n              if (Mr2 > ye2) return a2.json({ error: `Max items (${ye2}) exceeded already with ${Mr2} items.` }, 422);\n              let ci2 = await this.media.em.repo(b3).findMany({ select: [\"path\"], where: $3, sort: { by: \"id\", dir: \"asc\" }, limit: Mr2 - ye2 + 1 });\n              ci2.data && ci2.data.length > 0 && ci2.data.map((ka) => si2.push(ka.path));\n            }\n          }\n          let { exists: Aa } = await this.media.em.repository(d2).exists({ id: u3 });\n          if (!Aa) return a2.json({ error: `Entity \"${l2}\" with ID \"${u3}\" doesn't exist found` }, 404);\n          let jr2 = await zr$1(a2);\n          if (!jr2) return a2.json({ error: \"No file provided\" }, 400);\n          if (jr2.size > o) return a2.json({ error: `Max size (${o} bytes) exceeded` }, 413);\n          let Fa = Ps(jr2), Us = await this.getStorage().uploadFile(jr2, Fa, true), oi2 = this.media.em.mutator(b3);\n          oi2.__unstable_toggleSystemEntityCreation(false);\n          let _a = await oi2.insertOne({ ...this.media.uploadedEventDataToMediaPayload(Us), ...$3 });\n          if (oi2.__unstable_toggleSystemEntityCreation(true), si2.length > 0) for (let ai2 of si2) await this.getStorage().deleteFile(ai2);\n          return a2.json({ ok: true, result: _a.data, ...Us }, 201);\n        }), i.all(\"*\", (a2) => a2.notFound());\n      }\n    };\n    js = { media: wa };\n    ({ Type: Ie$2 } = p$1);\n    Ms = js.media;\n    __name(Is, \"Is\");\n    Is();\n    Jn$1 = class n23 extends H$3 {\n      static {\n        __name(this, \"n23\");\n      }\n      _storage;\n      async build() {\n        if (!this.config.enabled) {\n          this.setBuilt();\n          return;\n        }\n        if (!this.config.adapter) {\n          console.info(\"No storage adapter provided, skip building media.\");\n          return;\n        }\n        let e;\n        try {\n          let { type: t, config: r2 } = this.config.adapter, i = Ms.get(t).cls;\n          e = new i(r2), this._storage = new Tt$1(e, this.config.storage, this.ctx.emgr), this.setBuilt(), this.setupListeners(), this.ctx.guard.registerPermissions(Me$1), this.ctx.server.route(this.basepath, new Kn$1(this).getController());\n          let s2 = this.getMediaEntity(true);\n          this.ensureSchema(gn$1({ [s2.name]: s2 }, ({ index: o }, { media: c }) => {\n            o(c).on([\"path\"], true).on([\"reference\"]).on([\"entity_id\"]);\n          }));\n        } catch (t) {\n          throw console.error(t), new Error(`Could not build adapter with config ${JSON.stringify(this.config.adapter)}`);\n        }\n      }\n      getSchema() {\n        return Is();\n      }\n      get basepath() {\n        return this.config.basepath;\n      }\n      get storage() {\n        return this.throwIfNotBuilt(), this._storage;\n      }\n      uploadedEventDataToMediaPayload(e) {\n        let t = {};\n        return e.meta.width && e.meta.height && (t.width = e.meta.width, t.height = e.meta.height), { path: e.name, mime_type: e.meta.type, size: e.meta.size, etag: e.etag, modified_at: /* @__PURE__ */ new Date(), metadata: t };\n      }\n      static mediaFields = { path: Oe$2().required(), folder: Ko({ default_value: false, hidden: true, fillable: [\"create\"] }), mime_type: Oe$2(), size: gr$1(), scope: Oe$2({ hidden: true, fillable: [\"create\"] }), etag: Oe$2(), modified_at: br$1(), reference: Oe$2(), entity_id: gr$1(), metadata: Jo() };\n      getMediaEntity(e) {\n        let t = this.config.entity_name;\n        return e || !this.em.hasEntity(t) ? qt$1(t, n23.mediaFields, void 0, \"system\") : this.em.entity(t);\n      }\n      get em() {\n        return this.ctx.em;\n      }\n      setupListeners() {\n        let { emgr: e, em: t } = this.ctx, r2 = this.getMediaEntity().name;\n        e.onEvent(Tt$1.Events.FileUploadedEvent, async (i) => {\n          let s2 = t.mutator(r2);\n          s2.__unstable_toggleSystemEntityCreation(false);\n          let o = this.uploadedEventDataToMediaPayload(i.params), { data: c } = await s2.insertOne(o);\n          return s2.__unstable_toggleSystemEntityCreation(true), { data: c };\n        }, { mode: \"sync\", id: \"add-data-media\" }), e.onEvent(Tt$1.Events.FileDeletedEvent, async (i) => {\n          let { data: s2 } = await t.repo(r2).findOne({ path: i.params.name });\n          s2 && await t.mutator(r2).deleteOne(s2.id), m$1.log(\"App:storage:file deleted\", i.params);\n        }, { mode: \"sync\", id: \"delete-data-media\" });\n      }\n      getOverwritePaths() {\n        return [/^\\.?adapter$/];\n      }\n      toJSON(e) {\n        return !this.isBuilt() || !this.config.enabled ? this.configDefault : { ...this.config, adapter: this.storage.getAdapter().toJSON(e) };\n      }\n    };\n    ({ Type: Re$2 } = p$1);\n    kr$1 = { server: _n$1, data: Mn$1, auth: Jt$1, media: Jn$1, flows: Ln$1 };\n    Ta = Object.keys(kr$1);\n    nd = Re$2.Union([Sa(), Re$2.Array(Re$2.Object({ t: w$4([\"a\", \"r\", \"e\"]), p: Re$2.Array(Re$2.Union([Re$2.String(), Re$2.Number()])), o: Re$2.Optional(Re$2.Any()), n: Re$2.Optional(Re$2.Any()) }))]);\n    Ds = qt$1(la, { version: gr$1().required(), type: xr$1({ enum: [\"config\", \"diff\", \"backup\"] }).required(), json: zo({ schema: nd }).required(), created_at: br$1(), updated_at: br$1() });\n    id = sr$1(\"modules_debug\");\n    zn$1 = class zn {\n      static {\n        __name(this, \"zn\");\n      }\n      constructor(e, t) {\n        this.connection = e;\n        this.options = t;\n        this.__em = new et$1([Ds], this.connection), this.modules = {}, this.emgr = new V$2(), this.logger = new lr$1(id);\n        let r2 = {};\n        if (t?.initial) if (\"version\" in t.initial) {\n          let { version: i, ...s2 } = t.initial;\n          this._version = i, r2 = Gr$1(s2), this._booted_with = \"provided\";\n        } else r2 = mergeWith(va(), t.initial), this._booted_with = \"partial\";\n        this.logger.log(\"booted with\", this._booted_with), this.createModules(r2);\n      }\n      modules;\n      __em;\n      em;\n      server;\n      emgr;\n      guard;\n      _version = 0;\n      _built = false;\n      _booted_with;\n      _stable_configs;\n      logger;\n      createModules(e) {\n        this.logger.context(\"createModules\").log(\"creating modules\");\n        try {\n          let t = this.ctx(true);\n          for (let r2 in kr$1) {\n            let i = e && r2 in e ? e[r2] : {}, s2 = new kr$1[r2](i, t);\n            s2.setListener(async (o) => {\n              await this.onModuleConfigUpdated(r2, o);\n            }), this.modules[r2] = s2;\n          }\n          this.logger.log(\"modules created\");\n        } catch (t) {\n          throw this.logger.log(\"failed to create modules\", t), t;\n        }\n        this.logger.clear();\n      }\n      get verbosity() {\n        return this.options?.verbosity ?? 0;\n      }\n      isBuilt() {\n        return this._built;\n      }\n      async onModuleConfigUpdated(e, t) {\n        this.options?.onUpdated ? await this.options.onUpdated(e, t) : await this.buildModules();\n      }\n      repo() {\n        return this.__em.repo(Ds, { silent: true, includeCounts: false });\n      }\n      mutator() {\n        return this.__em.mutator(Ds);\n      }\n      get db() {\n        return this.connection.kysely;\n      }\n      async syncConfigTable() {\n        this.logger.context(\"sync\").log(\"start\");\n        let e = await this.__em.schema().sync({ force: true });\n        return this.logger.log(\"done\").clear(), e;\n      }\n      rebuildServer() {\n        this.server = new Hono2(), this.options?.basePath && (this.server = this.server.basePath(this.options.basePath)), this.options?.onServerInit && this.options.onServerInit(this.server), mi$1(this.modules, (e) => {\n          e.onServerInit(this.server);\n        });\n      }\n      ctx(e) {\n        return e && (this.rebuildServer(), this.em = new et$1([], this.connection, [], [], this.emgr), this.guard = new Sr$1()), { connection: this.connection, server: this.server, em: this.em, emgr: this.emgr, guard: this.guard, flags: H$3.ctx_flags, logger: this.logger };\n      }\n      async fetch() {\n        this.logger.context(\"fetch\").log(\"fetching\");\n        let e = performance.now(), { data: t } = await this.repo().findOne({ type: \"config\" }, { sort: { by: \"version\", dir: \"desc\" } });\n        if (!t) {\n          this.logger.log(\"error fetching\").clear();\n          return;\n        }\n        return this.logger.log(\"took\", performance.now() - e, \"ms\", { version: t.version, id: t.id }).clear(), t;\n      }\n      async save() {\n        this.logger.context(\"save\").log(\"saving version\", this.version());\n        let e = this.configs(), t = this.version();\n        try {\n          let r2 = await this.fetch();\n          if (!r2) throw new he$2(\"no config found\");\n          if (this.logger.log(\"fetched version\", r2.version), r2.version !== t) this.logger.log(\"version conflict, storing new version\", r2.version, t), await this.mutator().insertOne({ version: r2.version, type: \"backup\", json: e }), await this.mutator().insertOne({ version: t, type: \"config\", json: e });\n          else {\n            this.logger.log(\"version matches\", r2.version);\n            let i = aa(r2.json, zt$1(e));\n            if (this.logger.log(\"checking diff\", [i.length]), i.length > 0) {\n              this.validateDiffs(i);\n              let s2 = /* @__PURE__ */ new Date();\n              await this.mutator().insertOne({ version: t, type: \"diff\", json: zt$1(i), created_at: s2, updated_at: s2 }), await this.mutator().updateWhere({ version: t, json: e, updated_at: s2 }, { type: \"config\", version: t });\n            } else this.logger.log(\"no diff, not saving\");\n          }\n        } catch (r2) {\n          if (r2 instanceof he$2 && r2.message === \"no config found\") this.logger.log(\"no config, just save fresh\"), await this.mutator().insertOne({ type: \"config\", version: t, json: e, created_at: /* @__PURE__ */ new Date(), updated_at: /* @__PURE__ */ new Date() });\n          else throw r2 instanceof D$4 ? (m$1.error(\"ModuleManager: Cannot save invalid config\"), this.revertModules(), r2) : (m$1.error(\"ModuleManager: Aborting\"), this.revertModules(), r2);\n        }\n        return this.setConfigs(e), this.logger.clear(), this;\n      }\n      revertModules() {\n        this._stable_configs ? (m$1.warn(\"ModuleManager: Reverting modules\"), this.setConfigs(this._stable_configs)) : m$1.error(\"ModuleManager: No stable configs to revert to\");\n      }\n      validateDiffs(e) {\n        let t = [...new Set(e.map((r2) => r2.p[0]))];\n        if (t.length !== 0) for (let r2 of t) {\n          let i = r2, s2 = this.get(i);\n          if (!s2) {\n            let o = \"validateDiffs: module not registered\";\n            throw m$1.error(o, JSON.stringify({ module: i, diffs: e }, null, 2)), new Error(o);\n          }\n          if (this._stable_configs?.[i]) {\n            let o = zt$1(this._stable_configs?.[i]), c = ca2({ [i]: o }, e)[i];\n            s2.onBeforeUpdate(o, c);\n          }\n        }\n      }\n      setConfigs(e) {\n        this.logger.log(\"setting configs\"), mi$1(e, (t, r2) => {\n          try {\n            this.modules[r2].schema().set(t, true);\n          } catch (i) {\n            throw console.error(i), new Error(`Failed to set config for module ${r2}: ${JSON.stringify(t, null, 2)}`);\n          }\n        });\n      }\n      async build(e) {\n        if (this.logger.context(\"build\").log(\"version\", this.version()), await this.ctx().connection.init(), this.version() === 0 || e?.fetch === true) {\n          e?.fetch && this.logger.log(\"force fetch\");\n          let t = await this.fetch();\n          if (!t) this.logger.log(\"nothing in database, go initial\"), await this.setupInitial();\n          else if (this.logger.log(\"db has\", t.version), this._version = t.version, this.options?.trustFetched === true && (this.logger.log(\"trusting fetched config (mark)\"), ar$1(t.json)), this.version() !== Gt$1) {\n            this.logger.log(\"now migrating\"), await this.syncConfigTable();\n            let r2 = this.version(), [i, s2] = await pa(r2, t.json, { db: this.db });\n            this._version = i, this.ctx().flags.sync_required = true, this.logger.log(\"migrated to\", i), m$1.log(\"Migrated config from\", r2, \"to\", this.version()), this.createModules(s2), await this.buildModules();\n          } else this.logger.log(\"version is current\", this.version()), this.createModules(t.json), await this.buildModules();\n        } else {\n          if (this.version() !== Gt$1) throw new Error(`Given version (${this.version()}) and current version (${Gt$1}) do not match.`);\n          this.logger.log(\"current version is up to date\", this.version()), await this.buildModules();\n        }\n        return this.logger.log(\"done\"), this.logger.clear(), this;\n      }\n      async buildModules(e) {\n        let t = { built: false, modules: [], synced: false, saved: false, reloaded: false };\n        if (this.logger.context(\"buildModules\").log(\"triggered\", e, this._built), e?.graceful && this._built) return this.logger.log(\"skipping build (graceful)\"), t;\n        this.logger.log(\"building\");\n        let r2 = this.ctx(true);\n        for (let i in this.modules) await this.modules[i].setContext(r2).build(), this.logger.log(\"built\", i), t.modules.push(i);\n        return this._built = t.built = true, this.logger.log(\"modules built\", r2.flags), e?.ignoreFlags !== true && (r2.flags.sync_required && (r2.flags.sync_required = false, this.logger.log(\"db sync requested\"), await r2.em.schema().sync({ force: true }), t.synced = true, await this.save(), t.saved = true), r2.flags.ctx_reload_required && (r2.flags.ctx_reload_required = false, this.logger.log(\"ctx reload requested\"), this.ctx(true), t.reloaded = true)), this.logger.log(\"resetting flags\"), r2.flags = H$3.ctx_flags, this._stable_configs = zt$1(this.configs()), this.logger.clear(), t;\n      }\n      async setupInitial() {\n        this.logger.context(\"initial\").log(\"start\"), this._version = Gt$1, await this.syncConfigTable(), (await this.buildModules()).saved || await this.save();\n        let t = { ...this.ctx(), em: this.ctx().em.fork() };\n        await t.em.schema().sync({ force: true }), await this.options?.seed?.(t), await this.options?.onFirstBoot?.(), this.logger.clear();\n      }\n      mutateConfigSafe(e) {\n        let t = this.modules[e];\n        return new Proxy(t.schema(), { get: /* @__PURE__ */ __name((r2, i) => {\n          if (![\"set\", \"patch\", \"overwrite\", \"remove\"].includes(i)) throw new Error(`Method ${i} is not allowed`);\n          return async (...s2) => {\n            m$1.log(\"[Safe Mutate]\", e);\n            try {\n              t.setListener(async () => {\n                await this.buildModules();\n              });\n              let o = await r2[i](...s2);\n              return t.setListener(async (c) => {\n                await this.onModuleConfigUpdated(e, c);\n              }), this.options?.onUpdated && await this.options.onUpdated(e, t.config), o;\n            } catch (o) {\n              throw m$1.error(`[Safe Mutate] failed \"${e}\":`, String(o)), this.revertModules(), await this.onModuleConfigUpdated(e, t.config), m$1.warn(`[Safe Mutate] reverted \"${e}\":`), o;\n            }\n          };\n        }, \"get\") });\n      }\n      get(e) {\n        if (!(e in this.modules)) throw new Error(`Module \"${e}\" doesn't exist, cannot get`);\n        return this.modules[e];\n      }\n      version() {\n        return this._version;\n      }\n      built() {\n        return this._built;\n      }\n      configs() {\n        return O$2(this.modules, (e) => e.toJSON(true));\n      }\n      getSchema() {\n        let e = O$2(this.modules, (t) => t.getSchema());\n        return { version: this.version(), ...e };\n      }\n      toJSON(e) {\n        let t = O$2(this.modules, (r2) => {\n          if (this._built) return r2.isBuilt() ? r2.toJSON(e) : r2.configDefault;\n        });\n        return { version: this.version(), ...t };\n      }\n    };\n    __name(Sa, \"Sa\");\n    __name(va, \"va\");\n    qs = \"<!-- BKND_CONTEXT -->\";\n    Gn$1 = class Gn extends me$3 {\n      static {\n        __name(this, \"Gn\");\n      }\n      constructor(t, r2 = {}) {\n        super();\n        this.app = t;\n        this._options = r2;\n      }\n      get ctx() {\n        return this.app.modules.ctx();\n      }\n      get options() {\n        return { ...this._options, basepath: this._options.basepath ?? \"/\", adminBasepath: this._options.adminBasepath ?? \"\", assetsPath: this._options.assetsPath ?? ot$1.server.assets_path };\n      }\n      get basepath() {\n        return this.options.adminBasepath ?? \"/\";\n      }\n      withBasePath(t = \"\") {\n        return (this.options.basepath + t).replace(/(?<!:)\\/+/g, \"/\");\n      }\n      withAdminBasePath(t = \"\") {\n        return this.withBasePath(this.options.adminBasepath + t);\n      }\n      getController() {\n        let { auth: t, permission: r2 } = this.middlewares, i = this.create().use(t({})), s2 = this.app.module.auth, o = this.app.modules.configs(), c = o.auth.enabled, a2 = { success: o.auth.cookie.pathSuccess ?? this.withAdminBasePath(\"/\"), loggedOut: o.auth.cookie.pathLoggedOut ?? this.withAdminBasePath(\"/\"), login: this.withAdminBasePath(\"/auth/login\"), register: this.withAdminBasePath(\"/auth/register\"), logout: \"/api/auth/logout\" }, l2 = [\"/\", \"/data/*\", \"/auth/*\", \"/media/*\", \"/flows/*\", \"/settings/*\"];\n        K$1() && l2.push(\"/test/*\");\n        for (let p2 of l2) i.get(p2, r2(kn$1, { onDenied: /* @__PURE__ */ __name(async (u3) => (Ft$1(u3, \"You are not authorized to access the Admin UI\", \"error\"), m$1.log(\"redirecting\"), u3.redirect(a2.login)), \"onDenied\") }), r2(Wt$1, { onDenied: /* @__PURE__ */ __name(async (u3) => {\n          Ft$1(u3, \"You not allowed to read the schema\", \"warning\");\n        }, \"onDenied\") }), async (u3) => {\n          let d2 = { user: u3.get(\"auth\")?.user, logout_route: a2.logout, admin_basepath: this.options.adminBasepath }, y3 = await this.getHtml(d2);\n          return y3 ? (await s2.authenticator?.requestCookieRefresh(u3), u3.html(y3)) : (console.warn(\"Couldn't generate HTML for admin UI\"), u3.notFound());\n        });\n        if (c) {\n          let p2 = [r2([kn$1, Wt$1], { onGranted: /* @__PURE__ */ __name(async (u3) => {\n            if (u3.get(\"auth\")?.user) return m$1.log(\"redirecting to success\"), u3.redirect(a2.success);\n          }, \"onGranted\") }), async (u3) => u3.html(u3.get(\"html\"))];\n          i.get(a2.login, ...p2), i.get(a2.register, ...p2), i.get(a2.logout, async (u3) => (await s2.authenticator?.logout(u3), u3.redirect(a2.loggedOut)));\n        }\n        return i;\n      }\n      async getHtml(t) {\n        let r2 = `window.__BKND__ = JSON.parse('${JSON.stringify(t)}');`;\n        if (this.options.html) return this.options.html.includes(qs) ? this.options.html.replace(qs, \"<script>\" + r2 + \"</script>\") : (m$1.warn(`Custom HTML needs to include '${qs}' to inject BKND context`), this.options.html);\n        this.app.modules.configs();\n        let s2 = !K$1() && !this.options.forceDev, o = typeof this.options.forceDev == \"object\" && \"mainPath\" in this.options.forceDev ? this.options.forceDev.mainPath : \"/src/ui/main.tsx\", c = { js: \"main.js\", css: \"styles.css\" };\n        if (s2) {\n          let l2;\n          this.options.assetsPath.startsWith(\"http\") ? l2 = await fetch(this.options.assetsPath + \"manifest.json\", { headers: { Accept: \"application/json\" } }).then((p2) => p2.json()) : l2 = await Promise.resolve().then(() => Qs(Oa())).then((p2) => p2.default);\n          try {\n            c.js = l2[\"src/ui/main.tsx\"].file, c.css = l2[\"src/ui/main.tsx\"].css[0];\n          } catch (p2) {\n            m$1.warn(\"Couldn't find assets in manifest\", p2);\n          }\n        }\n        let a2 = s2 ? this.options.assetsPath + \"favicon.ico\" : \"/favicon.ico\";\n        return jsxDEV(Fragment2, { children: [html`<!DOCTYPE html>`, jsxDEV(\"html\", { lang: \"en\", children: [jsxDEV(\"head\", { children: [jsxDEV(\"meta\", { charset: \"UTF-8\" }), jsxDEV(\"meta\", { name: \"viewport\", content: \"width=device-width, initial-scale=1, maximum-scale=1\" }), jsxDEV(\"link\", { rel: \"icon\", href: a2, type: \"image/x-icon\" }), jsxDEV(\"title\", { children: \"BKND\" }), this.options.debugRerenders && jsxDEV(\"script\", { crossOrigin: \"anonymous\", src: \"//unpkg.com/react-scan/dist/auto.global.js\" }), s2 ? jsxDEV(Fragment2, { children: [jsxDEV(\"script\", { type: \"module\", src: this.options.assetsPath + c?.js }), jsxDEV(\"link\", { rel: \"stylesheet\", href: this.options.assetsPath + c?.css })] }) : jsxDEV(Fragment2, { children: [jsxDEV(\"script\", { type: \"module\", dangerouslySetInnerHTML: { __html: `import RefreshRuntime from \"/@react-refresh\"\n                              RefreshRuntime.injectIntoGlobalHook(window)\n                              window.$RefreshReg$ = () => {}\n                              window.$RefreshSig$ = () => (type) => type\n                              window.__vite_plugin_react_preamble_installed__ = true` } }), jsxDEV(\"script\", { type: \"module\", src: \"/@vite/client\" })] }), jsxDEV(\"style\", { dangerouslySetInnerHTML: { __html: \"body { margin: 0; padding: 0; }\" } })] }), jsxDEV(\"body\", { children: [jsxDEV(\"div\", { id: \"root\", children: [jsxDEV(Style, {}), jsxDEV(\"div\", { id: \"loading\", className: cd, children: jsxDEV(\"span\", { className: ld, children: \"Initializing...\" }) })] }), jsxDEV(\"script\", { dangerouslySetInnerHTML: { __html: r2 } }), !s2 && jsxDEV(\"script\", { type: \"module\", src: o })] })] })] });\n      }\n    };\n    cd = css`\n   margin: 0;\n   padding: 0;\n   height: 100vh;\n   width: 100vw;\n   display: flex;\n   justify-content: center;\n   align-items: center;\n   -webkit-font-smoothing: antialiased;\n   -moz-osx-font-smoothing: grayscale;\n   color: rgb(9,9,11);\n   background-color: rgb(250,250,250);\n   \n   @media (prefers-color-scheme: dark) {\n      color: rgb(250,250,250);\n      background-color: rgb(30,31,34);\n   }\n`;\n    ld = css`\n   opacity: 0.3;\n   font-size: 14px;\n   font-family: monospace;\n`;\n    Vn$1 = class Vn extends me$3 {\n      static {\n        __name(this, \"Vn\");\n      }\n      constructor(t) {\n        super();\n        this.app = t;\n      }\n      get ctx() {\n        return this.app.modules.ctx();\n      }\n      registerConfigController(t) {\n        let { permission: r2 } = this.middlewares, i = this.create();\n        i.use(r2(Pn$1)), i.get(\"/raw\", S$2({ summary: \"Get the raw config\", tags: [\"system\"] }), r2([vr$1]), async (o) => o.json(await this.app.modules.fetch())), i.get(\"/:module?\", S$2({ summary: \"Get the config for a module\", tags: [\"system\"] }), T$1(\"param\", f.object({ module: f.string({ enum: Ta }).optional() })), T$1(\"query\", f.object({ secrets: f.boolean().optional() })), async (o) => {\n          let { secrets: c } = o.req.valid(\"query\"), { module: a2 } = o.req.valid(\"param\");\n          c && this.ctx.guard.throwUnlessGranted(vr$1, o);\n          let l2 = this.app.toJSON(c);\n          return o.json(a2 ? { version: this.app.version(), module: a2, config: l2[a2] } : l2);\n        });\n        async function s2(o, c) {\n          try {\n            return o.json(await c(), { status: 202 });\n          } catch (a2) {\n            return m$1.error(\"config update error\", a2), a2 instanceof De$2 ? o.json({ success: false, type: \"type-invalid\", errors: a2.errors }, { status: 400 }) : a2 instanceof Error ? o.json({ success: false, type: \"error\", error: a2.message }, { status: 500 }) : o.json({ success: false, type: \"unknown\" }, { status: 500 });\n          }\n        }\n        __name(s2, \"s\");\n        i.post(\"/set/:module\", r2(bt$1), T$1(\"query\", f.object({ force: f.boolean().optional() }), { skipOpenAPI: true }), async (o) => {\n          let c = o.req.param(\"module\"), { force: a2 } = o.req.valid(\"query\"), l2 = await o.req.json();\n          return await s2(o, async () => {\n            if (a2 === true) {\n              let p2 = { ...this.app.module[c].config, ...l2 };\n              await this.app.mutateConfig(c).set(p2);\n            } else await this.app.mutateConfig(c).patch(\"\", l2);\n            return { success: true, module: c, config: this.app.module[c].config };\n          });\n        }), i.post(\"/add/:module/:path\", r2(bt$1), async (o) => {\n          let c = o.req.param(\"module\"), a2 = await o.req.json(), l2 = o.req.param(\"path\");\n          return this.app.modules.get(c).schema().has(l2) ? o.json({ success: false, path: l2, error: \"Path already exists\" }, { status: 400 }) : await s2(o, async () => (await this.app.mutateConfig(c).patch(l2, a2), { success: true, module: c, config: this.app.module[c].config }));\n        }), i.patch(\"/patch/:module/:path\", r2(bt$1), async (o) => {\n          let c = o.req.param(\"module\"), a2 = await o.req.json(), l2 = o.req.param(\"path\");\n          return await s2(o, async () => (await this.app.mutateConfig(c).patch(l2, a2), { success: true, module: c, config: this.app.module[c].config }));\n        }), i.put(\"/overwrite/:module/:path\", r2(bt$1), async (o) => {\n          let c = o.req.param(\"module\"), a2 = await o.req.json(), l2 = o.req.param(\"path\");\n          return await s2(o, async () => (await this.app.mutateConfig(c).overwrite(l2, a2), { success: true, module: c, config: this.app.module[c].config }));\n        }), i.delete(\"/remove/:module/:path\", r2(bt$1), async (o) => {\n          let c = o.req.param(\"module\"), a2 = o.req.param(\"path\");\n          return await s2(o, async () => (await this.app.mutateConfig(c).remove(a2), { success: true, module: c, config: this.app.module[c].config }));\n        }), t.route(\"/config\", i);\n      }\n      getController() {\n        let { permission: t, auth: r2 } = this.middlewares, i = this.create().use(r2());\n        return this.registerConfigController(i), i.get(\"/schema/:module?\", S$2({ summary: \"Get the schema for a module\", tags: [\"system\"] }), t(Wt$1), T$1(\"query\", f.partialObject({ config: f.boolean(), secrets: f.boolean(), fresh: f.boolean() })), async (s2) => {\n          let o = s2.req.param(\"module\"), { config: c, secrets: a2, fresh: l2 } = s2.req.valid(\"query\");\n          c && this.ctx.guard.throwUnlessGranted(Pn$1, s2), a2 && this.ctx.guard.throwUnlessGranted(vr$1, s2);\n          let { version: p2, ...u3 } = this.app.getSchema();\n          return l2 && await this.app.build({ fetch: true }), o ? s2.json({ module: o, version: p2, schema: u3[o], config: c ? this.app.module[o].toJSON(a2) : void 0 }) : s2.json({ module: o, version: p2, schema: u3, config: c ? this.app.toJSON(a2) : void 0, permissions: this.app.modules.ctx().guard.getPermissionNames() });\n        }), i.post(\"/build\", S$2({ summary: \"Build the app\", tags: [\"system\"] }), T$1(\"query\", f.object({ sync: f.boolean().optional(), fetch: f.boolean().optional() })), async (s2) => {\n          let o = s2.req.valid(\"query\");\n          return this.ctx.guard.throwUnlessGranted(Rs, s2), await this.app.build(o), s2.json({ success: true, options: o });\n        }), i.get(\"/ping\", S$2({ summary: \"Ping the server\", tags: [\"system\"] }), (s2) => s2.json({ pong: true })), i.get(\"/info\", S$2({ summary: \"Get the server info\", tags: [\"system\"] }), (s2) => s2.json({ version: s2.get(\"app\")?.version(), runtime: bi$1(), timezone: { name: mo(), offset: uo(), local: Kr$1(), utc: po() } })), i.get(\"/openapi.json\", Di$1(this.ctx.server, { info: { title: \"bknd API\", version: Gs() } })), i.get(\"/swagger\", middleware({ url: \"/api/system/openapi.json\" })), i;\n      }\n    };\n    Ce$1 = class Ce {\n      static {\n        __name(this, \"Ce\");\n      }\n      constructor(e = {}, t) {\n        this._options = e;\n        this.fetcher = t ?? fetch;\n      }\n      fetcher;\n      getDefaultOptions() {\n        return {};\n      }\n      get options() {\n        return { host: \"http://localhost\", token: void 0, ...this.getDefaultOptions(), ...this._options };\n      }\n      key() {\n        return this.options.basepath ?? \"\";\n      }\n      getUrl(e) {\n        let t = this.options.basepath ?? \"\";\n        return this.options.host + (t + \"/\" + e).replace(/\\/{2,}/g, \"/\").replace(/\\/$/, \"\");\n      }\n      request(e, t, r2) {\n        let i = r2?.method ?? \"GET\", s2 = Array.isArray(e) ? e.join(\"/\") : e, o = this.getUrl(s2);\n        t instanceof URLSearchParams ? o += \"?\" + t.toString() : typeof t == \"object\" && Object.keys(t).length > 0 && (o += \"?\" + zs(t));\n        let c = new Headers(this.options.headers ?? {});\n        for (let [p2, u3] of Object.entries(r2?.headers ?? {})) c.set(p2, u3);\n        c.has(\"Accept\") || c.set(\"Accept\", \"application/json\"), this.options.token && this.options.token_transport === \"header\" && c.set(\"Authorization\", `Bearer ${this.options.token}`);\n        let a2 = r2?.body;\n        if (r2 && \"body\" in r2 && [\"POST\", \"PATCH\", \"PUT\"].includes(i)) {\n          let p2 = c.get(\"Content-Type\") ?? void 0;\n          (!p2 || p2.startsWith(\"application/json\")) && (a2 = JSON.stringify(r2.body), c.set(\"Content-Type\", \"application/json\"));\n        }\n        let l2 = new Request(o, { ...r2, method: i, body: a2, headers: c });\n        return new Bs(l2, { fetcher: this.fetcher, verbose: this.options.verbose });\n      }\n      get(e, t, r2) {\n        return this.request(e, t, { ...r2, method: \"GET\" });\n      }\n      post(e, t, r2) {\n        return this.request(e, void 0, { ...r2, body: t, method: \"POST\" });\n      }\n      patch(e, t, r2) {\n        return this.request(e, void 0, { ...r2, body: t, method: \"PATCH\" });\n      }\n      put(e, t, r2) {\n        return this.request(e, void 0, { ...r2, body: t, method: \"PUT\" });\n      }\n      delete(e, t, r2) {\n        return this.request(e, void 0, { ...r2, body: t, method: \"DELETE\" });\n      }\n    };\n    __name(ud, \"ud\");\n    Bs = class n24 {\n      static {\n        __name(this, \"n24\");\n      }\n      constructor(e, t, r2) {\n        this.request = e;\n        this.options = t;\n        this.refineData = r2;\n      }\n      [Symbol.toStringTag];\n      get verbose() {\n        return this.options?.verbose ?? false;\n      }\n      refine(e) {\n        return new n24(this.request, this.options, e);\n      }\n      async execute() {\n        K$1() && await new Promise((o) => setTimeout(o, 200));\n        let e = this.options?.fetcher ?? fetch;\n        this.verbose && m$1.debug(\"[FetchPromise] Request\", { method: this.request.method, url: this.request.url });\n        let t = await e(this.request);\n        this.verbose && m$1.debug(\"[FetchPromise] Response\", { res: t, ok: t.ok, status: t.status });\n        let r2, i, s2 = t.headers.get(\"Content-Type\") ?? \"\";\n        if (s2.startsWith(\"application/json\") ? (r2 = await t.json(), typeof r2 == \"object\" && (i = \"data\" in r2 ? r2.data : r2)) : s2.startsWith(\"text\") ? r2 = await t.text() : r2 = t.body, this.refineData) try {\n          i = this.refineData(i);\n        } catch (o) {\n          console.warn(\"[FetchPromise] Error in refineData\", o), i = void 0;\n        }\n        return ud(t, r2, i);\n      }\n      then(e, t) {\n        return this.execute().then(e, t);\n      }\n      catch(e) {\n        return this.then(void 0, e);\n      }\n      finally(e) {\n        return this.then((t) => (e?.(), t), (t) => {\n          throw e?.(), t;\n        });\n      }\n      path() {\n        return new URL(this.request.url).pathname;\n      }\n      key(e) {\n        let t = new URL(this.request.url);\n        return e?.search !== false ? this.path() + t.search : this.path();\n      }\n      keyArray(e) {\n        let t = new URL(this.request.url), r2 = this.path().split(\"/\");\n        return (e?.search !== false ? [...r2, t.searchParams.toString()] : r2).filter(Boolean);\n      }\n      toString() {\n        return this.key({ search: true });\n      }\n      toJSON() {\n        return { url: this.request.url, method: this.request.method };\n      }\n    };\n    Wn$1 = class Wn extends Ce$1 {\n      static {\n        __name(this, \"Wn\");\n      }\n      getDefaultOptions() {\n        return { basepath: \"/api/auth\", credentials: \"include\" };\n      }\n      async login(e, t) {\n        let r2 = await this.post([e, \"login\"], t, { credentials: this.options.credentials });\n        return r2.ok && r2.body.token && await this.options.onTokenUpdate?.(r2.body.token), r2;\n      }\n      async register(e, t) {\n        let r2 = await this.post([e, \"register\"], t, { credentials: this.options.credentials });\n        return r2.ok && r2.body.token && await this.options.onTokenUpdate?.(r2.body.token), r2;\n      }\n      async actionSchema(e, t) {\n        return this.get([e, \"actions\", t, \"schema.json\"]);\n      }\n      async action(e, t, r2) {\n        return this.post([e, \"actions\", t], r2);\n      }\n      async loginWithPassword(e) {\n        return this.login(\"password\", e);\n      }\n      async registerWithPassword(e) {\n        return this.register(\"password\", e);\n      }\n      me() {\n        return this.get([\"me\"]);\n      }\n      strategies() {\n        return this.get([\"strategies\"]);\n      }\n      async logout() {\n        await this.options.onTokenUpdate?.(void 0);\n      }\n    };\n    Hn$1 = class Hn extends Ce$1 {\n      static {\n        __name(this, \"Hn\");\n      }\n      getDefaultOptions() {\n        return { basepath: \"/api/data\", queryLengthLimit: 1e3, defaultQuery: { limit: 10 } };\n      }\n      requireObjectSet(e, t) {\n        if (!e || typeof e != \"object\" || Object.keys(e).length === 0) throw new Error(t ?? \"object is required\");\n      }\n      readOne(e, t, r2 = {}) {\n        return this.get([\"entity\", e, t], r2);\n      }\n      readOneBy(e, t = {}) {\n        return this.readMany(e, { ...t, limit: 1, offset: 0 }).refine((r2) => r2[0]);\n      }\n      readMany(e, t = {}) {\n        let r2 = t ?? this.options.defaultQuery, i = this.get([\"entity\", e], r2);\n        return i.request.url.length <= this.options.queryLengthLimit ? i : this.post([\"entity\", e, \"query\"], r2);\n      }\n      readManyByReference(e, t, r2, i = {}) {\n        return this.get([\"entity\", e, t, r2], i ?? this.options.defaultQuery);\n      }\n      createOne(e, t) {\n        return this.post([\"entity\", e], t);\n      }\n      createMany(e, t) {\n        if (!t || !Array.isArray(t) || t.length === 0) throw new Error(\"input is required\");\n        return this.post([\"entity\", e], t);\n      }\n      updateOne(e, t, r2) {\n        if (!t) throw new Error(\"ID is required\");\n        return this.patch([\"entity\", e, t], r2);\n      }\n      updateMany(e, t, r2) {\n        return this.requireObjectSet(t), this.patch([\"entity\", e], { update: r2, where: t });\n      }\n      deleteOne(e, t) {\n        if (!t) throw new Error(\"ID is required\");\n        return this.delete([\"entity\", e, t]);\n      }\n      deleteMany(e, t) {\n        return this.requireObjectSet(t), this.delete([\"entity\", e], t);\n      }\n      count(e, t = {}) {\n        return this.post([\"entity\", e, \"fn\", \"count\"], t);\n      }\n      exists(e, t = {}) {\n        return this.post([\"entity\", e, \"fn\", \"exists\"], t);\n      }\n    };\n    Yn$2 = class Yn extends Ce$1 {\n      static {\n        __name(this, \"Yn\");\n      }\n      getDefaultOptions() {\n        return { basepath: \"/api/media\", upload_fetcher: fetch };\n      }\n      listFiles() {\n        return this.get([\"files\"]);\n      }\n      getFile(e) {\n        return this.get([\"file\", e], void 0, { headers: { Accept: \"*/*\" } });\n      }\n      async getFileStream(e) {\n        let { res: t } = await this.getFile(e);\n        if (!t.ok || !t.body) throw new Error(\"Failed to fetch file\");\n        return t.body;\n      }\n      async download(e) {\n        let { res: t } = await this.getFile(e);\n        if (!t.ok || !t.body) throw new Error(\"Failed to fetch file\");\n        return await t.blob();\n      }\n      getFileUploadUrl(e) {\n        return e ? this.getUrl(`/upload/${e.path}`) : this.getUrl(\"/upload\");\n      }\n      getEntityUploadUrl(e, t, r2) {\n        return this.getUrl(`/entity/${e}/${t}/${r2}`);\n      }\n      getUploadHeaders() {\n        return this.options.token_transport === \"header\" && this.options.token ? new Headers({ Authorization: `Bearer ${this.options.token}` }) : new Headers();\n      }\n      uploadFile(e, t) {\n        let r2 = { \"Content-Type\": \"application/octet-stream\", ...t?._init?.headers || {} }, i = t?.filename || \"\";\n        try {\n          typeof e.type < \"u\" && (r2[\"Content-Type\"] = e.type), t?.filename || (i = e.name);\n        } catch {\n        }\n        i && i.length > 0 && i.includes(\"/\") && (i = i.split(\"/\").pop() || \"\");\n        let s2 = { ...t?._init || {}, headers: r2 };\n        if (t?.path) return this.post(t.path, e, s2);\n        if (!i || i.length === 0) throw new Error(\"Invalid filename\");\n        return this.post(t?.path ?? [\"upload\", i], e, s2);\n      }\n      async upload(e, t = {}) {\n        if (e instanceof Request || typeof e == \"string\") {\n          let i = await (t.fetcher ?? this.options.upload_fetcher)(e);\n          if (!i.ok || !i.body) throw new Error(\"Failed to fetch file\");\n          return this.uploadFile(i.body, t);\n        } else if (e instanceof Response) {\n          if (!e.body) throw new Error(\"Invalid response\");\n          return this.uploadFile(e.body, { ...t ?? {}, _init: { ...t._init ?? {}, headers: { ...t._init?.headers ?? {}, \"Content-Type\": e.headers.get(\"Content-Type\") || \"application/octet-stream\" } } });\n        }\n        return this.uploadFile(e, t);\n      }\n      async uploadToEntity(e, t, r2, i, s2) {\n        return this.upload(i, { ...s2, path: [\"entity\", e, t, r2] });\n      }\n      deleteFile(e) {\n        return this.delete([\"file\", e]);\n      }\n    };\n    Xn$1 = class Xn extends Ce$1 {\n      static {\n        __name(this, \"Xn\");\n      }\n      getDefaultOptions() {\n        return { basepath: \"/api/system\" };\n      }\n      readConfig() {\n        return this.get(\"config\");\n      }\n      readSchema(e) {\n        return this.get(\"schema\", { config: e?.config ? 1 : 0, secrets: e?.secrets ? 1 : 0, fresh: e?.fresh ? 1 : 0 });\n      }\n      setConfig(e, t, r2) {\n        return this.post([\"config\", \"set\", e].join(\"/\") + `?force=${r2 ? 1 : 0}`, t);\n      }\n      addConfig(e, t, r2) {\n        return this.post([\"config\", \"add\", e, t], r2);\n      }\n      patchConfig(e, t, r2) {\n        return this.patch([\"config\", \"patch\", e, t], r2);\n      }\n      overwriteConfig(e, t, r2) {\n        return this.put([\"config\", \"overwrite\", e, t], r2);\n      }\n      removeConfig(e, t) {\n        return this.delete([\"config\", \"remove\", e, t]);\n      }\n    };\n    Pr = class {\n      static {\n        __name(this, \"Pr\");\n      }\n      constructor(e = {}) {\n        this.options = e;\n        this.verified = e.verified === true, \"request\" in e && e.request ? (this.options.host = e.host ?? new URL(e.request.url).origin, this.options.headers = e.headers ?? e.request.headers, this.extractToken()) : \"token\" in e && e.token ? (this.token_transport = \"header\", this.updateToken(e.token, { trigger: false })) : \"user\" in e && e.user ? (this.token_transport = \"none\", this.user = e.user, this.verified = e.verified !== false) : this.extractToken(), this.buildApis();\n      }\n      token;\n      user;\n      verified = false;\n      token_transport = \"header\";\n      system;\n      data;\n      auth;\n      media;\n      get fetcher() {\n        return this.options.fetcher ?? fetch;\n      }\n      get baseUrl() {\n        return this.options.host ?? \"http://localhost\";\n      }\n      get tokenKey() {\n        return this.options.key ?? \"auth\";\n      }\n      extractToken() {\n        if (this.verified = false, this.options.headers) {\n          let e = md(this.options.headers.get(\"cookie\"), \"auth\");\n          if (e) {\n            this.token_transport = \"cookie\", this.updateToken(e);\n            return;\n          }\n          let t = this.options.headers.get(\"authorization\")?.replace(\"Bearer \", \"\");\n          if (t) {\n            this.token_transport = \"header\", this.updateToken(t);\n            return;\n          }\n        } else this.storage && this.storage.getItem(this.tokenKey).then((e) => {\n          this.token_transport = \"header\", this.updateToken(e ? String(e) : void 0);\n        });\n      }\n      get storage() {\n        return this.options.storage ? { getItem: /* @__PURE__ */ __name(async (e) => await this.options.storage.getItem(e), \"getItem\"), setItem: /* @__PURE__ */ __name(async (e, t) => await this.options.storage.setItem(e, t), \"setItem\"), removeItem: /* @__PURE__ */ __name(async (e) => await this.options.storage.removeItem(e), \"removeItem\") } : null;\n      }\n      updateToken(e, t) {\n        if (this.token = e, this.verified = false, e ? this.user = Nr$1(decode(e).payload, [\"iat\", \"iss\", \"exp\"]) : this.user = void 0, this.storage) {\n          let r2 = this.tokenKey;\n          e ? this.storage.setItem(r2, e).then(() => {\n            this.options.onAuthStateChange?.(this.getAuthState());\n          }) : this.storage.removeItem(r2).then(() => {\n            this.options.onAuthStateChange?.(this.getAuthState());\n          });\n        } else t?.trigger !== false && this.options.onAuthStateChange?.(this.getAuthState());\n        t?.rebuild && this.buildApis();\n      }\n      markAuthVerified(e) {\n        return this.verified = e, this;\n      }\n      isAuthVerified() {\n        return this.verified;\n      }\n      getAuthState() {\n        return { token: this.token, user: this.user, verified: this.verified };\n      }\n      isAuthenticated() {\n        let { token: e, user: t } = this.getAuthState();\n        return !!e && !!t;\n      }\n      async getVerifiedAuthState() {\n        return await this.verifyAuth(), this.getAuthState();\n      }\n      async verifyAuth() {\n        if (!this.token) {\n          this.markAuthVerified(false);\n          return;\n        }\n        try {\n          let { ok: e, data: t } = await this.auth.me(), r2 = t?.user;\n          if (!e || !r2) throw new Error();\n          this.user = r2, this.markAuthVerified(true);\n        } catch {\n          this.markAuthVerified(false), this.updateToken(void 0);\n        }\n      }\n      getUser() {\n        return this.user || null;\n      }\n      getParams() {\n        return Object.freeze({ host: this.baseUrl, token: this.token, headers: this.options.headers, token_transport: this.token_transport, verbose: this.options.verbose });\n      }\n      buildApis() {\n        let e = this.getParams(), t = this.options.fetcher;\n        this.system = new Xn$1(e, t), this.data = new Hn$1({ ...e, ...this.options.data }, t), this.auth = new Wn$1({ ...e, credentials: this.options.storage ? \"omit\" : \"include\", ...this.options.auth, onTokenUpdate: /* @__PURE__ */ __name((r2) => {\n          this.updateToken(r2, { rebuild: true }), this.options.auth?.onTokenUpdate?.(r2);\n        }, \"onTokenUpdate\") }, t), this.media = new Yn$2({ ...e, ...this.options.media }, t);\n      }\n    };\n    __name(md, \"md\");\n    vt = class extends M$3 {\n      static {\n        __name(this, \"vt\");\n      }\n    };\n    Zn$1 = class Zn extends vt {\n      static {\n        __name(this, \"Zn\");\n      }\n      static slug = \"app-config-updated\";\n    };\n    ei$1 = class ei extends vt {\n      static {\n        __name(this, \"ei\");\n      }\n      static slug = \"app-built\";\n    };\n    ti$1 = class ti extends vt {\n      static {\n        __name(this, \"ti\");\n      }\n      static slug = \"app-first-boot\";\n    };\n    ri$1 = class ri extends vt {\n      static {\n        __name(this, \"ri\");\n      }\n      static slug = \"app-request\";\n    };\n    ni$1 = class ni extends vt {\n      static {\n        __name(this, \"ni\");\n      }\n      static slug = \"app-before-response\";\n    };\n    Ns = { AppConfigUpdatedEvent: Zn$1, AppBuiltEvent: ei$1, AppFirstBoot: ti$1, AppRequest: ri$1, AppBeforeResponse: ni$1 };\n    ii$1 = class ii {\n      static {\n        __name(this, \"ii\");\n      }\n      constructor(e, t, r2) {\n        this.connection = e;\n        this.options = r2;\n        this.plugins = r2?.plugins ?? [], this.modules = new zn$1(e, { ...r2?.manager ?? {}, initial: t, onUpdated: this.onUpdated.bind(this), onFirstBoot: this.onFirstBoot.bind(this), onServerInit: this.onServerInit.bind(this) }), this.modules.ctx().emgr.registerEvents(Ns);\n      }\n      static Events = Ns;\n      modules;\n      adminController;\n      _id = crypto.randomUUID();\n      trigger_first_boot = false;\n      plugins;\n      _building = false;\n      get emgr() {\n        return this.modules.ctx().emgr;\n      }\n      async build(e) {\n        if (this._building) {\n          for (; this._building; ) await new Promise((i) => setTimeout(i, 10));\n          if (!e?.forceBuild) return;\n        }\n        this._building = true, e?.sync && (this.modules.ctx().flags.sync_required = true), await this.modules.build({ fetch: e?.fetch });\n        let { guard: t, server: r2 } = this.modules.ctx();\n        t.registerPermissions(Object.values(Ht$1)), r2.route(\"/api/system\", new Vn$1(this).getController()), this.plugins.length > 0 && await Promise.all(this.plugins.map((i) => i(this))), m$1.log(\"App built\"), await this.emgr.emit(new ei$1({ app: this })), this.trigger_first_boot && (this.trigger_first_boot = false, await this.emgr.emit(new ti$1({ app: this })), await this.options?.seed?.({ ...this.modules.ctx(), app: this })), this._building = false;\n      }\n      mutateConfig(e) {\n        return this.modules.mutateConfigSafe(e);\n      }\n      get server() {\n        return this.modules.server;\n      }\n      get em() {\n        return this.modules.ctx().em;\n      }\n      get fetch() {\n        return this.server.fetch;\n      }\n      get module() {\n        return new Proxy({}, { get: /* @__PURE__ */ __name((e, t) => this.modules.get(t), \"get\") });\n      }\n      getSchema() {\n        return this.modules.getSchema();\n      }\n      version() {\n        return this.modules.version();\n      }\n      isBuilt() {\n        return this.modules.isBuilt();\n      }\n      registerAdminController(e) {\n        return this.adminController = new Gn$1(this, e), this.modules.server.route(this.adminController.basepath, this.adminController.getController()), this;\n      }\n      toJSON(e) {\n        return this.modules.toJSON(e);\n      }\n      static create(e) {\n        return Ca(e);\n      }\n      async createUser(e) {\n        return this.module.auth.createUser(e);\n      }\n      getApi(e) {\n        let t = this.server.request;\n        return e && e instanceof Request ? new Pr({ request: e, headers: e.headers, fetcher: t }) : new Pr({ host: \"http://localhost\", ...e ?? {}, fetcher: t });\n      }\n      async onUpdated(e, t) {\n        if (!this.emgr.enabled) {\n          m$1.warn(\"App config updated, but event manager is disabled, skip.\");\n          return;\n        }\n        m$1.log(\"App config updated\", e), await this.build({ sync: true }), await this.emgr.emit(new Zn$1({ app: this }));\n      }\n      async onFirstBoot() {\n        m$1.log(\"App first boot\"), this.trigger_first_boot = true;\n      }\n      async onServerInit(e) {\n        e.use(async (t, r2) => {\n          t.set(\"app\", this), await this.emgr.emit(new ri$1({ app: this, request: t.req.raw })), await r2();\n          try {\n            t.res.headers.set(\"X-bknd-id\", this._id);\n          } catch {\n          }\n          switch (await this.emgr.emit(new ni$1({ app: this, request: t.req.raw, response: t.res })), this.options?.asyncEventsMode ?? \"async\") {\n            case \"sync\":\n              await this.emgr.executeAsyncs();\n              break;\n            case \"async\":\n              this.emgr.executeAsyncs();\n              break;\n          }\n        }), this.options?.manager?.onServerInit && this.options.manager.onServerInit(e);\n      }\n    };\n    __name(Ca, \"Ca\");\n    __name(d$2, \"d$2\");\n    a$1 = /* @__PURE__ */ new Map();\n    __name(s$1, \"s$1\");\n    __name(C$1, \"C$1\");\n    __vite_import_meta_env__2 = { \"ASSETS_PREFIX\": void 0, \"BASE_URL\": \"/\", \"DEV\": false, \"MODE\": \"production\", \"PROD\": true, \"SITE\": void 0, \"SSR\": true };\n    __name(s, \"s\");\n    __name(v$3, \"v$3\");\n    ue$1 = Object.create;\n    V$1 = Object.defineProperty;\n    ye$2 = Object.getOwnPropertyDescriptor;\n    pe$2 = Object.getOwnPropertyNames;\n    me$2 = Object.getPrototypeOf;\n    de$1 = Object.prototype.hasOwnProperty;\n    Te$2 = /* @__PURE__ */ __name((e2, r2) => () => (r2 || e2((r2 = { exports: {} }).exports, r2), r2.exports), \"Te$2\");\n    ge$1 = /* @__PURE__ */ __name((e2, r2, n27, t) => {\n      if (r2 && typeof r2 == \"object\" || typeof r2 == \"function\") for (let o of pe$2(r2)) !de$1.call(e2, o) && o !== n27 && V$1(e2, o, { get: /* @__PURE__ */ __name(() => r2[o], \"get\"), enumerable: !(t = ye$2(r2, o)) || t.enumerable });\n      return e2;\n    }, \"ge$1\");\n    xe$2 = /* @__PURE__ */ __name((e2, r2, n27) => (n27 = e2 != null ? ue$1(me$2(e2)) : {}, ge$1(V$1(n27, \"default\", { value: e2, enumerable: true }), e2)), \"xe$2\");\n    re$2 = Te$2((Hr2, P3) => {\n      var c = String, ee2 = /* @__PURE__ */ __name(function() {\n        return { isColorSupported: false, reset: c, bold: c, dim: c, italic: c, underline: c, inverse: c, hidden: c, strikethrough: c, black: c, red: c, green: c, yellow: c, blue: c, magenta: c, cyan: c, white: c, gray: c, bgBlack: c, bgRed: c, bgGreen: c, bgYellow: c, bgBlue: c, bgMagenta: c, bgCyan: c, bgWhite: c, blackBright: c, redBright: c, greenBright: c, yellowBright: c, blueBright: c, magentaBright: c, cyanBright: c, whiteBright: c, bgBlackBright: c, bgRedBright: c, bgGreenBright: c, bgYellowBright: c, bgBlueBright: c, bgMagentaBright: c, bgCyanBright: c, bgWhiteBright: c };\n      }, \"ee\");\n      P3.exports = ee2();\n      P3.exports.createColors = ee2;\n    });\n    y$2 = xe$2(re$2());\n    Ne$1 = ((i) => (i[i.CONTINUE = 100] = \"CONTINUE\", i[i.PROCESSING = 102] = \"PROCESSING\", i[i.EARLY_HINTS = 103] = \"EARLY_HINTS\", i[i.OK = 200] = \"OK\", i[i.CREATED = 201] = \"CREATED\", i[i.ACCEPTED = 202] = \"ACCEPTED\", i[i.NON_AUTHORITATIVE_INFORMATION = 203] = \"NON_AUTHORITATIVE_INFORMATION\", i[i.PARTIAL_CONTENT = 206] = \"PARTIAL_CONTENT\", i[i.MULTI_STATUS = 207] = \"MULTI_STATUS\", i[i.ALREADY_REPORTED = 208] = \"ALREADY_REPORTED\", i[i.IM_USED = 226] = \"IM_USED\", i[i.MULTIPLE_CHOICES = 300] = \"MULTIPLE_CHOICES\", i[i.MOVED_PERMANENTLY = 301] = \"MOVED_PERMANENTLY\", i[i.FOUND = 302] = \"FOUND\", i[i.SEE_OTHER = 303] = \"SEE_OTHER\", i[i.USE_PROXY = 305] = \"USE_PROXY\", i[i.TEMPORARY_REDIRECT = 307] = \"TEMPORARY_REDIRECT\", i[i.PERMANENT_REDIRECT = 308] = \"PERMANENT_REDIRECT\", i[i.BAD_REQUEST = 400] = \"BAD_REQUEST\", i[i.UNAUTHORIZED = 401] = \"UNAUTHORIZED\", i[i.PAYMENT_REQUIRED = 402] = \"PAYMENT_REQUIRED\", i[i.FORBIDDEN = 403] = \"FORBIDDEN\", i[i.NOT_FOUND = 404] = \"NOT_FOUND\", i[i.METHOD_NOT_ALLOWED = 405] = \"METHOD_NOT_ALLOWED\", i[i.NOT_ACCEPTABLE = 406] = \"NOT_ACCEPTABLE\", i[i.PROXY_AUTHENTICATION_REQUIRED = 407] = \"PROXY_AUTHENTICATION_REQUIRED\", i[i.REQUEST_TIMEOUT = 408] = \"REQUEST_TIMEOUT\", i[i.CONFLICT = 409] = \"CONFLICT\", i[i.GONE = 410] = \"GONE\", i[i.LENGTH_REQUIRED = 411] = \"LENGTH_REQUIRED\", i[i.PRECONDITION_FAILED = 412] = \"PRECONDITION_FAILED\", i[i.PAYLOAD_TOO_LARGE = 413] = \"PAYLOAD_TOO_LARGE\", i[i.URI_TOO_LONG = 414] = \"URI_TOO_LONG\", i[i.UNSUPPORTED_MEDIA_TYPE = 415] = \"UNSUPPORTED_MEDIA_TYPE\", i[i.RANGE_NOT_SATISFIABLE = 416] = \"RANGE_NOT_SATISFIABLE\", i[i.EXPECTATION_FAILED = 417] = \"EXPECTATION_FAILED\", i[i.IM_A_TEAPOT = 418] = \"IM_A_TEAPOT\", i[i.MISDIRECTED_REQUEST = 421] = \"MISDIRECTED_REQUEST\", i[i.UNPROCESSABLE_ENTITY = 422] = \"UNPROCESSABLE_ENTITY\", i[i.LOCKED = 423] = \"LOCKED\", i[i.FAILED_DEPENDENCY = 424] = \"FAILED_DEPENDENCY\", i[i.TOO_EARLY = 425] = \"TOO_EARLY\", i[i.UPGRADE_REQUIRED = 426] = \"UPGRADE_REQUIRED\", i[i.PRECONDITION_REQUIRED = 428] = \"PRECONDITION_REQUIRED\", i[i.TOO_MANY_REQUESTS = 429] = \"TOO_MANY_REQUESTS\", i[i.REQUEST_HEADER_FIELDS_TOO_LARGE = 431] = \"REQUEST_HEADER_FIELDS_TOO_LARGE\", i[i.UNAVAILABLE_FOR_LEGAL_REASONS = 451] = \"UNAVAILABLE_FOR_LEGAL_REASONS\", i[i.INTERNAL_SERVER_ERROR = 500] = \"INTERNAL_SERVER_ERROR\", i[i.NOT_IMPLEMENTED = 501] = \"NOT_IMPLEMENTED\", i[i.BAD_GATEWAY = 502] = \"BAD_GATEWAY\", i[i.SERVICE_UNAVAILABLE = 503] = \"SERVICE_UNAVAILABLE\", i[i.GATEWAY_TIMEOUT = 504] = \"GATEWAY_TIMEOUT\", i[i.HTTP_VERSION_NOT_SUPPORTED = 505] = \"HTTP_VERSION_NOT_SUPPORTED\", i[i.VARIANT_ALSO_NEGOTIATES = 506] = \"VARIANT_ALSO_NEGOTIATES\", i[i.INSUFFICIENT_STORAGE = 507] = \"INSUFFICIENT_STORAGE\", i[i.LOOP_DETECTED = 508] = \"LOOP_DETECTED\", i[i.NOT_EXTENDED = 510] = \"NOT_EXTENDED\", i[i.NETWORK_AUTHENTICATION_REQUIRED = 511] = \"NETWORK_AUTHENTICATION_REQUIRED\", i))(Ne$1 || {});\n    je$2 = ((o) => (o[o.SWITCHING_PROTOCOLS = 101] = \"SWITCHING_PROTOCOLS\", o[o.NO_CONTENT = 204] = \"NO_CONTENT\", o[o.RESET_CONTENT = 205] = \"RESET_CONTENT\", o[o.NOT_MODIFIED = 304] = \"NOT_MODIFIED\", o))(je$2 || {});\n    ne2 = /* @__PURE__ */ __name((e2, r2) => typeof e2 == \"string\" ? [1, \"1\", \"true\"].includes(e2) : !!(e2 || r2), \"ne\");\n    Pe = { cli_log_level: { key: \"BKND_CLI_LOG_LEVEL\", validate: /* @__PURE__ */ __name((e2) => {\n      if (typeof e2 == \"string\" && [\"log\", \"info\", \"warn\", \"error\", \"debug\"].includes(e2.toLowerCase())) return e2.toLowerCase();\n    }, \"validate\") }, cli_create_ref: { key: \"BKND_CLI_CREATE_REF\", validate: /* @__PURE__ */ __name((e2) => typeof e2 == \"string\" ? e2 : void 0, \"validate\") }, cli_telemetry: { key: \"BKND_CLI_TELEMETRY\", validate: /* @__PURE__ */ __name((e2) => {\n      if (!(typeof e2 > \"u\")) return ne2(e2, true);\n    }, \"validate\") }, modules_debug: { key: \"BKND_MODULES_DEBUG\", validate: ne2 } };\n    D$3 = /* @__PURE__ */ __name((e2, r2, n27) => {\n      try {\n        let t = n27?.source ?? process.env, o = Pe[e2], s2 = t[o.key], f2 = o.validate(s2);\n        if (typeof f2 < \"u\") return n27?.onValid?.(f2), f2;\n        n27?.onFallback?.(s2);\n      } catch {\n      }\n      return r2;\n    }, \"D$3\");\n    __name(Ue$1, \"Ue$1\");\n    U$2 = { critical: { prefix: \"CRT\", color: y$2.default.red, args_color: y$2.default.red, original: console.error }, error: { prefix: \"ERR\", color: y$2.default.red, args_color: y$2.default.red, original: console.error }, warn: { prefix: \"WRN\", color: y$2.default.yellow, args_color: y$2.default.yellow, original: console.warn }, info: { prefix: \"INF\", color: y$2.default.cyan, original: console.info }, log: { prefix: \"LOG\", color: y$2.default.dim, args_color: y$2.default.dim, original: console.log }, debug: { prefix: \"DBG\", color: y$2.default.yellow, args_color: y$2.default.dim, original: console.debug } };\n    __name(ve$2, \"ve$2\");\n    oe$2 = D$3(\"cli_log_level\", \"log\");\n    h$2 = globalThis.__consoleConfig ??= { level: oe$2 };\n    te$2 = Object.keys(U$2);\n    new Proxy(h$2, { get: /* @__PURE__ */ __name((e2, r2) => {\n      switch (r2) {\n        case \"original\":\n          return console;\n        case \"setLevel\":\n          return (o) => {\n            h$2.level = o;\n          };\n        case \"resetLevel\":\n          return () => {\n            h$2.level = oe$2;\n          };\n      }\n      let n27 = te$2.indexOf(h$2.level), t = te$2.indexOf(r2);\n      return r2 in U$2 && t <= n27 ? (...o) => ve$2(r2, o) : () => null;\n    }, \"get\") });\n    __name(E$2, \"E$2\");\n    __name(A$3, \"A$3\");\n    L$3 = Symbol(\"tb-parse-validation\");\n    w$3 = class w extends Error {\n      static {\n        __name(this, \"w\");\n      }\n      constructor(n27, t, o) {\n        super(o ?? `Invalid: ${JSON.stringify(t)}`);\n        this.schema = n27;\n        this.data = t;\n        this.errors = [...Errors(n27, t)];\n      }\n      errors;\n      first() {\n        return this.errors[0];\n      }\n      firstToString() {\n        let n27 = this.first();\n        return `${n27.message} at \"${n27.path}\"`;\n      }\n      toJSON() {\n        return { message: this.message, schema: this.schema, data: this.data, errors: this.errors };\n      }\n    };\n    __name(B$3, \"B$3\");\n    __name(qe$1, \"qe$1\");\n    __name(We$2, \"We$2\");\n    We$2(type$1);\n    Type.String({ pattern: \"^[a-zA-Z_][a-zA-Z0-9_]*$\", minLength: 2, maxLength: 150 });\n    SetErrorFunction((e2) => e2?.schema?.errorMessage ? e2.schema.errorMessage : e2?.schema?.[Kind] === \"StringEnum\" ? `Expected: ${e2.schema.enum.map((r2) => `\"${r2}\"`).join(\", \")}` : DefaultErrorFunction(e2));\n    ze$2.extend(Pr$1);\n    __name(ie$1, \"ie$1\");\n    __name(Yn$1, \"Yn$1\");\n    Te$1 = Object.create;\n    U$1 = Object.defineProperty;\n    we$1 = Object.getOwnPropertyDescriptor;\n    Oe$1 = Object.getOwnPropertyNames;\n    ve$1 = Object.getPrototypeOf;\n    Ae$1 = Object.prototype.hasOwnProperty;\n    Re$1 = /* @__PURE__ */ __name((r2, e) => () => (e || r2((e = { exports: {} }).exports, e), e.exports), \"Re$1\");\n    X$2 = /* @__PURE__ */ __name((r2, e) => {\n      for (var t in e) U$1(r2, t, { get: e[t], enumerable: true });\n    }, \"X$2\");\n    Ce2 = /* @__PURE__ */ __name((r2, e, t, n27) => {\n      if (e && typeof e == \"object\" || typeof e == \"function\") for (let s2 of Oe$1(e)) !Ae$1.call(r2, s2) && s2 !== t && U$1(r2, s2, { get: /* @__PURE__ */ __name(() => e[s2], \"get\"), enumerable: !(n27 = we$1(e, s2)) || n27.enumerable });\n      return r2;\n    }, \"Ce\");\n    _e$1 = /* @__PURE__ */ __name((r2, e, t) => (t = r2 != null ? Te$1(ve$1(r2)) : {}, Ce2(U$1(t, \"default\", { value: r2, enumerable: true }), r2)), \"_e$1\");\n    oe$1 = Re$1((ut3, V3) => {\n      var c = String, ie2 = /* @__PURE__ */ __name(function() {\n        return { isColorSupported: false, reset: c, bold: c, dim: c, italic: c, underline: c, inverse: c, hidden: c, strikethrough: c, black: c, red: c, green: c, yellow: c, blue: c, magenta: c, cyan: c, white: c, gray: c, bgBlack: c, bgRed: c, bgGreen: c, bgYellow: c, bgBlue: c, bgMagenta: c, bgCyan: c, bgWhite: c, blackBright: c, redBright: c, greenBright: c, yellowBright: c, blueBright: c, magentaBright: c, cyanBright: c, whiteBright: c, bgBlackBright: c, bgRedBright: c, bgGreenBright: c, bgYellowBright: c, bgBlueBright: c, bgMagentaBright: c, bgCyanBright: c, bgWhiteBright: c };\n      }, \"ie\");\n      V3.exports = ie2();\n      V3.exports.createColors = ie2;\n    });\n    __name(je$1, \"je$1\");\n    __name(H$2, \"H$2\");\n    __name(ee$1, \"ee$1\");\n    S$1 = /* @__PURE__ */ __name((r2, e) => typeof r2 == \"string\" ? [1, \"1\", \"true\"].includes(r2) : !!(r2 || e), \"S$1\");\n    __name(M$2, \"M$2\");\n    ke$1 = { cli_log_level: { key: \"BKND_CLI_LOG_LEVEL\", validate: /* @__PURE__ */ __name((r2) => {\n      if (typeof r2 == \"string\" && [\"log\", \"info\", \"warn\", \"error\", \"debug\"].includes(r2.toLowerCase())) return r2.toLowerCase();\n    }, \"validate\") }, cli_create_ref: { key: \"BKND_CLI_CREATE_REF\", validate: /* @__PURE__ */ __name((r2) => typeof r2 == \"string\" ? r2 : void 0, \"validate\") }, cli_telemetry: { key: \"BKND_CLI_TELEMETRY\", validate: /* @__PURE__ */ __name((r2) => {\n      if (!(typeof r2 > \"u\")) return S$1(r2, true);\n    }, \"validate\") }, modules_debug: { key: \"BKND_MODULES_DEBUG\", validate: S$1 } };\n    B$2 = /* @__PURE__ */ __name((r2, e, t) => {\n      try {\n        let n27 = t?.source ?? process.env, s2 = ke$1[r2], i = n27[s2.key], o = s2.validate(i);\n        if (typeof o < \"u\") return t?.onValid?.(o), o;\n        t?.onFallback?.(i);\n      } catch {\n      }\n      return e;\n    }, \"B$2\");\n    __name(te$1, \"te$1\");\n    __name(P$2, \"P$2\");\n    __name(re$1, \"re$1\");\n    A$2 = class A extends AwsClient {\n      static {\n        __name(this, \"A\");\n      }\n      #e;\n      constructor(e, t) {\n        super(e), this.#e = t ?? { responseType: \"json\" };\n      }\n      convertParams(e) {\n        switch (this.#e.convertParams) {\n          case \"pascalToKebab\":\n            return P$2(e);\n          default:\n            return e;\n        }\n      }\n      getUrl(e = \"/\", t = {}) {\n        let n27 = new URL(e), s2 = this.convertParams(t);\n        return Object.entries(s2).forEach(([i, o]) => {\n          n27.searchParams.append(i, o);\n        }), n27.toString();\n      }\n      updateKeysRecursively(e, t) {\n        return e == null ? e : Array.isArray(e) ? e.map((n27) => this.updateKeysRecursively(n27, t)) : typeof e == \"object\" ? Object.keys(e).reduce((n27, s2) => {\n          let i = s2;\n          return s2.indexOf(\" \") === -1 && (i = s2.charAt(0)[t]() + s2.slice(1)), n27[i] = this.updateKeysRecursively(e[s2], t), n27;\n        }, {}) : e;\n      }\n      async fetchJson(e, t) {\n        let n27 = await this.fetch(e, t);\n        if (this.#e.responseType === \"xml\") {\n          if (!n27.ok) {\n            let o = await n27.text();\n            throw new Error(o);\n          }\n          let i = await n27.text();\n          return re$1(i);\n        }\n        if (!n27.ok) {\n          let i = await n27.json();\n          throw new Error(i.message);\n        }\n        let s2 = await n27.json();\n        return this.#e.responseKeysToUpper ? this.updateKeysRecursively(s2, \"toUpperCase\") : s2;\n      }\n    };\n    $$2 = { video: [\"mp4\", \"webm\"], audio: [\"ogg\"], image: [\"jpeg\", \"png\", \"gif\", \"webp\", \"bmp\", \"tiff\", \"avif\", \"heic\", \"heif\"], text: [\"html\", \"css\", \"mdx\", \"yaml\", \"vcard\", \"csv\", \"vtt\"], application: [\"zip\", \"xml\", \"toml\", \"json\", \"json5\"], font: [\"woff\", \"woff2\", \"ttf\", \"otf\"] };\n    l$1 = { vnd: \"vnd.openxmlformats-officedocument\", z: \"application/x-7z-compressed\", t: /* @__PURE__ */ __name((r2 = \"plain\") => `text/${r2}`, \"t\"), a: /* @__PURE__ */ __name((r2 = \"octet-stream\") => `application/${r2}`, \"a\"), i: /* @__PURE__ */ __name((r2) => `image/${r2}`, \"i\"), v: /* @__PURE__ */ __name((r2) => `video/${r2}`, \"v\") };\n    z$1 = /* @__PURE__ */ new Map([[\"7z\", l$1.z], [\"7zip\", l$1.z], [\"ai\", l$1.a(\"pdf\")], [\"apk\", l$1.a(\"vnd.android.package-archive\")], [\"doc\", l$1.a(\"msword\")], [\"docx\", `${l$1.vnd}.wordprocessingml.document`], [\"eps\", l$1.a(\"postscript\")], [\"epub\", l$1.a(\"epub+zip\")], [\"ini\", l$1.t()], [\"jar\", l$1.a(\"java-archive\")], [\"jsonld\", l$1.a(\"ld+json\")], [\"jpg\", l$1.i(\"jpeg\")], [\"log\", l$1.t()], [\"m3u\", l$1.t()], [\"m3u8\", l$1.a(\"vnd.apple.mpegurl\")], [\"manifest\", l$1.t(\"cache-manifest\")], [\"md\", l$1.t(\"markdown\")], [\"mkv\", l$1.v(\"x-matroska\")], [\"mp3\", l$1.a(\"mpeg\")], [\"mobi\", l$1.a(\"x-mobipocket-ebook\")], [\"ppt\", l$1.a(\"powerpoint\")], [\"pptx\", `${l$1.vnd}.presentationml.presentation`], [\"qt\", l$1.v(\"quicktime\")], [\"svg\", l$1.i(\"svg+xml\")], [\"tif\", l$1.i(\"tiff\")], [\"tsv\", l$1.t(\"tab-separated-values\")], [\"tgz\", l$1.a(\"x-tar\")], [\"txt\", l$1.t()], [\"text\", l$1.t()], [\"vcd\", l$1.a(\"x-cdlink\")], [\"vcs\", l$1.t(\"x-vcalendar\")], [\"wav\", l$1.a(\"x-wav\")], [\"webmanifest\", l$1.a(\"manifest+json\")], [\"xls\", l$1.a(\"vnd.ms-excel\")], [\"xlsx\", `${l$1.vnd}.spreadsheetml.sheet`], [\"yml\", l$1.t(\"yaml\")]]);\n    __name(Le$1, \"Le$1\");\n    d$1 = _e$1(oe$1());\n    __name(Ie$1, \"Ie$1\");\n    q$1 = { critical: { prefix: \"CRT\", color: d$1.default.red, args_color: d$1.default.red, original: console.error }, error: { prefix: \"ERR\", color: d$1.default.red, args_color: d$1.default.red, original: console.error }, warn: { prefix: \"WRN\", color: d$1.default.yellow, args_color: d$1.default.yellow, original: console.warn }, info: { prefix: \"INF\", color: d$1.default.cyan, original: console.info }, log: { prefix: \"LOG\", color: d$1.default.dim, args_color: d$1.default.dim, original: console.log }, debug: { prefix: \"DBG\", color: d$1.default.yellow, args_color: d$1.default.dim, original: console.debug } };\n    __name(Ne, \"Ne\");\n    ce$1 = B$2(\"cli_log_level\", \"log\");\n    F$2 = globalThis.__consoleConfig ??= { level: ce$1 };\n    ae$1 = Object.keys(q$1);\n    new Proxy(F$2, { get: /* @__PURE__ */ __name((r2, e) => {\n      switch (e) {\n        case \"original\":\n          return console;\n        case \"setLevel\":\n          return (s2) => {\n            F$2.level = s2;\n          };\n        case \"resetLevel\":\n          return () => {\n            F$2.level = ce$1;\n          };\n      }\n      let t = ae$1.indexOf(F$2.level), n27 = ae$1.indexOf(e);\n      return e in q$1 && n27 <= t ? (...s2) => Ne(e, s2) : () => null;\n    }, \"get\") });\n    __name(De$1, \"De$1\");\n    __name(m, \"m\");\n    G$1 = Symbol(\"tb-parse-validation\");\n    Y$1 = class Y extends Error {\n      static {\n        __name(this, \"Y\");\n      }\n      constructor(t, n27, s2) {\n        super(s2 ?? `Invalid: ${JSON.stringify(n27)}`);\n        this.schema = t;\n        this.data = n27;\n        this.errors = [...Errors(t, n27)];\n      }\n      errors;\n      first() {\n        return this.errors[0];\n      }\n      firstToString() {\n        let t = this.first();\n        return `${t.message} at \"${t.path}\"`;\n      }\n      toJSON() {\n        return { message: this.message, schema: this.schema, data: this.data, errors: this.errors };\n      }\n    };\n    __name(pe$1, \"pe$1\");\n    __name(L$2, \"L$2\");\n    __name(Be$1, \"Be$1\");\n    Be$1(type$1);\n    Type.String({ pattern: \"^[a-zA-Z_][a-zA-Z0-9_]*$\", minLength: 2, maxLength: 150 });\n    SetErrorFunction((r2) => r2?.schema?.errorMessage ? r2.schema.errorMessage : r2?.schema?.[Kind] === \"StringEnum\" ? `Expected: ${r2.schema.enum.map((e) => `\"${e}\"`).join(\", \")}` : DefaultErrorFunction(r2));\n    ze$2.extend(Pr$1);\n    __name(le$1, \"le$1\");\n    ze = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n    __name(me$1, \"me$1\");\n    ye$1 = { sha256: /* @__PURE__ */ __name(async (r2, e, t) => me$1(\"SHA-256\", r2, e, t), \"sha256\"), sha1: /* @__PURE__ */ __name(async (r2, e, t) => me$1(\"SHA-1\", r2, e, t), \"sha1\") };\n    u$1 = class u {\n      static {\n        __name(this, \"u\");\n      }\n      constructor(e) {\n        this.name = e;\n        this.name = e;\n      }\n      toJSON() {\n        return { name: this.name };\n      }\n    };\n    R$1 = class R2 {\n      static {\n        __name(this, \"R\");\n      }\n      constructor(e) {\n        this.registerFn = e;\n      }\n      is_set = false;\n      items = {};\n      set(e) {\n        if (this.is_set) throw new Error(\"Registry is already set\");\n        return this.items = e, this.is_set = true, this;\n      }\n      add(e, t) {\n        return this.items[e] = t, this;\n      }\n      register(e, t) {\n        if (this.registerFn) {\n          let n27 = this.registerFn(t);\n          return this.items[e] = n27, this;\n        }\n        return this.add(e, t);\n      }\n      get(e) {\n        return this.items[e];\n      }\n      has(e) {\n        return e in this.items;\n      }\n      all() {\n        return this.items;\n      }\n    };\n    y$1 = class y {\n      static {\n        __name(this, \"y\");\n      }\n      _returning;\n      static slug = \"untitled-event\";\n      params;\n      returned = false;\n      validate(e) {\n        throw new W$2(this, e);\n      }\n      clone(e) {\n        let t = new this.constructor(e);\n        return t.returned = true, t;\n      }\n      constructor(e) {\n        this.params = e;\n      }\n    };\n    h$1 = class h extends Error {\n      static {\n        __name(this, \"h\");\n      }\n      constructor(e, t) {\n        super(`Expected \"${e}\", got \"${t}\"`);\n      }\n    };\n    W$2 = class W extends Error {\n      static {\n        __name(this, \"W\");\n      }\n      constructor(t, n27) {\n        super(`Event \"${t.constructor.slug}\" returned without validation`);\n        this.data = n27;\n      }\n    };\n    N$2 = {};\n    X$2(N$2, { FileAccessEvent: /* @__PURE__ */ __name(() => J$1, \"FileAccessEvent\"), FileDeletedEvent: /* @__PURE__ */ __name(() => j$2, \"FileDeletedEvent\"), FileUploadedEvent: /* @__PURE__ */ __name(() => _$1, \"FileUploadedEvent\") });\n    _$1 = class _ extends y$1 {\n      static {\n        __name(this, \"_\");\n      }\n      static slug = \"file-uploaded\";\n      validate(e) {\n        if (typeof e != \"object\") throw new h$1(\"object\", typeof e);\n        return this.clone({ ...e, ...this.params });\n      }\n    };\n    j$2 = class j extends y$1 {\n      static {\n        __name(this, \"j\");\n      }\n      static slug = \"file-deleted\";\n    };\n    J$1 = class J extends y$1 {\n      static {\n        __name(this, \"J\");\n      }\n      static slug = \"file-access\";\n    };\n    he$1 = Symbol.for(\"bknd:storage\");\n    b$2 = class b {\n      static {\n        __name(this, \"b\");\n      }\n      constructor() {\n        this[he$1] = true;\n      }\n      static isAdapter(e) {\n        return e ? e[he$1] === true : false;\n      }\n    };\n    ({ Type: w$2 } = p$1);\n    be$1 = w$2.Object({ cloud_name: w$2.String(), api_key: w$2.String(), api_secret: w$2.String(), upload_preset: w$2.Optional(w$2.String()) }, { title: \"Cloudinary\", description: \"Cloudinary media storage\" });\n    O$1 = class O extends b$2 {\n      static {\n        __name(this, \"O\");\n      }\n      config;\n      constructor(e) {\n        super(), this.config = L$2(be$1, e);\n      }\n      getSchema() {\n        return be$1;\n      }\n      getMimeType(e) {\n        switch (true) {\n          case (e.format === \"jpeg\" || e.format === \"jpg\"):\n            return \"image/jpeg\";\n        }\n        return `${e.resource_type}/${e.format}`;\n      }\n      getName() {\n        return \"cloudinary\";\n      }\n      getAuthorizationHeader() {\n        return { Authorization: `Basic ${btoa(`${this.config.api_key}:${this.config.api_secret}`)}` };\n      }\n      async putObject(e, t) {\n        let n27 = e.replace(/\\.[a-z0-9]{2,5}$/, \"\"), s2 = new FormData();\n        s2.append(\"file\", t), s2.append(\"public_id\", n27), s2.append(\"api_key\", this.config.api_key), this.config.upload_preset && s2.append(\"upload_preset\", this.config.upload_preset);\n        let i = await fetch(`https://api.cloudinary.com/v1_1/${this.config.cloud_name}/auto/upload`, { method: \"POST\", headers: { Accept: \"application/json\" }, body: s2 });\n        if (!i.ok) return;\n        let o = await i.json();\n        return { name: o.public_id + \".\" + o.format, etag: o.etag, meta: { type: this.getMimeType(o), size: o.bytes } };\n      }\n      async listObjects(e) {\n        let t = await fetch(`https://api.cloudinary.com/v1_1/${this.config.cloud_name}/resources/search`, { method: \"GET\", headers: { Accept: \"application/json\", \"Cache-Control\": \"no-cache\", ...this.getAuthorizationHeader() } });\n        if (!t.ok) throw new Error(\"Failed to list objects\");\n        return (await t.json()).resources.map((i) => ({ key: i.public_id, last_modified: new Date(i.uploaded_at), size: i.bytes }));\n      }\n      async headObject(e) {\n        let t = this.getObjectUrl(e);\n        return await fetch(t, { method: \"HEAD\", headers: { \"Cache-Control\": \"no-cache, no-store, must-revalidate\", Pragma: \"no-cache\", Expires: \"0\", Range: \"bytes=0-1\" } });\n      }\n      async objectExists(e) {\n        return (await this.headObject(e)).ok;\n      }\n      async getObjectMeta(e) {\n        let t = await this.headObject(e);\n        if (t.ok) {\n          let n27 = t.headers.get(\"content-type\"), s2 = Number(t.headers.get(\"content-range\")?.split(\"/\")[1]);\n          return { type: n27, size: s2 };\n        }\n        throw new Error(\"Cannot get object meta\");\n      }\n      guessType(e) {\n        let t = { image: [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\", \"svg\"], video: [\"mp4\", \"webm\", \"ogg\"] }, n27 = e.split(\".\").pop();\n        return Object.keys(t).find((s2) => t[s2].includes(n27));\n      }\n      getObjectUrl(e) {\n        let t = this.guessType(e) ?? \"image\";\n        return `https://res.cloudinary.com/${this.config.cloud_name}/${t}/upload/${e}`;\n      }\n      async generateSignature(e, t) {\n        let n27 = e.timestamp ?? Math.floor(Date.now() / 1e3), s2 = Object.entries({ ...e, timestamp: n27 }).sort(([o], [a2]) => o.localeCompare(a2)).map(([o, a2]) => `${o}=${a2}`).join(\"&\");\n        return { signature: await ye$1.sha1(s2 + (t ?? this.config.api_secret)), timestamp: n27 };\n      }\n      filenameToPublicId(e) {\n        return e.split(\".\").slice(0, -1).join(\".\");\n      }\n      async getObject(e, t) {\n        let n27 = await fetch(this.getObjectUrl(e), { method: \"GET\", headers: H$2(t, [\"range\"]) });\n        return new Response(n27.body, { status: n27.status, statusText: n27.statusText, headers: n27.headers });\n      }\n      async deleteObject(e) {\n        let t = this.guessType(e) ?? \"image\", n27 = this.filenameToPublicId(e), { timestamp: s2, signature: i } = await this.generateSignature({ public_id: n27 }), o = new FormData();\n        o.append(\"public_id\", n27), o.append(\"timestamp\", String(s2)), o.append(\"signature\", i), o.append(\"api_key\", this.config.api_key);\n        let a2 = `https://api.cloudinary.com/v1_1/${this.config.cloud_name}/${t}/destroy`, g2 = await fetch(a2, { headers: { Accept: \"application/json\", \"Cache-Control\": \"no-cache\", ...this.getAuthorizationHeader() }, method: \"POST\", body: o });\n        if (!g2.ok) throw new Error(`Failed to delete object: ${g2.status} ${g2.statusText}`);\n      }\n      toJSON(e) {\n        return { type: \"cloudinary\", config: e ? this.config : { cloud_name: this.config.cloud_name } };\n      }\n    };\n    ({ Type: D$2 } = p$1);\n    xe$1 = D$2.Object({ access_key: D$2.String(), secret_access_key: D$2.String(), url: D$2.String({ pattern: \"^https?://(?:.*)?[^/.]+$\", description: \"URL to S3 compatible endpoint without trailing slash\", examples: [\"https://{account_id}.r2.cloudflarestorage.com/{bucket}\", \"https://{bucket}.s3.{region}.amazonaws.com\"] }) }, { title: \"AWS S3\", description: \"AWS S3 or compatible storage\" });\n    v$2 = class v extends b$2 {\n      static {\n        __name(this, \"v\");\n      }\n      #e;\n      client;\n      constructor(e) {\n        super(), this.client = new A$2({ accessKeyId: e.access_key, secretAccessKey: e.secret_access_key, retries: M$2() ? 0 : 10 }, { convertParams: \"pascalToKebab\", responseType: \"xml\" }), this.#e = L$2(xe$1, e);\n      }\n      getName() {\n        return \"s3\";\n      }\n      getSchema() {\n        return xe$1;\n      }\n      getUrl(e = \"\", t = {}) {\n        let n27 = this.getObjectUrl(\"\").slice(0, -1);\n        return e.length > 0 && (n27 += `/${e}`), this.client.getUrl(n27, t);\n      }\n      getObjectUrl(e) {\n        return `${this.#e.url}/${e}`;\n      }\n      async listObjects(e = \"\") {\n        let t = { ListType: 2, Prefix: e }, n27 = this.getUrl(\"\", t), s2 = await this.client.fetchJson(n27, { method: \"GET\" }), { Contents: i } = s2.ListBucketResult, o = i ? Array.isArray(i) ? i : [i] : [];\n        return transform(o, (g2, f2) => {\n          f2.Key && f2.LastModified && f2.Size && g2.push({ key: f2.Key, last_modified: f2.LastModified, size: f2.Size });\n        }, []);\n      }\n      async putObject(e, t, n27 = {}) {\n        let s2 = this.getUrl(e, {}), i = await this.client.fetch(s2, { method: \"PUT\", body: t, headers: m(t) ? { \"Content-Length\": String(t.size) } : {} });\n        if (!i.ok) throw new Error(`Failed to upload object: ${i.status} ${i.statusText}`);\n        return String(i.headers.get(\"etag\"));\n      }\n      async headObject(e, t = {}) {\n        let n27 = this.getUrl(e, {});\n        return await this.client.fetch(n27, { method: \"HEAD\", headers: { Range: \"bytes=0-1\" } });\n      }\n      async getObjectMeta(e) {\n        let t = await this.headObject(e), n27 = String(t.headers.get(\"content-type\")), s2 = Number(String(t.headers.get(\"content-range\")?.split(\"/\")[1]));\n        return { type: n27, size: s2 };\n      }\n      async objectExists(e, t = {}) {\n        return (await this.headObject(e)).ok;\n      }\n      async getObject(e, t) {\n        let n27 = this.getUrl(e), s2 = await this.client.fetch(n27, { method: \"GET\", headers: ee$1(t, [\"if-none-match\", \"accept-encoding\", \"accept\", \"if-modified-since\"]) });\n        return new Response(s2.body, { status: s2.status, statusText: s2.statusText, headers: s2.headers });\n      }\n      async deleteObject(e, t = {}) {\n        let n27 = this.getUrl(e, t);\n        await this.client.fetch(n27, { method: \"DELETE\" });\n      }\n      toJSON(e) {\n        return { type: this.getName(), config: e ? this.#e : void 0 };\n      }\n    };\n    Ee$1 = {};\n    X$2(Ee$1, { deleteFile: /* @__PURE__ */ __name(() => Je$1, \"deleteFile\"), listFiles: /* @__PURE__ */ __name(() => Ye2, \"listFiles\"), readFile: /* @__PURE__ */ __name(() => Ge$1, \"readFile\"), uploadFile: /* @__PURE__ */ __name(() => We$1, \"uploadFile\") });\n    Ge$1 = new u$1(\"media.file.read\");\n    Ye2 = new u$1(\"media.file.list\");\n    We$1 = new u$1(\"media.file.upload\");\n    Je$1 = new u$1(\"media.file.delete\");\n    new R$1((r2) => ({ cls: r2, schema: r2.prototype.getSchema() })).register(\"s3\", v$2).register(\"cloudinary\", O$1);\n    ({ s3: { schema: v$2.prototype.getSchema() }, cloudinary: { schema: O$1.prototype.getSchema() } });\n    GlobalRequest = global.Request;\n    Request$1 = class Request2 extends GlobalRequest {\n      static {\n        __name(this, \"Request\");\n      }\n      constructor(input2, options) {\n        if (typeof input2 === \"object\" && getRequestCache in input2) {\n          input2 = input2[getRequestCache]();\n        }\n        if (typeof options?.body?.getReader !== \"undefined\") {\n          options.duplex ??= \"half\";\n        }\n        super(input2, options);\n      }\n    };\n    newRequestFromIncoming = /* @__PURE__ */ __name((method, url, incoming, abortController) => {\n      const headerRecord = [];\n      const rawHeaders = incoming.rawHeaders;\n      for (let i = 0; i < rawHeaders.length; i += 2) {\n        const { [i]: key, [i + 1]: value2 } = rawHeaders;\n        if (key.charCodeAt(0) !== /*:*/\n        58) {\n          headerRecord.push([key, value2]);\n        }\n      }\n      const init2 = {\n        method,\n        headers: headerRecord,\n        signal: abortController.signal\n      };\n      if (method === \"TRACE\") {\n        init2.method = \"GET\";\n        const req = new Request$1(url, init2);\n        Object.defineProperty(req, \"method\", {\n          get() {\n            return \"TRACE\";\n          }\n        });\n        return req;\n      }\n      if (!(method === \"GET\" || method === \"HEAD\")) {\n        if (\"rawBody\" in incoming && incoming.rawBody instanceof Buffer) {\n          init2.body = new ReadableStream({\n            start(controller) {\n              controller.enqueue(incoming.rawBody);\n              controller.close();\n            }\n          });\n        } else {\n          init2.body = Readable.toWeb(incoming);\n        }\n      }\n      return new Request$1(url, init2);\n    }, \"newRequestFromIncoming\");\n    getRequestCache = Symbol(\"getRequestCache\");\n    requestCache = Symbol(\"requestCache\");\n    incomingKey = Symbol(\"incomingKey\");\n    urlKey = Symbol(\"urlKey\");\n    abortControllerKey = Symbol(\"abortControllerKey\");\n    getAbortController = Symbol(\"getAbortController\");\n    requestPrototype = {\n      get method() {\n        return this[incomingKey].method || \"GET\";\n      },\n      get url() {\n        return this[urlKey];\n      },\n      [getAbortController]() {\n        this[getRequestCache]();\n        return this[abortControllerKey];\n      },\n      [getRequestCache]() {\n        this[abortControllerKey] ||= new AbortController();\n        return this[requestCache] ||= newRequestFromIncoming(\n          this.method,\n          this[urlKey],\n          this[incomingKey],\n          this[abortControllerKey]\n        );\n      }\n    };\n    [\n      \"body\",\n      \"bodyUsed\",\n      \"cache\",\n      \"credentials\",\n      \"destination\",\n      \"headers\",\n      \"integrity\",\n      \"mode\",\n      \"redirect\",\n      \"referrer\",\n      \"referrerPolicy\",\n      \"signal\",\n      \"keepalive\"\n    ].forEach((k2) => {\n      Object.defineProperty(requestPrototype, k2, {\n        get() {\n          return this[getRequestCache]()[k2];\n        }\n      });\n    });\n    [\"arrayBuffer\", \"blob\", \"clone\", \"formData\", \"json\", \"text\"].forEach((k2) => {\n      Object.defineProperty(requestPrototype, k2, {\n        value: /* @__PURE__ */ __name(function() {\n          return this[getRequestCache]()[k2]();\n        }, \"value\")\n      });\n    });\n    Object.setPrototypeOf(requestPrototype, Request$1.prototype);\n    responseCache = Symbol(\"responseCache\");\n    getResponseCache = Symbol(\"getResponseCache\");\n    cacheKey = Symbol(\"cache\");\n    GlobalResponse = global.Response;\n    Response2 = class _Response {\n      static {\n        __name(this, \"_Response\");\n      }\n      #body;\n      #init;\n      [getResponseCache]() {\n        delete this[cacheKey];\n        return this[responseCache] ||= new GlobalResponse(this.#body, this.#init);\n      }\n      constructor(body, init2) {\n        let headers;\n        this.#body = body;\n        if (init2 instanceof _Response) {\n          const cachedGlobalResponse = init2[responseCache];\n          if (cachedGlobalResponse) {\n            this.#init = cachedGlobalResponse;\n            this[getResponseCache]();\n            return;\n          } else {\n            this.#init = init2.#init;\n            headers = new Headers(init2.#init.headers);\n          }\n        } else {\n          this.#init = init2;\n        }\n        if (typeof body === \"string\" || typeof body?.getReader !== \"undefined\" || body instanceof Blob || body instanceof Uint8Array) {\n          headers ||= init2?.headers || { \"content-type\": \"text/plain; charset=UTF-8\" };\n          this[cacheKey] = [init2?.status || 200, body, headers];\n        }\n      }\n      get headers() {\n        const cache = this[cacheKey];\n        if (cache) {\n          if (!(cache[2] instanceof Headers)) {\n            cache[2] = new Headers(cache[2]);\n          }\n          return cache[2];\n        }\n        return this[getResponseCache]().headers;\n      }\n      get status() {\n        return this[cacheKey]?.[0] ?? this[getResponseCache]().status;\n      }\n      get ok() {\n        const status = this.status;\n        return status >= 200 && status < 300;\n      }\n    };\n    [\"body\", \"bodyUsed\", \"redirected\", \"statusText\", \"trailers\", \"type\", \"url\"].forEach((k2) => {\n      Object.defineProperty(Response2.prototype, k2, {\n        get() {\n          return this[getResponseCache]()[k2];\n        }\n      });\n    });\n    [\"arrayBuffer\", \"blob\", \"clone\", \"formData\", \"json\", \"text\"].forEach((k2) => {\n      Object.defineProperty(Response2.prototype, k2, {\n        value: /* @__PURE__ */ __name(function() {\n          return this[getResponseCache]()[k2]();\n        }, \"value\")\n      });\n    });\n    Object.setPrototypeOf(Response2, GlobalResponse);\n    Object.setPrototypeOf(Response2.prototype, GlobalResponse.prototype);\n    webFetch = global.fetch;\n    if (typeof global.crypto === \"undefined\") {\n      global.crypto = crypto_default;\n    }\n    global.fetch = (info4, init2) => {\n      init2 = {\n        // Disable compression handling so people can return the result of a fetch\n        // directly in the loader without messing with the Content-Encoding header.\n        compress: false,\n        ...init2\n      };\n      return webFetch(info4, init2);\n    };\n    D$1 = Object.create;\n    b$1 = Object.defineProperty;\n    P$1 = Object.getOwnPropertyDescriptor;\n    N$1 = Object.getOwnPropertyNames;\n    j$1 = Object.getPrototypeOf;\n    A$1 = Object.prototype.hasOwnProperty;\n    M$1 = /* @__PURE__ */ __name((t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), \"M$1\");\n    $$1 = /* @__PURE__ */ __name((t, e, r2, n27) => {\n      if (e && typeof e == \"object\" || typeof e == \"function\") for (let o of N$1(e)) !A$1.call(t, o) && o !== r2 && b$1(t, o, { get: /* @__PURE__ */ __name(() => e[o], \"get\"), enumerable: !(n27 = P$1(e, o)) || n27.enumerable });\n      return t;\n    }, \"$$1\");\n    H$1 = /* @__PURE__ */ __name((t, e, r2) => (r2 = t != null ? D$1(j$1(t)) : {}, $$1(b$1(r2, \"default\", { value: t, enumerable: true }), t)), \"H$1\");\n    E$1 = M$1((fe2, f2) => {\n      var m2 = process || {}, C2 = m2.argv || [], c = m2.env || {}, J3 = !(c.NO_COLOR || C2.includes(\"--no-color\")) && (!!c.FORCE_COLOR || C2.includes(\"--color\") || m2.platform === \"win32\" || (m2.stdout || {}).isTTY && c.TERM !== \"dumb\" || !!c.CI), q2 = /* @__PURE__ */ __name((t, e, r2 = t) => (n27) => {\n        let o = \"\" + n27, i = o.indexOf(e, t.length);\n        return ~i ? t + Q2(o, e, r2, i) + e : t + o + e;\n      }, \"q\"), Q2 = /* @__PURE__ */ __name((t, e, r2, n27) => {\n        let o = \"\", i = 0;\n        do\n          o += t.substring(i, n27) + r2, i = n27 + e.length, n27 = t.indexOf(e, i);\n        while (~n27);\n        return o + t.substring(i);\n      }, \"Q\"), _3 = /* @__PURE__ */ __name((t = J3) => {\n        let e = t ? q2 : () => String;\n        return { isColorSupported: t, reset: e(\"\\x1B[0m\", \"\\x1B[0m\"), bold: e(\"\\x1B[1m\", \"\\x1B[22m\", \"\\x1B[22m\\x1B[1m\"), dim: e(\"\\x1B[2m\", \"\\x1B[22m\", \"\\x1B[22m\\x1B[2m\"), italic: e(\"\\x1B[3m\", \"\\x1B[23m\"), underline: e(\"\\x1B[4m\", \"\\x1B[24m\"), inverse: e(\"\\x1B[7m\", \"\\x1B[27m\"), hidden: e(\"\\x1B[8m\", \"\\x1B[28m\"), strikethrough: e(\"\\x1B[9m\", \"\\x1B[29m\"), black: e(\"\\x1B[30m\", \"\\x1B[39m\"), red: e(\"\\x1B[31m\", \"\\x1B[39m\"), green: e(\"\\x1B[32m\", \"\\x1B[39m\"), yellow: e(\"\\x1B[33m\", \"\\x1B[39m\"), blue: e(\"\\x1B[34m\", \"\\x1B[39m\"), magenta: e(\"\\x1B[35m\", \"\\x1B[39m\"), cyan: e(\"\\x1B[36m\", \"\\x1B[39m\"), white: e(\"\\x1B[37m\", \"\\x1B[39m\"), gray: e(\"\\x1B[90m\", \"\\x1B[39m\"), bgBlack: e(\"\\x1B[40m\", \"\\x1B[49m\"), bgRed: e(\"\\x1B[41m\", \"\\x1B[49m\"), bgGreen: e(\"\\x1B[42m\", \"\\x1B[49m\"), bgYellow: e(\"\\x1B[43m\", \"\\x1B[49m\"), bgBlue: e(\"\\x1B[44m\", \"\\x1B[49m\"), bgMagenta: e(\"\\x1B[45m\", \"\\x1B[49m\"), bgCyan: e(\"\\x1B[46m\", \"\\x1B[49m\"), bgWhite: e(\"\\x1B[47m\", \"\\x1B[49m\"), blackBright: e(\"\\x1B[90m\", \"\\x1B[39m\"), redBright: e(\"\\x1B[91m\", \"\\x1B[39m\"), greenBright: e(\"\\x1B[92m\", \"\\x1B[39m\"), yellowBright: e(\"\\x1B[93m\", \"\\x1B[39m\"), blueBright: e(\"\\x1B[94m\", \"\\x1B[39m\"), magentaBright: e(\"\\x1B[95m\", \"\\x1B[39m\"), cyanBright: e(\"\\x1B[96m\", \"\\x1B[39m\"), whiteBright: e(\"\\x1B[97m\", \"\\x1B[39m\"), bgBlackBright: e(\"\\x1B[100m\", \"\\x1B[49m\"), bgRedBright: e(\"\\x1B[101m\", \"\\x1B[49m\"), bgGreenBright: e(\"\\x1B[102m\", \"\\x1B[49m\"), bgYellowBright: e(\"\\x1B[103m\", \"\\x1B[49m\"), bgBlueBright: e(\"\\x1B[104m\", \"\\x1B[49m\"), bgMagentaBright: e(\"\\x1B[105m\", \"\\x1B[49m\"), bgCyanBright: e(\"\\x1B[106m\", \"\\x1B[49m\"), bgWhiteBright: e(\"\\x1B[107m\", \"\\x1B[49m\") };\n      }, \"_\");\n      f2.exports = _3();\n      f2.exports.createColors = _3;\n    });\n    ({ Type: h2 } = p$1);\n    v$1 = h2.Object({ path: h2.String({ default: \"./\" }) }, { title: \"Local\", description: \"Local file system storage\", additionalProperties: false });\n    l = class extends b$2 {\n      static {\n        __name(this, \"l\");\n      }\n      config;\n      constructor(e = {}) {\n        super(), this.config = qe$1(v$1, e);\n      }\n      getSchema() {\n        return v$1;\n      }\n      getName() {\n        return \"local\";\n      }\n      async listObjects(e) {\n        let r2 = await readdir(this.config.path);\n        return await Promise.all(r2.filter((o) => !e || o.startsWith(e)).map(async (o) => {\n          let i = await stat(`${this.config.path}/${o}`);\n          return { key: o, last_modified: i.mtime, size: i.size };\n        }));\n      }\n      async computeEtag(e) {\n        let r2 = A$3(e) ? e : new Response(e), n27 = await crypto.subtle.digest(\"SHA-256\", await r2.arrayBuffer());\n        return `\"${Array.from(new Uint8Array(n27)).map((s2) => s2.toString(16).padStart(2, \"0\")).join(\"\")}\"`;\n      }\n      async putObject(e, r2) {\n        if (r2 === null) throw new Error(\"Body is empty\");\n        let n27 = `${this.config.path}/${e}`, o = A$3(r2);\n        return await writeFile(n27, o ? r2.stream() : r2), await this.computeEtag(r2);\n      }\n      async deleteObject(e) {\n        try {\n          await unlink(`${this.config.path}/${e}`);\n        } catch {\n        }\n      }\n      async objectExists(e) {\n        try {\n          return (await stat(`${this.config.path}/${e}`)).isFile();\n        } catch {\n          return false;\n        }\n      }\n      async getObject(e, r2) {\n        try {\n          let n27 = await readFile(`${this.config.path}/${e}`), o = Le$1(e);\n          return new Response(n27, { status: 200, headers: { \"Content-Type\": o || \"application/octet-stream\", \"Content-Length\": n27.length.toString() } });\n        } catch {\n          return new Response(\"\", { status: 404 });\n        }\n      }\n      getObjectUrl(e) {\n        throw new Error(\"Method not implemented.\");\n      }\n      async getObjectMeta(e) {\n        let r2 = await stat(`${this.config.path}/${e}`);\n        return { type: Le$1(e) || \"application/octet-stream\", size: r2.size };\n      }\n      toJSON(e) {\n        return { type: this.getName(), config: this.config };\n      }\n    };\n    w$1 = /* @__PURE__ */ __name((t, e) => typeof t == \"string\" ? [1, \"1\", \"true\"].includes(t) : !!(t || e), \"w$1\");\n    W$1 = { cli_log_level: { key: \"BKND_CLI_LOG_LEVEL\", validate: /* @__PURE__ */ __name((t) => {\n      if (typeof t == \"string\" && [\"log\", \"info\", \"warn\", \"error\", \"debug\"].includes(t.toLowerCase())) return t.toLowerCase();\n    }, \"validate\") }, cli_create_ref: { key: \"BKND_CLI_CREATE_REF\", validate: /* @__PURE__ */ __name((t) => typeof t == \"string\" ? t : void 0, \"validate\") }, cli_telemetry: { key: \"BKND_CLI_TELEMETRY\", validate: /* @__PURE__ */ __name((t) => {\n      if (!(typeof t > \"u\")) return w$1(t, true);\n    }, \"validate\") }, modules_debug: { key: \"BKND_MODULES_DEBUG\", validate: w$1 } };\n    d = /* @__PURE__ */ __name((t, e, r2) => {\n      try {\n        let n27 = r2?.source ?? process.env, o = W$1[t], i = n27[o.key], s2 = o.validate(i);\n        if (typeof s2 < \"u\") return r2?.onValid?.(s2), s2;\n        r2?.onFallback?.(i);\n      } catch {\n      }\n      return e;\n    }, \"d\");\n    a = H$1(E$1());\n    __name(Z, \"Z\");\n    u2 = { critical: { prefix: \"CRT\", color: a.default.red, args_color: a.default.red, original: console.error }, error: { prefix: \"ERR\", color: a.default.red, args_color: a.default.red, original: console.error }, warn: { prefix: \"WRN\", color: a.default.yellow, args_color: a.default.yellow, original: console.warn }, info: { prefix: \"INF\", color: a.default.cyan, original: console.info }, log: { prefix: \"LOG\", color: a.default.dim, args_color: a.default.dim, original: console.log }, debug: { prefix: \"DBG\", color: a.default.yellow, args_color: a.default.dim, original: console.debug } };\n    __name(X$1, \"X$1\");\n    B$1 = d(\"cli_log_level\", \"log\");\n    p = globalThis.__consoleConfig ??= { level: B$1 };\n    k = Object.keys(u2);\n    new Proxy(p, { get: /* @__PURE__ */ __name((t, e) => {\n      switch (e) {\n        case \"original\":\n          return console;\n        case \"setLevel\":\n          return (o) => {\n            p.level = o;\n          };\n        case \"resetLevel\":\n          return () => {\n            p.level = B$1;\n          };\n      }\n      let r2 = k.indexOf(p.level), n27 = k.indexOf(e);\n      return e in u2 && n27 <= r2 ? (...o) => X$1(e, o) : () => null;\n    }, \"get\") });\n    ze$2.extend(Pr$1);\n    __name(L$1, \"L$1\");\n    F$1 = false;\n    __name(T, \"T\");\n    mr = Object.create;\n    Ft = Object.defineProperty;\n    hr = Object.getOwnPropertyDescriptor;\n    gr = Object.getOwnPropertyNames;\n    xr = Object.getPrototypeOf;\n    br = Object.prototype.hasOwnProperty;\n    Er2 = /* @__PURE__ */ __name((n122, e) => () => (e || n122((e = { exports: {} }).exports, e), e.exports), \"Er\");\n    Cn2 = /* @__PURE__ */ __name((n122, e) => {\n      for (var t in e) Ft(n122, t, { get: e[t], enumerable: true });\n    }, \"Cn\");\n    Tr = /* @__PURE__ */ __name((n122, e, t, r2) => {\n      if (e && typeof e == \"object\" || typeof e == \"function\") for (let i of gr(e)) !br.call(n122, i) && i !== t && Ft(n122, i, { get: /* @__PURE__ */ __name(() => e[i], \"get\"), enumerable: !(r2 = hr(e, i)) || r2.enumerable });\n      return n122;\n    }, \"Tr\");\n    wr2 = /* @__PURE__ */ __name((n122, e, t) => (t = n122 != null ? mr(xr(n122)) : {}, Tr(Ft(t, \"default\", { value: n122, enumerable: true }), n122)), \"wr\");\n    _n2 = Er2((Ts2, $t2) => {\n      var h3 = String, In2 = /* @__PURE__ */ __name(function() {\n        return { isColorSupported: false, reset: h3, bold: h3, dim: h3, italic: h3, underline: h3, inverse: h3, hidden: h3, strikethrough: h3, black: h3, red: h3, green: h3, yellow: h3, blue: h3, magenta: h3, cyan: h3, white: h3, gray: h3, bgBlack: h3, bgRed: h3, bgGreen: h3, bgYellow: h3, bgBlue: h3, bgMagenta: h3, bgCyan: h3, bgWhite: h3, blackBright: h3, redBright: h3, greenBright: h3, yellowBright: h3, blueBright: h3, magentaBright: h3, cyanBright: h3, whiteBright: h3, bgBlackBright: h3, bgRedBright: h3, bgGreenBright: h3, bgYellowBright: h3, bgBlueBright: h3, bgMagentaBright: h3, bgCyanBright: h3, bgWhiteBright: h3 };\n      }, \"In\");\n      $t2.exports = In2();\n      $t2.exports.createColors = In2;\n    });\n    Y2 = class extends Error {\n      static {\n        __name(this, \"Y\");\n      }\n      code = 400;\n      name = \"Exception\";\n      _context = void 0;\n      constructor(e, t) {\n        super(e), t && (this.code = t);\n      }\n      context(e) {\n        return this._context = e, this;\n      }\n      toJSON() {\n        return { error: this.message, type: this.name, context: this._context };\n      }\n    };\n    $n2 = /* @__PURE__ */ __name((n122, e) => typeof n122 == \"string\" ? [1, \"1\", \"true\"].includes(n122) : !!(n122 || e), \"$n\");\n    Sr = { cli_log_level: { key: \"BKND_CLI_LOG_LEVEL\", validate: /* @__PURE__ */ __name((n122) => {\n      if (typeof n122 == \"string\" && [\"log\", \"info\", \"warn\", \"error\", \"debug\"].includes(n122.toLowerCase())) return n122.toLowerCase();\n    }, \"validate\") }, cli_create_ref: { key: \"BKND_CLI_CREATE_REF\", validate: /* @__PURE__ */ __name((n122) => typeof n122 == \"string\" ? n122 : void 0, \"validate\") }, cli_telemetry: { key: \"BKND_CLI_TELEMETRY\", validate: /* @__PURE__ */ __name((n122) => {\n      if (!(typeof n122 > \"u\")) return $n2(n122, true);\n    }, \"validate\") }, modules_debug: { key: \"BKND_MODULES_DEBUG\", validate: $n2 } };\n    Ct2 = /* @__PURE__ */ __name((n122, e, t) => {\n      try {\n        let r2 = t?.source ?? process.env, i = Sr[n122], o = r2[i.key], s2 = i.validate(o);\n        if (typeof s2 < \"u\") return t?.onValid?.(s2), s2;\n        t?.onFallback?.(o);\n      } catch {\n      }\n      return e;\n    }, \"Ct\");\n    Qe = { data: { default_primary_field: \"id\" } };\n    __name(Ie, \"Ie\");\n    __name(Le, \"Le\");\n    __name(Ke2, \"Ke\");\n    Pn = Ke2;\n    __name(nt2, \"nt\");\n    D = wr2(_n2());\n    __name(vr, \"vr\");\n    Pt2 = { critical: { prefix: \"CRT\", color: D.default.red, args_color: D.default.red, original: console.error }, error: { prefix: \"ERR\", color: D.default.red, args_color: D.default.red, original: console.error }, warn: { prefix: \"WRN\", color: D.default.yellow, args_color: D.default.yellow, original: console.warn }, info: { prefix: \"INF\", color: D.default.cyan, original: console.info }, log: { prefix: \"LOG\", color: D.default.dim, args_color: D.default.dim, original: console.log }, debug: { prefix: \"DBG\", color: D.default.yellow, args_color: D.default.dim, original: console.debug } };\n    __name(Or2, \"Or\");\n    jn2 = Ct2(\"cli_log_level\", \"log\");\n    rt2 = globalThis.__consoleConfig ??= { level: jn2 };\n    kn = Object.keys(Pt2);\n    g = new Proxy(rt2, { get: /* @__PURE__ */ __name((n122, e) => {\n      switch (e) {\n        case \"original\":\n          return console;\n        case \"setLevel\":\n          return (i) => {\n            rt2.level = i;\n          };\n        case \"resetLevel\":\n          return () => {\n            rt2.level = jn2;\n          };\n      }\n      let t = kn.indexOf(rt2.level), r2 = kn.indexOf(e);\n      return e in Pt2 && r2 <= t ? (...i) => Or2(e, i) : () => null;\n    }, \"get\") });\n    It2 = Symbol(\"tb-parse-validation\");\n    Ve = class extends Error {\n      static {\n        __name(this, \"Ve\");\n      }\n      constructor(t, r2, i) {\n        super(i ?? `Invalid: ${JSON.stringify(r2)}`);\n        this.schema = t;\n        this.data = r2;\n        this.errors = [...Errors(t, r2)];\n      }\n      errors;\n      first() {\n        return this.errors[0];\n      }\n      firstToString() {\n        let t = this.first();\n        return `${t.message} at \"${t.path}\"`;\n      }\n      toJSON() {\n        return { message: this.message, schema: this.schema, data: this.data, errors: this.errors };\n      }\n    };\n    __name(Dn2, \"Dn\");\n    __name(_e, \"_e\");\n    __name($r, \"$r\");\n    $r(type$1);\n    $2 = /* @__PURE__ */ __name((n122, e) => Type.Unsafe({ [Kind]: \"StringEnum\", type: \"string\", enum: n122, ...e }), \"$\");\n    Je = /* @__PURE__ */ __name((n122, e) => Type.Object({}, { ...e, additionalProperties: n122 }), \"Je\");\n    _t = /* @__PURE__ */ __name((n122, e) => Type.Literal(n122, { ...e, default: n122, const: n122, readOnly: true }), \"_t\");\n    Type.String({ pattern: \"^[a-zA-Z_][a-zA-Z0-9_]*$\", minLength: 2, maxLength: 150 });\n    SetErrorFunction((n122) => n122?.schema?.errorMessage ? n122.schema.errorMessage : n122?.schema?.[Kind] === \"StringEnum\" ? `Expected: ${n122.schema.enum.map((e) => `\"${e}\"`).join(\", \")}` : DefaultErrorFunction(n122));\n    ze$2.extend(Pr$1);\n    __name(Mn2, \"Mn\");\n    __name(An2, \"An\");\n    ye = /* @__PURE__ */ __name((n122, e) => n122 === e, \"ye\");\n    _r2 = /* @__PURE__ */ __name((n122) => IsString$2(n122) || IsNumber$2(n122) || IsBoolean$2(n122), \"_r\");\n    kr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && IsArray$2(n122.enum) && n122.enum.every((e) => _r2(e)), \"kr\");\n    jr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && IsArray$2(n122.allOf), \"jr\");\n    Mr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && IsArray$2(n122.anyOf), \"Mr\");\n    Br = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && IsArray$2(n122.oneOf), \"Br\");\n    Dr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"array\") && IsArray$2(n122.items), \"Dr\");\n    Ar2 = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"array\") && !IsArray$2(n122.items) && IsObject$2(n122.items), \"Ar\");\n    qr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && IsObject$2(n122.const), \"qr\");\n    Nr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"string\"), \"Nr\");\n    Qr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"number\"), \"Qr\");\n    Lr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"integer\"), \"Lr\");\n    Kr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"boolean\"), \"Kr\");\n    Vr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"null\"), \"Vr\");\n    Jr = /* @__PURE__ */ __name((n122) => IsObject$2(n122), \"Jr\");\n    zr = /* @__PURE__ */ __name((n122) => IsObject$2(n122) && ye(n122.type, \"object\") && Jr(n122.properties) && (n122.required === void 0 || IsArray$2(n122.required) && n122.required.every((e) => IsString$2(e))), \"zr\");\n    __name(ot, \"ot\");\n    __name(Ur, \"Ur\");\n    __name(Wr, \"Wr\");\n    __name(Gr, \"Gr\");\n    __name(Hr, \"Hr\");\n    __name(Yr, \"Yr\");\n    __name(Zr, \"Zr\");\n    __name(Xr, \"Xr\");\n    __name(ei2, \"ei\");\n    __name(ti2, \"ti\");\n    __name(de2, \"de\");\n    __name(kt, \"kt\");\n    J2 = class {\n      static {\n        __name(this, \"J\");\n      }\n      constructor(e) {\n        this.name = e;\n        this.name = e;\n      }\n      toJSON() {\n        return { name: this.name };\n      }\n    };\n    __name(X, \"X\");\n    __name(Mt2, \"Mt\");\n    jt2 = class {\n      static {\n        __name(this, \"jt\");\n      }\n      constructor(e, t, r2) {\n        this.key = e;\n        this.valid = t;\n        this.validate = r2;\n      }\n      expect;\n    };\n    __name(A2, \"A\");\n    __name(Qn, \"Qn\");\n    qn2 = \"$or\";\n    __name(Bt2, \"Bt\");\n    __name(Nn, \"Nn\");\n    __name(ni2, \"ni\");\n    __name(Dt2, \"Dt\");\n    O2 = {};\n    Cn2(O2, { $kind: /* @__PURE__ */ __name(() => Nt, \"$kind\"), $optional: /* @__PURE__ */ __name(() => Qt2, \"$optional\"), $raw: /* @__PURE__ */ __name(() => Ee2, \"$raw\"), any: /* @__PURE__ */ __name(() => Wi, \"any\"), anyOf: /* @__PURE__ */ __name(() => eo, \"anyOf\"), array: /* @__PURE__ */ __name(() => Zn2, \"array\"), boolean: /* @__PURE__ */ __name(() => Xn2, \"boolean\"), error: /* @__PURE__ */ __name(() => b2, \"error\"), fromSchema: /* @__PURE__ */ __name(() => Te2, \"fromSchema\"), integer: /* @__PURE__ */ __name(() => Hn2, \"integer\"), makeOpts: /* @__PURE__ */ __name(() => Se, \"makeOpts\"), number: /* @__PURE__ */ __name(() => Gn2, \"number\"), object: /* @__PURE__ */ __name(() => We, \"object\"), oneOf: /* @__PURE__ */ __name(() => to, \"oneOf\"), partialObject: /* @__PURE__ */ __name(() => Hi, \"partialObject\"), record: /* @__PURE__ */ __name(() => Yi, \"record\"), recursive: /* @__PURE__ */ __name(() => io, \"recursive\"), ref: /* @__PURE__ */ __name(() => no, \"ref\"), refId: /* @__PURE__ */ __name(() => ro, \"refId\"), schema: /* @__PURE__ */ __name(() => v2, \"schema\"), strictObject: /* @__PURE__ */ __name(() => Gi2, \"strictObject\"), string: /* @__PURE__ */ __name(() => Wn2, \"string\"), stringConst: /* @__PURE__ */ __name(() => Zi, \"stringConst\"), valid: /* @__PURE__ */ __name(() => y2, \"valid\") });\n    Nt = Symbol.for(\"kind\");\n    Qt2 = Symbol.for(\"optional\");\n    Ee2 = Symbol.for(\"raw\");\n    we2 = class extends Error {\n      static {\n        __name(this, \"we\");\n      }\n      constructor(n122) {\n        super(`Expected ${n122}`);\n      }\n    };\n    ri2 = class extends Error {\n      static {\n        __name(this, \"ri\");\n      }\n      constructor(n122, e) {\n        super(`${n122 ?? \"Invalid raw schema\"}: ${JSON.stringify(e)}`), this.schema = e;\n      }\n    };\n    ii2 = class extends Error {\n      static {\n        __name(this, \"ii\");\n      }\n      constructor(n122, e) {\n        super(`${n122}, got: '${JSON.stringify(e)}'`), this.value = e;\n      }\n    };\n    __name(oi, \"oi\");\n    __name(C, \"C\");\n    __name(ee, \"ee\");\n    __name(ie, \"ie\");\n    __name(si, \"si\");\n    __name(ke2, \"ke\");\n    __name(oe, \"oe\");\n    __name(ai, \"ai\");\n    __name(li, \"li\");\n    __name(ci, \"ci\");\n    __name(L, \"L\");\n    __name(ui, \"ui\");\n    __name(At2, \"At\");\n    __name(re, \"re\");\n    qt = /* @__PURE__ */ __name((n122 = [], e = \"\") => \"/\" + [e, ...n122.map((t) => String(t).replace(/\\./g, \"/\"))].filter(Boolean).join(\"/\"), \"qt\");\n    pi = /* @__PURE__ */ __name((n122) => n122.split(\"/\").slice(1), \"pi\");\n    __name(di, \"di\");\n    __name(Jn, \"Jn\");\n    b2 = /* @__PURE__ */ __name((n122 = {}, e, t, r2) => ({ valid: false, errors: [...n122.errors ?? [], { keywordLocation: qt([...n122.keywordPath ?? [], e]), instanceLocation: qt(n122.instancePath), error: typeof t == \"string\" ? t : `Invalid value for ${e}`, data: r2 }] }), \"b\");\n    y2 = /* @__PURE__ */ __name(() => ({ valid: true, errors: [] }), \"y\");\n    Se = /* @__PURE__ */ __name((n122, e, t) => {\n      let r2 = Array.isArray(e) ? e : [e], i = t ? Array.isArray(t) ? t : [t] : [];\n      return { ...n122, keywordPath: [...n122.keywordPath ?? [], ...r2], instancePath: i ? [...n122.instancePath ?? [], ...i] : n122.instancePath };\n    }, \"Se\");\n    st = /* @__PURE__ */ __name((n122 = {}) => ({ ...n122, errors: [] }), \"st\");\n    yi = /* @__PURE__ */ __name(({ type: n122 }, e, t = {}) => {\n      if (n122 === void 0) return y2();\n      let r2, i = { string: ee, number: ie, integer: si, object: C, array: oe, boolean: ke2, null: oi };\n      if (Array.isArray(n122)) {\n        for (let o of n122) {\n          if (!(o in i)) throw new we2(`Unknown type: ${o}`);\n          if (i[o](e)) return y2();\n        }\n        r2 = `Expected one of: ${n122.join(\", \")}`;\n      } else {\n        if (!(n122 in i)) throw new we2(`Unknown type: ${n122}`);\n        i[n122](e) || (r2 = `Expected ${n122}`);\n      }\n      return r2 ? b2(t, \"type\", r2, e) : y2();\n    }, \"yi\");\n    fi = /* @__PURE__ */ __name(({ const: n122 }, e, t = {}) => {\n      let r2 = JSON.stringify(re(n122)), i = JSON.stringify(re(e));\n      return r2 !== i ? b2(t, \"const\", `Expected const: ${r2}`, i) : y2();\n    }, \"fi\");\n    mi = /* @__PURE__ */ __name(({ enum: n122 = [] }, e, t = {}) => {\n      let r2 = JSON.stringify(n122.map(re)), i = JSON.stringify(re(e));\n      return r2.includes(i) ? y2() : b2(t, \"enum\", `Expected enum: ${r2}`, e);\n    }, \"mi\");\n    __name(Ue, \"Ue\");\n    hi = /* @__PURE__ */ __name(({ anyOf: n122 = [] }, e, t = {}) => Ue(n122, e, t).length > 0 ? y2() : b2(t, \"anyOf\", \"Expected at least one to match\", e), \"hi\");\n    gi = /* @__PURE__ */ __name(({ oneOf: n122 = [] }, e, t = {}) => Ue(n122, e).length === 1 ? y2() : b2(t, \"oneOf\", \"Expected exactly one to match\", e), \"gi\");\n    xi = /* @__PURE__ */ __name(({ allOf: n122 = [] }, e, t = {}) => Ue(n122, e, t).length === n122.length ? y2() : b2(t, \"allOf\", \"Expected all to match\", e), \"xi\");\n    bi = /* @__PURE__ */ __name(({ not: n122 }, e, t = {}) => L(n122) && n122.validate(e, t).valid ? b2(t, \"not\", \"Expected not to match\", e) : y2(), \"bi\");\n    Ei = /* @__PURE__ */ __name(({ if: n122, then: e, else: t }, r2, i = {}) => {\n      if (n122 && (e || t)) {\n        if (n122.validate(r2, st(i)).valid) return e ? e.validate(r2, st(i)) : y2();\n        if (t) return t.validate(r2, st(i));\n      }\n      return y2();\n    }, \"Ei\");\n    Ti = /* @__PURE__ */ __name(({ pattern: n122 = \"\" }, e, t = {}) => ee(e) ? new RegExp(n122, \"u\").test(e) ? y2() : b2(t, \"pattern\", `Expected string matching pattern ${n122}`, e) : y2(), \"Ti\");\n    wi = /* @__PURE__ */ __name(({ minLength: n122 = 0 }, e, t = {}) => ee(e) ? [...re(e)].length >= n122 ? y2() : b2(t, \"minLength\", `Expected string with minimum length of ${n122}`, e) : y2(), \"wi\");\n    Si = /* @__PURE__ */ __name(({ maxLength: n122 = 0 }, e, t = {}) => ee(e) ? [...re(e)].length <= n122 ? y2() : b2(t, \"maxLength\", `Expected string with maximum length of ${n122}`, e) : y2(), \"Si\");\n    vi = /* @__PURE__ */ __name(({ multipleOf: n122 = 0 }, e, t = {}) => {\n      if (!ie(e)) return y2();\n      if (!(Number.isFinite(e) && Number.isFinite(n122)) || n122 <= 0) throw new we2(\"number\");\n      let r2 = e / n122, i = Number.EPSILON * Math.max(1, Math.abs(r2));\n      return Math.abs(r2 - Math.round(r2)) <= i ? y2() : b2(t, \"multipleOf\", `Expected number being a multiple of ${n122}`, e);\n    }, \"vi\");\n    Oi2 = /* @__PURE__ */ __name(({ maximum: n122 = 0 }, e, t = {}) => !ie(e) || e <= n122 ? y2() : b2(t, \"maximum\", `Expected number less than or equal to ${n122}`, e), \"Oi\");\n    Ri = /* @__PURE__ */ __name(({ exclusiveMaximum: n122 = 0 }, e, t = {}) => !ie(e) || e < n122 ? y2() : b2(t, \"exclusiveMaximum\", `Expected number less than ${n122}`, e), \"Ri\");\n    Fi = /* @__PURE__ */ __name(({ minimum: n122 = 0 }, e, t = {}) => !ie(e) || e >= n122 ? y2() : b2(t, \"minimum\", `Expected number greater than or equal to ${n122}`, e), \"Fi\");\n    Ci = /* @__PURE__ */ __name(({ exclusiveMinimum: n122 = 0 }, e, t = {}) => !ie(e) || e > n122 ? y2() : b2(t, \"exclusiveMinimum\", `Expected number greater than ${n122}`, e), \"Ci\");\n    $i2 = /* @__PURE__ */ __name(({ properties: n122 = {} }, e, t = {}) => {\n      if (!C(e)) return y2();\n      for (let [r2, i] of Object.entries(e)) {\n        let o = n122[r2];\n        if (!L(o)) continue;\n        let s2 = o.validate(i, Se(t, [\"properties\", r2], r2));\n        if (!s2.valid) return s2;\n      }\n      return y2();\n    }, \"$i\");\n    Pi = /* @__PURE__ */ __name(({ properties: n122 = {}, additionalProperties: e, patternProperties: t }, r2, i = {}) => {\n      if (!C(r2)) return y2();\n      if (!L(e)) throw new we2(\"additionalProperties must be a boolean or a managed schema\");\n      let o = Object.keys(n122), s2 = C(t) ? Object.keys(r2).filter((a2) => Object.keys(t).some((c) => new RegExp(c).test(a2))) : [], l2 = Object.keys(r2).filter((a2) => !o.includes(a2) && !s2.includes(a2));\n      if (l2.length > 0) {\n        if (ui(e)) return e.validate(void 0);\n        if (L(e)) for (let a2 of l2) {\n          let c = e.validate(r2[a2], Se(i, [\"additionalProperties\"], a2));\n          if (!c.valid) return c;\n        }\n      }\n      return y2();\n    }, \"Pi\");\n    Ii = /* @__PURE__ */ __name(({ dependentRequired: n122 }, e, t = {}) => {\n      if (!C(e)) return y2();\n      let r2 = Object.keys(e).filter((i) => typeof e[i] != \"function\");\n      if (C(n122)) {\n        for (let [i, o] of Object.entries(n122)) if (r2.includes(i)) {\n          for (let s2 of o) if (!r2.includes(s2)) return b2(t, \"dependentRequired\", `Expected dependent required property ${s2}`, e);\n        }\n      }\n      return y2();\n    }, \"Ii\");\n    _i = /* @__PURE__ */ __name(({ required: n122 = [] }, e, t = {}) => {\n      if (!C(e)) return y2();\n      let r2 = Object.keys(e).filter((i) => typeof e[i] != \"function\");\n      return n122.every((i) => r2.includes(i)) ? y2() : b2(t, \"required\", `Expected object with required properties ${n122.join(\", \")}`, e);\n    }, \"_i\");\n    ki = /* @__PURE__ */ __name(({ dependentSchemas: n122 }, e, t = {}) => {\n      if (!C(e)) return y2();\n      let r2 = Object.keys(e).filter((i) => typeof e[i] != \"function\");\n      if (C(n122)) {\n        for (let [i, o] of Object.entries(n122)) if (r2.includes(i)) {\n          let s2 = o.validate(e, t);\n          if (!s2.valid) return s2;\n        }\n      }\n      return y2();\n    }, \"ki\");\n    ji2 = /* @__PURE__ */ __name(({ minProperties: n122 = 0 }, e, t = {}) => C(e) ? Object.keys(e).length >= n122 ? y2() : b2(t, \"minProperties\", `Expected object with at least ${n122} properties`, e) : y2(), \"ji\");\n    Mi = /* @__PURE__ */ __name(({ maxProperties: n122 = 0 }, e, t = {}) => !C(e) || Object.keys(e).length <= n122 ? y2() : b2(t, \"maxProperties\", `Expected object with at most ${n122} properties`, e), \"Mi\");\n    Bi2 = /* @__PURE__ */ __name(({ patternProperties: n122 = {} }, e, t = {}) => {\n      if (!C(e)) return y2();\n      if (!C(n122)) throw new we2(\"patternProperties must be an object\");\n      for (let [r2, i] of Object.entries(e)) for (let [o, s2] of Object.entries(n122)) if (new RegExp(o, \"u\").test(r2)) {\n        let l2 = s2.validate(i, Se(t, [\"patternProperties\"], r2));\n        if (!l2.valid) return l2;\n      }\n      return y2();\n    }, \"Bi\");\n    Di = /* @__PURE__ */ __name(({ propertyNames: n122 }, e, t = {}) => {\n      if (!C(e) || n122 === void 0) return y2();\n      if (!L(n122)) throw new we2(\"propertyNames must be a managed schema\");\n      for (let r2 of Object.keys(e)) {\n        let i = n122.validate(r2, Se(t, [\"propertyNames\"], r2));\n        if (!i.valid) return i;\n      }\n      return y2();\n    }, \"Di\");\n    Ai = /* @__PURE__ */ __name(({ items: n122, prefixItems: e = [] }, t, r2 = {}) => {\n      if (!oe(t) || n122 === void 0) return y2();\n      if (!L(n122)) throw new we2(\"items must be a managed schema\");\n      for (let [i, o] of t.slice(e.length).entries()) {\n        let s2 = n122.validate(o, Se(r2, [\"items\"], String(i)));\n        if (!s2.valid) return s2;\n      }\n      return y2();\n    }, \"Ai\");\n    qi2 = /* @__PURE__ */ __name(({ minItems: n122 = 0 }, e, t = {}) => !oe(e) || e.length >= n122 ? y2() : b2(t, \"minItems\", `Expected array with at least ${n122} items`, e), \"qi\");\n    Ni2 = /* @__PURE__ */ __name(({ maxItems: n122 = 0 }, e, t = {}) => !oe(e) || e.length <= n122 ? y2() : b2(t, \"maxItems\", `Expected array with at most ${n122} items`, e), \"Ni\");\n    Qi2 = /* @__PURE__ */ __name(({ uniqueItems: n122 = false }, e, t = {}) => {\n      if (!oe(e) || !n122) return y2();\n      let r2 = e.map(re);\n      return new Set(r2.map((i) => JSON.stringify(i))).size === e.length ? y2() : b2(t, \"uniqueItems\", \"Expected array with unique items\", e);\n    }, \"Qi\");\n    Li2 = /* @__PURE__ */ __name(({ contains: n122, minContains: e, maxContains: t }, r2, i = {}) => {\n      if (!L(n122)) throw new Error(\"contains must be a managed schema\");\n      if (!oe(r2)) return y2();\n      let o = r2.filter((s2) => n122.validate(s2).valid).length;\n      return o < (e ?? 1) ? b2(i, e ? \"minContains\" : \"contains\", `Expected array to contain at least ${e ?? 1}, but found ${o}`, r2) : t !== void 0 && o > t ? b2(i, \"maxContains\", `Expected array to contain at most ${t}, but found ${o}`, r2) : y2();\n    }, \"Li\");\n    Ki2 = /* @__PURE__ */ __name(({ prefixItems: n122 = [] }, e, t = {}) => {\n      if (!oe(e)) return y2();\n      for (let r2 = 0; r2 < e.length; r2++) {\n        let i = n122[r2]?.validate(e[r2], Se(t, String(r2), String(r2)));\n        if (i && i?.valid !== true) return i;\n      }\n      return y2();\n    }, \"Ki\");\n    Ln2 = { email: /* @__PURE__ */ __name((n122) => {\n      if (n122.length > 318) return false;\n      if (/^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(n122)) return true;\n      if (!n122.includes(\"@\") || /(^\\.|^\"|\\.@|\\.\\.)/.test(n122)) return false;\n      let [e, t, ...r2] = n122.split(\"@\");\n      return !e || !t || r2.length !== 0 || e.length > 64 || t.length > 253 || !/^[a-z0-9.-]+$/i.test(t) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(e) ? false : t.split(\".\").every((i) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(i));\n    }, \"email\"), hostname: /* @__PURE__ */ __name((n122) => n122.length > (n122.endsWith(\".\") ? 254 : 253) ? false : /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\\.?$/i.test(n122), \"hostname\"), date: /* @__PURE__ */ __name((n122) => {\n      if (n122.length !== 10) return false;\n      if (n122[5] === \"0\" && n122[6] === \"2\") {\n        if (/^\\d\\d\\d\\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(n122)) return true;\n        let e = n122.match(/^(\\d\\d\\d\\d)-02-29$/);\n        if (!e) return false;\n        let t = Number(e[1]);\n        return t % 16 === 0 || t % 4 === 0 && t % 25 !== 0;\n      }\n      return n122.endsWith(\"31\") ? /^\\d\\d\\d\\d-(?:0[13578]|1[02])-31$/.test(n122) : /^\\d\\d\\d\\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(n122);\n    }, \"date\"), time: /* @__PURE__ */ __name((n122) => {\n      if (n122.length > 27 || !/^(?:2[0-3]|[0-1]\\d):[0-5]\\d:(?:[0-5]\\d|60)(?:\\.\\d+)?(?:z|[+-](?:2[0-3]|[0-1]\\d)(?::?[0-5]\\d)?)?$/i.test(n122)) return false;\n      if (!/:60/.test(n122)) return true;\n      let e = n122.match(/([0-9.]+|[^0-9.])/g);\n      if (!e) return false;\n      let t = Number(e[0]) * 60 + Number(e[2]);\n      return e[5] === \"+\" ? t += 24 * 60 - Number(e[6] || 0) * 60 - Number(e[8] || 0) : e[5] === \"-\" && (t += Number(e[6] || 0) * 60 + Number(e[8] || 0)), t % (24 * 60) === 23 * 60 + 59;\n    }, \"time\"), \"date-time\": /* @__PURE__ */ __name((n122) => {\n      if (n122.length > 38) return false;\n      let e = /^\\d\\d\\d\\d-(?:0[1-9]|1[0-2])-(?:[0-2]\\d|3[01])[t\\s](?:2[0-3]|[0-1]\\d):[0-5]\\d:(?:[0-5]\\d|60)(?:\\.\\d+)?(?:z|[+-](?:2[0-3]|[0-1]\\d)(?::?[0-5]\\d)?)$/i, t = n122[5] === \"0\" && n122[6] === \"2\";\n      if (t && n122[8] === \"3\" || !e.test(n122)) return false;\n      if (n122[17] === \"6\") {\n        let r2 = n122.slice(11).match(/([0-9.]+|[^0-9.])/g);\n        if (!r2) return false;\n        let i = Number(r2[0]) * 60 + Number(r2[2]);\n        if (r2[5] === \"+\" ? i += 24 * 60 - Number(r2[6] || 0) * 60 - Number(r2[8] || 0) : r2[5] === \"-\" && (i += Number(r2[6] || 0) * 60 + Number(r2[8] || 0)), i % (24 * 60) !== 23 * 60 + 59) return false;\n      }\n      if (t) {\n        if (/^\\d\\d\\d\\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(n122)) return true;\n        let r2 = n122.match(/^(\\d\\d\\d\\d)-02-29/);\n        if (!r2) return false;\n        let i = Number(r2[1] ?? 0);\n        return i % 16 === 0 || i % 4 === 0 && i % 25 !== 0;\n      }\n      return n122[8] === \"3\" && n122[9] === \"1\" ? /^\\d\\d\\d\\d-(?:0[13578]|1[02])-31/.test(n122) : /^\\d\\d\\d\\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(n122);\n    }, \"date-time\"), ipv4: /* @__PURE__ */ __name((n122) => n122.length <= 15 && /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)$/.test(n122), \"ipv4\"), ipv6: /* @__PURE__ */ __name((n122) => {\n      if (n122.length > 45 || n122.length < 2) return false;\n      let e = 0, t = 0, r2 = 0, i = false, o = false, s2 = 0, l2 = true;\n      for (let c = 0; c < n122.length; c++) {\n        let u3 = n122.charCodeAt(c);\n        if (c === 1 && s2 === 58 && u3 !== 58) return false;\n        if (u3 >= 48 && u3 <= 57) {\n          if (++r2 > 4) return false;\n        } else if (u3 === 46) {\n          if (e > 6 || t >= 3 || r2 === 0 || o) return false;\n          t++, r2 = 0;\n        } else if (u3 === 58) {\n          if (t > 0 || e >= 7) return false;\n          if (s2 === 58) {\n            if (i) return false;\n            i = true;\n          } else c === 0 && (l2 = false);\n          e++, r2 = 0, o = false;\n        } else if (u3 >= 97 && u3 <= 102 || u3 >= 65 && u3 <= 70) {\n          if (t > 0 || ++r2 > 4) return false;\n          o = true;\n        } else return false;\n        s2 = u3;\n      }\n      if (e < 2 || t > 0 && (t !== 3 || r2 === 0)) return false;\n      if (i && n122.length === 2) return true;\n      if (t > 0 && !/(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}$/.test(n122)) return false;\n      let a2 = t > 0 ? 6 : 7;\n      return i ? (l2 || r2 > 0) && e < a2 : e === a2 && l2 && r2 > 0;\n    }, \"ipv6\"), uri: /* @__PURE__ */ __name((n122) => /^[a-z][a-z0-9+\\-.]*:(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/?(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i.test(n122), \"uri\"), \"uri-reference\": /* @__PURE__ */ __name((n122) => /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/?(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i.test(n122), \"uri-reference\"), \"uri-template\": /* @__PURE__ */ __name((n122) => /^(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2}|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i.test(n122), \"uri-template\"), \"json-pointer\": /* @__PURE__ */ __name((n122) => /^(?:|\\/(?:[^~]|~0|~1)*)$/.test(n122), \"json-pointer\"), \"relative-json-pointer\": /* @__PURE__ */ __name((n122) => /^(?:0|[1-9][0-9]*)(?:|#|\\/(?:[^~]|~0|~1)*)$/.test(n122), \"relative-json-pointer\"), uuid: /* @__PURE__ */ __name((n122) => /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(n122), \"uuid\"), duration: /* @__PURE__ */ __name((n122) => n122.length > 1 && n122.length < 80 && (/^P\\d+([.,]\\d+)?W$/.test(n122) || /^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(n122) && /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(n122)), \"duration\"), regex: /* @__PURE__ */ __name((n122) => {\n      if (/[^\\\\]\\\\Z/.test(n122)) return false;\n      try {\n        return new RegExp(n122, \"u\"), true;\n      } catch {\n        return false;\n      }\n    }, \"regex\") };\n    Vi = /* @__PURE__ */ __name(({ format: n122 }, e, t = {}) => !ee(e) || !n122 ? y2() : Ln2[n122] ? Ln2[n122](e) ? y2() : b2(t, \"format\", `Expected format: ${n122}`, e) : y2(), \"Vi\");\n    Lt2 = class {\n      static {\n        __name(this, \"Lt\");\n      }\n      constructor(n122) {\n        this.root = n122, this.cache = /* @__PURE__ */ new Map();\n      }\n      cache;\n      hasRef(n122, e) {\n        return e !== void 0 && \"$ref\" in n122 && ee(n122.$ref);\n      }\n      resolve(n122) {\n        let e = this.cache.get(n122);\n        if (!e) {\n          if (e = di(this.root, n122), !L(e)) throw new Error(`ref not found: ${n122}`);\n          if (\"$ref\" in e && e.$ref === n122) throw new Error(`ref loop: ${n122}`);\n          this.cache.set(n122, e);\n        }\n        return e;\n      }\n    };\n    Ji2 = { type: yi, const: fi, enum: mi, allOf: xi, anyOf: hi, oneOf: gi, not: bi, minLength: wi, maxLength: Si, pattern: Ti, format: Vi, minimum: Fi, exclusiveMinimum: Ci, maximum: Oi2, exclusiveMaximum: Ri, multipleOf: vi, required: _i, dependentRequired: Ii, dependentSchemas: ki, minProperties: ji2, maxProperties: Mi, propertyNames: Di, properties: $i2, patternProperties: Bi2, additionalProperties: Pi, minItems: qi2, maxItems: Ni2, uniqueItems: Qi2, contains: Li2, prefixItems: Ki2, items: Ai, if: Ei };\n    __name(zi2, \"zi\");\n    __name(Ui2, \"Ui\");\n    v2 = /* @__PURE__ */ __name((n122 = {}, e = \"any\") => {\n      let t = C(n122) ? n122 : {}, r2 = ke2(n122) ? n122 : Ee2 in n122 ? n122[Ee2] : void 0, i = { ...t, [Nt]: e, [Ee2]: r2, optional: /* @__PURE__ */ __name(function() {\n        return v2({ ...this, validate: void 0, [Ee2]: r2, [Qt2]: true }, e);\n      }, \"optional\"), template: /* @__PURE__ */ __name(function(o = {}) {\n        if (t.const !== void 0) return t.const;\n        if (t.default !== void 0) return t.default;\n        if (t.enum !== void 0) return t.enum[0];\n        if (t.template) return t.template(o);\n      }, \"template\"), toJSON: /* @__PURE__ */ __name(function() {\n        let o = this[Ee2];\n        return ke2(o) ? o : JSON.parse(JSON.stringify(t));\n      }, \"toJSON\") };\n      return i.coerce = function(o, s2 = {}) {\n        let l2 = { ...s2, resolver: s2.resolver || new Lt2(i), depth: s2.depth ? s2.depth + 1 : 0 }, a2 = o;\n        return \"coerce\" in t && t.coerce !== void 0 ? t.coerce(a2, l2) : Ui2(i, a2, l2);\n      }, i.validate = function(o, s2 = {}) {\n        if (ke2(r2)) return r2 === false ? b2(s2, \"\", \"Always fails\") : y2();\n        let l2 = s2.errors || [];\n        if (\"validate\" in t && t.validate !== void 0) {\n          let a2 = t.validate(o, s2);\n          a2.valid || (l2 = [...l2, ...a2.errors]);\n        }\n        return zi2(i, o, { ...s2, errors: l2 });\n      }, i;\n    }, \"v\");\n    Wi = /* @__PURE__ */ __name((n122 = {}) => v2(n122, \"any\"), \"Wi\");\n    We = /* @__PURE__ */ __name((n122, e = {}) => {\n      for (let r2 of Object.keys(n122 || {})) At2(ai(r2), \"invalid property name\", r2), At2(L(n122[r2]), \"properties must be managed schemas\", n122[r2]);\n      let t = Object.entries(n122 || {}).filter(([, r2]) => !(Qt2 in r2)).map(([r2]) => r2);\n      return v2({ template: zn2, coerce: Un2, ...e, type: \"object\", properties: n122, required: t.length > 0 ? t : void 0 }, \"object\");\n    }, \"We\");\n    Gi2 = /* @__PURE__ */ __name((n122, e = {}) => We(n122, { ...e, additionalProperties: v2(false) }), \"Gi\");\n    Hi = /* @__PURE__ */ __name((n122, e = {}) => {\n      let t = Object.fromEntries(Object.entries(n122).map(([r2, i]) => [r2, \"optional\" in i ? i.optional() : i]));\n      return We(t, e);\n    }, \"Hi\");\n    Yi = /* @__PURE__ */ __name((n122, e = {}, t) => v2({ template: zn2, coerce: Un2, ...e, type: \"object\", additionalProperties: We(n122, t) }, \"object\"), \"Yi\");\n    __name(zn2, \"zn\");\n    __name(Un2, \"Un\");\n    Wn2 = /* @__PURE__ */ __name((n122 = {}) => v2({ template: /* @__PURE__ */ __name(() => \"\", \"template\"), coerce: /* @__PURE__ */ __name((e) => ie(e) ? String(e) : e, \"coerce\"), ...n122, type: \"string\" }, \"string\"), \"Wn\");\n    Zi = /* @__PURE__ */ __name((n122, e = {}) => v2({ const: n122, default: n122, readOnly: true, template: /* @__PURE__ */ __name(() => n122, \"template\"), coerce: /* @__PURE__ */ __name((t) => String(t), \"coerce\"), ...e, type: \"string\" }, \"string\"), \"Zi\");\n    Gn2 = /* @__PURE__ */ __name((n122 = {}) => v2({ coerce: /* @__PURE__ */ __name((e) => ee(e) ? Number(e) : e, \"coerce\"), template: Yn2, ...n122, type: \"number\" }, \"number\"), \"Gn\");\n    Hn2 = /* @__PURE__ */ __name((n122 = {}) => v2({ coerce: /* @__PURE__ */ __name((e) => ee(e) ? Number.parseInt(e) : e, \"coerce\"), template: Yn2, ...n122, type: \"integer\" }, \"integer\"), \"Hn\");\n    __name(Yn2, \"Yn\");\n    Zn2 = /* @__PURE__ */ __name((n122, e = {}) => (n122 !== void 0 && At2(L(n122), \"items must be a schema\", n122), v2({ template: /* @__PURE__ */ __name(() => [], \"template\"), coerce: Xi, ...e, type: \"array\", items: n122 }, \"array\")), \"Zn\");\n    __name(Xi, \"Xi\");\n    Xn2 = /* @__PURE__ */ __name((n122 = {}) => v2({ ...n122, coerce: /* @__PURE__ */ __name(function(e) {\n      if (\"coerce\" in n122 && n122.coerce) return n122.coerce(e);\n      if (ee(e) && [\"true\", \"false\", \"1\", \"0\"].includes(e)) return e === \"true\" || e === \"1\";\n      if (ie(e)) {\n        if (e === 1) return true;\n        if (e === 0) return false;\n      }\n      return e;\n    }, \"coerce\"), type: \"boolean\" }, \"boolean\"), \"Xn\");\n    __name(Kn2, \"Kn\");\n    __name(Vn2, \"Vn\");\n    __name(Te2, \"Te\");\n    eo = /* @__PURE__ */ __name((n122, e = {}) => v2({ ...e, coerce: /* @__PURE__ */ __name(function(t, r2 = {}) {\n      let i = t;\n      if (\"coerce\" in e && e.coerce !== void 0) return e.coerce.bind(this)(t, r2);\n      let o = Ue(n122, i, { ignoreUnsupported: true, resolver: r2.resolver, coerce: true });\n      return o.length > 0 ? o[0].coerce(i, r2) : i;\n    }, \"coerce\"), anyOf: n122 }, \"anyOf\"), \"eo\");\n    to = /* @__PURE__ */ __name((n122, e = {}) => v2({ ...e, coerce: /* @__PURE__ */ __name(function(t, r2 = {}) {\n      let i = Ue(n122, t, { ignoreUnsupported: true, resolver: r2.resolver, coerce: true });\n      return i.length === 1 ? i[0].coerce(t, r2) : t;\n    }, \"coerce\"), oneOf: n122 }, \"oneOf\"), \"to\");\n    no = /* @__PURE__ */ __name((n122, e) => {\n      if (!n122.$id) throw new Error(\"Schema must have an $id\");\n      return v2({ $ref: e ?? n122.$id, coerce: /* @__PURE__ */ __name(function(t, r2 = {}) {\n        return n122.coerce(t, r2);\n      }, \"coerce\") }, \"ref\");\n    }, \"no\");\n    ro = /* @__PURE__ */ __name((n122) => v2({ $ref: n122 }, \"ref\"), \"ro\");\n    io = /* @__PURE__ */ __name((n122) => {\n      let { validate: e, ...t } = n122(v2({ $ref: \"#\" }, \"recursive\"));\n      return v2(t, \"recursive\");\n    }, \"io\");\n    j2 = class {\n      static {\n        __name(this, \"j\");\n      }\n      _returning;\n      static slug = \"untitled-event\";\n      params;\n      returned = false;\n      validate(e) {\n        throw new Kt2(this, e);\n      }\n      clone(e) {\n        let t = new this.constructor(e);\n        return t.returned = true, t;\n      }\n      constructor(e) {\n        this.params = e;\n      }\n    };\n    fe = class extends Error {\n      static {\n        __name(this, \"fe\");\n      }\n      constructor(e, t) {\n        super(`Expected \"${e}\", got \"${t}\"`);\n      }\n    };\n    Kt2 = class extends Error {\n      static {\n        __name(this, \"Kt\");\n      }\n      constructor(t, r2) {\n        super(`Event \"${t.constructor.slug}\" returned without validation`);\n        this.data = r2;\n      }\n    };\n    at = class {\n      static {\n        __name(this, \"at\");\n      }\n      mode = \"async\";\n      event;\n      handler;\n      once = false;\n      id;\n      constructor(e, t, r2 = \"async\", i) {\n        this.event = e, this.handler = t, this.mode = r2, this.id = i;\n      }\n    };\n    se2 = class {\n      static {\n        __name(this, \"se\");\n      }\n      constructor(e, t) {\n        this.options = t;\n        e && this.registerEvents(e), t?.listeners?.forEach((r2) => this.addListener(r2));\n      }\n      events = [];\n      listeners = [];\n      enabled = true;\n      asyncs = [];\n      enable() {\n        return this.enabled = true, this;\n      }\n      disable() {\n        return this.enabled = false, this;\n      }\n      clearEvents() {\n        return this.events = [], this;\n      }\n      clearAll() {\n        return this.clearEvents(), this.listeners = [], this;\n      }\n      getListeners() {\n        return [...this.listeners];\n      }\n      get Events() {\n        return new Proxy(this, { get: /* @__PURE__ */ __name((e, t) => this.events.find((r2) => r2.slug === t), \"get\") });\n      }\n      eventExists(e) {\n        let t;\n        return typeof e == \"string\" ? t = e : t = e.constructor?.slug ?? e.slug, !!this.events.find((r2) => t === r2.slug);\n      }\n      throwIfEventNotRegistered(e) {\n        if (!this.eventExists(e)) {\n          let t = e.constructor?.slug ?? e.slug ?? e;\n          throw new Error(`Event \"${t}\" not registered`);\n        }\n      }\n      registerEvent(e, t = false) {\n        if (this.eventExists(e)) {\n          if (t) return this;\n          throw new Error(`Event \"${e.name}\" already registered.`);\n        }\n        return this.events.push(e), this;\n      }\n      registerEvents(e) {\n        return (typeof e == \"object\" ? Object.values(e) : e).forEach((r2) => this.registerEvent(r2, true)), this;\n      }\n      addListener(e) {\n        return this.throwIfEventNotRegistered(e.event), e.id && this.listeners.find((r2) => r2.id === e.id) ? (g.debug(`Listener with id \"${e.id}\" already exists.`), this) : (this.listeners.push(e), this);\n      }\n      createEventListener(e, t, r2 = \"async\") {\n        let i = typeof e == \"string\" ? this.events.find((l2) => l2.slug === e) : e, o = typeof r2 == \"string\" ? { mode: r2 } : r2, s2 = new at(i, t, o.mode);\n        o.once && (s2.once = true), o.id && (s2.id = `${i.slug}-${o.id}`), this.addListener(s2);\n      }\n      onEvent(e, t, r2) {\n        this.createEventListener(e, t, r2);\n      }\n      on(e, t, r2) {\n        this.createEventListener(e, t, r2);\n      }\n      onAny(e, t) {\n        this.events.forEach((r2) => this.onEvent(r2, e, t));\n      }\n      collectAsyncs(e) {\n        this.asyncs.push(...e);\n      }\n      async executeAsyncs(e = (t) => Promise.all(t)) {\n        if (this.asyncs.length === 0) return;\n        let t = [...this.asyncs];\n        this.asyncs = [], await e(t.map((r2) => r2()));\n      }\n      async emit(e) {\n        let t = e.constructor.slug;\n        if (!this.enabled) return g.debug(\"EventManager disabled, not emitting\", t), e;\n        if (!this.eventExists(e)) throw new Error(`Event \"${t}\" not registered`);\n        let r2 = [], i = [];\n        this.listeners = this.listeners.filter((s2) => s2.event.slug !== t ? true : (s2.mode === \"sync\" ? r2.push(s2) : i.push(async () => await s2.handler(e, s2.event.slug)), !s2.once)), this.collectAsyncs(i);\n        let o = e;\n        for (let s2 of r2) try {\n          let l2 = await s2.handler(o, s2.event.slug);\n          if (typeof l2 < \"u\") {\n            let a2 = o.validate(l2);\n            if (a2 && a2.constructor.slug === t) {\n              if (!a2.returned) throw new Error(`Returned event ${a2.constructor.slug} must be marked as returned.`);\n              o = a2;\n            }\n          }\n        } catch (l2) {\n          if (l2 instanceof fe) this.options?.onInvalidReturn?.(o, l2), g.warn(`Invalid return of event listener for \"${t}\": ${l2.message}`);\n          else if (this.options?.onError) this.options.onError(o, l2);\n          else throw l2;\n        }\n        return o;\n      }\n    };\n    Vt = class extends j2 {\n      static {\n        __name(this, \"Vt\");\n      }\n      static slug = \"mutator-insert-before\";\n      validate(e) {\n        let { entity: t } = this.params;\n        if (!t.isValidData(e, \"create\")) throw g.warn(\"MutatorInsertBefore.validate: invalid\", { entity: t.name, data: e }), new fe(\"EntityData\", \"invalid\");\n        return this.clone({ entity: t, data: e });\n      }\n    };\n    Jt = class extends j2 {\n      static {\n        __name(this, \"Jt\");\n      }\n      static slug = \"mutator-insert-after\";\n    };\n    zt = class extends j2 {\n      static {\n        __name(this, \"zt\");\n      }\n      static slug = \"mutator-update-before\";\n      validate(e) {\n        let { entity: t, entityId: r2 } = this.params;\n        if (!t.isValidData(e, \"update\")) throw g.warn(\"MutatorUpdateBefore.validate: invalid\", { entity: t.name, entityId: r2, data: e }), new fe(\"EntityData\", \"invalid\");\n        return this.clone({ entityId: r2, entity: t, data: e });\n      }\n    };\n    Ut = class extends j2 {\n      static {\n        __name(this, \"Ut\");\n      }\n      static slug = \"mutator-update-after\";\n    };\n    Wt = class extends j2 {\n      static {\n        __name(this, \"Wt\");\n      }\n      static slug = \"mutator-delete-before\";\n    };\n    Gt = class extends j2 {\n      static {\n        __name(this, \"Gt\");\n      }\n      static slug = \"mutator-delete-after\";\n    };\n    ae2 = { MutatorInsertBefore: Vt, MutatorInsertAfter: Jt, MutatorUpdateBefore: zt, MutatorUpdateAfter: Ut, MutatorDeleteBefore: Wt, MutatorDeleteAfter: Gt };\n    Ht = class extends j2 {\n      static {\n        __name(this, \"Ht\");\n      }\n      static slug = \"repository-find-one-before\";\n    };\n    Yt2 = class extends j2 {\n      static {\n        __name(this, \"Yt\");\n      }\n      static slug = \"repository-find-one-after\";\n    };\n    Zt = class extends j2 {\n      static {\n        __name(this, \"Zt\");\n      }\n      static slug = \"repository-find-many-before\";\n      static another = \"one\";\n    };\n    Xt = class extends j2 {\n      static {\n        __name(this, \"Xt\");\n      }\n      static slug = \"repository-find-many-after\";\n    };\n    je = { RepositoryFindOneBefore: Ht, RepositoryFindOneAfter: Yt2, RepositoryFindManyBefore: Zt, RepositoryFindManyAfter: Xt };\n    lt2 = class extends Y2 {\n      static {\n        __name(this, \"lt\");\n      }\n      name = \"UnableToConnectException\";\n      code = 500;\n    };\n    q = class extends Y2 {\n      static {\n        __name(this, \"q\");\n      }\n      name = \"InvalidSearchParamsException\";\n      code = 422;\n    };\n    ct = class extends Y2 {\n      static {\n        __name(this, \"ct\");\n      }\n      name = \"TransformRetrieveFailedException\";\n      code = 422;\n    };\n    R3 = class n25 extends Y2 {\n      static {\n        __name(this, \"n\");\n      }\n      name = \"TransformPersistFailedException\";\n      code = 422;\n      static invalidType(e, t, r2) {\n        let i = typeof r2 == \"object\" ? JSON.stringify(r2) : r2, o = `Property \"${e}\" must be of type \"${t}\", \"${i}\" of type \"${typeof r2}\" given.`;\n        return new n25(o);\n      }\n      static required(e) {\n        return new n25(`Property \"${e}\" is required`);\n      }\n    };\n    ut2 = class extends Y2 {\n      static {\n        __name(this, \"ut\");\n      }\n      constructor(t, r2, i) {\n        console.error(\"InvalidFieldConfigException\", { given: r2, error: i.firstToString() });\n        super(`Invalid Field config given for field \"${t.name}\": ${i.firstToString()}`);\n        this.given = r2;\n      }\n      name = \"InvalidFieldConfigException\";\n      code = 400;\n    };\n    pt = class extends Y2 {\n      static {\n        __name(this, \"pt\");\n      }\n      name = \"EntityNotDefinedException\";\n      code = 400;\n      constructor(e) {\n        e ? super(`Entity \"${typeof e != \"string\" ? e.name : e}\" not defined`) : super(\"Cannot find an entity that is undefined\");\n      }\n    };\n    ({ Type: S } = p$1);\n    so = [\"create\", \"read\", \"update\", \"delete\"];\n    ao = [\"create\", \"read\", \"update\", \"delete\", \"form\", \"table\", \"submit\"];\n    lo = false;\n    en2 = true;\n    tn2 = false;\n    w2 = S.Object({ label: S.Optional(S.String()), description: S.Optional(S.String()), required: S.Optional(S.Boolean({ default: lo })), fillable: S.Optional(S.Union([S.Boolean({ title: \"Boolean\", default: en2 }), S.Array($2(so), { title: \"Context\", uniqueItems: true })], { default: en2 })), hidden: S.Optional(S.Union([S.Boolean({ title: \"Boolean\", default: tn2 }), S.Array($2(ao), { title: \"Context\", uniqueItems: true })], { default: tn2 })), virtual: S.Optional(S.Boolean()), default_value: S.Optional(S.Any()) }, { additionalProperties: false });\n    E2 = class {\n      static {\n        __name(this, \"E\");\n      }\n      _required;\n      _type;\n      name;\n      type = \"field\";\n      config;\n      constructor(e, t) {\n        this.name = e, this._type, this._required;\n        try {\n          this.config = _e(this.getSchema(), t || {});\n        } catch (r2) {\n          throw r2 instanceof Ve ? new ut2(this, t, r2) : r2;\n        }\n      }\n      getType() {\n        return this.type;\n      }\n      schema() {\n        return Object.freeze({ name: this.name, type: \"text\", nullable: true, dflt: this.getDefault() });\n      }\n      hasDefault() {\n        return this.config.default_value !== void 0;\n      }\n      getDefault() {\n        return this.config?.default_value;\n      }\n      isFillable(e) {\n        return Array.isArray(this.config.fillable) ? e ? this.config.fillable.includes(e) : en2 : !!this.config.fillable;\n      }\n      isHidden(e) {\n        return Array.isArray(this.config.hidden) ? e ? this.config.hidden.includes(e) : tn2 : this.config.hidden ?? false;\n      }\n      isRequired() {\n        return this.config?.required ?? false;\n      }\n      isVirtual() {\n        return this.config.virtual ?? false;\n      }\n      getLabel(e) {\n        return this.config.label ? this.config.label : e?.fallback !== false ? Ie(this.name) : void 0;\n      }\n      getDescription() {\n        return this.config.description;\n      }\n      getValue(e, t) {\n        return e;\n      }\n      getHtmlConfig() {\n        return { element: \"input\", props: { type: \"text\" } };\n      }\n      isValid(e, t) {\n        return typeof e < \"u\" ? this.isFillable(t) : t === \"create\" ? !this.isRequired() : true;\n      }\n      transformRetrieve(e) {\n        return e;\n      }\n      async transformPersist(e, t, r2) {\n        if (this.nullish(e)) {\n          if (this.isRequired() && !this.hasDefault()) throw R3.required(this.name);\n          return this.getDefault();\n        }\n        return e;\n      }\n      toSchemaWrapIfRequired(e) {\n        return this.isRequired() ? e : S.Optional(e);\n      }\n      nullish(e) {\n        return e == null;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(S.Any());\n      }\n      toType() {\n        return { required: this.isRequired(), comment: this.getDescription(), type: \"any\" };\n      }\n      toJSON() {\n        return { type: this.type, config: this.config };\n      }\n    };\n    ({ Type: Ge } = p$1);\n    nn2 = Ge.Composite([Ge.Object({ default_value: Ge.Optional(Ge.Boolean({ default: false })) }), w2]);\n    Me = class extends E2 {\n      static {\n        __name(this, \"Me\");\n      }\n      type = \"boolean\";\n      getSchema() {\n        return nn2;\n      }\n      getValue(e, t) {\n        switch (t) {\n          case \"table\":\n            return e ? \"Yes\" : \"No\";\n          default:\n            return e;\n        }\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: \"boolean\" });\n      }\n      getHtmlConfig() {\n        return { ...super.getHtmlConfig(), element: \"boolean\" };\n      }\n      transformRetrieve(e) {\n        return typeof e > \"u\" || e === null ? this.isRequired() ? false : this.hasDefault() ? this.getDefault() : null : typeof e == \"string\" ? e === \"1\" : !!e;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return this.isRequired() ? !!this.config.default_value : void 0;\n        if (typeof i == \"number\") return i !== 0;\n        if (typeof i != \"boolean\") throw R3.invalidType(this.name, \"boolean\", i);\n        return i;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(Ge.Boolean({ default: this.getDefault() }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"boolean\" };\n      }\n    };\n    ({ Type: le } = p$1);\n    rn2 = le.Composite([le.Object({ type: $2([\"date\", \"datetime\", \"week\"], { default: \"date\" }), timezone: le.Optional(le.String()), min_date: le.Optional(le.String()), max_date: le.Optional(le.String()) }), w2], { additionalProperties: false });\n    ve = class extends E2 {\n      static {\n        __name(this, \"ve\");\n      }\n      type = \"date\";\n      getSchema() {\n        return rn2;\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: this.config.type === \"datetime\" ? \"datetime\" : \"date\" });\n      }\n      getHtmlConfig() {\n        let e = this.config.type === \"datetime\" ? \"datetime-local\" : this.config.type;\n        return { ...super.getHtmlConfig(), element: \"date\", props: { type: e } };\n      }\n      parseDateFromString(e) {\n        if (this.config.type === \"week\" && e.includes(\"-W\")) {\n          let [t, r2] = e.split(\"-W\").map((i) => Number.parseInt(i, 10));\n          return ze$2().year(t).week(r2).toDate();\n        }\n        return new Date(e);\n      }\n      getValue(e, t) {\n        if (e === null || !e) return;\n        let r2 = this.parseDateFromString(e);\n        if (t === \"submit\") try {\n          return r2.toISOString();\n        } catch {\n          return;\n        }\n        if (this.config.type === \"week\") try {\n          return `${r2.getFullYear()}-W${ze$2(r2).week()}`;\n        } catch (i) {\n          g.warn(\"DateField.getValue:week error\", e, String(i));\n          return;\n        }\n        try {\n          let o = (/* @__PURE__ */ new Date()).getTimezoneOffset(), s2 = new Date(r2.getTime() - o * 6e4);\n          return this.formatDate(s2);\n        } catch (i) {\n          g.warn(\"DateField.getValue error\", this.config.type, e, String(i));\n          return;\n        }\n      }\n      formatDate(e) {\n        switch (this.config.type) {\n          case \"datetime\":\n            return e.toISOString().split(\".\")[0].replace(\"T\", \" \");\n          default:\n            return e.toISOString().split(\"T\")[0];\n        }\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        if (t === null) return null;\n        try {\n          return new Date(t);\n        } catch {\n          return null;\n        }\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        switch (this.config.type) {\n          case \"date\":\n          case \"week\":\n            return new Date(i).toISOString().split(\"T\")[0];\n          default:\n            return new Date(i).toISOString();\n        }\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(le.String({ default: this.getDefault() }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"Date | string\" };\n      }\n    };\n    ({ Type: M2 } = p$1);\n    on3 = M2.Composite([M2.Object({ default_value: M2.Optional(M2.String()), options: M2.Optional(M2.Union([M2.Object({ type: _t(\"strings\"), values: M2.Array(M2.String()) }, { title: \"Strings\" }), M2.Object({ type: _t(\"objects\"), values: M2.Array(M2.Object({ label: M2.String(), value: M2.String() })) }, { title: \"Objects\", additionalProperties: false })])) }), w2], { additionalProperties: false });\n    Be = class extends E2 {\n      static {\n        __name(this, \"Be\");\n      }\n      type = \"enum\";\n      constructor(e, t) {\n        if (super(e, t), this.config.default_value && !this.isValidValue(this.config.default_value)) throw new Error(`Default value \"${this.config.default_value}\" is not a valid option`);\n      }\n      getSchema() {\n        return on3;\n      }\n      getOptions() {\n        let e = this.config?.options ?? { type: \"strings\", values: [] };\n        return e.type === \"strings\" ? e.values?.map((t) => ({ label: t, value: t })) : e?.values;\n      }\n      isValidValue(e) {\n        return this.getOptions().map((r2) => r2.value).includes(e);\n      }\n      getValue(e, t) {\n        if (!this.isValidValue(e)) return this.hasDefault() ? this.getDefault() : null;\n        switch (t) {\n          case \"table\":\n            return this.getOptions().find((r2) => r2.value === e)?.label ?? e;\n        }\n        return e;\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        return t === null && this.hasDefault() ? this.getDefault() : this.isValidValue(t) ? t : this.hasDefault() ? this.getDefault() : null;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (!this.isValidValue(i)) throw new R3(`Field \"${this.name}\" must be one of the following values: ${this.getOptions().map((o) => o.value).join(\", \")}`);\n        return i;\n      }\n      toJsonSchema() {\n        let t = (this.config?.options ?? { values: [] }).values?.map((r2) => typeof r2 == \"string\" ? r2 : r2.value) ?? [];\n        return this.toSchemaWrapIfRequired($2(t, { default: this.getDefault() }));\n      }\n      toType() {\n        let e = this.getOptions().map(({ value: t }) => typeof t == \"string\" ? `\"${t}\"` : t);\n        return { ...super.toType(), type: e.length > 0 ? e.join(\" | \") : \"string\" };\n      }\n    };\n    ({ Type: er } = p$1);\n    sn2 = er.Composite([w2, er.Object({})]);\n    De2 = class extends E2 {\n      static {\n        __name(this, \"De\");\n      }\n      type = \"json\";\n      getSchema() {\n        return sn2;\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        return t === null && this.hasDefault() ? this.getDefault() : this.isSerialized(t) ? JSON.parse(t) : t;\n      }\n      isSerializable(e) {\n        try {\n          let t = JSON.stringify(e);\n          if (t === JSON.stringify(JSON.parse(t))) return true;\n        } catch {\n        }\n        return false;\n      }\n      isSerialized(e) {\n        try {\n          if (typeof e == \"string\") return e === JSON.stringify(JSON.parse(e));\n        } catch {\n        }\n        return false;\n      }\n      getValue(e, t) {\n        switch (t) {\n          case \"form\":\n            return e === null ? \"\" : JSON.stringify(e, null, 2);\n          case \"table\":\n            return e === null ? null : JSON.stringify(e);\n          case \"submit\":\n            return typeof e == \"string\" && e.length === 0 ? null : JSON.parse(e);\n        }\n        return e;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (!this.isSerializable(i)) throw new R3(`Field \"${this.name}\" must be serializable to JSON.`);\n        return this.isSerialized(i) ? i : JSON.stringify(i);\n      }\n      toType() {\n        return { ...super.toType(), type: \"any\" };\n      }\n    };\n    ({ Type: Oe } = p$1);\n    an = Oe.Composite([Oe.Object({ schema: Oe.Object({}, { default: {} }), ui_schema: Oe.Optional(Oe.Object({})), default_from_schema: Oe.Optional(Oe.Boolean()) }), w2], { additionalProperties: false });\n    Ae = class extends E2 {\n      static {\n        __name(this, \"Ae\");\n      }\n      type = \"jsonschema\";\n      validator;\n      constructor(e, t) {\n        super(e, t), this.validator = new Validator(this.getJsonSchema());\n      }\n      getSchema() {\n        return an;\n      }\n      getJsonSchema() {\n        return this.config?.schema;\n      }\n      getJsonUiSchema() {\n        return this.config.ui_schema ?? {};\n      }\n      isValid(e, t = \"update\") {\n        return super.isValid(e, t) ? !this.isRequired() && (!e || typeof e != \"object\") ? true : this.validator.validate(e).valid : false;\n      }\n      getValue(e, t) {\n        switch (t) {\n          case \"form\":\n            return e === null ? \"\" : e;\n          case \"table\":\n            return e === null ? null : JSON.stringify(e);\n        }\n        return e;\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        if (t === null) {\n          if (this.config.default_from_schema) try {\n            return Default(de2(this.getJsonSchema()), {});\n          } catch {\n            return null;\n          }\n          else if (this.hasDefault()) return this.getDefault();\n        }\n        return t;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (!this.isValid(i)) throw new R3(this.name, i);\n        return !i || typeof i != \"object\" ? this.getDefault() : JSON.stringify(i);\n      }\n      toJsonSchema() {\n        let e = this.getJsonSchema() ?? { type: \"object\" };\n        return this.toSchemaWrapIfRequired(de2({ default: this.getDefault(), ...e }));\n      }\n      toType() {\n        return { ...super.toType(), import: [{ package: \"json-schema-to-ts\", name: \"FromSchema\" }], type: `FromSchema<${nt2(this.getJsonSchema(), 2, 1)}>` };\n      }\n    };\n    ({ Type: _2 } = p$1);\n    ln = _2.Composite([_2.Object({ default_value: _2.Optional(_2.Number()), minimum: _2.Optional(_2.Number()), maximum: _2.Optional(_2.Number()), exclusiveMinimum: _2.Optional(_2.Number()), exclusiveMaximum: _2.Optional(_2.Number()), multipleOf: _2.Optional(_2.Number()) }), w2], { additionalProperties: false });\n    me = class extends E2 {\n      static {\n        __name(this, \"me\");\n      }\n      type = \"number\";\n      getSchema() {\n        return ln;\n      }\n      getHtmlConfig() {\n        return { element: \"input\", props: { type: \"number\", pattern: \"d*\", inputMode: \"numeric\" } };\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: \"integer\" });\n      }\n      getValue(e, t) {\n        if (typeof e > \"u\" || e === null) return null;\n        switch (t) {\n          case \"submit\":\n            return Number.parseInt(e);\n        }\n        return e;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (!this.nullish(i) && typeof i != \"number\") throw R3.invalidType(this.name, \"number\", i);\n        if (this.config.maximum && i > this.config.maximum) throw new R3(`Field \"${this.name}\" cannot be greater than ${this.config.maximum}`);\n        if (this.config.minimum && i < this.config.minimum) throw new R3(`Field \"${this.name}\" cannot be less than ${this.config.minimum}`);\n        return i;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(_2.Number({ default: this.getDefault(), minimum: this.config?.minimum, maximum: this.config?.maximum, exclusiveMinimum: this.config?.exclusiveMinimum, exclusiveMaximum: this.config?.exclusiveMaximum, multipleOf: this.config?.multipleOf }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"number\" };\n      }\n    };\n    ({ Type: he } = p$1);\n    He = [\"integer\", \"uuid\"];\n    cn = he.Composite([he.Omit(w2, [\"required\"]), he.Object({ format: he.Optional($2(He, { default: \"integer\" })), required: he.Optional(he.Literal(false)) })]);\n    z = class extends E2 {\n      static {\n        __name(this, \"z\");\n      }\n      type = \"primary\";\n      constructor(e = Qe.data.default_primary_field, t) {\n        super(e, { fillable: false, required: false, ...t });\n      }\n      isRequired() {\n        return false;\n      }\n      getSchema() {\n        return cn;\n      }\n      get format() {\n        return this.config.format ?? \"integer\";\n      }\n      get fieldType() {\n        return this.format === \"integer\" ? \"integer\" : \"text\";\n      }\n      schema() {\n        return Object.freeze({ type: this.fieldType, name: this.name, primary: true, nullable: false });\n      }\n      getNewValue() {\n        if (this.format === \"uuid\") return An2();\n      }\n      async transformPersist(e) {\n        throw new Error(\"PrimaryField: This function should not be called\");\n      }\n      toJsonSchema() {\n        return this.format === \"uuid\" ? this.toSchemaWrapIfRequired(he.String({ writeOnly: void 0 })) : this.toSchemaWrapIfRequired(he.Number({ writeOnly: void 0 }));\n      }\n      toType() {\n        let e = this.format === \"integer\" ? \"number\" : \"string\";\n        return { ...super.toType(), required: true, import: [{ package: \"kysely\", name: \"Generated\" }], type: `Generated<${e}>` };\n      }\n    };\n    ({ Type: F } = p$1);\n    un = F.Composite([F.Object({ default_value: F.Optional(F.String()), minLength: F.Optional(F.Number()), maxLength: F.Optional(F.Number()), pattern: F.Optional(F.String()), html_config: F.Optional(F.Object({ element: F.Optional(F.String({ default: \"input\" })), props: F.Optional(F.Object({}, { additionalProperties: F.Union([F.String({ title: \"String\" }), F.Number({ title: \"Number\" })]) })) })) }), w2], { additionalProperties: false });\n    ge = class extends E2 {\n      static {\n        __name(this, \"ge\");\n      }\n      type = \"text\";\n      getSchema() {\n        return un;\n      }\n      getHtmlConfig() {\n        return this.config.html_config ? this.config.html_config : super.getHtmlConfig();\n      }\n      transformRetrieve(e) {\n        let t = super.transformRetrieve(e);\n        return this.config.maxLength ? t.substring(0, this.config.maxLength) : this.isRequired() ? t ? t.toString() : \"\" : t;\n      }\n      async transformPersist(e, t, r2) {\n        let i = await super.transformPersist(e, t, r2);\n        if (this.nullish(i)) return i;\n        if (i !== null && typeof i != \"string\" && (i = String(i)), this.config.maxLength && i?.length > this.config.maxLength) throw new R3(`Field \"${this.name}\" must be at most ${this.config.maxLength} character(s)`);\n        if (this.config.minLength && i?.length < this.config.minLength) throw new R3(`Field \"${this.name}\" must be at least ${this.config.minLength} character(s)`);\n        if (this.config.pattern && i && !new RegExp(this.config.pattern).test(i)) throw new R3(`Field \"${this.name}\" must match the pattern ${this.config.pattern}`);\n        return i;\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(F.String({ default: this.getDefault(), minLength: this.config?.minLength, maxLength: this.config?.maxLength, pattern: this.config?.pattern }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"string\" };\n      }\n    };\n    ({ Type: pn2 } = p$1);\n    pn2.Composite([w2, pn2.Object({})]);\n    dt = class {\n      static {\n        __name(this, \"dt\");\n      }\n      constructor(e, t, r2 = false, i) {\n        this.entity = e;\n        this.fields = t;\n        this.unique = r2;\n        this.name = i;\n        if (t.length === 0) throw new Error(\"Indices must contain at least one field\");\n        if (t.some((o) => !(o instanceof E2))) throw new Error(\"All fields must be instances of Field\");\n        if (r2 && !t[0]?.isRequired()) throw new Error(`Unique indices must have first field as required: ${t.map((s2) => s2.name).join(\", \")}`);\n        i || (this.name = [r2 ? \"idx_unique\" : \"idx\", e.name, ...t.map((o) => o.name)].join(\"_\"));\n      }\n      toJSON() {\n        return { entity: this.entity.name, fields: this.fields.map((e) => e.name), unique: this.unique };\n      }\n    };\n    nr2 = { primary: { schema: cn, field: z }, text: { schema: un, field: ge }, number: { schema: ln, field: me }, boolean: { schema: nn2, field: Me }, date: { schema: rn2, field: ve }, enum: { schema: on3, field: Be }, json: { schema: sn2, field: De2 }, jsonschema: { schema: an, field: Ae } };\n    ({ Type: K } = p$1);\n    dn2 = K.Object({ name: K.Optional(K.String()), name_singular: K.Optional(K.String()), description: K.Optional(K.String()), sort_field: K.Optional(K.String({ default: Qe.data.default_primary_field })), sort_dir: K.Optional($2([\"asc\", \"desc\"], { default: \"asc\" })), primary_format: K.Optional($2(He)) }, { additionalProperties: false });\n    rr = [\"regular\", \"system\", \"generated\"];\n    V2 = class n26 {\n      static {\n        __name(this, \"n2\");\n      }\n      #e;\n      #t;\n      name;\n      fields;\n      config;\n      data;\n      type = \"regular\";\n      constructor(e, t, r2, i) {\n        if (typeof e != \"string\" || e.length === 0) throw new Error(\"Entity name must be a non-empty string\");\n        this.name = e, this.config = _e(dn2, r2 || {});\n        let o = t?.filter((s2) => s2 instanceof z).length ?? 0;\n        if (o > 1) throw new Error(`Entity \"${e}\" has more than one primary field`);\n        this.fields = o === 1 ? [] : [new z(void 0, { format: this.config.primary_format })], t && t.forEach((s2) => this.addField(s2)), i && (this.type = i);\n      }\n      static create(e) {\n        return new n26(e.name, e.fields, e.config, e.type);\n      }\n      getType() {\n        return this.type;\n      }\n      getSelect(e, t) {\n        return this.getFields().filter((r2) => !r2.isHidden(t ?? \"read\")).map((r2) => e ? `${e}.${r2.name} as ${r2.name}` : r2.name);\n      }\n      getDefaultSort() {\n        return { by: this.config.sort_field ?? \"id\", dir: this.config.sort_dir ?? \"asc\" };\n      }\n      getAliasedSelectFrom(e, t, r2) {\n        let i = t ?? this.name;\n        return this.getFields().filter((o) => !o.isVirtual() && !o.isHidden(r2 ?? \"read\") && e.includes(o.name)).map((o) => i ? `${i}.${o.name} as ${o.name}` : o.name);\n      }\n      getFillableFields(e, t) {\n        return this.getFields(t).filter((r2) => r2.isFillable(e));\n      }\n      getRequiredFields() {\n        return this.getFields().filter((e) => e.isRequired());\n      }\n      getDefaultObject() {\n        return this.getFields().reduce((e, t) => (t.hasDefault() && (e[t.name] = t.getDefault()), e), {});\n      }\n      getField(e) {\n        return this.fields.find((t) => t.name === e);\n      }\n      __replaceField(e, t) {\n        let r2 = this.fields.findIndex((i) => i.name === e);\n        if (r2 === -1) throw new Error(`Field \"${e}\" not found on entity \"${this.name}\"`);\n        this.fields[r2] = t;\n      }\n      getPrimaryField() {\n        return this.fields[0];\n      }\n      id() {\n        return this.getPrimaryField();\n      }\n      get label() {\n        return this.config.name ?? Ie(this.name);\n      }\n      field(e) {\n        return this.getField(e);\n      }\n      hasField(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        return this.fields.findIndex((r2) => r2.name === t) !== -1;\n      }\n      getFields(e = false) {\n        return e ? this.fields : this.fields.filter((t) => !t.isVirtual());\n      }\n      addField(e) {\n        let t = this.getField(e.name);\n        if (t) {\n          if (JSON.stringify(t) === JSON.stringify(e)) {\n            g.warn(`Field \"${e.name}\" already exists on entity \"${this.name}\", but it's the same, so skipping.`);\n            return;\n          }\n          throw new Error(`Field \"${e.name}\" already exists on entity \"${this.name}\"`);\n        }\n        this.fields.push(e);\n      }\n      __setData(e) {\n        this.data = e;\n      }\n      isValidData(e, t, r2) {\n        if (typeof e != \"object\" && r2?.explain) throw new Error(`Entity \"${this.name}\" data must be an object`);\n        let i = this.getFillableFields(t, false);\n        if (r2?.ignoreUnknown !== true) {\n          let o = i.map((a2) => a2.name), l2 = Object.keys(e).filter((a2) => !o.includes(a2));\n          if (l2.length > 0 && r2?.explain) throw new Error(`Entity \"${this.name}\" data must only contain known keys, unknown: \"${l2}\"`);\n        }\n        for (let o of i) if (!o.isValid(e?.[o.name], t)) {\n          if (g.warn(\"invalid data given for\", this.name, t, o.name, e[o.name]), r2?.explain) throw new Error(`Field \"${o.name}\" has invalid data: \"${e[o.name]}\"`);\n          return false;\n        }\n        return true;\n      }\n      toSchema(e) {\n        let t;\n        switch (e?.context) {\n          case \"create\":\n          case \"update\":\n            t = this.getFillableFields(e.context);\n            break;\n          default:\n            t = this.getFields(true);\n        }\n        let r2 = Object.fromEntries(t.map((o) => [o.name, o])), i = K.Object(Ke2(r2, (o) => {\n          let s2 = o.isFillable(e?.context);\n          return { title: o.config.label, $comment: o.config.description, $field: o.type, readOnly: s2 ? void 0 : true, ...o.toJsonSchema() };\n        }), { additionalProperties: false });\n        return e?.clean ? JSON.parse(JSON.stringify(i)) : i;\n      }\n      toTypes() {\n        return { name: this.name, type: this.type, comment: this.config.description, fields: Object.fromEntries(this.getFields().map((e) => [e.name, e.toType()])) };\n      }\n      toJSON() {\n        return { type: this.type, fields: Object.fromEntries(this.fields.map((e) => [e.name, e.toJSON()])), config: this.config };\n      }\n    };\n    ir2 = [\"text\", \"integer\", \"real\", \"blob\", \"date\", \"datetime\", \"timestamp\", \"boolean\", \"json\"];\n    or2 = Symbol.for(\"bknd:connection\");\n    ce = class {\n      static {\n        __name(this, \"ce\");\n      }\n      constructor(e, t = {}, r2 = []) {\n        this.fn = t;\n        this.plugins = r2;\n        this.kysely = e, this[or2] = true;\n      }\n      initialized = false;\n      kysely;\n      supported = { batching: false };\n      async init() {\n        this.initialized = true;\n      }\n      static isConnection(e) {\n        return e ? e[or2] === true : false;\n      }\n      getIntrospector() {\n        return this.kysely.introspection;\n      }\n      supports(e) {\n        return this.supported[e] ?? false;\n      }\n      async ping() {\n        return (await sql`SELECT 1`.execute(this.kysely)).rows.length > 0;\n      }\n      async batch(e) {\n        throw new Error(\"Batching not supported\");\n      }\n      async batchQuery(e) {\n        if (!this.supports(\"batching\")) {\n          let t = [];\n          for (let r2 of e) {\n            let i = await r2.execute();\n            t.push(i);\n          }\n          return t;\n        }\n        return await this.batch(e);\n      }\n      validateFieldSpecType(e) {\n        if (!ir2.includes(e)) throw new Error(`Invalid field type \"${e}\". Allowed types are: ${ir2.join(\", \")}`);\n        return true;\n      }\n      async close() {\n      }\n    };\n    yt2 = class {\n      static {\n        __name(this, \"yt\");\n      }\n      _relations = [];\n      constructor(e) {\n        this._relations = e;\n      }\n      get all() {\n        return this._relations;\n      }\n      relationsOf(e) {\n        return this._relations.filter((t) => t.visibleFrom(\"source\") && t.source.entity.name === e.name || t.visibleFrom(\"target\") && t.target.entity.name === e.name);\n      }\n      sourceRelationsOf(e) {\n        return this._relations.filter((t) => t.source.entity.name === e.name);\n      }\n      targetRelationsOf(e) {\n        return this._relations.filter((t) => t.visibleFrom(\"target\") && t.target.entity.name === e.name);\n      }\n      listableRelationsOf(e) {\n        return this.relationsOf(e).filter((t) => t.isListableFor(e));\n      }\n      relationOf(e, t) {\n        return this.relationsOf(e).find((r2) => r2.target.entity.name === e.name && r2.source.reference === t || r2.source.entity.name === e.name && r2.target.reference === t);\n      }\n      hasRelations(e) {\n        return this.relationsOf(e).length > 0;\n      }\n      relatedEntitiesOf(e) {\n        return this.relationsOf(e).map((t) => t.other(e).entity);\n      }\n      relationReferencesOf(e) {\n        return this.relationsOf(e).map((t) => t.other(e).reference);\n      }\n    };\n    ft2 = class n32 {\n      static {\n        __name(this, \"n3\");\n      }\n      constructor(e) {\n        this.em = e;\n      }\n      static EXCLUDE_TABLES = [\"libsql_wasm_func_table\", \"sqlite_sequence\", \"_cf_KV\"];\n      getIntrospector() {\n        return this.em.connection.getIntrospector();\n      }\n      async introspect() {\n        let e = await this.getIntrospector().getTables({ withInternalKyselyTables: false }), t = await this.getIntrospector().getIndices(), r2 = [];\n        for (let i of e) n32.EXCLUDE_TABLES.includes(i.name) || r2.push({ ...i, indices: t.filter((o) => o.table === i.name) });\n        return r2;\n      }\n      getIntrospectionFromEntity(e) {\n        let t = e.getFields(false), r2 = this.em.getIndicesOf(e);\n        return { name: e.name, isView: false, columns: t.map((i) => ({ name: i.name, dataType: \"TEXT\", isNullable: true, isAutoIncrementing: i instanceof z, hasDefaultValue: false, comment: void 0 })), indices: r2.map((i) => ({ name: i.name, table: e.name, isUnique: i.unique, columns: i.fields.map((o) => ({ name: o.name, order: 0 })) })) };\n      }\n      async getDiff() {\n        let e = await this.introspect(), t = this.em.entities.map((o) => this.getIntrospectionFromEntity(o)), r2 = [], i = /* @__PURE__ */ __name((o) => o.name, \"i\");\n        e.filter((o) => /bknd/.test(o.name) || o.isView ? false : !t.map((s2) => s2.name).includes(o.name)).forEach((o) => {\n          r2.push({ name: o.name, isDrop: true, isNew: false, columns: { add: [], drop: [], change: [] }, indices: { add: [], drop: [] } });\n        });\n        for (let o of t) {\n          let s2 = e.find((l2) => l2.name === o.name);\n          if (!s2) r2.push({ name: o.name, isNew: true, columns: { add: o.columns.map(i), drop: [], change: [] }, indices: { add: o.indices.map(i), drop: [] } });\n          else {\n            let l2 = o.columns.filter((m2) => !s2.columns.map(i).includes(m2.name)), a2 = s2.columns.filter((m2) => !o.columns.map(i).includes(m2.name)), c = [];\n            for (let m2 of o.columns) {\n              let T2 = s2.columns.find((ne3) => ne3.name === m2.name), k2 = [];\n              for (let [ne3, Fn2] of Object.entries(m2)) T2 && T2[ne3] !== Fn2 && k2.push({ attribute: ne3, prev: T2[ne3], next: Fn2 });\n              Object.keys(k2).length > 0 && c.push({ name: m2.name, changes: k2 });\n            }\n            let u3 = o.indices.filter((m2) => !s2.indices.map((T2) => T2.name).includes(m2.name)), f2 = s2.indices.filter((m2) => !o.indices.map((T2) => T2.name).includes(m2.name));\n            [l2, a2, u3, f2].some((m2) => m2.length > 0) && r2.push({ name: o.name, isNew: false, columns: { add: l2.map(i), drop: a2.map(i), change: [] }, indices: { add: u3.map(i), drop: f2.map(i) } });\n          }\n        }\n        return r2;\n      }\n      collectFieldSchemas(e, t) {\n        let r2 = [];\n        if (t.length === 0) return r2;\n        for (let i of t) {\n          let s2 = this.em.entity(e).getField(i).schema();\n          s2 && r2.push(this.em.connection.getFieldSchema(s2));\n        }\n        return r2;\n      }\n      async sync(e = { force: false, drop: false }) {\n        let t = await this.getDiff(), i = [], o = this.em.connection.kysely.schema;\n        for (let s2 of t) {\n          let l2 = [], a2 = 0, c = this.collectFieldSchemas(s2.name, s2.columns.add), u3 = s2.columns.drop, f2 = s2.indices.drop;\n          if (s2.isDrop) a2++, e.drop && l2.push(o.dropTable(s2.name));\n          else if (s2.isNew) {\n            let d2 = o.createTable(s2.name);\n            for (let m2 of c) a2++, d2 = d2.addColumn(...m2);\n            l2.push(d2);\n          } else {\n            if (c.length > 0) for (let d2 of c) a2++, l2.push(o.alterTable(s2.name).addColumn(...d2));\n            if (e.drop && u3.length > 0) for (let d2 of u3) a2++, l2.push(o.alterTable(s2.name).dropColumn(d2));\n          }\n          for (let d2 of s2.indices.add) {\n            let T2 = this.em.getIndicesOf(s2.name).find((ne3) => ne3.name === d2), k2 = o.createIndex(d2).on(s2.name).columns(T2.fields.map((ne3) => ne3.name));\n            T2.unique && (k2 = k2.unique()), l2.push(k2), a2++;\n          }\n          if (e.drop) for (let d2 of f2) l2.push(o.dropIndex(d2)), a2++;\n          if (a2 !== 0) for (let d2 of l2) {\n            let { sql: m2, parameters: T2 } = d2.compile();\n            if (i.push({ sql: m2, parameters: T2 }), e.force) try {\n              g.info(\"[SchemaManager]\", m2, T2), await d2.execute();\n            } catch (k2) {\n              throw new Error(`Failed to execute query: ${m2}: ${k2.message}`);\n            }\n          }\n        }\n        return i;\n      }\n    };\n    Ze2 = class n42 {\n      static {\n        __name(this, \"n4\");\n      }\n      connection;\n      _entities = [];\n      _relations = [];\n      _indices = [];\n      _schema;\n      emgr;\n      static Events = { ...ae2, ...je };\n      constructor(e, t, r2 = [], i = [], o) {\n        if (e.forEach((s2) => this.addEntity(s2)), r2.forEach((s2) => this.addRelation(s2)), i.forEach((s2) => this.addIndex(s2)), !ce.isConnection(t)) throw new lt2(\"\");\n        this.connection = t, this.emgr = o ?? new se2(), this.emgr.registerEvents(n42.Events);\n      }\n      fork() {\n        return new n42(this._entities, this.connection, this._relations, this._indices);\n      }\n      get entities() {\n        return this._entities;\n      }\n      get relations() {\n        return new yt2(this._relations);\n      }\n      get indices() {\n        return this._indices;\n      }\n      async ping() {\n        return (await sql`SELECT 1`.execute(this.connection.kysely)).rows.length > 0;\n      }\n      addEntity(e) {\n        let t = this.entities.find((r2) => r2.name === e.name);\n        if (t) {\n          if (JSON.stringify(t) === JSON.stringify(e)) {\n            g.warn(`Entity \"${e.name}\" already exists, but it's the same, skipping adding it.`);\n            return;\n          }\n          throw new Error(`Entity \"${e.name}\" already exists`);\n        }\n        this.entities.push(e);\n      }\n      __replaceEntity(e, t = e.name) {\n        let r2 = this._entities.findIndex((i) => i.name === t);\n        if (r2 === -1) throw new Error(`Entity \"${t}\" not found and cannot be replaced`);\n        this._entities[r2] = e;\n      }\n      entity(e, t) {\n        let r2 = this.entities.find((i) => e instanceof V2 ? i.name === e.name : i.name === e);\n        if (!r2) {\n          if (t === true) return;\n          throw new pt(e instanceof V2 ? e.name : e);\n        }\n        return r2;\n      }\n      hasEntity(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        return this.entities.some((r2) => r2.name === t);\n      }\n      hasIndex(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        return this.indices.some((r2) => r2.name === t);\n      }\n      getIndexedFields(e) {\n        let t = this.entity(e), r2 = this.getIndicesOf(t), i = t.fields.filter((s2) => s2.type === \"relation\"), o = r2.map((s2) => s2.fields[0]);\n        return [t.getPrimaryField(), ...i, ...o].filter(Boolean);\n      }\n      addRelation(e) {\n        if (!this.entity(e.source.entity.name) || !this.entity(e.target.entity.name)) throw new Error(\"Relation source or target entity not found\");\n        if (this._relations.find((r2) => {\n          let i = r2.source.entity.name === e.source.entity.name && r2.target.entity.name === e.target.entity.name, o = r2.source.reference === e.source.reference && r2.target.reference === e.target.reference;\n          return i && o;\n        })) throw new Error(`Relation \"${e.type}\" between \"${e.source.entity.name}\" and \"${e.target.entity.name}\" already exists`);\n        this._relations.push(e), e.initialize(this);\n      }\n      relationsOf(e) {\n        return this.relations.relationsOf(this.entity(e));\n      }\n      relationOf(e, t) {\n        return this.relations.relationOf(this.entity(e), t);\n      }\n      hasRelations(e) {\n        return this.relations.hasRelations(this.entity(e));\n      }\n      relatedEntitiesOf(e) {\n        return this.relations.relatedEntitiesOf(this.entity(e));\n      }\n      relationReferencesOf(e) {\n        return this.relations.relationReferencesOf(this.entity(e));\n      }\n      repository(e) {\n        return this.repo(e);\n      }\n      repo(e, t = {}) {\n        return new ht2(this, this.entity(e), { ...t, emgr: this.emgr });\n      }\n      mutator(e) {\n        return new mt(this, this.entity(e), { emgr: this.emgr });\n      }\n      addIndex(e, t = false) {\n        if (this.indices.find((r2) => r2.name === e.name)) {\n          if (t) throw new Error(`Index \"${e.name}\" already exists`);\n          return;\n        }\n        this._indices.push(e);\n      }\n      getIndicesOf(e) {\n        let t = e instanceof V2 ? e : this.entity(e);\n        return this.indices.filter((r2) => r2.entity.name === t.name);\n      }\n      schema() {\n        return this._schema || (this._schema = new ft2(this)), this._schema;\n      }\n      hydrate(e, t) {\n        let r2 = this.entity(e), i = [];\n        for (let o of t) {\n          for (let [s2, l2] of Object.entries(o)) {\n            let a2 = r2.getField(s2);\n            if (!a2 || a2.isVirtual()) {\n              let c = this.relationOf(e, s2);\n              if (c) {\n                if (!l2) continue;\n                l2 = c.hydrate(s2, Array.isArray(l2) ? l2 : [l2], this), o[s2] = l2;\n                continue;\n              } else if (a2?.isVirtual()) continue;\n              throw new Error(`Field \"${s2}\" not found on entity \"${r2.name}\"`);\n            }\n            try {\n              l2 === null && a2.hasDefault() && (o[s2] = a2.getDefault()), o[s2] = a2.transformRetrieve(l2);\n            } catch (c) {\n              throw new ct(`\"${a2.type}\" field \"${s2}\" on entity \"${r2.name}\": ${c.message}`);\n            }\n          }\n          i.push(o);\n        }\n        return i;\n      }\n      toJSON() {\n        return { entities: Object.fromEntries(this.entities.map((e) => [e.name, e.toJSON()])), relations: Object.fromEntries(this.relations.all.map((e) => [e.getName(), e.toJSON()])), indices: Object.fromEntries(this.indices.map((e) => [e.name, e.toJSON()])) };\n      }\n    };\n    ({ Type: Re } = p$1);\n    U = class {\n      static {\n        __name(this, \"U\");\n      }\n      config;\n      source;\n      target;\n      directions = [\"source\", \"target\"];\n      static schema = Re.Object({ mappedBy: Re.Optional(Re.String()), inversedBy: Re.Optional(Re.String()), required: Re.Optional(Re.Boolean()) });\n      constructor(e, t, r2 = {}) {\n        this.source = e, this.target = t;\n        let i = this.constructor.schema;\n        this.config = _e(i, r2);\n      }\n      getReferenceQuery(e, t, r2) {\n        return {};\n      }\n      helper(e) {\n        return new gt(this, e);\n      }\n      other(e) {\n        let t = typeof e == \"string\" ? e : e.name;\n        if (this.source.entity.name === this.target.entity.name) return this.source.cardinality === 1 ? this.target : this.source;\n        if (this.source.entity.name === t) return this.target;\n        if (this.target.entity.name === t) return this.source;\n        throw new Error(`Entity \"${t}\" is not part of the relation \"${this.source.entity.name} <-> ${this.target.entity.name}\"`);\n      }\n      self(e) {\n        return this.other(e).entity.name === this.source.entity.name ? this.target : this.source;\n      }\n      ref(e) {\n        return this.source.reference === e ? this.source : this.target;\n      }\n      otherRef(e) {\n        return this.source.reference === e ? this.target : this.source;\n      }\n      visibleFrom(e) {\n        return this.directions.includes(e);\n      }\n      hydrate(e, t, r2) {\n        let i = typeof e == \"string\" ? e : e.name, o = this.ref(i), s2 = r2.hydrate(o.entity.name, t);\n        if (o.cardinality === 1) {\n          if (Array.isArray(s2) && s2.length > 1) throw new Error(`Failed to hydrate \"${o.entity.name}\" with value: ${JSON.stringify(t)} (cardinality: 1)`);\n          return s2[0];\n        }\n        if (!s2) throw new Error(`Failed to hydrate \"${o.entity.name}\" with value: ${JSON.stringify(t)} (cardinality: -)`);\n        return s2;\n      }\n      isListableFor(e) {\n        return this.target.entity.name === e.name;\n      }\n      get required() {\n        return !!this.config.required;\n      }\n      async $set(e, t, r2) {\n        throw new Error(\"$set is not allowed\");\n      }\n      async $create(e, t, r2) {\n        throw new Error(\"$create is not allowed\");\n      }\n      async $attach(e, t, r2) {\n        throw new Error(\"$attach is not allowed\");\n      }\n      async $detach(e, t, r2) {\n        throw new Error(\"$detach is not allowed\");\n      }\n      getName() {\n        return [this.type().replace(\":\", \"\"), this.source.entity.name, this.target.entity.name, this.config.mappedBy, this.config.inversedBy].filter(Boolean).join(\"_\");\n      }\n      toJSON() {\n        return { type: this.type(), source: this.source.entity.name, target: this.target.entity.name, config: this.config };\n      }\n    };\n    W2 = class {\n      static {\n        __name(this, \"W\");\n      }\n      entity;\n      cardinality;\n      reference;\n      constructor(e, t, r2) {\n        this.entity = e, this.cardinality = r2, this.reference = t;\n      }\n      toJSON() {\n        return { entity: this.entity.name, cardinality: this.cardinality, name: this.reference };\n      }\n    };\n    ({ Type: ue2 } = p$1);\n    $o = [\"cascade\", \"set null\", \"set default\", \"restrict\", \"no action\"];\n    yn2 = ue2.Composite([w2, ue2.Object({ reference: ue2.String(), target: ue2.String(), target_field: ue2.Optional(ue2.String({ default: \"id\" })), target_field_type: ue2.Optional($2([\"integer\", \"text\"], { default: \"integer\" })), on_delete: ue2.Optional($2($o, { default: \"set null\" })) })]);\n    P2 = class n52 extends E2 {\n      static {\n        __name(this, \"n5\");\n      }\n      type = \"relation\";\n      getSchema() {\n        return yn2;\n      }\n      static create(e, t, r2) {\n        let i = [t.reference ?? t.entity.name, t.entity.getPrimaryField().name].join(\"_\");\n        return new n52(i, { ...r2, required: e.required, reference: t.reference, target: t.entity.name, target_field: t.entity.getPrimaryField().name, target_field_type: t.entity.getPrimaryField().fieldType });\n      }\n      reference() {\n        return this.config.reference;\n      }\n      target() {\n        return this.config.target;\n      }\n      targetField() {\n        return this.config.target_field;\n      }\n      schema() {\n        return Object.freeze({ ...super.schema(), type: this.config.target_field_type ?? \"integer\", references: `${this.config.target}.${this.config.target_field}`, onDelete: this.config.on_delete ?? \"set null\" });\n      }\n      transformRetrieve(e) {\n        return e;\n      }\n      async transformPersist(e, t) {\n        throw new Error(\"RelationField: This function should not be called\");\n      }\n      toJsonSchema() {\n        return this.toSchemaWrapIfRequired(ue2.Number({ $ref: `${this.config?.target}#/properties/${this.config?.target_field}` }));\n      }\n      toType() {\n        return { ...super.toType(), type: \"number\" };\n      }\n    };\n    I2 = { OneToOne: \"1:1\", ManyToOne: \"n:1\", ManyToMany: \"m:n\", Polymorphic: \"poly\" };\n    ({ Type: qe } = p$1);\n    N = class n62 extends U {\n      static {\n        __name(this, \"n6\");\n      }\n      connectionEntity;\n      additionalFields = [];\n      connectionTableMappedName;\n      em;\n      static schema = qe.Composite([U.schema, qe.Object({ connectionTable: qe.Optional(qe.String()), connectionTableMappedName: qe.Optional(qe.String()) })], { additionalProperties: false });\n      constructor(e, t, r2, i) {\n        let o = r2?.connectionTable || n62.defaultConnectionTable(e, t), s2 = new W2(e, e.name), l2 = new W2(t, t.name);\n        super(s2, l2, r2), this.connectionEntity = new V2(o, i, void 0, \"generated\"), this.connectionTableMappedName = r2?.connectionTableMappedName || o, this.additionalFields = i || [];\n      }\n      static defaultConnectionTable(e, t) {\n        return `${e.name}_${t.name}`;\n      }\n      type() {\n        return I2.ManyToMany;\n      }\n      isListableFor() {\n        return true;\n      }\n      getField(e) {\n        let t = this.connectionEntity, r2 = t.fields.find((i) => i instanceof P2 && i.target() === e.name);\n        if (!r2 || !(r2 instanceof P2)) throw new Error(`Connection entity \"${t.name}\" does not have a relation to \"${e.name}\"`);\n        return r2;\n      }\n      getQueryInfo(e) {\n        let t = this.other(e), r2 = this.connectionEntity, i = this.getField(e), o = this.getField(t.entity), s2 = `${e.name}.${e.getPrimaryField().name}`, l2 = `${r2.name}.${i.name}`, a2 = `${r2.name}.${o.name}`, c = [r2.name, `${t.entity.name}.${t.entity.getPrimaryField().name}`, a2], u3 = `${e.name}.${e.getPrimaryField().name}`;\n        return { other: t, join: c, entityRef: s2, selfRef: l2, otherRef: a2, groupBy: u3 };\n      }\n      getReferenceQuery(e, t) {\n        let { other: r2, otherRef: i } = this.getQueryInfo(e);\n        return { where: { [i]: t }, join: [r2.reference] };\n      }\n      buildJoin(e, t) {\n        let { other: r2, join: i, entityRef: o, selfRef: s2, groupBy: l2 } = this.getQueryInfo(e);\n        return t.innerJoin(r2.entity.name, o, s2).innerJoin(...i).groupBy(l2);\n      }\n      buildWith(e) {\n        if (!this.em) throw new Error(\"EntityManager not set, can't build\");\n        let t = this.em.connection.fn.jsonBuildObject;\n        if (!t) throw new Error(\"Connection does not support jsonBuildObject\");\n        let r2 = 5, { other: i, join: o, entityRef: s2, selfRef: l2 } = this.getQueryInfo(e), a2 = this.connectionEntity.fields.filter((c) => !(c instanceof P2 || c instanceof z));\n        return (c) => c.selectFrom(i.entity.name).select((u3) => {\n          let f2 = [];\n          if (a2.length > 0) {\n            let d2 = this.connectionEntity.name;\n            f2.push(t(Object.fromEntries(a2.map((m2) => [m2.name, u3.ref(`${d2}.${m2.name}`)]))).as(this.connectionTableMappedName));\n          }\n          return f2;\n        }).whereRef(s2, \"=\", l2).innerJoin(...o).limit(r2);\n      }\n      initialize(e) {\n        this.em = e;\n        let t = P2.create(this, this.source), r2 = P2.create(this, this.target);\n        e.hasEntity(this.connectionEntity) ? (this.connectionEntity.hasField(t) || this.connectionEntity.addField(t), this.connectionEntity.hasField(r2) || this.connectionEntity.addField(r2)) : (this.connectionEntity.addField(t), this.connectionEntity.addField(r2), e.addEntity(this.connectionEntity));\n      }\n      getName() {\n        return [super.getName(), [this.connectionEntity.name, this.connectionTableMappedName].filter(Boolean)].join(\"_\");\n      }\n    };\n    ({ Type: pe2 } = p$1);\n    G = class n72 extends U {\n      static {\n        __name(this, \"n7\");\n      }\n      fieldConfig;\n      static DEFAULTS = { with_limit: 5 };\n      static schema = pe2.Composite([U.schema, pe2.Object({ sourceCardinality: pe2.Optional(pe2.Number()), with_limit: pe2.Optional(pe2.Number({ default: n72.DEFAULTS.with_limit })), fieldConfig: pe2.Optional(pe2.Object({ label: pe2.String() })) })], { additionalProperties: false });\n      constructor(e, t, r2 = {}) {\n        let i = r2.mappedBy || t.name, o = r2.inversedBy || e.name, s2 = typeof r2.sourceCardinality == \"number\" && r2.sourceCardinality > 0 ? r2.sourceCardinality : void 0, l2 = new W2(e, o, s2), a2 = new W2(t, i, 1);\n        super(l2, a2, r2), this.fieldConfig = r2.fieldConfig ?? {};\n      }\n      type() {\n        return I2.ManyToOne;\n      }\n      initialize(e) {\n        let t = Ie(this.target.reference), r2 = P2.create(this, this.target, { label: t, ...this.fieldConfig });\n        this.source.entity.field(r2.name) || this.source.entity.addField(P2.create(this, this.target, { label: t, ...this.fieldConfig }));\n      }\n      getField() {\n        let e = this.target.entity.getPrimaryField().name, t = this.source.entity.getField(`${this.target.reference}_${e}`);\n        if (!(t instanceof P2)) throw new Error(`Field \"${this.target.reference}_${e}\" not found on entity \"${this.source.entity.name}\"`);\n        return t;\n      }\n      queryInfo(e, t) {\n        let r2 = this.source.reference === t ? \"source\" : \"target\", i = this[r2], o = this[r2 === \"source\" ? \"target\" : \"source\"], s2, l2, a2;\n        r2 === \"source\" ? (s2 = this.source.reference, l2 = `${s2}.${this.getField().name}`, a2 = `${e.name}.${i.entity.getPrimaryField().name}`) : (s2 = this.target.reference, l2 = `${s2}.${e.getPrimaryField().name}`, a2 = `${e.name}.${this.getField().name}`);\n        let c = `${e.name}.${e.getPrimaryField().name}`;\n        return { other: o, self: i, relationRef: s2, entityRef: l2, otherRef: a2, groupBy: c };\n      }\n      getReferenceQuery(e, t, r2) {\n        let i = this.source.reference === r2 ? \"source\" : \"target\", o = this[i], s2 = this[i === \"source\" ? \"target\" : \"source\"];\n        return { where: { [`${s2.reference}_${s2.entity.getPrimaryField().name}`]: t }, join: s2.entity.name === o.entity.name ? [] : [s2.entity.name] };\n      }\n      buildJoin(e, t, r2) {\n        let { self: i, entityRef: o, otherRef: s2, groupBy: l2 } = this.queryInfo(e, r2);\n        return t.innerJoin(i.entity.name, o, s2).groupBy(l2);\n      }\n      buildWith(e, t) {\n        let { self: r2, entityRef: i, otherRef: o, relationRef: s2 } = this.queryInfo(e, t);\n        return (l2) => l2.selectFrom(`${r2.entity.name} as ${s2}`).whereRef(i, \"=\", o).$if(r2.cardinality === 1, (a2) => a2.limit(1));\n      }\n      async $set(e, t, r2) {\n        if (typeof r2 != \"object\") throw new Error(`Invalid value for relation field \"${t}\" given, expected object.`);\n        let i = this.source.entity, s2 = this.helper(i.name).getMutationInfo();\n        if (!s2.$set) throw new Error(`Cannot perform $set for relation \"${t}\"`);\n        let l2 = s2.local_field, a2 = this.getField(), c = r2[Object.keys(r2)[0]];\n        if (!l2 || !(a2 instanceof P2)) throw new Error(`Cannot perform $set for relation \"${t}\"`);\n        if (c === null && !a2.isRequired()) return [l2, null];\n        if (!(await e.repository(a2.target()).exists({ [a2.targetField()]: c })).exists) {\n          let f2 = a2.targetField();\n          throw new Error(`Cannot connect \"${i.name}.${t}\" to \"${a2.target()}.${f2}\" = \"${c}\": not found.`);\n        }\n        return [l2, c];\n      }\n    };\n    Fe = class extends G {\n      static {\n        __name(this, \"Fe\");\n      }\n      constructor(e, t, r2) {\n        let { mappedBy: i, inversedBy: o, required: s2 } = r2 || {};\n        super(e, t, { mappedBy: i, inversedBy: o, sourceCardinality: 1, required: s2 });\n      }\n      type() {\n        return I2.OneToOne;\n      }\n      isListableFor() {\n        return false;\n      }\n      async $set(e, t, r2) {\n        throw new Error(\"$set is not allowed\");\n      }\n      async $create(e, t, r2) {\n        if (r2 === null || typeof r2 != \"object\") throw new Error(`Invalid value for relation field \"${t}\" given, expected object.`);\n        let i = this.other(this.source.entity).entity, s2 = this.helper(this.source.entity.name).getMutationInfo(), l2 = s2.primary, a2 = s2.local_field;\n        if (!s2.$create || !l2 || !a2) throw new Error(`Cannot perform $create for relation \"${t}\"`);\n        try {\n          let { data: c } = await e.mutator(i).insertOne(r2), u3 = c[l2];\n          return [a2, u3];\n        } catch {\n          throw new Error(`Error performing $create on \"${i.name}\".`);\n        }\n      }\n    };\n    ({ Type: xt } = p$1);\n    xe2 = class extends U {\n      static {\n        __name(this, \"xe\");\n      }\n      static schema = xt.Composite([U.schema, xt.Object({ targetCardinality: xt.Optional(xt.Number()) })], { additionalProperties: false });\n      constructor(e, t, r2 = {}) {\n        let i = r2.mappedBy || t.name, o = r2.inversedBy || e.name, s2 = typeof r2.targetCardinality == \"number\" && r2.targetCardinality > 0 ? r2.targetCardinality : void 0, l2 = new W2(e, o, 1), a2 = new W2(t, i, s2);\n        super(l2, a2, r2), this.directions = [\"source\"];\n      }\n      type() {\n        return I2.Polymorphic;\n      }\n      queryInfo(e) {\n        let t = this.other(e), r2 = `${t.entity.name}.${this.getReferenceField().name}`, i = `${e.name}.${this.config.mappedBy}`, o = `${t.entity.name}.${this.config.mappedBy}`, s2 = `${e.name}.${e.getPrimaryField().name}`, l2 = `${t.entity.name}.${this.getEntityIdField().name}`, a2 = `${e.name}.${e.getPrimaryField().name}`;\n        return { other: t, whereLhs: r2, reference: i, reference_other: o, entityRef: s2, otherRef: l2, groupBy: a2 };\n      }\n      buildJoin(e, t) {\n        let { other: r2, whereLhs: i, reference: o, entityRef: s2, otherRef: l2, groupBy: a2 } = this.queryInfo(e);\n        return t.innerJoin(r2.entity.name, (c) => c.onRef(s2, \"=\", l2).on(i, \"=\", o)).groupBy(a2);\n      }\n      getReferenceQuery(e, t) {\n        let r2 = this.queryInfo(e);\n        return { where: { [this.getReferenceField().name]: r2.reference_other, [this.getEntityIdField().name]: t } };\n      }\n      buildWith(e) {\n        let { other: t, whereLhs: r2, reference: i, entityRef: o, otherRef: s2 } = this.queryInfo(e);\n        return (l2) => l2.selectFrom(t.entity.name).where(r2, \"=\", i).whereRef(o, \"=\", s2).$if(t.cardinality === 1, (a2) => a2.limit(1));\n      }\n      isListableFor(e) {\n        return this.source.entity.name === e.name && this.target.cardinality !== 1;\n      }\n      getReferenceField() {\n        return new ge(\"reference\", { hidden: true, fillable: [\"create\"] });\n      }\n      getEntityIdField() {\n        return new me(\"entity_id\", { hidden: true, fillable: [\"create\"] });\n      }\n      initialize(e) {\n        let t = this.getReferenceField(), r2 = this.getEntityIdField();\n        this.target.entity.field(t.name) || this.target.entity.addField(t), this.target.entity.field(r2.name) || this.target.entity.addField(r2);\n      }\n    };\n    fn = [\"$set\", \"$create\", \"$attach\", \"$detach\"];\n    gt = class {\n      static {\n        __name(this, \"gt\");\n      }\n      relation;\n      access;\n      self;\n      other;\n      constructor(e, t) {\n        if (this.relation = e, e.source.entity.name === t) this.access = \"source\", this.self = e.source, this.other = e.target;\n        else if (e.target.entity.name === t) this.access = \"target\", this.self = e.target, this.other = e.source;\n        else throw new Error(`Entity \"${t}\" is not part of the relation \"${e.source.entity.name} <-> ${e.target.entity.name}\"`);\n      }\n      getMutationInfo() {\n        let e = { $set: false, $create: false, $attach: false, $detach: false }, t, r2;\n        switch (this.relation.type()) {\n          case I2.ManyToOne:\n            typeof this.self.cardinality > \"u\" && this.other.cardinality === 1 && (e.$set = true, t = this.relation.getField()?.name, r2 = this.other.entity.getPrimaryField().name);\n            break;\n          case I2.OneToOne:\n            this.access === \"source\" && (e.$create = true, e.$set = true, t = this.relation.getField()?.name, r2 = this.other.entity.getPrimaryField().name);\n            break;\n          case I2.ManyToMany:\n            this.access === \"source\" && (e.$attach = true, e.$detach = true, r2 = this.other.entity.getPrimaryField().name);\n            break;\n        }\n        return { reference: this.other.reference, local_field: t, ...e, primary: r2, cardinality: this.other.cardinality, relation_type: this.relation.type() };\n      }\n    };\n    bt = class {\n      static {\n        __name(this, \"bt\");\n      }\n      constructor(e, t) {\n        this.entity = e;\n        this.em = t;\n      }\n      getRelationalKeys() {\n        let e = [];\n        return this.entity.type === \"generated\" && this.em.relations.all.find((r2) => r2 instanceof N && r2.connectionEntity.name === this.entity.name) instanceof N && e.push(...this.entity.fields.filter((r2) => r2.type === \"relation\").map((r2) => r2.name)), this.em.relationsOf(this.entity.name).map((t) => {\n          let r2 = t.helper(this.entity.name).getMutationInfo();\n          e.push(r2.reference), r2.local_field && e.push(r2.local_field);\n        }), e;\n      }\n      async persistRelationField(e, t, r2) {\n        if (r2 === null && !e.isRequired()) return [t, r2];\n        if (typeof r2 == \"object\") throw new Error(`Invalid value for relation field \"${t}\" given, expected primitive.`);\n        if (!(await this.em.repository(e.target()).exists({ [e.targetField()]: r2 })).exists) {\n          let o = e.targetField();\n          throw new Error(`Cannot connect \"${this.entity.name}.${t}\" to \"${e.target()}.${o}\" = \"${r2}\": not found.`);\n        }\n        return [t, r2];\n      }\n      async persistReference(e, t, r2) {\n        if (typeof r2 != \"object\" || r2 === null || typeof r2 > \"u\") throw new Error(`Invalid value for relation \"${t}\" given, expected object to persist reference. Like '{$set: {id: 1}}'.`);\n        let i = Object.keys(r2)[0];\n        if (!fn.includes(i)) throw new Error(`Invalid operation \"${i}\" for relation \"${t}\". Allowed: ${fn.join(\", \")}`);\n        let o = r2[i];\n        return await e[i](this.em, t, o);\n      }\n      async persistRelation(e, t) {\n        let r2 = this.entity.getField(e);\n        if (r2 instanceof P2) return this.persistRelationField(r2, e, t);\n        let i = this.em.relationOf(this.entity.name, e);\n        if (i) return this.persistReference(i, e, t);\n        throw new Error(`Relation \"${e}\" failed to resolve on entity \"${this.entity.name}\": Unable to resolve relation origin.`);\n      }\n    };\n    mn = { [I2.OneToOne]: { schema: Fe.schema, cls: Fe }, [I2.ManyToOne]: { schema: G.schema, cls: G }, [I2.ManyToMany]: { schema: N.schema, cls: N }, [I2.Polymorphic]: { schema: xe2.schema, cls: xe2 } };\n    sr = { relation: { schema: yn2, field: P2 } };\n    mt = class n82 {\n      static {\n        __name(this, \"n8\");\n      }\n      constructor(e, t, r2) {\n        this.em = e;\n        this.entity = t;\n        this.options = r2;\n        this.emgr = r2?.emgr ?? new se2(ae2);\n      }\n      static Events = ae2;\n      emgr;\n      __unstable_disable_system_entity_creation = true;\n      __unstable_toggleSystemEntityCreation(e) {\n        this.__unstable_disable_system_entity_creation = e;\n      }\n      get conn() {\n        return this.em.connection.kysely;\n      }\n      async getValidatedData(e, t) {\n        let r2 = this.entity;\n        if (!t) throw new Error(\"Context must be provided for validation\");\n        let i = Object.keys(e), o = {}, s2 = new bt(r2, this.em), l2 = s2.getRelationalKeys();\n        for (let a2 of i) {\n          if (l2.includes(a2)) {\n            let u3 = await s2.persistRelation(a2, e[a2]);\n            if (Array.isArray(u3)) {\n              let [f2, d2] = u3;\n              o[f2] = d2;\n            }\n            continue;\n          }\n          let c = r2.getField(a2);\n          if (!c) throw new Error(`Field \"${a2}\" not found on entity \"${r2.name}\". Fields: ${r2.getFillableFields().map((u3) => u3.name).join(\", \")}`);\n          if (!c.isFillable(t)) throw new Error(`Field \"${a2}\" is not fillable on entity \"${r2.name}\"`);\n          o[a2] = await c.transformPersist(e[a2], this.em, t);\n        }\n        if (Object.keys(o).length === 0) throw new Error(`No data left to update \"${r2.name}\"`);\n        return o;\n      }\n      async many(e) {\n        let t = this.entity, { sql: r2, parameters: i } = e.compile();\n        try {\n          let o = await e.execute(), s2 = this.em.hydrate(t.name, o);\n          return { entity: t, sql: r2, parameters: [...i], result: o, data: s2 };\n        } catch (o) {\n          throw g.error(\"[Error in query]\", r2), o;\n        }\n      }\n      async single(e) {\n        let { data: t, ...r2 } = await this.many(e);\n        return { ...r2, data: t[0] };\n      }\n      async insertOne(e) {\n        let t = this.entity;\n        if (t.type === \"system\" && this.__unstable_disable_system_entity_creation) throw new Error(`Creation of system entity \"${t.name}\" is disabled`);\n        let r2 = await this.emgr.emit(new n82.Events.MutatorInsertBefore({ entity: t, data: e })), i = r2.returned ? r2.params.data : e, o = { ...t.getDefaultObject(), ...await this.getValidatedData(i, \"create\") }, s2 = t.getRequiredFields();\n        for (let f2 of s2) if (typeof o[f2.name] > \"u\" || o[f2.name] === null) throw new Error(`Field \"${f2.name}\" is required`);\n        let l2 = t.getPrimaryField(), a2 = l2.getNewValue();\n        a2 && (o = { [l2.name]: a2, ...o });\n        let c = this.conn.insertInto(t.name).values(o).returning(t.getSelect()), u3 = await this.single(c);\n        return await this.emgr.emit(new n82.Events.MutatorInsertAfter({ entity: t, data: u3.data, changed: o })), u3;\n      }\n      async updateOne(e, t) {\n        let r2 = this.entity;\n        if (!e) throw new Error(\"ID must be provided for update\");\n        let i = await this.emgr.emit(new n82.Events.MutatorUpdateBefore({ entity: r2, entityId: e, data: t })), o = i.returned ? i.params.data : t, s2 = await this.getValidatedData(o, \"update\"), l2 = this.conn.updateTable(r2.name).set(s2).where(r2.id().name, \"=\", e).returning(r2.getSelect()), a2 = await this.single(l2);\n        return await this.emgr.emit(new n82.Events.MutatorUpdateAfter({ entity: r2, entityId: e, data: a2.data, changed: s2 })), a2;\n      }\n      async deleteOne(e) {\n        let t = this.entity;\n        if (!e) throw new Error(\"ID must be provided for deletion\");\n        await this.emgr.emit(new n82.Events.MutatorDeleteBefore({ entity: t, entityId: e }));\n        let r2 = this.conn.deleteFrom(t.name).where(t.id().name, \"=\", e).returning(t.getSelect()), i = await this.single(r2);\n        return await this.emgr.emit(new n82.Events.MutatorDeleteAfter({ entity: t, entityId: e, data: i.data })), i;\n      }\n      getValidOptions(e) {\n        let t = this.entity, r2 = {};\n        if (e?.where) {\n          let i = Q.getPropertyNames(e.where).filter((o) => typeof t.getField(o) > \"u\");\n          if (i.length > 0) throw new q(`Invalid where field(s): ${i.join(\", \")}`);\n          r2.where = e.where;\n        }\n        return r2;\n      }\n      appendWhere(e, t) {\n        let r2 = this.entity;\n        r2.name;\n        if (t) {\n          let s2 = Q.getPropertyNames(t).filter((l2) => typeof r2.getField(l2) > \"u\");\n          if (s2.length > 0) throw new q(`Invalid where field(s): ${s2.join(\", \")}`);\n          return Q.addClause(e, t);\n        }\n        return e;\n      }\n      async deleteWhere(e) {\n        let t = this.entity;\n        if (!e || typeof e != \"object\" || Object.keys(e).length === 0) throw new Error(\"Where clause must be provided for mass deletion\");\n        let r2 = this.appendWhere(this.conn.deleteFrom(t.name), e).returning(t.getSelect());\n        return await this.many(r2);\n      }\n      async updateWhere(e, t) {\n        let r2 = this.entity, i = await this.getValidatedData(e, \"update\");\n        if (!t || typeof t != \"object\" || Object.keys(t).length === 0) throw new Error(\"Where clause must be provided for mass update\");\n        let o = this.appendWhere(this.conn.updateTable(r2.name), t).set(i).returning(r2.getSelect());\n        return await this.many(o);\n      }\n      async insertMany(e) {\n        let t = this.entity;\n        if (t.type === \"system\" && this.__unstable_disable_system_entity_creation) throw new Error(`Creation of system entity \"${t.name}\" is disabled`);\n        let r2 = [];\n        for (let o of e) {\n          let s2 = { ...t.getDefaultObject(), ...await this.getValidatedData(o, \"create\") }, l2 = t.getRequiredFields();\n          for (let a2 of l2) if (typeof s2[a2.name] > \"u\" || s2[a2.name] === null) throw new Error(`Field \"${a2.name}\" is required`);\n          r2.push(s2);\n        }\n        let i = this.conn.insertInto(t.name).values(r2).returning(t.getSelect());\n        return await this.many(i);\n      }\n    };\n    Et2 = O2.string({ pattern: \"^(?:[a-zA-Z_$][\\\\w$]*)(?:,[a-zA-Z_$][\\\\w$]*)*$\" });\n    ar = O2.anyOf([Et2, O2.array(Et2, { uniqueItems: true })], { default: [], coerce: /* @__PURE__ */ __name((n122) => Array.isArray(n122) ? n122 : typeof n122 == \"string\" ? n122.includes(\",\") ? n122.split(\",\") : [n122] : [], \"coerce\") });\n    lr2 = { by: \"id\", dir: \"asc\" };\n    ko = O2.object({ by: O2.string(), dir: O2.string({ enum: [\"asc\", \"desc\"] }).optional() });\n    jo = O2.anyOf([O2.string(), ko], { default: lr2, coerce: /* @__PURE__ */ __name((n122) => {\n      if (typeof n122 == \"string\") {\n        if (/^-?[a-zA-Z_][a-zA-Z0-9_.]*$/.test(n122)) {\n          let e = n122[0] === \"-\" ? \"desc\" : \"asc\";\n          return { by: e === \"desc\" ? n122.slice(1) : n122, dir: e };\n        } else if (/^{.*}$/.test(n122)) return JSON.parse(n122);\n        return g.warn(`Invalid sort given: '${JSON.stringify(n122)}'`), lr2;\n      }\n      return n122;\n    }, \"coerce\") });\n    Mo = O2.anyOf([O2.string(), O2.object({})], { default: {}, examples: [{ attribute: { $eq: 1 } }], coerce: /* @__PURE__ */ __name((n122) => {\n      let e = typeof n122 == \"string\" ? JSON.parse(n122) : n122;\n      return Q.convert(e);\n    }, \"coerce\") });\n    Bo = /* @__PURE__ */ __name((n122) => O2.anyOf([Et2, O2.array(Et2), n122], { coerce: /* @__PURE__ */ __name(function(e, t = {}) {\n      let r2 = e;\n      if (typeof r2 == \"string\" && (r2.match(/^\\{/) || r2.match(/^\\[/) ? r2 = JSON.parse(r2) : r2.includes(\",\") ? r2 = r2.split(\",\") : r2 = [r2]), Array.isArray(r2) && (r2 = r2.reduce((i, o) => (i[o] = {}, i), {})), Le(r2)) for (let i in r2) r2[i] = n122.coerce(r2[i], t);\n      return r2;\n    }, \"coerce\") }), \"Bo\");\n    cr = O2.recursive((n122) => O2.partialObject({ limit: O2.number({ default: 10 }), offset: O2.number({ default: 0 }), sort: jo, where: Mo, select: ar, join: ar, with: Bo(n122) }));\n    hn = /* @__PURE__ */ __name(() => cr.template({ withOptional: true }), \"hn\");\n    Xe = class n92 {\n      static {\n        __name(this, \"n9\");\n      }\n      static buildClause(e, t, r2, i) {\n        let o = e.relationOf(r2.name, i);\n        if (!o) throw new Error(`Relation \"${i}\" not found`);\n        return o.buildJoin(r2, t, i);\n      }\n      static getJoinedEntityNames(e, t, r2) {\n        return r2.flatMap((i) => {\n          let o = e.relationOf(t.name, i);\n          if (!o) throw new Error(`Relation \"${i}\" not found`);\n          let s2 = o.other(t);\n          return o instanceof G ? [s2.entity.name] : o instanceof N ? [s2.entity.name, o.connectionEntity.name] : [];\n        });\n      }\n      static addClause(e, t, r2, i) {\n        if (i.length === 0) return t;\n        let o = t;\n        for (let s2 of i) o = n92.buildClause(e, o, r2, s2);\n        return o;\n      }\n    };\n    ht2 = class n102 {\n      static {\n        __name(this, \"n10\");\n      }\n      constructor(e, t, r2 = {}) {\n        this.em = e;\n        this.entity = t;\n        this.options = r2;\n        this.emgr = r2?.emgr ?? new se2(ae2);\n      }\n      static Events = je;\n      emgr;\n      cloneFor(e, t = {}) {\n        return new n102(this.em, this.em.entity(e), { ...this.options, ...t, emgr: this.emgr });\n      }\n      get conn() {\n        return this.em.connection.kysely;\n      }\n      checkIndex(e, t, r2) {\n        !this.em.getIndexedFields(e).map((o) => o.name).includes(t) && this.options?.silent !== true && g.warn(`Field \"${e}.${t}\" used in \"${r2}\" is not indexed`);\n      }\n      getValidOptions(e) {\n        let t = this.entity, r2 = { ...structuredClone(hn()), sort: t.getDefaultSort(), select: t.getSelect() };\n        if (!e) return r2;\n        if (e.sort) {\n          if (!r2.select.includes(e.sort.by)) throw new q(`Invalid sort field \"${e.sort.by}\"`);\n          if (![\"asc\", \"desc\"].includes(e.sort.dir)) throw new q(`Invalid sort direction \"${e.sort.dir}\"`);\n          this.checkIndex(t.name, e.sort.by, \"sort\"), r2.sort = { dir: \"asc\", ...e.sort };\n        }\n        if (e.select && e.select.length > 0) {\n          let i = e.select.filter((o) => !r2.select.includes(o));\n          if (i.length > 0) throw new q(`Invalid select field(s): ${i.join(\", \")}`).context({ entity: t.name, valid: r2.select });\n          r2.select = e.select;\n        }\n        if (e.with) {\n          et.validateWiths(this.em, t.name, e.with);\n          r2.with = e.with;\n        }\n        if (e.join && e.join.length > 0) for (let i of e.join) {\n          if (!this.em.relationOf(t.name, i)) throw new q(`JOIN: \"${i}\" is not a relation of \"${t.name}\"`);\n          r2.join.push(i);\n        }\n        if (e.where) {\n          let i = [t.name];\n          r2.join.length > 0 && i.push(...Xe.getJoinedEntityNames(this.em, t, r2.join));\n          let o = Q.getPropertyNames(e.where).filter((s2) => {\n            if (s2.includes(\".\")) {\n              let [l2, a2] = s2.split(\".\");\n              return i.includes(l2) ? (this.checkIndex(l2, a2, \"where\"), !this.em.entity(l2).getField(a2)) : true;\n            }\n            return this.checkIndex(t.name, s2, \"where\"), typeof t.getField(s2) > \"u\";\n          });\n          if (o.length > 0) throw new q(`Invalid where field(s): ${o.join(\", \")}`).context({ aliases: i, entity: t.name });\n          r2.where = e.where;\n        }\n        return e.limit && (r2.limit = e.limit), e.offset && (r2.offset = e.offset), r2;\n      }\n      async executeQb(e) {\n        let t = e.compile();\n        this.options?.silent !== true && g.debug(`Repository: query\n${t.sql}\n`, t.parameters);\n        let r2;\n        try {\n          r2 = await e.execute();\n        } catch (i) {\n          if (this.options?.silent !== true) throw i instanceof Error && g.error(\"[ERROR] Repository.executeQb\", i.message), i;\n        }\n        return { result: r2, sql: t.sql, parameters: [...t.parameters] };\n      }\n      async performQuery(e) {\n        let t = this.entity, r2 = e.compile(), i = { entity: t, sql: r2.sql, parameters: [...r2.parameters], result: [], data: [], meta: { total: 0, count: 0, items: 0, time: 0, query: { sql: r2.sql, parameters: r2.parameters } } };\n        if (this.options?.includeCounts === false || this.options?.includeCounts === true && !this.em.connection.supports(\"batching\")) {\n          let a2 = performance.now(), c = await this.executeQb(e), u3 = Number.parseFloat((performance.now() - a2).toFixed(2)), f2 = c.result ?? [], d2 = this.em.hydrate(t.name, f2);\n          return { ...i, result: f2, data: d2, meta: { ...i.meta, total: void 0, count: void 0, items: d2.length, time: u3 } };\n        }\n        this.options?.silent !== true && g.debug(`Repository: query\n${r2.sql}\n`, r2.parameters);\n        let o = /* @__PURE__ */ __name((a2 = \"count\") => this.conn.fn.countAll().as(a2), \"o\"), s2 = e.clearSelect().select(o()).clearLimit().clearOffset().clearGroupBy().clearOrderBy(), l2 = this.conn.selectFrom(t.name).select(o());\n        try {\n          let a2 = performance.now(), [c, u3, f2] = await this.em.connection.batchQuery([s2, l2, e]), d2 = Number.parseFloat((performance.now() - a2).toFixed(2)), m2 = this.em.hydrate(t.name, f2);\n          return { ...i, result: f2, data: m2, meta: { ...i.meta, total: kt(u3[0]?.count), count: kt(c[0]?.count), items: f2.length, time: d2 } };\n        } catch (a2) {\n          if (this.options?.silent !== true) throw a2 instanceof Error && g.error(\"[ERROR] Repository.performQuery\", a2.message), a2;\n          return i;\n        }\n      }\n      async triggerFindBefore(e, t) {\n        let r2 = t.limit === 1 ? n102.Events.RepositoryFindOneBefore : n102.Events.RepositoryFindManyBefore;\n        await this.emgr.emit(new r2({ entity: e, options: t }));\n      }\n      async triggerFindAfter(e, t, r2) {\n        t.limit === 1 ? await this.emgr.emit(new n102.Events.RepositoryFindOneAfter({ entity: e, options: t, data: r2[0] })) : await this.emgr.emit(new n102.Events.RepositoryFindManyAfter({ entity: e, options: t, data: r2 }));\n      }\n      async single(e, t) {\n        await this.triggerFindBefore(this.entity, t);\n        let { data: r2, ...i } = await this.performQuery(e);\n        return await this.triggerFindAfter(this.entity, t, r2), { ...i, data: r2[0] };\n      }\n      addOptionsToQueryBuilder(e, t, r2) {\n        let i = this.entity, o = e ?? this.conn.selectFrom(i.name), s2 = r2?.validate !== false ? this.getValidOptions(t) : t;\n        if (!s2) return o;\n        let l2 = r2?.alias ?? i.name, a2 = /* @__PURE__ */ __name((f2) => `${l2}.${f2}`, \"a\"), c = r2?.ignore ?? [], u3 = { limit: 10, offset: 0, ...r2?.defaults };\n        return !c.includes(\"select\") && s2.select && (o = o.select(i.getAliasedSelectFrom(s2.select, l2))), !c.includes(\"with\") && s2.with && (o = et.addClause(this.em, o, i, s2.with)), !c.includes(\"join\") && s2.join && (o = Xe.addClause(this.em, o, i, s2.join)), !c.includes(\"where\") && s2.where && (o = Q.addClause(o, s2.where)), c.includes(\"limit\") || (o = o.limit(s2.limit ?? u3.limit)), c.includes(\"offset\") || (o = o.offset(s2.offset ?? u3.offset)), c.includes(\"sort\") || (o = o.orderBy(a2(s2.sort?.by ?? \"id\"), s2.sort?.dir ?? \"asc\")), o;\n      }\n      buildQuery(e, t = []) {\n        let r2 = this.entity, i = this.getValidOptions(e);\n        return { qb: this.addOptionsToQueryBuilder(void 0, i, { ignore: t, alias: r2.name, validate: false }), options: i };\n      }\n      async findId(e, t) {\n        let { qb: r2, options: i } = this.buildQuery({ ...t, where: { [this.entity.getPrimaryField().name]: e }, limit: 1 }, [\"offset\", \"sort\"]);\n        return this.single(r2, i);\n      }\n      async findOne(e, t) {\n        let { qb: r2, options: i } = this.buildQuery({ ...t, where: e, limit: 1 });\n        return await this.single(r2, i);\n      }\n      async findMany(e) {\n        let { qb: t, options: r2 } = this.buildQuery(e);\n        await this.triggerFindBefore(this.entity, r2);\n        let i = await this.performQuery(t);\n        return await this.triggerFindAfter(this.entity, r2, i.data), i;\n      }\n      async findManyByReference(e, t, r2) {\n        let i = this.entity, s2 = this.em.relations.listableRelationsOf(i).find((u3) => u3.ref(t).reference === t);\n        if (!s2) throw new Error(`Relation \"${t}\" not found or not listable on entity \"${i.name}\"`);\n        let l2 = s2.other(i).entity, a2 = s2.getReferenceQuery(l2, e, t);\n        if (!(\"where\" in a2) || Object.keys(a2.where).length === 0) throw new Error(`Invalid reference query for \"${t}\" on entity \"${l2.name}\"`);\n        let c = { ...r2, ...a2, where: { ...a2.where, ...r2?.where } };\n        return this.cloneFor(l2).findMany(c);\n      }\n      async count(e) {\n        let t = this.entity, r2 = this.getValidOptions({ where: e }), i = this.conn.fn.count(sql`*`).as(\"count\"), o = this.conn.selectFrom(t.name).select(i);\n        r2.where && (o = Q.addClause(o, r2.where));\n        let { result: s2, ...l2 } = await this.executeQb(o);\n        return { sql: l2.sql, parameters: [...l2.parameters], result: s2, count: s2[0]?.count ?? 0 };\n      }\n      async exists(e) {\n        let t = this.entity, r2 = this.getValidOptions({ where: e }), i = this.conn.fn.count(sql`*`).as(\"count\"), o = this.conn.selectFrom(t.name).select(i);\n        o = Q.addClause(o, r2.where).limit(1);\n        let { result: s2, ...l2 } = await this.executeQb(o);\n        return { sql: l2.sql, parameters: [...l2.parameters], result: s2, exists: s2[0].count > 0 };\n      }\n    };\n    __name(H2, \"H\");\n    Do = [A2(\"$eq\", (n122) => X(n122), (n122, e, t) => t(H2(e), \"=\", n122)), A2(\"$ne\", (n122) => X(n122), (n122, e, t) => t(H2(e), \"!=\", n122)), A2(\"$gt\", (n122) => X(n122), (n122, e, t) => t(H2(e), \">\", n122)), A2(\"$gte\", (n122) => X(n122), (n122, e, t) => t(H2(e), \">=\", n122)), A2(\"$lt\", (n122) => X(n122), (n122, e, t) => t(H2(e), \"<\", n122)), A2(\"$lte\", (n122) => X(n122), (n122, e, t) => t(H2(e), \"<=\", n122)), A2(\"$isnull\", (n122) => Mt2(n122), (n122, e, t) => t(H2(e), n122 ? \"is\" : \"is not\", null)), A2(\"$in\", (n122) => Array.isArray(n122), (n122, e, t) => t(H2(e), \"in\", n122)), A2(\"$notin\", (n122) => Array.isArray(n122), (n122, e, t) => t(H2(e), \"not in\", n122)), A2(\"$between\", (n122) => Array.isArray(n122) && n122.length === 2, (n122, e, t) => t.between(H2(e), n122[0], n122[1])), A2(\"$like\", (n122) => X(n122), (n122, e, t) => t(H2(e), \"like\", String(n122).replace(/\\*/g, \"%\")))];\n    Tt = Dt2(Do);\n    Q = class {\n      static {\n        __name(this, \"Q\");\n      }\n      static addClause(e, t) {\n        return Object.keys(t).length === 0 ? e : e.where((r2) => {\n          let i = Tt.build(t, { value_is_kv: true, exp_ctx: r2, convert: true });\n          return i.$or.length > 0 && i.$and.length > 0 ? r2.and(i.$and).or(r2.and(i.$or)) : i.$or.length > 0 ? r2.or(i.$or) : r2.and(i.$and);\n        });\n      }\n      static convert(e) {\n        return Tt.convert(e);\n      }\n      static getPropertyNames(e) {\n        let { keys: t } = Tt.build(e, { value_is_kv: true, exp_ctx: /* @__PURE__ */ __name(() => null, \"exp_ctx\"), convert: true });\n        return Array.from(t);\n      }\n    };\n    et = class n112 {\n      static {\n        __name(this, \"n11\");\n      }\n      static addClause(e, t, r2, i) {\n        if (!i || !Le(i)) return console.warn(`'withs' undefined or invalid, given: ${JSON.stringify(i)}`), t;\n        let o = e.connection.fn, s2 = t;\n        for (let [l2, a2] of Object.entries(i)) {\n          let c = e.relationOf(r2.name, l2);\n          if (!c) throw new Error(`Relation \"${r2.name}<>${l2}\" not found`);\n          let u3 = c.ref(l2).cardinality, f2 = u3 === 1 ? o.jsonObjectFrom : o.jsonArrayFrom;\n          if (!f2) throw new Error(\"Connection does not support jsonObjectFrom/jsonArrayFrom\");\n          let d2 = c.other(r2);\n          s2 = s2.select((m2) => {\n            let T2 = c.buildWith(r2, l2)(m2);\n            return a2 && (T2 = e.repo(d2.entity).addOptionsToQueryBuilder(T2, a2, { ignore: [\"with\", \"join\", u3 === 1 ? \"limit\" : void 0].filter(Boolean) })), a2.with && (T2 = n112.addClause(e, T2, d2.entity, a2.with)), f2(T2).as(d2.reference);\n          });\n        }\n        return s2;\n      }\n      static validateWiths(e, t, r2) {\n        let i = 0;\n        if (!r2 || !Le(r2)) return r2 && console.warn(`'withs' invalid, given: ${JSON.stringify(r2)}`), i;\n        let o = [];\n        for (let [s2, l2] of Object.entries(r2)) {\n          if (!e.relationOf(t, s2)) throw new q(`WITH: \"${s2}\" is not a relation of \"${t}\"`);\n          i++, \"with\" in l2 && o.push(n112.validateWiths(e, s2, l2.with));\n        }\n        return o.length > 0 && (i += Math.max(...o)), i;\n      }\n    };\n    wt = class extends ce {\n      static {\n        __name(this, \"wt\");\n      }\n      supported = { batching: true };\n      constructor() {\n        super(void 0);\n      }\n      getFieldSchema(e, t) {\n        throw new Error(\"Method not implemented.\");\n      }\n    };\n    ({ Type: te } = p$1);\n    gn = te.Composite([te.Object({ entity: te.String(), min_items: te.Optional(te.Number()), max_items: te.Optional(te.Number()), mime_types: te.Optional(te.Array(te.String())) }), w2]);\n    be = class extends E2 {\n      static {\n        __name(this, \"be\");\n      }\n      type = \"media\";\n      constructor(e, t) {\n        super(e, { ...t, fillable: [\"update\"], virtual: true });\n      }\n      getSchema() {\n        return gn;\n      }\n      getMaxItems() {\n        return this.config.max_items;\n      }\n      getMinItems() {\n        return this.config.min_items;\n      }\n      schema() {\n      }\n      toJsonSchema() {\n        let e = \"../schema.json#/properties/media\", t = this.config?.min_items, r2 = this.config?.max_items;\n        return r2 === 1 ? { $ref: e } : { type: \"array\", items: { $ref: e }, minItems: t, maxItems: r2 };\n      }\n    };\n    St = { text: /* @__PURE__ */ __name((n122) => new ge(n122.field_name, { ...n122.config, required: n122.is_required }), \"text\"), number: /* @__PURE__ */ __name((n122) => new me(n122.field_name, { ...n122.config, required: n122.is_required }), \"number\"), date: /* @__PURE__ */ __name((n122) => new ve(n122.field_name, { ...n122.config, required: n122.is_required }), \"date\"), datetime: /* @__PURE__ */ __name((n122) => new ve(n122.field_name, { ...n122.config, required: n122.is_required }), \"datetime\"), boolean: /* @__PURE__ */ __name((n122) => new Me(n122.field_name, { ...n122.config, required: n122.is_required }), \"boolean\"), enumm: /* @__PURE__ */ __name((n122) => new Be(n122.field_name, { ...n122.config, required: n122.is_required }), \"enumm\"), json: /* @__PURE__ */ __name((n122) => new De2(n122.field_name, { ...n122.config, required: n122.is_required }), \"json\"), jsonSchema: /* @__PURE__ */ __name((n122) => new Ae(n122.field_name, { ...n122.config, required: n122.is_required }), \"jsonSchema\"), media: /* @__PURE__ */ __name((n122) => new be(n122.field_name, { ...n122.config, entity: n122.entity.name, required: n122.is_required }), \"media\"), medium: /* @__PURE__ */ __name((n122) => new be(n122.field_name, { ...n122.config, entity: n122.entity.name, required: n122.is_required }), \"medium\") };\n    __name($u, \"$u\");\n    __name(Pu, \"Pu\");\n    B = class {\n      static {\n        __name(this, \"B\");\n      }\n      constructor(e, t, r2) {\n        this.type = e;\n        this.config = t;\n        this.is_required = r2;\n      }\n      required() {\n        return this.is_required = true, this;\n      }\n      getField(e) {\n        if (!St[this.type]) throw new Error(`Unknown field type: ${this.type}`);\n        try {\n          return St[this.type](e);\n        } catch (t) {\n          throw new Error(`Faild to construct field \"${this.type}\": ${t}`);\n        }\n      }\n      make(e) {\n        if (!St[this.type]) throw new Error(`Unknown field type: ${this.type}`);\n        try {\n          return St[this.type]({ entity: { name: \"unknown\", fields: {} }, field_name: e, config: this.config, is_required: this.is_required });\n        } catch (t) {\n          throw new Error(`Faild to construct field \"${this.type}\": ${t}`);\n        }\n      }\n    };\n    __name(Qu, \"Qu\");\n    __name(qo, \"qo\");\n    __name(No, \"No\");\n    xn2 = class extends Ze2 {\n      static {\n        __name(this, \"xn\");\n      }\n      constructor(t, r2 = [], i = []) {\n        super(Object.values(t), new wt(), r2, i);\n        this.__entities = t;\n      }\n      withConnection(t) {\n        return new Ze2(this.entities, t, this.relations.all, this.indices);\n      }\n    };\n    __name(Lu, \"Lu\");\n    Ot = class {\n      static {\n        __name(this, \"Ot\");\n      }\n      transformQuery(e) {\n        return e.node;\n      }\n      transformResult(e) {\n        return Promise.resolve({ ...e.result, rows: e.result.rows.map((t) => {\n          let r2 = {};\n          for (let i in t) Number.isNaN(+i) && (r2[i] = t[i]);\n          return r2;\n        }) });\n      }\n    };\n    [new Ot(), new ParseJSONResultsPlugin()];\n    [new ParseJSONResultsPlugin()];\n    Rt = { ...nr2, ...sr, media: { schema: gn, field: be } };\n    es = Pn(Rt, (n122, e) => Type.Object({ type: Type.Const(e, { default: e, readOnly: true }), config: Type.Optional(n122.schema) }, { title: e }));\n    ts = Type.Union(Object.values(es));\n    ns = Je(ts);\n    rs = Type.Object({ type: Type.Optional(Type.String({ enum: rr, default: \"regular\", readOnly: true })), config: Type.Optional(dn2), fields: Type.Optional(ns) });\n    is = Object.entries(mn).map(([n122, e]) => Type.Object({ type: Type.Const(n122, { default: n122, readOnly: true }), source: Type.String(), target: Type.String(), config: Type.Optional(e.schema) }, { title: n122 }));\n    os = Type.Object({ entity: Type.String(), fields: Type.Array(Type.String(), { minItems: 1 }), unique: Type.Optional(Type.Boolean({ default: false })) }, { additionalProperties: false });\n    Type.Object({ basepath: Type.Optional(Type.String({ default: \"/api/data\" })), default_primary_format: Type.Optional($2(He, { default: \"integer\" })), entities: Type.Optional(Je(rs, { default: {} })), relations: Type.Optional(Je(Type.Union(is), { default: {} })), indices: Type.Optional(Je(os, { default: {} })) }, { additionalProperties: false });\n    fr = {};\n    Cn2(fr, { databaseSync: /* @__PURE__ */ __name(() => ds2, \"databaseSync\"), entityCreate: /* @__PURE__ */ __name(() => cs, \"entityCreate\"), entityDelete: /* @__PURE__ */ __name(() => ps2, \"entityDelete\"), entityRead: /* @__PURE__ */ __name(() => ls, \"entityRead\"), entityUpdate: /* @__PURE__ */ __name(() => us2, \"entityUpdate\"), rawMutate: /* @__PURE__ */ __name(() => fs2, \"rawMutate\"), rawQuery: /* @__PURE__ */ __name(() => ys, \"rawQuery\") });\n    ls = new J2(\"data.entity.read\");\n    cs = new J2(\"data.entity.create\");\n    us2 = new J2(\"data.entity.update\");\n    ps2 = new J2(\"data.entity.delete\");\n    ds2 = new J2(\"data.database.sync\");\n    ys = new J2(\"data.raw.query\");\n    fs2 = new J2(\"data.raw.mutate\");\n    ({ ...ae2 });\n    local = T();\n    schema = Lu(\n      {\n        posts: Qu(\"posts\", {\n          // \"id\" is automatically added\n          title: $u().required(),\n          slug: $u().required(),\n          content: $u(),\n          views: Pu()\n        }),\n        comments: Qu(\"comments\", {\n          content: $u()\n        })\n        // relations and indices are defined separately.\n        // the first argument are the helper functions, the second the entities.\n      },\n      ({ relation, index }, { posts, comments }) => {\n        relation(comments).manyToOne(posts);\n        index(posts).on([\"title\"]).on([\"slug\"], true);\n      }\n    );\n    config2 = {\n      // Cloudflare D1 binding is implicit: https://docs.bknd.io/integration/cloudflare#cloudflare-d1\n      // an initial config is only applied if the database is empty\n      initialConfig: {\n        data: schema.toJSON(),\n        // we're enabling auth ...\n        auth: {\n          allow_register: true,\n          enabled: true,\n          jwt: {\n            issuer: \"bknd-astro-example\",\n            secret: Yn$1(64)\n          },\n          guard: {\n            enabled: true\n          },\n          roles: {\n            admin: {\n              implicit_allow: true\n            },\n            default: {\n              permissions: [\n                \"data.database.sync\",\n                \"data.entity.create\",\n                \"data.entity.delete\",\n                \"data.entity.update\",\n                \"data.entity.read\",\n                \"media.file.delete\",\n                \"media.file.read\",\n                \"media.file.list\",\n                \"media.file.upload\"\n              ],\n              is_default: true\n            }\n          }\n        },\n        // ... and media\n        media: {\n          enabled: true,\n          adapter: local({\n            path: \"./public/temp/uploads\"\n          })\n        }\n      },\n      options: {\n        // the seed option is only executed if the database was empty\n        seed: /* @__PURE__ */ __name(async (ctx) => {\n          await ctx.app.module.auth.createUser({\n            email: \"admin@example.com\",\n            password: \"password\",\n            role: \"admin\"\n          });\n          await ctx.app.module.auth.createUser({\n            email: \"user@example.com\",\n            password: \"password\",\n            role: \"default\"\n          });\n          await ctx.em.mutator(\"posts\").insertMany([\n            { title: \"First post\", slug: \"first-post\", content: \"...\" },\n            { title: \"Second post\", slug: \"second-post\" }\n          ]);\n        }, \"seed\")\n      }\n    };\n  }\n});\n\n// dist/_worker.js/chunks/bknd_BKPYnq1E.mjs\nasync function getApp() {\n  return await s(config2);\n}\nasync function getApi(requestHeaders, opts) {\n  const app = await getApp();\n  if (opts?.mode !== \"static\" && opts?.verify) {\n    const api = app.getApi({ headers: requestHeaders });\n    await api.verifyAuth();\n    return api;\n  }\n  return app.getApi();\n}\nvar init_bknd_BKPYnq1E = __esm({\n  \"dist/_worker.js/chunks/bknd_BKPYnq1E.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_bknd_config_m27Qk_4t();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    __name(getApp, \"getApp\");\n    __name(getApi, \"getApi\");\n  }\n});\n\n// dist/_worker.js/pages/admin/_---admin_.astro.mjs\nvar admin_astro_exports = {};\n__export(admin_astro_exports, {\n  page: () => page2,\n  renderers: () => renderers\n});\nvar $$Astro, $$, $$file, $$url, _page2, page2;\nvar init_admin_astro = __esm({\n  \"dist/_worker.js/pages/admin/_---admin_.astro.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    init_bknd_BKPYnq1E();\n    init_renderers();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    $$Astro = createAstro();\n    $$ = createComponent(async ($$result, $$props, $$slots) => {\n      const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);\n      Astro2.self = $$;\n      const api = await getApi(Astro2.request.headers, { verify: true, mode: \"dynamic\" });\n      const user = api.getUser() ?? void 0;\n      return renderTemplate`<html> ${maybeRenderHead()}<body> ${renderComponent($$result, \"Admin\", null, { \"withProvider\": {\n        user\n      }, \"config\": {\n        basepath: \"/admin\",\n        theme: \"system\",\n        logo_return_path: \"/../\"\n      }, \"client:only\": \"react\", \"client:component-hydration\": \"only\", \"client:component-path\": \"bknd/ui\", \"client:component-export\": \"Admin\" })} </body></html>`;\n    }, \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/admin/[...admin].astro\", void 0);\n    $$file = \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/admin/[...admin].astro\";\n    $$url = \"/admin/[...admin]\";\n    _page2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      default: $$,\n      file: $$file,\n      url: $$url\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    page2 = /* @__PURE__ */ __name(() => _page2, \"page\");\n  }\n});\n\n// dist/_worker.js/pages/api/_---api_.astro.mjs\nvar api_astro_exports = {};\n__export(api_astro_exports, {\n  page: () => page3,\n  renderers: () => renderers\n});\nvar ALL, _page3, page3;\nvar init_api_astro = __esm({\n  \"dist/_worker.js/pages/api/_---api_.astro.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_bknd_config_m27Qk_4t();\n    init_renderers();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    ALL = v$3(config2);\n    _page3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      ALL\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    page3 = /* @__PURE__ */ __name(() => _page3, \"page\");\n  }\n});\n\n// dist/_worker.js/chunks/Layout_Co7HziVl.mjs\nvar $$Astro2, $$Layout;\nvar init_Layout_Co7HziVl = __esm({\n  \"dist/_worker.js/chunks/Layout_Co7HziVl.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    $$Astro2 = createAstro();\n    $$Layout = createComponent(async ($$result, $$props, $$slots) => {\n      const Astro2 = $$result.createAstro($$Astro2, $$props, $$slots);\n      Astro2.self = $$Layout;\n      const flash = Astro2.cookies.get(\"__bknd_flash\");\n      const { title: title3 = \"Freedom Stack v2\" } = Astro2.props;\n      return renderTemplate`<html lang=\"en\"> <head><meta charset=\"utf-8\"><link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\"><meta name=\"viewport\" content=\"width=device-width\"><meta name=\"generator\"${addAttribute(Astro2.generator, \"content\")}><title>${title3}</title>${renderHead()}</head> <body class=\"bg-(background) text-(foreground)\"> ${flash && renderTemplate`<div x-data=\"{ open: false }\" x-show=\"open\" x-init=\"$nextTick(() => open = true)\" x-transition @click=\"open = false; await cookieStore.delete('__bknd_flash');\" class=\"alert fixed top-4 right-4 z-50 max-w-xs shadow-lg\"> <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"> <circle cx=\"12\" cy=\"12\" r=\"10\"></circle> <line x1=\"12\" x2=\"12\" y1=\"8\" y2=\"12\"></line> <line x1=\"12\" x2=\"12.01\" y1=\"16\" y2=\"16\"></line> </svg> <h2>${JSON.parse(flash.value).message}</h2> <section>${JSON.parse(flash.value).description}</section> </div>`} ${renderSlot($$result, $$slots[\"default\"])}  ${renderScript($$result, \"/Users/cameronpak/Projects/freedom-stack-v2/src/layouts/Layout.astro?astro&type=script&index=0&lang.ts\")} </body></html>`;\n    }, \"/Users/cameronpak/Projects/freedom-stack-v2/src/layouts/Layout.astro\", void 0);\n  }\n});\n\n// dist/_worker.js/pages/login.astro.mjs\nvar login_astro_exports = {};\n__export(login_astro_exports, {\n  page: () => page4,\n  renderers: () => renderers\n});\nvar $$Login, $$file2, $$url2, _page4, page4;\nvar init_login_astro = __esm({\n  \"dist/_worker.js/pages/login.astro.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    init_Layout_Co7HziVl();\n    init_renderers();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    $$Login = createComponent(($$result, $$props, $$slots) => {\n      return renderTemplate`${renderComponent($$result, \"Layout\", $$Layout, { \"title\": \"Login\" }, { \"default\": /* @__PURE__ */ __name(($$result2) => renderTemplate` ${maybeRenderHead()}<section class=\"mx-auto flex max-w-md flex-col gap-4 p-6\"> <div class=\"card w-full\"> <header> <h2>Login to your account</h2> <p>Enter your details below to login to your account</p> </header> <section> <form method=\"post\" action=\"/api/auth/password/login\" class=\"form grid gap-6\"> <div class=\"grid gap-2\"> <label for=\"demo-card-form-email\">Email</label> <input name=\"email\" type=\"email\" id=\"demo-card-form-email\"> </div> <div class=\"grid gap-2\"> <div class=\"flex items-center gap-2\"> <label for=\"demo-card-form-password\">Password</label> </div> <input name=\"password\" type=\"password\" id=\"demo-card-form-password\"> </div> <button type=\"submit\" class=\"btn w-full\">Login</button> </form> </section> <footer class=\"flex flex-col items-center gap-2\"> <p class=\"mt-4 text-center text-sm\">\nDon't have an account? <a href=\"/register\" class=\"underline-offset-4 hover:underline\">Sign up</a> </p> </footer> </div> </section> `, \"default\") })}`;\n    }, \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/login.astro\", void 0);\n    $$file2 = \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/login.astro\";\n    $$url2 = \"/login\";\n    _page4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      default: $$Login,\n      file: $$file2,\n      url: $$url2\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    page4 = /* @__PURE__ */ __name(() => _page4, \"page\");\n  }\n});\n\n// dist/_worker.js/pages/register.astro.mjs\nvar register_astro_exports = {};\n__export(register_astro_exports, {\n  page: () => page5,\n  renderers: () => renderers\n});\nvar $$Register, $$file3, $$url3, _page5, page5;\nvar init_register_astro = __esm({\n  \"dist/_worker.js/pages/register.astro.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    init_Layout_Co7HziVl();\n    init_renderers();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    $$Register = createComponent(($$result, $$props, $$slots) => {\n      return renderTemplate`${renderComponent($$result, \"Layout\", $$Layout, { \"title\": \"Register\" }, { \"default\": /* @__PURE__ */ __name(($$result2) => renderTemplate` ${maybeRenderHead()}<section class=\"mx-auto flex max-w-md flex-col gap-4 p-6\"> <div class=\"card w-full\"> <header> <h2>Register for an account</h2> </header> <section> <form method=\"post\" class=\"form grid gap-6\" action=\"/api/auth/password/register\"> <div class=\"grid gap-2\"> <label for=\"demo-card-form-email\">Email</label> <input name=\"email\" type=\"email\" id=\"demo-card-form-email\"> </div> <div class=\"grid gap-2\"> <div class=\"flex items-center gap-2\"> <label for=\"demo-card-form-password\">Password</label> </div> <input name=\"password\" type=\"password\" id=\"demo-card-form-password\"> </div> <button type=\"submit\" class=\"btn w-full\">Register</button> </form> </section> <footer class=\"flex flex-col items-center gap-2\"> <p class=\"mt-4 text-center text-sm\">\nAlready have an account? <a href=\"/login\" class=\"underline-offset-4 hover:underline\">Sign in</a> </p> </footer> </div> </section> `, \"default\") })}`;\n    }, \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/register.astro\", void 0);\n    $$file3 = \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/register.astro\";\n    $$url3 = \"/register\";\n    _page5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      default: $$Register,\n      file: $$file3,\n      url: $$url3\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    page5 = /* @__PURE__ */ __name(() => _page5, \"page\");\n  }\n});\n\n// dist/_worker.js/pages/index.astro.mjs\nvar index_astro_exports = {};\n__export(index_astro_exports, {\n  page: () => page6,\n  renderers: () => renderers\n});\nvar $$Astro$1, $$Authenticated, $$Astro3, $$Index, $$file4, $$url4, _page6, page6;\nvar init_index_astro = __esm({\n  \"dist/_worker.js/pages/index.astro.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_server_C8vVOH8G();\n    init_bknd_BKPYnq1E();\n    init_Layout_Co7HziVl();\n    init_renderers();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    $$Astro$1 = createAstro();\n    $$Authenticated = createComponent(async ($$result, $$props, $$slots) => {\n      const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);\n      Astro2.self = $$Authenticated;\n      const api = await getApi(Astro2.request.headers, { verify: true, mode: \"dynamic\" });\n      const user = api.getUser();\n      return renderTemplate`${user?.email ? renderTemplate`${renderSlot($$result, $$slots[\"default\"])}` : renderTemplate`${renderSlot($$result, $$slots[\"fallback\"])}`}`;\n    }, \"/Users/cameronpak/Projects/freedom-stack-v2/src/components/Authenticated.astro\", void 0);\n    $$Astro3 = createAstro();\n    $$Index = createComponent(async ($$result, $$props, $$slots) => {\n      const Astro2 = $$result.createAstro($$Astro3, $$props, $$slots);\n      Astro2.self = $$Index;\n      const api = await getApi(Astro2.request.headers, { verify: true, mode: \"dynamic\" });\n      const { data } = await api.data.readMany(\"posts\");\n      const user = api.getUser();\n      return renderTemplate`${renderComponent($$result, \"Layout\", $$Layout, { \"title\": \"Freedom Stack v2\" }, { \"default\": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<section class=\"mx-auto flex max-w-md flex-col gap-4 p-6\"> <h1 class=\"heading-1\">Freedom Stack v2</h1> <div class=\"grid grid-cols-2 items-center gap-4\"> <a href=\"/admin\" class=\"btn btn-primary\">Open Bknd Admin</a> ${renderComponent($$result2, \"Authenticated\", $$Authenticated, {}, { \"default\": /* @__PURE__ */ __name(async ($$result3) => renderTemplate`  <a href=\"/api/auth/logout\" class=\"btn btn-secondary\">Logout</a> `, \"default\"), \"fallback\": /* @__PURE__ */ __name(async ($$result3) => renderTemplate`<a href=\"/login\" class=\"btn btn-secondary\">Login</a>`, \"fallback\") })} </div> ${user?.email ? renderTemplate`<p>Logged in as ${user.email}</p>` : renderTemplate`<p>Not logged in</p>`} </section> `, \"default\") })}`;\n    }, \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/index.astro\", void 0);\n    $$file4 = \"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/index.astro\";\n    $$url4 = \"\";\n    _page6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n      __proto__: null,\n      default: $$Index,\n      file: $$file4,\n      url: $$url4\n    }, Symbol.toStringTag, { value: \"Module\" }));\n    page6 = /* @__PURE__ */ __name(() => _page6, \"page\");\n  }\n});\n\n// dist/_worker.js/_noop-actions.mjs\nvar noop_actions_exports = {};\n__export(noop_actions_exports, {\n  server: () => server\n});\nvar server;\nvar init_noop_actions = __esm({\n  \"dist/_worker.js/_noop-actions.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    server = {};\n  }\n});\n\n// dist/_worker.js/_astro-internal_middleware.mjs\nvar astro_internal_middleware_exports = {};\n__export(astro_internal_middleware_exports, {\n  onRequest: () => onRequest\n});\nvar onRequest$1, onRequest;\nvar init_astro_internal_middleware = __esm({\n  \"dist/_worker.js/_astro-internal_middleware.mjs\"() {\n    \"use strict\";\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\n    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\n    init_performance2();\n    init_astro_designed_error_pages_DuwJl2PN();\n    init_server_C8vVOH8G();\n    init_index_Bos_IFPf();\n    globalThis.process ??= {};\n    globalThis.process.env ??= {};\n    onRequest$1 = /* @__PURE__ */ __name((context2, next) => {\n      if (context2.isPrerendered) {\n        context2.locals.runtime ??= {\n          env: process.env\n        };\n      }\n      return next();\n    }, \"onRequest$1\");\n    onRequest = sequence(\n      onRequest$1\n    );\n  }\n});\n\n// dist/_worker.js/index.js\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\ninit_performance2();\ninit_renderers();\n\n// dist/_worker.js/chunks/_@astrojs-ssr-adapter_1KT6roWP.mjs\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\ninit_performance2();\ninit_index_Bos_IFPf();\ninit_server_C8vVOH8G();\ninit_astro_designed_error_pages_DuwJl2PN();\nimport \"cloudflare:workers\";\n\n// dist/_worker.js/chunks/noop-middleware_BS-seCif.mjs\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\ninit_performance2();\ninit_server_C8vVOH8G();\nglobalThis.process ??= {};\nglobalThis.process.env ??= {};\nvar NOOP_MIDDLEWARE_FN = /* @__PURE__ */ __name(async (_ctx, next) => {\n  const response = await next();\n  response.headers.set(NOOP_MIDDLEWARE_HEADER, \"true\");\n  return response;\n}, \"NOOP_MIDDLEWARE_FN\");\n\n// dist/_worker.js/chunks/_@astrojs-ssr-adapter_1KT6roWP.mjs\nglobalThis.process ??= {};\nglobalThis.process.env ??= {};\nfunction createI18nMiddleware(i18n, base, trailingSlash, format2) {\n  if (!i18n) return (_3, next) => next();\n  const payload = {\n    ...i18n,\n    trailingSlash,\n    base,\n    format: format2\n  };\n  const _redirectToDefaultLocale = redirectToDefaultLocale(payload);\n  const _noFoundForNonLocaleRoute = notFound(payload);\n  const _requestHasLocale = requestHasLocale(payload.locales);\n  const _redirectToFallback = redirectToFallback(payload);\n  const prefixAlways = /* @__PURE__ */ __name((context2, response) => {\n    const url = context2.url;\n    if (url.pathname === base + \"/\" || url.pathname === base) {\n      return _redirectToDefaultLocale(context2);\n    } else if (!_requestHasLocale(context2)) {\n      return _noFoundForNonLocaleRoute(context2, response);\n    }\n    return void 0;\n  }, \"prefixAlways\");\n  const prefixOtherLocales = /* @__PURE__ */ __name((context2, response) => {\n    let pathnameContainsDefaultLocale = false;\n    const url = context2.url;\n    for (const segment of url.pathname.split(\"/\")) {\n      if (normalizeTheLocale(segment) === normalizeTheLocale(i18n.defaultLocale)) {\n        pathnameContainsDefaultLocale = true;\n        break;\n      }\n    }\n    if (pathnameContainsDefaultLocale) {\n      const newLocation = url.pathname.replace(`/${i18n.defaultLocale}`, \"\");\n      response.headers.set(\"Location\", newLocation);\n      return _noFoundForNonLocaleRoute(context2);\n    }\n    return void 0;\n  }, \"prefixOtherLocales\");\n  return async (context2, next) => {\n    const response = await next();\n    const type2 = response.headers.get(ROUTE_TYPE_HEADER);\n    const isReroute = response.headers.get(REROUTE_DIRECTIVE_HEADER);\n    if (isReroute === \"no\" && typeof i18n.fallback === \"undefined\") {\n      return response;\n    }\n    if (type2 !== \"page\" && type2 !== \"fallback\") {\n      return response;\n    }\n    if (requestIs404Or500(context2.request, base)) {\n      return response;\n    }\n    if (isRequestServerIsland(context2.request, base)) {\n      return response;\n    }\n    const { currentLocale } = context2;\n    switch (i18n.strategy) {\n      // NOTE: theoretically, we should never hit this code path\n      case \"manual\": {\n        return response;\n      }\n      case \"domains-prefix-other-locales\": {\n        if (localeHasntDomain(i18n, currentLocale)) {\n          const result = prefixOtherLocales(context2, response);\n          if (result) {\n            return result;\n          }\n        }\n        break;\n      }\n      case \"pathname-prefix-other-locales\": {\n        const result = prefixOtherLocales(context2, response);\n        if (result) {\n          return result;\n        }\n        break;\n      }\n      case \"domains-prefix-always-no-redirect\": {\n        if (localeHasntDomain(i18n, currentLocale)) {\n          const result = _noFoundForNonLocaleRoute(context2, response);\n          if (result) {\n            return result;\n          }\n        }\n        break;\n      }\n      case \"pathname-prefix-always-no-redirect\": {\n        const result = _noFoundForNonLocaleRoute(context2, response);\n        if (result) {\n          return result;\n        }\n        break;\n      }\n      case \"pathname-prefix-always\": {\n        const result = prefixAlways(context2, response);\n        if (result) {\n          return result;\n        }\n        break;\n      }\n      case \"domains-prefix-always\": {\n        if (localeHasntDomain(i18n, currentLocale)) {\n          const result = prefixAlways(context2, response);\n          if (result) {\n            return result;\n          }\n        }\n        break;\n      }\n    }\n    return _redirectToFallback(context2, response);\n  };\n}\n__name(createI18nMiddleware, \"createI18nMiddleware\");\nfunction localeHasntDomain(i18n, currentLocale) {\n  for (const domainLocale of Object.values(i18n.domainLookupTable)) {\n    if (domainLocale === currentLocale) {\n      return false;\n    }\n  }\n  return true;\n}\n__name(localeHasntDomain, \"localeHasntDomain\");\nvar NOOP_ACTIONS_MOD = {\n  server: {}\n};\nvar FORM_CONTENT_TYPES = [\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\"\n];\nvar SAFE_METHODS = [\"GET\", \"HEAD\", \"OPTIONS\"];\nfunction createOriginCheckMiddleware() {\n  return defineMiddleware((context2, next) => {\n    const { request, url, isPrerendered } = context2;\n    if (isPrerendered) {\n      return next();\n    }\n    if (SAFE_METHODS.includes(request.method)) {\n      return next();\n    }\n    const isSameOrigin = request.headers.get(\"origin\") === url.origin;\n    const hasContentType2 = request.headers.has(\"content-type\");\n    if (hasContentType2) {\n      const formLikeHeader = hasFormLikeHeader(request.headers.get(\"content-type\"));\n      if (formLikeHeader && !isSameOrigin) {\n        return new Response(`Cross-site ${request.method} form submissions are forbidden`, {\n          status: 403\n        });\n      }\n    } else {\n      if (!isSameOrigin) {\n        return new Response(`Cross-site ${request.method} form submissions are forbidden`, {\n          status: 403\n        });\n      }\n    }\n    return next();\n  });\n}\n__name(createOriginCheckMiddleware, \"createOriginCheckMiddleware\");\nfunction hasFormLikeHeader(contentType) {\n  if (contentType) {\n    for (const FORM_CONTENT_TYPE of FORM_CONTENT_TYPES) {\n      if (contentType.toLowerCase().includes(FORM_CONTENT_TYPE)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n__name(hasFormLikeHeader, \"hasFormLikeHeader\");\nfunction createDefaultRoutes(manifest2) {\n  const root2 = new URL(manifest2.hrefRoot);\n  return [\n    {\n      instance: default404Instance,\n      matchesComponent: /* @__PURE__ */ __name((filePath) => filePath.href === new URL(DEFAULT_404_COMPONENT, root2).href, \"matchesComponent\"),\n      route: DEFAULT_404_ROUTE.route,\n      component: DEFAULT_404_COMPONENT\n    },\n    {\n      instance: createEndpoint(manifest2),\n      matchesComponent: /* @__PURE__ */ __name((filePath) => filePath.href === new URL(SERVER_ISLAND_COMPONENT, root2).href, \"matchesComponent\"),\n      route: SERVER_ISLAND_ROUTE,\n      component: SERVER_ISLAND_COMPONENT\n    }\n  ];\n}\n__name(createDefaultRoutes, \"createDefaultRoutes\");\nvar Pipeline = class {\n  static {\n    __name(this, \"Pipeline\");\n  }\n  constructor(logger, manifest2, runtimeMode, renderers2, resolve, serverLike, streaming, adapterName = manifest2.adapterName, clientDirectives = manifest2.clientDirectives, inlinedScripts = manifest2.inlinedScripts, compressHTML = manifest2.compressHTML, i18n = manifest2.i18n, middleware2 = manifest2.middleware, routeCache = new RouteCache(logger, runtimeMode), site = manifest2.site ? new URL(manifest2.site) : void 0, defaultRoutes = createDefaultRoutes(manifest2), actions2 = manifest2.actions) {\n    this.logger = logger;\n    this.manifest = manifest2;\n    this.runtimeMode = runtimeMode;\n    this.renderers = renderers2;\n    this.resolve = resolve;\n    this.serverLike = serverLike;\n    this.streaming = streaming;\n    this.adapterName = adapterName;\n    this.clientDirectives = clientDirectives;\n    this.inlinedScripts = inlinedScripts;\n    this.compressHTML = compressHTML;\n    this.i18n = i18n;\n    this.middleware = middleware2;\n    this.routeCache = routeCache;\n    this.site = site;\n    this.defaultRoutes = defaultRoutes;\n    this.actions = actions2;\n    this.internalMiddleware = [];\n    if (i18n?.strategy !== \"manual\") {\n      this.internalMiddleware.push(\n        createI18nMiddleware(i18n, manifest2.base, manifest2.trailingSlash, manifest2.buildFormat)\n      );\n    }\n  }\n  internalMiddleware;\n  resolvedMiddleware = void 0;\n  resolvedActions = void 0;\n  /**\n   * Resolves the middleware from the manifest, and returns the `onRequest` function. If `onRequest` isn't there,\n   * it returns a no-op function\n   */\n  async getMiddleware() {\n    if (this.resolvedMiddleware) {\n      return this.resolvedMiddleware;\n    } else if (this.middleware) {\n      const middlewareInstance = await this.middleware();\n      const onRequest2 = middlewareInstance.onRequest ?? NOOP_MIDDLEWARE_FN;\n      if (this.manifest.checkOrigin) {\n        this.resolvedMiddleware = sequence(createOriginCheckMiddleware(), onRequest2);\n      } else {\n        this.resolvedMiddleware = onRequest2;\n      }\n      return this.resolvedMiddleware;\n    } else {\n      this.resolvedMiddleware = NOOP_MIDDLEWARE_FN;\n      return this.resolvedMiddleware;\n    }\n  }\n  setActions(actions2) {\n    this.resolvedActions = actions2;\n  }\n  async getActions() {\n    if (this.resolvedActions) {\n      return this.resolvedActions;\n    } else if (this.actions) {\n      return await this.actions();\n    }\n    return NOOP_ACTIONS_MOD;\n  }\n  async getAction(path) {\n    const pathKeys = path.split(\".\").map((key) => decodeURIComponent(key));\n    let { server: server2 } = await this.getActions();\n    if (!server2 || !(typeof server2 === \"object\")) {\n      throw new TypeError(\n        `Expected \\`server\\` export in actions file to be an object. Received ${typeof server2}.`\n      );\n    }\n    for (const key of pathKeys) {\n      if (!(key in server2)) {\n        throw new AstroError({\n          ...ActionNotFoundError,\n          message: ActionNotFoundError.message(pathKeys.join(\".\"))\n        });\n      }\n      server2 = server2[key];\n    }\n    if (typeof server2 !== \"function\") {\n      throw new TypeError(\n        `Expected handler for action ${pathKeys.join(\".\")} to be a function. Received ${typeof server2}.`\n      );\n    }\n    return server2;\n  }\n};\nvar RedirectComponentInstance = {\n  default() {\n    return new Response(null, {\n      status: 301\n    });\n  }\n};\nvar RedirectSinglePageBuiltModule = {\n  page: /* @__PURE__ */ __name(() => Promise.resolve(RedirectComponentInstance), \"page\"),\n  onRequest: /* @__PURE__ */ __name((_3, next) => next(), \"onRequest\"),\n  renderers: []\n};\nvar dateTimeFormat = new Intl.DateTimeFormat([], {\n  hour: \"2-digit\",\n  minute: \"2-digit\",\n  second: \"2-digit\",\n  hour12: false\n});\nvar levels = {\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  silent: 90\n};\nfunction log3(opts, level, label, message, newLine = true) {\n  const logLevel = opts.level;\n  const dest = opts.dest;\n  const event = {\n    label,\n    level,\n    message,\n    newLine\n  };\n  if (!isLogLevelEnabled(logLevel, level)) {\n    return;\n  }\n  dest.write(event);\n}\n__name(log3, \"log\");\nfunction isLogLevelEnabled(configuredLogLevel, level) {\n  return levels[configuredLogLevel] <= levels[level];\n}\n__name(isLogLevelEnabled, \"isLogLevelEnabled\");\nfunction info3(opts, label, message, newLine = true) {\n  return log3(opts, \"info\", label, message, newLine);\n}\n__name(info3, \"info\");\nfunction warn3(opts, label, message, newLine = true) {\n  return log3(opts, \"warn\", label, message, newLine);\n}\n__name(warn3, \"warn\");\nfunction error3(opts, label, message, newLine = true) {\n  return log3(opts, \"error\", label, message, newLine);\n}\n__name(error3, \"error\");\nfunction debug3(...args) {\n  if (\"_astroGlobalDebug\" in globalThis) {\n    globalThis._astroGlobalDebug(...args);\n  }\n}\n__name(debug3, \"debug\");\nfunction getEventPrefix({ level, label }) {\n  const timestamp = `${dateTimeFormat.format(/* @__PURE__ */ new Date())}`;\n  const prefix = [];\n  if (level === \"error\" || level === \"warn\") {\n    prefix.push(bold(timestamp));\n    prefix.push(`[${level.toUpperCase()}]`);\n  } else {\n    prefix.push(timestamp);\n  }\n  if (label) {\n    prefix.push(`[${label}]`);\n  }\n  if (level === \"error\") {\n    return red(prefix.join(\" \"));\n  }\n  if (level === \"warn\") {\n    return yellow(prefix.join(\" \"));\n  }\n  if (prefix.length === 1) {\n    return dim(prefix[0]);\n  }\n  return dim(prefix[0]) + \" \" + blue(prefix.splice(1).join(\" \"));\n}\n__name(getEventPrefix, \"getEventPrefix\");\nvar Logger = class {\n  static {\n    __name(this, \"Logger\");\n  }\n  options;\n  constructor(options) {\n    this.options = options;\n  }\n  info(label, message, newLine = true) {\n    info3(this.options, label, message, newLine);\n  }\n  warn(label, message, newLine = true) {\n    warn3(this.options, label, message, newLine);\n  }\n  error(label, message, newLine = true) {\n    error3(this.options, label, message, newLine);\n  }\n  debug(label, ...messages) {\n    debug3(label, ...messages);\n  }\n  level() {\n    return this.options.level;\n  }\n  forkIntegrationLogger(label) {\n    return new AstroIntegrationLogger(this.options, label);\n  }\n};\nvar AstroIntegrationLogger = class _AstroIntegrationLogger {\n  static {\n    __name(this, \"AstroIntegrationLogger\");\n  }\n  options;\n  label;\n  constructor(logging, label) {\n    this.options = logging;\n    this.label = label;\n  }\n  /**\n   * Creates a new logger instance with a new label, but the same log options.\n   */\n  fork(label) {\n    return new _AstroIntegrationLogger(this.options, label);\n  }\n  info(message) {\n    info3(this.options, this.label, message);\n  }\n  warn(message) {\n    warn3(this.options, this.label, message);\n  }\n  error(message) {\n    error3(this.options, this.label, message);\n  }\n  debug(message) {\n    debug3(this.label, message);\n  }\n};\nvar consoleLogDestination = {\n  write(event) {\n    let dest = console.error;\n    if (levels[event.level] < levels[\"error\"]) {\n      dest = console.log;\n    }\n    if (event.label === \"SKIP_FORMAT\") {\n      dest(event.message);\n    } else {\n      dest(getEventPrefix(event) + \" \" + event.message);\n    }\n    return true;\n  }\n};\nfunction getAssetsPrefix(fileExtension2, assetsPrefix) {\n  if (!assetsPrefix) return \"\";\n  if (typeof assetsPrefix === \"string\") return assetsPrefix;\n  const dotLessFileExtension = fileExtension2.slice(1);\n  if (assetsPrefix[dotLessFileExtension]) {\n    return assetsPrefix[dotLessFileExtension];\n  }\n  return assetsPrefix.fallback;\n}\n__name(getAssetsPrefix, \"getAssetsPrefix\");\nfunction createAssetLink(href, base, assetsPrefix) {\n  if (assetsPrefix) {\n    const pf = getAssetsPrefix(fileExtension(href), assetsPrefix);\n    return joinPaths(pf, slash(href));\n  } else if (base) {\n    return prependForwardSlash(joinPaths(base, slash(href)));\n  } else {\n    return href;\n  }\n}\n__name(createAssetLink, \"createAssetLink\");\nfunction createStylesheetElement(stylesheet, base, assetsPrefix) {\n  if (stylesheet.type === \"inline\") {\n    return {\n      props: {},\n      children: stylesheet.content\n    };\n  } else {\n    return {\n      props: {\n        rel: \"stylesheet\",\n        href: createAssetLink(stylesheet.src, base, assetsPrefix)\n      },\n      children: \"\"\n    };\n  }\n}\n__name(createStylesheetElement, \"createStylesheetElement\");\nfunction createStylesheetElementSet(stylesheets, base, assetsPrefix) {\n  return new Set(stylesheets.map((s2) => createStylesheetElement(s2, base, assetsPrefix)));\n}\n__name(createStylesheetElementSet, \"createStylesheetElementSet\");\nfunction createModuleScriptElement(script2, base, assetsPrefix) {\n  if (script2.type === \"external\") {\n    return createModuleScriptElementWithSrc(script2.value, base, assetsPrefix);\n  } else {\n    return {\n      props: {\n        type: \"module\"\n      },\n      children: script2.value\n    };\n  }\n}\n__name(createModuleScriptElement, \"createModuleScriptElement\");\nfunction createModuleScriptElementWithSrc(src, base, assetsPrefix) {\n  return {\n    props: {\n      type: \"module\",\n      src: createAssetLink(src, base, assetsPrefix)\n    },\n    children: \"\"\n  };\n}\n__name(createModuleScriptElementWithSrc, \"createModuleScriptElementWithSrc\");\nfunction redirectTemplate({\n  status,\n  absoluteLocation,\n  relativeLocation,\n  from\n}) {\n  const delay = status === 302 ? 2 : 0;\n  return `<!doctype html>\n<title>Redirecting to: ${relativeLocation}</title>\n<meta http-equiv=\"refresh\" content=\"${delay};url=${relativeLocation}\">\n<meta name=\"robots\" content=\"noindex\">\n<link rel=\"canonical\" href=\"${absoluteLocation}\">\n<body>\n\t<a href=\"${relativeLocation}\">Redirecting ${from ? `from <code>${from}</code> ` : \"\"}to <code>${relativeLocation}</code></a>\n</body>`;\n}\n__name(redirectTemplate, \"redirectTemplate\");\nvar AppPipeline = class _AppPipeline extends Pipeline {\n  static {\n    __name(this, \"AppPipeline\");\n  }\n  static create({\n    logger,\n    manifest: manifest2,\n    runtimeMode,\n    renderers: renderers2,\n    resolve,\n    serverLike,\n    streaming,\n    defaultRoutes\n  }) {\n    const pipeline = new _AppPipeline(\n      logger,\n      manifest2,\n      runtimeMode,\n      renderers2,\n      resolve,\n      serverLike,\n      streaming,\n      void 0,\n      void 0,\n      void 0,\n      void 0,\n      void 0,\n      void 0,\n      void 0,\n      void 0,\n      defaultRoutes\n    );\n    return pipeline;\n  }\n  headElements(routeData) {\n    const routeInfo = this.manifest.routes.find((route) => route.routeData === routeData);\n    const links = /* @__PURE__ */ new Set();\n    const scripts = /* @__PURE__ */ new Set();\n    const styles = createStylesheetElementSet(routeInfo?.styles ?? []);\n    for (const script2 of routeInfo?.scripts ?? []) {\n      if (\"stage\" in script2) {\n        if (script2.stage === \"head-inline\") {\n          scripts.add({\n            props: {},\n            children: script2.children\n          });\n        }\n      } else {\n        scripts.add(createModuleScriptElement(script2));\n      }\n    }\n    return { links, styles, scripts };\n  }\n  componentMetadata() {\n  }\n  async getComponentByRoute(routeData) {\n    const module2 = await this.getModuleForRoute(routeData);\n    return module2.page();\n  }\n  async tryRewrite(payload, request) {\n    const { newUrl, pathname, routeData } = findRouteToRewrite({\n      payload,\n      request,\n      routes: this.manifest?.routes.map((r2) => r2.routeData),\n      trailingSlash: this.manifest.trailingSlash,\n      buildFormat: this.manifest.buildFormat,\n      base: this.manifest.base\n    });\n    const componentInstance = await this.getComponentByRoute(routeData);\n    return { newUrl, pathname, componentInstance, routeData };\n  }\n  async getModuleForRoute(route) {\n    for (const defaultRoute of this.defaultRoutes) {\n      if (route.component === defaultRoute.component) {\n        return {\n          page: /* @__PURE__ */ __name(() => Promise.resolve(defaultRoute.instance), \"page\"),\n          renderers: []\n        };\n      }\n    }\n    if (route.type === \"redirect\") {\n      return RedirectSinglePageBuiltModule;\n    } else {\n      if (this.manifest.pageMap) {\n        const importComponentInstance = this.manifest.pageMap.get(route.component);\n        if (!importComponentInstance) {\n          throw new Error(\n            `Unexpectedly unable to find a component instance for route ${route.route}`\n          );\n        }\n        return await importComponentInstance();\n      } else if (this.manifest.pageModule) {\n        return this.manifest.pageModule;\n      }\n      throw new Error(\n        \"Astro couldn't find the correct page to render, probably because it wasn't correctly mapped for SSR usage. This is an internal error, please file an issue.\"\n      );\n    }\n  }\n};\nvar App = class _App {\n  static {\n    __name(this, \"App\");\n  }\n  #manifest;\n  #manifestData;\n  #logger = new Logger({\n    dest: consoleLogDestination,\n    level: \"info\"\n  });\n  #baseWithoutTrailingSlash;\n  #pipeline;\n  #adapterLogger;\n  constructor(manifest2, streaming = true) {\n    this.#manifest = manifest2;\n    this.#manifestData = {\n      routes: manifest2.routes.map((route) => route.routeData)\n    };\n    ensure404Route(this.#manifestData);\n    this.#baseWithoutTrailingSlash = removeTrailingForwardSlash(this.#manifest.base);\n    this.#pipeline = this.#createPipeline(streaming);\n    this.#adapterLogger = new AstroIntegrationLogger(\n      this.#logger.options,\n      this.#manifest.adapterName\n    );\n  }\n  getAdapterLogger() {\n    return this.#adapterLogger;\n  }\n  /**\n   * Creates a pipeline by reading the stored manifest\n   *\n   * @param streaming\n   * @private\n   */\n  #createPipeline(streaming = false) {\n    return AppPipeline.create({\n      logger: this.#logger,\n      manifest: this.#manifest,\n      runtimeMode: \"production\",\n      renderers: this.#manifest.renderers,\n      defaultRoutes: createDefaultRoutes(this.#manifest),\n      resolve: /* @__PURE__ */ __name(async (specifier) => {\n        if (!(specifier in this.#manifest.entryModules)) {\n          throw new Error(`Unable to resolve [${specifier}]`);\n        }\n        const bundlePath = this.#manifest.entryModules[specifier];\n        if (bundlePath.startsWith(\"data:\") || bundlePath.length === 0) {\n          return bundlePath;\n        } else {\n          return createAssetLink(bundlePath, this.#manifest.base, this.#manifest.assetsPrefix);\n        }\n      }, \"resolve\"),\n      serverLike: true,\n      streaming\n    });\n  }\n  set setManifestData(newManifestData) {\n    this.#manifestData = newManifestData;\n  }\n  removeBase(pathname) {\n    if (pathname.startsWith(this.#manifest.base)) {\n      return pathname.slice(this.#baseWithoutTrailingSlash.length + 1);\n    }\n    return pathname;\n  }\n  /**\n   * It removes the base from the request URL, prepends it with a forward slash and attempts to decoded it.\n   *\n   * If the decoding fails, it logs the error and return the pathname as is.\n   * @param request\n   * @private\n   */\n  #getPathnameFromRequest(request) {\n    const url = new URL(request.url);\n    const pathname = prependForwardSlash(this.removeBase(url.pathname));\n    try {\n      return decodeURI(pathname);\n    } catch (e) {\n      this.getAdapterLogger().error(e.toString());\n      return pathname;\n    }\n  }\n  match(request) {\n    const url = new URL(request.url);\n    if (this.#manifest.assets.has(url.pathname)) return void 0;\n    let pathname = this.#computePathnameFromDomain(request);\n    if (!pathname) {\n      pathname = prependForwardSlash(this.removeBase(url.pathname));\n    }\n    let routeData = matchRoute(decodeURI(pathname), this.#manifestData);\n    if (!routeData || routeData.prerender) return void 0;\n    return routeData;\n  }\n  #computePathnameFromDomain(request) {\n    let pathname = void 0;\n    const url = new URL(request.url);\n    if (this.#manifest.i18n && (this.#manifest.i18n.strategy === \"domains-prefix-always\" || this.#manifest.i18n.strategy === \"domains-prefix-other-locales\" || this.#manifest.i18n.strategy === \"domains-prefix-always-no-redirect\")) {\n      let host = request.headers.get(\"X-Forwarded-Host\");\n      let protocol = request.headers.get(\"X-Forwarded-Proto\");\n      if (protocol) {\n        protocol = protocol + \":\";\n      } else {\n        protocol = url.protocol;\n      }\n      if (!host) {\n        host = request.headers.get(\"Host\");\n      }\n      if (host && protocol) {\n        host = host.split(\":\")[0];\n        try {\n          let locale;\n          const hostAsUrl = new URL(`${protocol}//${host}`);\n          for (const [domainKey, localeValue] of Object.entries(\n            this.#manifest.i18n.domainLookupTable\n          )) {\n            const domainKeyAsUrl = new URL(domainKey);\n            if (hostAsUrl.host === domainKeyAsUrl.host && hostAsUrl.protocol === domainKeyAsUrl.protocol) {\n              locale = localeValue;\n              break;\n            }\n          }\n          if (locale) {\n            pathname = prependForwardSlash(\n              joinPaths(normalizeTheLocale(locale), this.removeBase(url.pathname))\n            );\n            if (url.pathname.endsWith(\"/\")) {\n              pathname = appendForwardSlash(pathname);\n            }\n          }\n        } catch (e) {\n          this.#logger.error(\n            \"router\",\n            `Astro tried to parse ${protocol}//${host} as an URL, but it threw a parsing error. Check the X-Forwarded-Host and X-Forwarded-Proto headers.`\n          );\n          this.#logger.error(\"router\", `Error: ${e}`);\n        }\n      }\n    }\n    return pathname;\n  }\n  #redirectTrailingSlash(pathname) {\n    const { trailingSlash } = this.#manifest;\n    if (pathname === \"/\" || pathname.startsWith(\"/_\")) {\n      return pathname;\n    }\n    const path = collapseDuplicateTrailingSlashes(pathname, trailingSlash !== \"never\");\n    if (path !== pathname) {\n      return path;\n    }\n    if (trailingSlash === \"ignore\") {\n      return pathname;\n    }\n    if (trailingSlash === \"always\" && !hasFileExtension(pathname)) {\n      return appendForwardSlash(pathname);\n    }\n    if (trailingSlash === \"never\") {\n      return removeTrailingForwardSlash(pathname);\n    }\n    return pathname;\n  }\n  async render(request, renderOptions) {\n    let routeData;\n    let locals;\n    let clientAddress;\n    let addCookieHeader;\n    const url = new URL(request.url);\n    const redirect = this.#redirectTrailingSlash(url.pathname);\n    const prerenderedErrorPageFetch = renderOptions?.prerenderedErrorPageFetch ?? fetch;\n    if (redirect !== url.pathname) {\n      const status = request.method === \"GET\" ? 301 : 308;\n      return new Response(\n        redirectTemplate({\n          status,\n          relativeLocation: url.pathname,\n          absoluteLocation: redirect,\n          from: request.url\n        }),\n        {\n          status,\n          headers: {\n            location: redirect + url.search\n          }\n        }\n      );\n    }\n    addCookieHeader = renderOptions?.addCookieHeader;\n    clientAddress = renderOptions?.clientAddress ?? Reflect.get(request, clientAddressSymbol);\n    routeData = renderOptions?.routeData;\n    locals = renderOptions?.locals;\n    if (routeData) {\n      this.#logger.debug(\n        \"router\",\n        \"The adapter \" + this.#manifest.adapterName + \" provided a custom RouteData for \",\n        request.url\n      );\n      this.#logger.debug(\"router\", \"RouteData:\\n\" + routeData);\n    }\n    if (locals) {\n      if (typeof locals !== \"object\") {\n        const error4 = new AstroError(LocalsNotAnObject);\n        this.#logger.error(null, error4.stack);\n        return this.#renderError(request, {\n          status: 500,\n          error: error4,\n          clientAddress,\n          prerenderedErrorPageFetch\n        });\n      }\n    }\n    if (!routeData) {\n      routeData = this.match(request);\n      this.#logger.debug(\"router\", \"Astro matched the following route for \" + request.url);\n      this.#logger.debug(\"router\", \"RouteData:\\n\" + routeData);\n    }\n    if (!routeData) {\n      routeData = this.#manifestData.routes.find(\n        (route) => route.component === \"404.astro\" || route.component === DEFAULT_404_COMPONENT\n      );\n    }\n    if (!routeData) {\n      this.#logger.debug(\"router\", \"Astro hasn't found routes that match \" + request.url);\n      this.#logger.debug(\"router\", \"Here's the available routes:\\n\", this.#manifestData);\n      return this.#renderError(request, {\n        locals,\n        status: 404,\n        clientAddress,\n        prerenderedErrorPageFetch\n      });\n    }\n    const pathname = this.#getPathnameFromRequest(request);\n    const defaultStatus = this.#getDefaultStatusCode(routeData, pathname);\n    let response;\n    let session;\n    try {\n      const mod = await this.#pipeline.getModuleForRoute(routeData);\n      const renderContext = await RenderContext.create({\n        pipeline: this.#pipeline,\n        locals,\n        pathname,\n        request,\n        routeData,\n        status: defaultStatus,\n        clientAddress\n      });\n      session = renderContext.session;\n      response = await renderContext.render(await mod.page());\n    } catch (err) {\n      this.#logger.error(null, err.stack || err.message || String(err));\n      return this.#renderError(request, {\n        locals,\n        status: 500,\n        error: err,\n        clientAddress,\n        prerenderedErrorPageFetch\n      });\n    } finally {\n      await session?.[PERSIST_SYMBOL]();\n    }\n    if (REROUTABLE_STATUS_CODES.includes(response.status) && response.headers.get(REROUTE_DIRECTIVE_HEADER) !== \"no\") {\n      return this.#renderError(request, {\n        locals,\n        response,\n        status: response.status,\n        // We don't have an error to report here. Passing null means we pass nothing intentionally\n        // while undefined means there's no error\n        error: response.status === 500 ? null : void 0,\n        clientAddress,\n        prerenderedErrorPageFetch\n      });\n    }\n    if (response.headers.has(REROUTE_DIRECTIVE_HEADER)) {\n      response.headers.delete(REROUTE_DIRECTIVE_HEADER);\n    }\n    if (addCookieHeader) {\n      for (const setCookieHeaderValue of _App.getSetCookieFromResponse(response)) {\n        response.headers.append(\"set-cookie\", setCookieHeaderValue);\n      }\n    }\n    Reflect.set(response, responseSentSymbol, true);\n    return response;\n  }\n  setCookieHeaders(response) {\n    return getSetCookiesFromResponse(response);\n  }\n  /**\n   * Reads all the cookies written by `Astro.cookie.set()` onto the passed response.\n   * For example,\n   * ```ts\n   * for (const cookie_ of App.getSetCookieFromResponse(response)) {\n   *     const cookie: string = cookie_\n   * }\n   * ```\n   * @param response The response to read cookies from.\n   * @returns An iterator that yields key-value pairs as equal-sign-separated strings.\n   */\n  static getSetCookieFromResponse = getSetCookiesFromResponse;\n  /**\n   * If it is a known error code, try sending the according page (e.g. 404.astro / 500.astro).\n   * This also handles pre-rendered /404 or /500 routes\n   */\n  async #renderError(request, {\n    locals,\n    status,\n    response: originalResponse,\n    skipMiddleware = false,\n    error: error4,\n    clientAddress,\n    prerenderedErrorPageFetch\n  }) {\n    const errorRoutePath = `/${status}${this.#manifest.trailingSlash === \"always\" ? \"/\" : \"\"}`;\n    const errorRouteData = matchRoute(errorRoutePath, this.#manifestData);\n    const url = new URL(request.url);\n    if (errorRouteData) {\n      if (errorRouteData.prerender) {\n        const maybeDotHtml = errorRouteData.route.endsWith(`/${status}`) ? \".html\" : \"\";\n        const statusURL = new URL(\n          `${this.#baseWithoutTrailingSlash}/${status}${maybeDotHtml}`,\n          url\n        );\n        if (statusURL.toString() !== request.url) {\n          const response2 = await prerenderedErrorPageFetch(statusURL.toString());\n          const override = { status };\n          return this.#mergeResponses(response2, originalResponse, override);\n        }\n      }\n      const mod = await this.#pipeline.getModuleForRoute(errorRouteData);\n      let session;\n      try {\n        const renderContext = await RenderContext.create({\n          locals,\n          pipeline: this.#pipeline,\n          middleware: skipMiddleware ? NOOP_MIDDLEWARE_FN : void 0,\n          pathname: this.#getPathnameFromRequest(request),\n          request,\n          routeData: errorRouteData,\n          status,\n          props: { error: error4 },\n          clientAddress\n        });\n        session = renderContext.session;\n        const response2 = await renderContext.render(await mod.page());\n        return this.#mergeResponses(response2, originalResponse);\n      } catch {\n        if (skipMiddleware === false) {\n          return this.#renderError(request, {\n            locals,\n            status,\n            response: originalResponse,\n            skipMiddleware: true,\n            clientAddress,\n            prerenderedErrorPageFetch\n          });\n        }\n      } finally {\n        await session?.[PERSIST_SYMBOL]();\n      }\n    }\n    const response = this.#mergeResponses(new Response(null, { status }), originalResponse);\n    Reflect.set(response, responseSentSymbol, true);\n    return response;\n  }\n  #mergeResponses(newResponse, originalResponse, override) {\n    if (!originalResponse) {\n      if (override !== void 0) {\n        return new Response(newResponse.body, {\n          status: override.status,\n          statusText: newResponse.statusText,\n          headers: newResponse.headers\n        });\n      }\n      return newResponse;\n    }\n    const status = override?.status ? override.status : originalResponse.status === 200 ? newResponse.status : originalResponse.status;\n    try {\n      originalResponse.headers.delete(\"Content-type\");\n    } catch {\n    }\n    const mergedHeaders = new Map([\n      ...Array.from(newResponse.headers),\n      ...Array.from(originalResponse.headers)\n    ]);\n    const newHeaders = new Headers();\n    for (const [name, value2] of mergedHeaders) {\n      newHeaders.set(name, value2);\n    }\n    return new Response(newResponse.body, {\n      status,\n      statusText: status === 200 ? newResponse.statusText : originalResponse.statusText,\n      // If you're looking at here for possible bugs, it means that it's not a bug.\n      // With the middleware, users can meddle with headers, and we should pass to the 404/500.\n      // If users see something weird, it's because they are setting some headers they should not.\n      //\n      // Although, we don't want it to replace the content-type, because the error page must return `text/html`\n      headers: newHeaders\n    });\n  }\n  #getDefaultStatusCode(routeData, pathname) {\n    if (!routeData.pattern.test(pathname)) {\n      for (const fallbackRoute of routeData.fallbackRoutes) {\n        if (fallbackRoute.pattern.test(pathname)) {\n          return 302;\n        }\n      }\n    }\n    const route = removeTrailingForwardSlash(routeData.route);\n    if (route.endsWith(\"/404\")) return 404;\n    if (route.endsWith(\"/500\")) return 500;\n    return 200;\n  }\n};\nfunction createExports(manifest2) {\n  const app = new App(manifest2);\n  const fetch2 = /* @__PURE__ */ __name(async (request, env2, context2) => {\n    const { pathname } = new URL(request.url);\n    const bindingName = \"SESSION\";\n    globalThis.__env__ ??= {};\n    globalThis.__env__[bindingName] = env2[bindingName];\n    if (manifest2.assets.has(pathname)) {\n      return env2.ASSETS.fetch(request.url.replace(/\\.html$/, \"\"));\n    }\n    const routeData = app.match(request);\n    if (!routeData) {\n      const asset = await env2.ASSETS.fetch(\n        request.url.replace(/index.html$/, \"\").replace(/\\.html$/, \"\")\n      );\n      if (asset.status !== 404) {\n        return asset;\n      }\n    }\n    Reflect.set(\n      request,\n      Symbol.for(\"astro.clientAddress\"),\n      request.headers.get(\"cf-connecting-ip\")\n    );\n    process.env.ASTRO_STUDIO_APP_TOKEN ??= (() => {\n      if (typeof env2.ASTRO_STUDIO_APP_TOKEN === \"string\") {\n        return env2.ASTRO_STUDIO_APP_TOKEN;\n      }\n    })();\n    const locals = {\n      runtime: {\n        env: env2,\n        cf: request.cf,\n        caches,\n        ctx: {\n          waitUntil: /* @__PURE__ */ __name((promise) => context2.waitUntil(promise), \"waitUntil\"),\n          // Currently not available: https://developers.cloudflare.com/pages/platform/known-issues/#pages-functions\n          passThroughOnException: /* @__PURE__ */ __name(() => {\n            throw new Error(\n              \"`passThroughOnException` is currently not available in Cloudflare Pages. See https://developers.cloudflare.com/pages/platform/known-issues/#pages-functions.\"\n            );\n          }, \"passThroughOnException\"),\n          props: {}\n        }\n      }\n    };\n    const response = await app.render(request, { routeData, locals });\n    if (app.setCookieHeaders) {\n      for (const setCookieHeader of app.setCookieHeaders(response)) {\n        response.headers.append(\"Set-Cookie\", setCookieHeader);\n      }\n    }\n    return response;\n  }, \"fetch\");\n  return { default: { fetch: fetch2 } };\n}\n__name(createExports, \"createExports\");\nvar serverEntrypointModule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  createExports\n}, Symbol.toStringTag, { value: \"Module\" }));\n\n// dist/_worker.js/manifest_IvPXL3eN.mjs\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();\ninit_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();\ninit_performance2();\ninit_server_C8vVOH8G();\ninit_astro_designed_error_pages_DuwJl2PN();\nglobalThis.process ??= {};\nglobalThis.process.env ??= {};\nfunction sanitizeParams(params) {\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value2]) => {\n      if (typeof value2 === \"string\") {\n        return [key, value2.normalize().replace(/#/g, \"%23\").replace(/\\?/g, \"%3F\")];\n      }\n      return [key, value2];\n    })\n  );\n}\n__name(sanitizeParams, \"sanitizeParams\");\nfunction getParameter(part, params) {\n  if (part.spread) {\n    return params[part.content.slice(3)] || \"\";\n  }\n  if (part.dynamic) {\n    if (!params[part.content]) {\n      throw new TypeError(`Missing parameter: ${part.content}`);\n    }\n    return params[part.content];\n  }\n  return part.content.normalize().replace(/\\?/g, \"%3F\").replace(/#/g, \"%23\").replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n}\n__name(getParameter, \"getParameter\");\nfunction getSegment(segment, params) {\n  const segmentPath = segment.map((part) => getParameter(part, params)).join(\"\");\n  return segmentPath ? \"/\" + segmentPath : \"\";\n}\n__name(getSegment, \"getSegment\");\nfunction getRouteGenerator(segments, addTrailingSlash) {\n  return (params) => {\n    const sanitizedParams = sanitizeParams(params);\n    let trailing = \"\";\n    if (addTrailingSlash === \"always\" && segments.length) {\n      trailing = \"/\";\n    }\n    const path = segments.map((segment) => getSegment(segment, sanitizedParams)).join(\"\") + trailing;\n    return path || \"/\";\n  };\n}\n__name(getRouteGenerator, \"getRouteGenerator\");\nfunction deserializeRouteData(rawRouteData) {\n  return {\n    route: rawRouteData.route,\n    type: rawRouteData.type,\n    pattern: new RegExp(rawRouteData.pattern),\n    params: rawRouteData.params,\n    component: rawRouteData.component,\n    generate: getRouteGenerator(rawRouteData.segments, rawRouteData._meta.trailingSlash),\n    pathname: rawRouteData.pathname || void 0,\n    segments: rawRouteData.segments,\n    prerender: rawRouteData.prerender,\n    redirect: rawRouteData.redirect,\n    redirectRoute: rawRouteData.redirectRoute ? deserializeRouteData(rawRouteData.redirectRoute) : void 0,\n    fallbackRoutes: rawRouteData.fallbackRoutes.map((fallback) => {\n      return deserializeRouteData(fallback);\n    }),\n    isIndex: rawRouteData.isIndex,\n    origin: rawRouteData.origin\n  };\n}\n__name(deserializeRouteData, \"deserializeRouteData\");\nfunction deserializeManifest(serializedManifest) {\n  const routes = [];\n  for (const serializedRoute of serializedManifest.routes) {\n    routes.push({\n      ...serializedRoute,\n      routeData: deserializeRouteData(serializedRoute.routeData)\n    });\n    const route = serializedRoute;\n    route.routeData = deserializeRouteData(serializedRoute.routeData);\n  }\n  const assets = new Set(serializedManifest.assets);\n  const componentMetadata = new Map(serializedManifest.componentMetadata);\n  const inlinedScripts = new Map(serializedManifest.inlinedScripts);\n  const clientDirectives = new Map(serializedManifest.clientDirectives);\n  const serverIslandNameMap = new Map(serializedManifest.serverIslandNameMap);\n  const key = decodeKey(serializedManifest.key);\n  return {\n    // in case user middleware exists, this no-op middleware will be reassigned (see plugin-ssr.ts)\n    middleware() {\n      return { onRequest: NOOP_MIDDLEWARE_FN };\n    },\n    ...serializedManifest,\n    assets,\n    componentMetadata,\n    inlinedScripts,\n    clientDirectives,\n    routes,\n    serverIslandNameMap,\n    key\n  };\n}\n__name(deserializeManifest, \"deserializeManifest\");\nvar manifest = deserializeManifest({ \"hrefRoot\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/\", \"cacheDir\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/node_modules/.astro/\", \"outDir\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/dist/\", \"srcDir\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/src/\", \"publicDir\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/public/\", \"buildClientDir\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/dist/\", \"buildServerDir\": \"file:///Users/cameronpak/Projects/freedom-stack-v2/dist/_worker.js/\", \"adapterName\": \"@astrojs/cloudflare\", \"routes\": [{ \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [], \"routeData\": { \"type\": \"page\", \"component\": \"_server-islands.astro\", \"params\": [\"name\"], \"segments\": [[{ \"content\": \"_server-islands\", \"dynamic\": false, \"spread\": false }], [{ \"content\": \"name\", \"dynamic\": true, \"spread\": false }]], \"pattern\": \"^\\\\/_server-islands\\\\/([^/]+?)\\\\/?$\", \"prerender\": false, \"isIndex\": false, \"fallbackRoutes\": [], \"route\": \"/_server-islands/[name]\", \"origin\": \"internal\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }, { \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [], \"routeData\": { \"type\": \"endpoint\", \"isIndex\": false, \"route\": \"/_image\", \"pattern\": \"^\\\\/_image\\\\/?$\", \"segments\": [[{ \"content\": \"_image\", \"dynamic\": false, \"spread\": false }]], \"params\": [], \"component\": \"node_modules/@astrojs/cloudflare/dist/entrypoints/image-endpoint.js\", \"pathname\": \"/_image\", \"prerender\": false, \"fallbackRoutes\": [], \"origin\": \"internal\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }, { \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [{ \"type\": \"external\", \"src\": \"/_astro/_admin_.CJlyoYAQ.css\" }], \"routeData\": { \"route\": \"/admin/[...admin]\", \"isIndex\": false, \"type\": \"page\", \"pattern\": \"^\\\\/admin(?:\\\\/(.*?))?\\\\/?$\", \"segments\": [[{ \"content\": \"admin\", \"dynamic\": false, \"spread\": false }], [{ \"content\": \"...admin\", \"dynamic\": true, \"spread\": true }]], \"params\": [\"...admin\"], \"component\": \"src/pages/admin/[...admin].astro\", \"prerender\": false, \"fallbackRoutes\": [], \"distURL\": [], \"origin\": \"project\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }, { \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [], \"routeData\": { \"route\": \"/api/[...api]\", \"isIndex\": false, \"type\": \"endpoint\", \"pattern\": \"^\\\\/api(?:\\\\/(.*?))?\\\\/?$\", \"segments\": [[{ \"content\": \"api\", \"dynamic\": false, \"spread\": false }], [{ \"content\": \"...api\", \"dynamic\": true, \"spread\": true }]], \"params\": [\"...api\"], \"component\": \"src/pages/api/[...api].ts\", \"prerender\": false, \"fallbackRoutes\": [], \"distURL\": [], \"origin\": \"project\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }, { \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [{ \"type\": \"external\", \"src\": \"/_astro/index.D8R6ytBx.css\" }], \"routeData\": { \"route\": \"/login\", \"isIndex\": false, \"type\": \"page\", \"pattern\": \"^\\\\/login\\\\/?$\", \"segments\": [[{ \"content\": \"login\", \"dynamic\": false, \"spread\": false }]], \"params\": [], \"component\": \"src/pages/login.astro\", \"pathname\": \"/login\", \"prerender\": false, \"fallbackRoutes\": [], \"distURL\": [], \"origin\": \"project\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }, { \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [{ \"type\": \"external\", \"src\": \"/_astro/index.D8R6ytBx.css\" }], \"routeData\": { \"route\": \"/register\", \"isIndex\": false, \"type\": \"page\", \"pattern\": \"^\\\\/register\\\\/?$\", \"segments\": [[{ \"content\": \"register\", \"dynamic\": false, \"spread\": false }]], \"params\": [], \"component\": \"src/pages/register.astro\", \"pathname\": \"/register\", \"prerender\": false, \"fallbackRoutes\": [], \"distURL\": [], \"origin\": \"project\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }, { \"file\": \"\", \"links\": [], \"scripts\": [], \"styles\": [{ \"type\": \"external\", \"src\": \"/_astro/index.D8R6ytBx.css\" }], \"routeData\": { \"route\": \"/\", \"isIndex\": true, \"type\": \"page\", \"pattern\": \"^\\\\/$\", \"segments\": [], \"params\": [], \"component\": \"src/pages/index.astro\", \"pathname\": \"/\", \"prerender\": false, \"fallbackRoutes\": [], \"distURL\": [], \"origin\": \"project\", \"_meta\": { \"trailingSlash\": \"ignore\" } } }], \"base\": \"/\", \"trailingSlash\": \"ignore\", \"compressHTML\": true, \"componentMetadata\": [[\"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/index.astro\", { \"propagation\": \"none\", \"containsHead\": true }], [\"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/login.astro\", { \"propagation\": \"none\", \"containsHead\": true }], [\"/Users/cameronpak/Projects/freedom-stack-v2/src/pages/register.astro\", { \"propagation\": \"none\", \"containsHead\": true }]], \"renderers\": [], \"clientDirectives\": [[\"idle\", '(()=>{var l=(n,t)=>{let i=async()=>{await(await n())()},e=typeof t.value==\"object\"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};\"requestIdleCallback\"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event(\"astro:idle\"));})();'], [\"load\", '(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event(\"astro:load\"));})();'], [\"media\", '(()=>{var n=(a,t)=>{let i=async()=>{await(await a())()};if(t.value){let e=matchMedia(t.value);e.matches?i():e.addEventListener(\"change\",i,{once:!0})}};(self.Astro||(self.Astro={})).media=n;window.dispatchEvent(new Event(\"astro:media\"));})();'], [\"only\", '(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event(\"astro:only\"));})();'], [\"visible\", '(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value==\"object\"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event(\"astro:visible\"));})();']], \"entryModules\": { \"\\0astro-internal:middleware\": \"_astro-internal_middleware.mjs\", \"\\0noop-actions\": \"_noop-actions.mjs\", \"\\0@astro-page:node_modules/@astrojs/cloudflare/dist/entrypoints/image-endpoint@_@js\": \"pages/_image.astro.mjs\", \"\\0@astro-page:src/pages/admin/[...admin]@_@astro\": \"pages/admin/_---admin_.astro.mjs\", \"\\0@astro-page:src/pages/api/[...api]@_@ts\": \"pages/api/_---api_.astro.mjs\", \"\\0@astro-page:src/pages/login@_@astro\": \"pages/login.astro.mjs\", \"\\0@astro-page:src/pages/register@_@astro\": \"pages/register.astro.mjs\", \"\\0@astro-page:src/pages/index@_@astro\": \"pages/index.astro.mjs\", \"\\0@astrojs-ssr-virtual-entry\": \"index.js\", \"\\0@astro-renderers\": \"renderers.mjs\", \"\\0@astrojs-ssr-adapter\": \"_@astrojs-ssr-adapter.mjs\", \"\\0@astrojs-manifest\": \"manifest_IvPXL3eN.mjs\", \"/Users/cameronpak/Projects/freedom-stack-v2/node_modules/unstorage/drivers/cloudflare-kv-binding.mjs\": \"chunks/cloudflare-kv-binding_DMly_2Gl.mjs\", \"bknd/ui\": \"_astro/ui.Cp5AA5ci.js\", \"@astrojs/react/client.js\": \"_astro/client.Up2Hkbyd.js\", \"/Users/cameronpak/Projects/freedom-stack-v2/src/layouts/Layout.astro?astro&type=script&index=0&lang.ts\": \"_astro/Layout.astro_astro_type_script_index_0_lang.76o3Buaa.js\", \"astro:scripts/before-hydration.js\": \"\" }, \"inlinedScripts\": [], \"assets\": [\"/_astro/_admin_.CJlyoYAQ.css\", \"/_astro/index.D8R6ytBx.css\", \"/favicon.svg\", \"/_astro/Layout.astro_astro_type_script_index_0_lang.76o3Buaa.js\", \"/_astro/client.Up2Hkbyd.js\", \"/_astro/index.N6C3Up5A.js\", \"/_astro/ui.Cp5AA5ci.js\", \"/_worker.js/_@astrojs-ssr-adapter.mjs\", \"/_worker.js/_astro-internal_middleware.mjs\", \"/_worker.js/_noop-actions.mjs\", \"/_worker.js/index.js\", \"/_worker.js/renderers.mjs\", \"/_worker.js/_astro/_admin_.CJlyoYAQ.css\", \"/_worker.js/_astro/index.D8R6ytBx.css\", \"/_worker.js/chunks/Layout_Co7HziVl.mjs\", \"/_worker.js/chunks/_@astrojs-ssr-adapter_1KT6roWP.mjs\", \"/_worker.js/chunks/astro-designed-error-pages_DuwJl2PN.mjs\", \"/_worker.js/chunks/astro_BrVUdXHF.mjs\", \"/_worker.js/chunks/bknd.config_m27Qk-4t.mjs\", \"/_worker.js/chunks/bknd_BKPYnq1E.mjs\", \"/_worker.js/chunks/cloudflare-kv-binding_DMly_2Gl.mjs\", \"/_worker.js/chunks/index_Bos_IFPf.mjs\", \"/_worker.js/chunks/noop-middleware_BS-seCif.mjs\", \"/_worker.js/pages/_image.astro.mjs\", \"/_worker.js/pages/index.astro.mjs\", \"/_worker.js/pages/login.astro.mjs\", \"/_worker.js/pages/register.astro.mjs\", \"/temp/uploads/5oBXmkHJk3PWESFr.png\", \"/temp/uploads/CBGvO0XmceD1t4tz.png\", \"/temp/uploads/camoji.png\", \"/_worker.js/chunks/astro/server_C8vVOH8G.mjs\", \"/_worker.js/pages/admin/_---admin_.astro.mjs\", \"/_worker.js/pages/api/_---api_.astro.mjs\"], \"buildFormat\": \"directory\", \"checkOrigin\": true, \"serverIslandNameMap\": [], \"key\": \"8VwiGZKxvjnLzHMbzVD1dNj84W8g+ROPGJOPCNgps5o=\", \"sessionConfig\": { \"driver\": \"cloudflare-kv-binding\", \"options\": { \"binding\": \"SESSION\" } } });\nif (manifest.sessionConfig) manifest.sessionConfig.driverModule = () => Promise.resolve().then(() => (init_cloudflare_kv_binding_DMly_2Gl(), cloudflare_kv_binding_DMly_2Gl_exports));\n\n// dist/_worker.js/index.js\nglobalThis.process ??= {};\nglobalThis.process.env ??= {};\nvar serverIslandMap = /* @__PURE__ */ new Map();\nvar _page0 = /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_image_astro(), image_astro_exports)), \"_page0\");\nvar _page1 = /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_admin_astro(), admin_astro_exports)), \"_page1\");\nvar _page22 = /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_api_astro(), api_astro_exports)), \"_page2\");\nvar _page32 = /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_login_astro(), login_astro_exports)), \"_page3\");\nvar _page42 = /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_register_astro(), register_astro_exports)), \"_page4\");\nvar _page52 = /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_index_astro(), index_astro_exports)), \"_page5\");\nvar pageMap = /* @__PURE__ */ new Map([\n  [\"node_modules/@astrojs/cloudflare/dist/entrypoints/image-endpoint.js\", _page0],\n  [\"src/pages/admin/[...admin].astro\", _page1],\n  [\"src/pages/api/[...api].ts\", _page22],\n  [\"src/pages/login.astro\", _page32],\n  [\"src/pages/register.astro\", _page42],\n  [\"src/pages/index.astro\", _page52]\n]);\nvar _manifest = Object.assign(manifest, {\n  pageMap,\n  serverIslandMap,\n  renderers,\n  actions: /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_noop_actions(), noop_actions_exports)), \"actions\"),\n  middleware: /* @__PURE__ */ __name(() => Promise.resolve().then(() => (init_astro_internal_middleware(), astro_internal_middleware_exports)), \"middleware\")\n});\nvar _args = void 0;\nvar _exports = createExports(_manifest);\nvar __astrojsSsrVirtualEntry = _exports.default;\nvar _start = \"start\";\nif (_start in serverEntrypointModule) {\n  serverEntrypointModule[_start](_manifest, _args);\n}\nexport {\n  __astrojsSsrVirtualEntry as default,\n  pageMap\n};\n/**\n * shortdash - https://github.com/bibig/node-shorthash\n *\n * @license\n *\n * (The MIT License)\n *\n * Copyright (c) 2013 Bibig <bibig@me.com>\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n/*! https://mths.be/cssesc v3.0.0 by @mathias */\n/**\n * @license React\n * react.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license React\n * react-dom.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license React\n * react-dom-server.edge.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license React\n * react-dom-server-legacy.browser.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * @license MIT <https://opensource.org/licenses/MIT>\n * @copyright Michael Hart 2024\n */\n"
  },
  "props": {
    "entryPoint": "dist/_worker.js",
    "format": "esm",
    "target": "esnext",
    "platform": "node",
    "minify": false,
    "conditions": [
      "workerd",
      "worker",
      "browser"
    ],
    "absWorkingDir": "/Users/cameronpak/Projects/freedom-stack-v2",
    "keepNames": true,
    "loader": {
      ".sql": "text",
      ".json": "json"
    },
    "plugins": [
      {
        "name": "wasm"
      },
      {
        "name": "hybrid-nodejs_compat"
      }
    ],
    "external": [
      "node:async_hooks",
      "node:assert",
      "node:buffer",
      "node:console",
      "node:crypto",
      "node:debug",
      "node:diagnostics_channel",
      "node:dns",
      "node:events",
      "node:inspector",
      "node:net",
      "node:path",
      "node:perf_hooks",
      "node:process",
      "node:querystring",
      "node:stream",
      "node:string_decoder",
      "node:timers",
      "node:tls",
      "node:url",
      "node:util",
      "node:zlib",
      "async_hooks",
      "assert",
      "buffer",
      "console",
      "crypto",
      "debug",
      "diagnostics_channel",
      "dns",
      "events",
      "inspector",
      "net",
      "path",
      "perf_hooks",
      "process",
      "querystring",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "zlib",
      "cloudflare:workers",
      "cloudflare:workflows",
      "cloudflare:*"
    ]
  }
}